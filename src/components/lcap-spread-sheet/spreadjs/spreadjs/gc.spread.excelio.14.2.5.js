/*!
 *
 * Spread.Sheets ExcelIO Library 14.2.5
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 *
 * Licensed under the SpreadJS Commercial License.
 * us.sales@grapecity.com
 * http://www.grapecity.com/licensing/grapecity/
 *
 */
module.exports = function (GC) {
  return (function webpackUniversalModuleDefinition(root, factory) {
	root['GC'] = GC || {}, root['GC']['Spread'] = root['GC']['Spread'] || {}, root['GC']['Spread']['Excel'] = factory();
  return root['GC']
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = '/assets/';
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = './src/excel-io.ts');
/******/ })
/************************************************************************/
/******/ ({

/***/ './node_modules/process/browser.js':
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ());
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return []; };

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/'; };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };
/***/ }),

/***/ './node_modules/setimmediate/setImmediate.js':
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
/* WEBPACK VAR INJECTION */(function(process) {(function (global, undefined) {
    'use strict';

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== 'function') {
        callback = new Function('' + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage('', '*');
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = 'setImmediate$' + Math.random() + '$';
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === 'string' &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener('message', onGlobalMessage, false);
        } else {
            global.attachEvent('onmessage', onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, '*');
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement('script');
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === '[object process]') {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && 'onreadystatechange' in doc.createElement('script')) {
        // For IE 6\u20138
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === 'undefined' ? typeof global === 'undefined' ? this : global : self));
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ './node_modules/process/browser.js')));
/***/ }),

/***/ './node_modules/timers-browserify/main.js':
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
var scope = (typeof global !== 'undefined' && global) ||
            (typeof self !== 'undefined' && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ './node_modules/setimmediate/setImmediate.js');
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== 'undefined' && self.setImmediate) ||
                       (typeof global !== 'undefined' && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== 'undefined' && self.clearImmediate) ||
                         (typeof global !== 'undefined' && global.clearImmediate) ||
                         (this && this.clearImmediate);
/***/ }),

/***/ './src/common/builtIn-resource.ts':
/*!****************************************!*\
  !*** ./src/common/builtIn-resource.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });
exports.BuiltInStylesResource = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"><numFmts count="4"><numFmt numFmtId="42" formatCode="_(&quot;$&quot;* #,##0_);_(&quot;$&quot;* \(#,##0\);_(&quot;$&quot;* &quot;-&quot;_);_(@_)"/><numFmt numFmtId="41" formatCode="_(* #,##0_);_(* \(#,##0\);_(* &quot;-&quot;_);_(@_)"/><numFmt numFmtId="44" formatCode="_(&quot;$&quot;* #,##0.00_);_(&quot;$&quot;* \(#,##0.00\);_(&quot;$&quot;* &quot;-&quot;??_);_(@_)"/><numFmt numFmtId="43" formatCode="_(* #,##0.00_);_(* \(#,##0.00\);_(* &quot;-&quot;??_);_(@_)"/></numFmts><fonts count="18"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="18"/><color theme="3"/><name val="Cambria"/><family val="2"/><scheme val="major"/></font><font><b/><sz val="15"/><color theme="3"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="13"/><color theme="3"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color theme="3"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color rgb="FF006100"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color rgb="FF9C0006"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color rgb="FF9C6500"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color rgb="FF3F3F76"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color rgb="FF3F3F3F"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color rgb="FFFA7D00"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color rgb="FFFA7D00"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color theme="0"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color rgb="FFFF0000"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><i/><sz val="11"/><color rgb="FF7F7F7F"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><sz val="11"/><color theme="0"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="33"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill><fill><patternFill patternType="solid"><fgColor rgb="FFC6EFCE"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFFFC7CE"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFFFEB9C"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFFFCC99"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFF2F2F2"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFA5A5A5"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFFFFFCC"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="4"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="4" tint="0.79998168889431442"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="4" tint="0.59999389629810485"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="4" tint="0.39997558519241921"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="5"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="5" tint="0.79998168889431442"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="5" tint="0.59999389629810485"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="5" tint="0.39997558519241921"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="6"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="6" tint="0.79998168889431442"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="6" tint="0.59999389629810485"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="6" tint="0.39997558519241921"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="7"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="7" tint="0.79998168889431442"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="7" tint="0.59999389629810485"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="7" tint="0.39997558519241921"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="8"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="8" tint="0.79998168889431442"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="8" tint="0.59999389629810485"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="8" tint="0.39997558519241921"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="9"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="9" tint="0.79998168889431442"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="9" tint="0.59999389629810485"/><bgColor indexed="65"/></patternFill></fill><fill><patternFill patternType="solid"><fgColor theme="9" tint="0.39997558519241921"/><bgColor indexed="65"/></patternFill></fill></fills><borders count="10"><border><left/><right/><top/><bottom/><diagonal/></border><border><left/><right/><top/><bottom style="thick"><color theme="4"/></bottom><diagonal/></border><border><left/><right/><top/><bottom style="thick"><color theme="4" tint="0.499984740745262"/></bottom><diagonal/></border><border><left/><right/><top/><bottom style="medium"><color theme="4" tint="0.39997558519241921"/></bottom><diagonal/></border><border><left style="thin"><color rgb="FF7F7F7F"/></left><right style="thin"><color rgb="FF7F7F7F"/></right><top style="thin"><color rgb="FF7F7F7F"/></top><bottom style="thin"><color rgb="FF7F7F7F"/></bottom><diagonal/></border><border><left style="thin"><color rgb="FF3F3F3F"/></left><right style="thin"><color rgb="FF3F3F3F"/></right><top style="thin"><color rgb="FF3F3F3F"/></top><bottom style="thin"><color rgb="FF3F3F3F"/></bottom><diagonal/></border><border><left/><right/><top/><bottom style="double"><color rgb="FFFF8001"/></bottom><diagonal/></border><border><left style="double"><color rgb="FF3F3F3F"/></left><right style="double"><color rgb="FF3F3F3F"/></right><top style="double"><color rgb="FF3F3F3F"/></top><bottom style="double"><color rgb="FF3F3F3F"/></bottom><diagonal/></border><border><left style="thin"><color rgb="FFB2B2B2"/></left><right style="thin"><color rgb="FFB2B2B2"/></right><top style="thin"><color rgb="FFB2B2B2"/></top><bottom style="thin"><color rgb="FFB2B2B2"/></bottom><diagonal/></border><border><left/><right/><top style="thin"><color theme="4"/></top><bottom style="double"><color theme="4"/></bottom><diagonal/></border></borders><cellStyleXfs count="47"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/><xf numFmtId="43" fontId="1" fillId="0" borderId="0" applyFont="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="41" fontId="1" fillId="0" borderId="0" applyFont="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="44" fontId="1" fillId="0" borderId="0" applyFont="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="42" fontId="1" fillId="0" borderId="0" applyFont="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="9" fontId="1" fillId="0" borderId="0" applyFont="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="2" fillId="0" borderId="0" applyNumberFormat="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="3" fillId="0" borderId="1" applyNumberFormat="0" applyFill="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="4" fillId="0" borderId="2" applyNumberFormat="0" applyFill="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="5" fillId="0" borderId="3" applyNumberFormat="0" applyFill="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="5" fillId="0" borderId="0" applyNumberFormat="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="6" fillId="2" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="7" fillId="3" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="8" fillId="4" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="9" fillId="5" borderId="4" applyNumberFormat="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="10" fillId="6" borderId="5" applyNumberFormat="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="11" fillId="6" borderId="4" applyNumberFormat="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="12" fillId="0" borderId="6" applyNumberFormat="0" applyFill="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="13" fillId="7" borderId="7" applyNumberFormat="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="14" fillId="0" borderId="0" applyNumberFormat="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="8" borderId="8" applyNumberFormat="0" applyFont="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="15" fillId="0" borderId="0" applyNumberFormat="0" applyFill="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="16" fillId="0" borderId="9" applyNumberFormat="0" applyFill="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="9" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="10" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="11" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="12" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="13" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="14" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="15" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="16" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="17" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="18" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="19" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="20" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="21" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="22" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="23" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="24" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="25" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="26" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="27" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="28" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="29" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="30" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="1" fillId="31" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/><xf numFmtId="0" fontId="17" fillId="32" borderId="0" applyNumberFormat="0" applyBorder="0" applyAlignment="0" applyProtection="0"/></cellStyleXfs><cellXfs count="47"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/><xf numFmtId="0" fontId="6" fillId="2" borderId="0" xfId="11"/><xf numFmtId="0" fontId="7" fillId="3" borderId="0" xfId="12"/><xf numFmtId="0" fontId="8" fillId="4" borderId="0" xfId="13"/><xf numFmtId="0" fontId="13" fillId="7" borderId="7" xfId="18"/><xf numFmtId="0" fontId="11" fillId="6" borderId="4" xfId="16"/><xf numFmtId="0" fontId="15" fillId="0" borderId="0" xfId="21"/><xf numFmtId="0" fontId="9" fillId="5" borderId="4" xfId="14"/><xf numFmtId="0" fontId="12" fillId="0" borderId="6" xfId="17"/><xf numFmtId="0" fontId="0" fillId="8" borderId="8" xfId="20" applyFont="1"/><xf numFmtId="0" fontId="14" fillId="0" borderId="0" xfId="19"/><xf numFmtId="0" fontId="10" fillId="6" borderId="5" xfId="15"/><xf numFmtId="0" fontId="1" fillId="14" borderId="0" xfId="28"/><xf numFmtId="0" fontId="3" fillId="0" borderId="1" xfId="7"/><xf numFmtId="0" fontId="4" fillId="0" borderId="2" xfId="8"/><xf numFmtId="0" fontId="5" fillId="0" borderId="3" xfId="9"/><xf numFmtId="0" fontId="5" fillId="0" borderId="0" xfId="10"/><xf numFmtId="0" fontId="2" fillId="0" borderId="0" xfId="6"/><xf numFmtId="0" fontId="16" fillId="0" borderId="9" xfId="22"/><xf numFmtId="0" fontId="1" fillId="10" borderId="0" xfId="24"/><xf numFmtId="0" fontId="1" fillId="18" borderId="0" xfId="32"/><xf numFmtId="0" fontId="1" fillId="22" borderId="0" xfId="36"/><xf numFmtId="0" fontId="1" fillId="26" borderId="0" xfId="40"/><xf numFmtId="0" fontId="1" fillId="30" borderId="0" xfId="44"/><xf numFmtId="0" fontId="1" fillId="11" borderId="0" xfId="25"/><xf numFmtId="0" fontId="1" fillId="15" borderId="0" xfId="29"/><xf numFmtId="0" fontId="17" fillId="12" borderId="0" xfId="26"/><xf numFmtId="0" fontId="17" fillId="9" borderId="0" xfId="23"/><xf numFmtId="43" fontId="0" fillId="0" borderId="0" xfId="1" applyFont="1"/><xf numFmtId="0" fontId="1" fillId="19" borderId="0" xfId="33"/><xf numFmtId="0" fontId="17" fillId="16" borderId="0" xfId="30"/><xf numFmtId="0" fontId="17" fillId="13" borderId="0" xfId="27"/><xf numFmtId="0" fontId="17" fillId="20" borderId="0" xfId="34"/><xf numFmtId="0" fontId="17" fillId="17" borderId="0" xfId="31"/><xf numFmtId="0" fontId="1" fillId="23" borderId="0" xfId="37"/><xf numFmtId="0" fontId="17" fillId="24" borderId="0" xfId="38"/><xf numFmtId="0" fontId="17" fillId="21" borderId="0" xfId="35"/><xf numFmtId="0" fontId="17" fillId="28" borderId="0" xfId="42"/><xf numFmtId="0" fontId="1" fillId="27" borderId="0" xfId="41"/><xf numFmtId="0" fontId="17" fillId="25" borderId="0" xfId="39"/><xf numFmtId="0" fontId="1" fillId="31" borderId="0" xfId="45"/><xf numFmtId="0" fontId="17" fillId="32" borderId="0" xfId="46"/><xf numFmtId="0" fontId="17" fillId="29" borderId="0" xfId="43"/><xf numFmtId="9" fontId="0" fillId="0" borderId="0" xfId="5" applyFont="1"/><xf numFmtId="42" fontId="0" fillId="0" borderId="0" xfId="4" applyFont="1"/><xf numFmtId="44" fontId="0" fillId="0" borderId="0" xfId="3" applyFont="1"/><xf numFmtId="41" fontId="0" fillId="0" borderId="0" xfId="2" applyFont="1"/></cellXfs><cellStyles count="47"><cellStyle name="20% - Accent1" xfId="24" builtinId="30"/><cellStyle name="20% - Accent2" xfId="28" builtinId="34"/><cellStyle name="20% - Accent3" xfId="32" builtinId="38"/><cellStyle name="20% - Accent4" xfId="36" builtinId="42"/><cellStyle name="20% - Accent5" xfId="40" builtinId="46"/><cellStyle name="20% - Accent6" xfId="44" builtinId="50"/><cellStyle name="40% - Accent1" xfId="25" builtinId="31"/><cellStyle name="40% - Accent2" xfId="29" builtinId="35"/><cellStyle name="40% - Accent3" xfId="33" builtinId="39"/><cellStyle name="40% - Accent4" xfId="37" builtinId="43"/><cellStyle name="40% - Accent5" xfId="41" builtinId="47"/><cellStyle name="40% - Accent6" xfId="45" builtinId="51"/><cellStyle name="60% - Accent1" xfId="26" builtinId="32"/><cellStyle name="60% - Accent2" xfId="30" builtinId="36"/><cellStyle name="60% - Accent3" xfId="34" builtinId="40"/><cellStyle name="60% - Accent4" xfId="38" builtinId="44"/><cellStyle name="60% - Accent5" xfId="42" builtinId="48"/><cellStyle name="60% - Accent6" xfId="46" builtinId="52"/><cellStyle name="Accent1" xfId="23" builtinId="29"/><cellStyle name="Accent2" xfId="27" builtinId="33"/><cellStyle name="Accent3" xfId="31" builtinId="37"/><cellStyle name="Accent4" xfId="35" builtinId="41"/><cellStyle name="Accent5" xfId="39" builtinId="45"/><cellStyle name="Accent6" xfId="43" builtinId="49"/><cellStyle name="Bad" xfId="12" builtinId="27"/><cellStyle name="Calculation" xfId="16" builtinId="22"/><cellStyle name="Check Cell" xfId="18" builtinId="23"/><cellStyle name="Comma" xfId="1" builtinId="3"/><cellStyle name="Comma [0]" xfId="2" builtinId="6"/><cellStyle name="Currency" xfId="3" builtinId="4"/><cellStyle name="Currency [0]" xfId="4" builtinId="7"/><cellStyle name="Explanatory Text" xfId="21" builtinId="53"/><cellStyle name="Good" xfId="11" builtinId="26"/><cellStyle name="Heading 1" xfId="7" builtinId="16"/><cellStyle name="Heading 2" xfId="8" builtinId="17"/><cellStyle name="Heading 3" xfId="9" builtinId="18"/><cellStyle name="Heading 4" xfId="10" builtinId="19"/><cellStyle name="Input" xfId="14" builtinId="20"/><cellStyle name="Linked Cell" xfId="17" builtinId="24"/><cellStyle name="Neutral" xfId="13" builtinId="28"/><cellStyle name="Normal" xfId="0" builtinId="0"/><cellStyle name="Note" xfId="20" builtinId="10"/><cellStyle name="Output" xfId="15" builtinId="21"/><cellStyle name="Percent" xfId="5" builtinId="5"/><cellStyle name="Title" xfId="6" builtinId="15"/><cellStyle name="Total" xfId="22" builtinId="25"/><cellStyle name="Warning Text" xfId="19" builtinId="11"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleLight16"/></styleSheet>';
function getClrScheme(themeName, background1, background2, text1, text2, accent1, accent2, accent3, accent4, accent5, accent6, link, followedLink) {
    return '<a:clrScheme name="' + themeName + '"><a:dk1><a:sysClr val="windowText" lastClr="' + text1 + '"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="' + background1 + '"/></a:lt1><a:dk2><a:srgbClr val="' + text2 + '"/></a:dk2><a:lt2><a:srgbClr val="' + background2 + '"/></a:lt2><a:accent1><a:srgbClr val="' + accent1 + '"/></a:accent1><a:accent2><a:srgbClr val="' + accent2 + '"/></a:accent2><a:accent3><a:srgbClr val="' + accent3 + '"/></a:accent3><a:accent4><a:srgbClr val="' + accent4 + '"/></a:accent4><a:accent5><a:srgbClr val="' + accent5 + '"/></a:accent5><a:accent6><a:srgbClr val="' + accent6 + '"/></a:accent6><a:hlink><a:srgbClr val="' + link + '"/></a:hlink><a:folHlink><a:srgbClr val="' + followedLink + '"/></a:folHlink></a:clrScheme>';
}
var color000000 = '000000';
var colorFFFFFF = 'FFFFFF';
exports.ThemeClrSchemes = {
    Default: getClrScheme('Default', colorFFFFFF, 'EEECE1', color000000, '1F497D', '4F81BD', 'C0504D', '9BBB59', '8064A2', '4BACC6', 'F79646', '0000FF', '800080'),
    Office2007: getClrScheme('Office2007', colorFFFFFF, 'EEECE1', color000000, '1F497D', '4F81BD', 'C0504D', '9BBB59', '8064A2', '4BACC6', 'F79646', '0000FF', '800080'),
    Office: getClrScheme('Office', colorFFFFFF, 'E7E6E6', color000000, '44546A', '5B9BD5', 'ED7D31', 'A5A5A5', 'FFC000', '4472C4', '70AD47', '0563C1', '954F72'),
    Apex: getClrScheme('Apex', colorFFFFFF, 'C9C2D1', color000000, '69676D', 'CEB966', '9CB084', '6BB1C9', '6585CF', '7E6BC9', 'A379BB', '410082', '932968'),
    Aspect: getClrScheme('Aspect', colorFFFFFF, 'E3DED1', color000000, '323232', 'F07F09', '9F2936', '1B587C', '4E8542', '604878', 'C19859', '6B9F25', 'B26B02'),
    Concourse: getClrScheme('Concourse', colorFFFFFF, 'DEF5FA', color000000, '464646', '2DA2BF', 'DA1F28', 'EB641B', '39639D', '474B78', '7D3C4A', 'FF8119', '44B9E8'),
    Civic: getClrScheme('Civic', colorFFFFFF, 'C5D1D7', color000000, '646B86', 'D16349', 'CCB400', '8CADAE', '8C7B70', '8FB08C', 'D19049', '00A3D6', '694F07'),
    Oriel: getClrScheme('Oriel', colorFFFFFF, 'FFF39D', color000000, '575F6D', 'FE8637', '7598D9', 'B32C16', 'F5CD2D', 'AEBAD5', '777C84', 'D2611C', '3B435B'),
    Origin: getClrScheme('Origin', colorFFFFFF, 'DDE9EC', color000000, '464653', '727CA3', '9FB8CD', 'D2DA7A', 'FADA7A', 'B88472', '8E736A', 'B292CA', '6B5680'),
    Paper: getClrScheme('Paper', colorFFFFFF, 'FEFAC9', color000000, '444D26', 'A5B592', 'F3A447', 'E7BC29', 'D092A7', '9C85C0', '809EC2', '8E58B6', '7F6F6F'),
    Solstice: getClrScheme('Solstice', colorFFFFFF, 'E7DEC9', color000000, '4F271C', '3891A7', 'FEB80A', 'C32D2E', '84AA33', '964305', '475A8D', '8DC765', 'AA8A14'),
    Technic: getClrScheme('Technic', colorFFFFFF, 'D4D2D0', color000000, '3B3B3B', '6EA0B0', 'CCAF0A', '8D89A4', '748560', '9E9273', '7E848D', '00C8C3', 'A116E0'),
    Trek: getClrScheme('Trek', colorFFFFFF, 'FBEEC9', color000000, '4E3B30', 'F0A22E', 'A5644E', 'B58B80', 'C3986D', 'A19574', 'C17529', 'AD1F1F', 'FFC42F'),
    Urban: getClrScheme('Urban', colorFFFFFF, 'DEDEDE', color000000, '424456', '53548A', '438086', 'A04DA3', 'C4652D', '8B5D3D', '5C92B5', '67AFBD', 'C2A874'),
    Verve: getClrScheme('Verve', colorFFFFFF, 'D2D2D2', color000000, '666666', 'FF388C', 'E40059', '9C007F', '68007F', '005BD3', '00349E', '17BBFD', 'FF79C2'),
    Equity: getClrScheme('Equity', colorFFFFFF, 'E9E5DC', color000000, '696464', 'D34817', '9B2D1F', 'A28E6A', '956251', '918485', '855D5D', 'CC9900', '96A9A9'),
    Flow: getClrScheme('Flow', colorFFFFFF, 'DBF5F9', color000000, '04617B', '0F6FC6', '009DD9', '0BD0D9', '10CF9B', '7CCA62', 'A5C249', 'E2D700', '85DFD0'),
    Foundry: getClrScheme('Foundry', colorFFFFFF, 'EAEBDE', color000000, '676A55', '72A376', 'B0CCB0', 'A8CDD7', 'C0BEAF', 'CEC597', 'E8B7B7', 'DB5353', '903638'),
    Median: getClrScheme('Median', colorFFFFFF, 'EBDDC3', color000000, '775F55', '94B6D2', 'DD8047', 'A5AB81', 'D8B25C', '7BA79D', '968C8C', 'F7B615', '704404'),
    Metro: getClrScheme('Metro', colorFFFFFF, 'D6ECFF', color000000, '4E5B6F', '7FD13B', 'EA157A', 'FEB80A', '00ADDC', '738AC8', '1AB39F', 'EB8803', '5F7791'),
    Module: getClrScheme('Module', colorFFFFFF, 'D4D4D6', color000000, '5A6378', 'F0AD00', '60B5CC', 'E66C7D', '6BB76D', 'E88651', 'C64847', '168BBA', '680000'),
    Opulent: getClrScheme('Opulent', colorFFFFFF, 'F4E7ED', color000000, 'B13F9A', 'B83D68', 'AC66BB', 'DE6C36', 'F9B639', 'CF6DA4', 'FA8D3D', 'FFDE66', 'D490C5')
};
function getFontScheme(themeName, headerFont, bodyFont) {
    return '<a:fontScheme name="' + themeName + '"><a:majorFont><a:latin typeface="' + headerFont + '" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af"/><a:font script="Hang" typeface="\ub9d1\uc740 \uace0\ub515"/><a:font script="Hans" typeface="\u5b8b\u4f53"/><a:font script="Hant" typeface="\u65b0\u7d30\u660e\u9ad4"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="' + bodyFont + '" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af"/><a:font script="Hang" typeface="\ub9d1\uc740 \uace0\ub515"/><a:font script="Hans" typeface="\u5b8b\u4f53"/><a:font script="Hant" typeface="\u65b0\u7d30\u660e\u9ad4"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme>';
}
exports.ThemeFontSchemes = {
    Default: getFontScheme('Default', 'Cambria', 'Calibri'),
    Office: getFontScheme('Office', 'Calibri Light', 'Calibri'),
    Office2007: getFontScheme('Office2007', 'Cambria', 'Calibri'),
    Apex: getFontScheme('Apex', 'Lucida Sans', 'Book Antiqua'),
    Aspect: getFontScheme('Aspect', 'Verdana', 'Verdana'),
    Concourse: getFontScheme('Concourse', 'Lucida Sans Unicode', 'Lucida Sans Unicode'),
    Civic: getFontScheme('Civic', 'Georgia', 'Georgia'),
    Oriel: getFontScheme('Oriel', 'Century Schoolbook', 'Century Schoolbook'),
    Origin: getFontScheme('Origin', 'Bookman Old Style', 'Gill Sans MT'),
    Paper: getFontScheme('Paper', 'Constantia', 'Constantia'),
    Solstice: getFontScheme('Solstice', 'Gill Sans MT', 'Gill Sans MT'),
    Technic: getFontScheme('Technic', 'Franklin Gothic Book', 'Arial'),
    Trek: getFontScheme('Trek', 'Franklin Gothic Medium', 'Franklin Gothic Book'),
    Urban: getFontScheme('Urban', 'Trebuchet MS', 'Georgia'),
    Verve: getFontScheme('Verve', 'Century Gothic', 'Century Gothic'),
    Equity: getFontScheme('Equity', 'Franklin Gothic Book', 'Perpetua'),
    Flow: getFontScheme('Flow', 'Calibri', 'Constantia'),
    Foundry: getFontScheme('Foundry', 'Rockwell', 'Rockwell'),
    Median: getFontScheme('Median', 'Tw Cen MT', 'Tw Cen MT'),
    Metro: getFontScheme('Metro', 'Consolas', 'Corbel'),
    Module: getFontScheme('Module', 'Corbel', 'Corbel'),
    Opulent: getFontScheme('Opulent', 'Trebuchet MS', 'Trebuchet MS')
};
function getFmtScheme(themeName) {
    return '<a:fmtScheme name="' + themeName + '"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="1"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:shade val="51000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="80000"><a:schemeClr val="phClr"><a:shade val="93000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="94000"/><a:satMod val="135000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst><a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d><a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path></a:gradFill></a:bgFillStyleLst></a:fmtScheme>';
}
exports.ThemeFmtSchemes = {};
['Default', 'Office', 'Office2007', 'Apex', 'Aspect', 'Concourse', 'Civic', 'Oriel',
    'Origin', 'Paper', 'Solstice', 'Technic', 'Trek', 'Urban', 'Verve', 'Equity', 'Flow',
    'Foundry', 'Median', 'Metro', 'Module', 'Opulent'].forEach(function (themeName) {
    exports.ThemeFmtSchemes[themeName] = getFmtScheme(themeName);
});
exports.RelationsFile = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>';
/***/ }),

/***/ './src/common/common.ts':
/*!******************************!*\
  !*** ./src/common/common.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });
var keyword_null = null, keyword_undefined = void 0, const_object = 'object', const_string = 'string';
function isNullOrUndefined(obj) {
    return obj === null || obj === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
exports._isNullOrUndefined = isNullOrUndefined;
function isEmptyObject(obj) {
    var state = true;
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            state = false;
            break;
        }
    }
    return state;
}
exports.isEmptyObject = isEmptyObject;
function getRoot() {
    var root;
    try {
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
            return typeof obj;
        } : function (obj) {
            return obj && typeof Symbol === 'function' && obj.constructor === Symbol ? 'symbol' : typeof obj;
        };
        var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) === 'object' && global && global.Object === Object && global;
        var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self && self.Object === Object && self;
        root = freeGlobal || freeSelf || Function('return this')();
    }
    catch (e) {
    }
    return root;
}
exports._getRoot = getRoot;
var StringEx = /** @class */ (function () {
    function StringEx() {
    }
    StringEx._isNullOrEmpty = function (obj) {
        return !obj || obj === '';
    };
    StringEx._isNullOrWhiteSpace = function (obj) {
        return !obj || obj === ' ';
    };
    return StringEx;
}());
exports.StringEx = StringEx;
var Range = /** @class */ (function () {
    function Range(row, col, rowCount, colCount) {
        this.row = row;
        this.col = col;
        this.rowCount = rowCount;
        this.colCount = colCount;
    }
    return Range;
}());
exports.Range = Range;
function isRangeWholeRow(range) {
    return range.col === -1 || range.colCount === -1;
}
exports.isRangeWholeRow = isRangeWholeRow;
function isRangeWholeColumn(range) {
    return range.row === -1 || range.rowCount === -1;
}
exports.isRangeWholeColumn = isRangeWholeColumn;
var xlwsFunctionPrefix = '_xlfn._xlws.';
var expCharReferenceInDecimalForm = /&#(\d+);/g;
var expCharReferenceInHexForm = /&#x([0-9A-F]+);/gi;
var specialFuncionRegDic = {
    'AVERAGEIF': /\bAVERAGEIF\b\(/gi,
    'AVERAGEIFS': /\bAVERAGEIFS\b\(/gi,
    'CUBEKPIMEMBER': /\bCUBEKPIMEMBER\b\(/gi,
    'CUBEMEMBER': /\bCUBEMEMBER\b\(/gi,
    'CUBEMEMBERPROPERTY': /\bCUBEMEMBERPROPERTY\b\(/gi,
    'CUBERANKEDMEMBER': /\bCUBERANKEDMEMBER\b\(/gi,
    'CUBESET': /\bCUBESET\b\(/gi,
    'CUBESETCOUNT': /\bCUBESETCOUNT\b\(/gi,
    'CUBEVALUE': /\bCUBEVALUE\b\(/gi,
    'COUNTIFS': /\bCOUNTIFS\b\(/gi,
    'IFERROR': /\bIFERROR\b\(/gi,
    'SUMIFS': /\bSUMIFS\b\(/gi,
    'ACOT': /\bACOT\b\(/gi,
    'ACOTH': /\bACOTH\b\(/gi,
    'AGGREGATE': /\bAGGREGATE\b\(/gi,
    'ARABIC': /\bARABIC\b\(/gi,
    'BASE': /\bBASE\b\(/gi,
    'BETA.DIST': /\bBETA\.DIST\b\(/gi,
    'BETA.INV': /\bBETA\.INV\b\(/gi,
    'BINOM.DIST': /\bBINOM\.DIST\b\(/gi,
    'BINOM.DIST.RANGE': /\bBINOM\.DIST\.RANGE\b\(/gi,
    'BINOM.INV': /\bBINOM\.INV\b\(/gi,
    'BITAND': /\bBITAND\b\(/gi,
    'BITLSHIFT': /\bBITLSHIFT\b\(/gi,
    'BITOR': /\bBITOR\b\(/gi,
    'BITRSHIFT': /\bBITRSHIFT\b\(/gi,
    'BITXOR': /\bBITXOR\b\(/gi,
    'CEILING.MATH': /\bCEILING\.MATH\b\(/gi,
    'CEILING.PRECISE': /\bCEILING\.PRECISE\b\(/gi,
    'CHISQ.DIST': /\bCHISQ\.DIST\b\(/gi,
    'CHISQ.DIST.RT': /\bCHISQ\.DIST\.RT\b\(/gi,
    'CHISQ.INV': /\bCHISQ\.INV\b\(/gi,
    'CHISQ.INV.RT': /\bCHISQ\.INV\.RT\b\(/gi,
    'CHISQ.TEST': /\bCHISQ\.TEST\b\(/gi,
    'COMBINA': /\bCOMBINA\b\(/gi,
    'CONCAT': /\bCONCAT\b\(/gi,
    'CONFIDENCE.T': /\bCONFIDENCE\.T\b\(/gi,
    'COT': /\bCOT\b\(/gi,
    'COVARIANCE.P': /\bCOVARIANCE\.P\b\(/gi,
    'COVARIANCE.S': /\bCOVARIANCE\.S\b\(/gi,
    'CSC': /\bCSC\b\(/gi,
    'CSCH': /\bCSCH\b\(/gi,
    'DAYS': /\bDAYS\b\(/gi,
    'DECIMAL': /\bDECIMAL\b\(/gi,
    'ENCODEURL': /\bENCODEURL\b\(/gi,
    'ERF.PRECISE': /\bERF\.PRECISE\b\(/gi,
    'ERFC.PRECISE': /\bERFC\.PRECISE\b\(/gi,
    'EXPON.DIST': /\bEXPON\.DIST\b\(/gi,
    'F.DIST': /\bF\.DIST\b\(/gi,
    'F.DIST.RT': /\bF\.DIST\.RT\b\(/gi,
    'F.INV': /\bF\.INV\b\(/gi,
    'F.INV.RT': /\bF\.INV\.RT\b\(/gi,
    'FILTERXML': /\bFILTERXML\b\(/gi,
    'FLOOR.MATH': /\bFLOOR\.MATH\b\(/gi,
    'FLOOR.PRECISE': /\bFLOOR\.PRECISE\b\(/gi,
    'FORMULATEXT': /\bFORMULATEXT\b\(/gi,
    'GAMMA': /\bGAMMA\b\(/gi,
    'GAMMA.DIST': /\bGAMMA\.DIST\b\(/gi,
    'GAMMA.INV': /\bGAMMA\.INV\b\(/gi,
    'GAMMALN.PRECISE': /\bGAMMALN\.PRECISE\b\(/gi,
    'HYPGEOM.DIST': /\bHYPGEOM\.DIST\b\(/gi,
    'IFNA': /\bIFNA\b\(/gi,
    'IFS': /\bIFS\b\(/gi,
    'IMCOSH': /\bIMCOSH\b\(/gi,
    'IMCOT': /\bIMCOT\b\(/gi,
    'IMCSCH': /\bIMCSCH\b\(/gi,
    'IMSEC': /\bIMSEC\b\(/gi,
    'IMSECH': /\bIMSECH\b\(/gi,
    'IMSINH': /\bIMSINH\b\(/gi,
    'IMTAN': /\bIMTAN\b\(/gi,
    'ISFORMULA': /\bISFORMULA\b\(/gi,
    'ISOWEEKNUM': /\bISOWEEKNUM\b\(/gi,
    'LOGNORM.DIST': /\bLOGNORM\.DIST\b\(/gi,
    'LOGNORM.INV': /\bLOGNORM\.INV\b\(/gi,
    'MAXIFS': /\bMAXIFS\b\(/gi,
    'MINIFS': /\bMINIFS\b\(/gi,
    'MODE.MULT': /\bMODE\.MULT\b\(/gi,
    'MODE.SNGL': /\bMODE\.SNGL\b\(/gi,
    'MUNIT': /\bMUNIT\b\(/gi,
    'NEGBINOM.DIST': /\bNEGBINOM\.DIST\b\(/gi,
    'NORM.DIST': /\bNORM\.DIST\b\(/gi,
    'NORM.INV': /\bNORM\.INV\b\(/gi,
    'NORM.S.DIST': /\bNORM\.S\.DIST\b\(/gi,
    'NORM.S.INV': /\bNORM\.S\.INV\b\(/gi,
    'NUMBERVALUE': /\bNUMBERVALUE\b\(/gi,
    'PDURATION': /\bPDURATION\b\(/gi,
    'PERCENTILE.EXC': /\bPERCENTILE\.EXC\b\(/gi,
    'PERCENTILE.INC': /\bPERCENTILE\.INC\b\(/gi,
    'PERCENTRANK.EXC': /\bPERCENTRANK\.EXC\b\(/gi,
    'PERCENTRANK.INC': /\bPERCENTRANK\.INC\b\(/gi,
    'PERMUTATIONA': /\bPERMUTATIONA\b\(/gi,
    'PHI': /\bPHI\b\(/gi,
    'POISSON.DIST': /\bPOISSON\.DIST\b\(/gi,
    'QUARTILE.EXC': /\bQUARTILE\.EXC\b\(/gi,
    'QUARTILE.INC': /\bQUARTILE\.INC\b\(/gi,
    'RANK.AVG': /\bRANK\.AVG\b\(/gi,
    'RANK.EQ': /\bRANK\.EQ\b\(/gi,
    'RRI': /\bRRI\b\(/gi,
    'SECH': /\bSECH\b\(/gi,
    'SHEET': /\bSHEET\b\(/gi,
    'SHEETS': /\bSHEETS\b\(/gi,
    'STDEV.P': /\bSTDEV\.P\b\(/gi,
    'STDEV.S': /\bSTDEV\.S\b\(/gi,
    'SWITCH': /\bSWITCH\b\(/gi,
    'T.DIST': /\bT\.DIST\b\(/gi,
    'T.DIST.2T': /\bT\.DIST\.2T\b\(/gi,
    'T.DIST.RT': /\bT\.DIST\.RT\b\(/gi,
    'T.INV': /\bT\.INV\b\(/gi,
    'T.INV.2T': /\bT\.INV\.2T\b\(/gi,
    'TEXTJOIN': /\bTEXTJOIN\b\(/gi,
    'UNICHAR': /\bUNICHAR\b\(/gi,
    'UNICODE': /\bUNICODE\b\(/gi,
    'VAR.P': /\bVAR\.P\b\(/gi,
    'VAR.S': /\bVAR\.S\b\(/gi,
    'WEBSERVICE': /\bWEBSERVICE\b\(/gi,
    'WEIBULL.DIST': /\bWEIBULL\.DIST\b\(/gi,
    'XOR': /\bXOR\b\(/gi,
    'Z.TEST': /\bZ\.TEST\b\(/gi,
    'XMATCH': /\bXLOOKUP\b\(/gi,
    'XLOOKUP': /\bXLOOKUP\b\(/gi,
    'RANDARRAY': /RANDARRAY\(/gi,
    'SEQUENCE': /SEQUENCE\(/gi,
    'SORTBY': /SORTBY\(/gi,
    'UNIQUE': /UNIQUE\(/gi,
    'ANCHORARRAY': /ANCHORARRAY\(/gi,
    'SINGLE': /SINGLE\(/gi,
    'LET': /\bLET\b\(/gi,
    'FILTER': {
        reg: /FILTER\(/gi,
        prefix: xlwsFunctionPrefix
    },
    'SORT': {
        reg: /SORT\(/gi,
        prefix: xlwsFunctionPrefix
    }
};
var regExcelFunctionCall = /([A-Z][A-Z.]+)\(/gi;
var ExcelFunctionPrefix = '_xlfn.';
function addPrefix(match, p1) {
    var name = p1.toUpperCase();
    var item = specialFuncionRegDic[name];
    if (item) {
        var prefix = ExcelFunctionPrefix;
        if (item.reg) {
            prefix = item.prefix;
        }
        return prefix + match;
    }
    return match;
}
function addXLFNPrefix(formula) {
    if (formula.indexOf('@') === 0) {
        formula = formula.slice(1, formula.length);
    }
    var tokens = formula.split('"');
    for (var i = 0; i < tokens.length; i += 2) {
        var s = tokens[i];
        s = s.replace(/\@(.*)\,/gi, 'SINGLE($1),').replace(/\@(.*)\)/gi, 'SINGLE($1))');
        tokens[i] = s.replace(regExcelFunctionCall, addPrefix);
    }
    return tokens.join('"');
}
exports.addXLFNPrefix = addXLFNPrefix;
function processFunction(formula) {
    var specialFunctionName = '_xlfn.';
    if (formula && formula.toLowerCase().indexOf(specialFunctionName) >= 0) {
        return formula.replace(/_xlfn\.|_xlws\.|_xlpm\./gi, '');
    }
    return formula;
}
exports.processFunction = processFunction;
var isLetter = function (c) {
    var cc = c.charCodeAt(0);
    cc |= 0x20;
    return (cc >= 96 && cc <= 122);
};
var IndexHelper = /** @class */ (function () {
    function IndexHelper() {
    }
    IndexHelper._getRowIndexInNumber = function (s) {
        if (StringEx._isNullOrEmpty(s)) {
            return 0;
        }
        var row = 0, n = 0;
        while (n < s.length && isNaN(parseInt(s[n], 10))) {
            n++;
        }
        if (n < s.length) {
            row = parseInt(s.substring(n), 10);
        }
        return row - 1;
    };
    IndexHelper._getColumnIndexInNumber = function (s) {
        var column = 0, len = s.length;
        for (var i = 0; i < len; i++) {
            var c = s[i], charCode = c.charCodeAt();
            var value = charCode - 97;
            if (value > 25) {
                break;
            }
            if (value < 0) {
                value = charCode - 65;
            }
            if (value < 0) {
                break;
            }
            column = 26 * column + value + 1;
        }
        column--;
        return column;
    };
    IndexHelper._getColumnIndexInA1Letter = function (coord) {
        if (coord < 0) {
            return '';
        }
        var result = IndexHelper._columnsInA1Letter[coord];
        if (result) {
            return result;
        }
        var key = coord;
        var sb = '';
        var position = sb.length;
        for (coord += 1; coord > 0; coord = Math.floor((coord - 1) / 26)) {
            var temp1 = sb.substring(0, position);
            var temp2 = sb.substring(position);
            sb = temp1 + String.fromCharCode((65 + (coord - 1) % 26)) + temp2;
        }
        result = sb.toString();
        IndexHelper._columnsInA1Letter[key] = result;
        return result;
    };
    IndexHelper._getSheetName = function (sheetName) {
        var validSheetName = function (name) {
            var isWholeNumberName = true;
            for (var i = 0; i < name.length; i++) {
                var cur = name[i];
                if (IndexHelper._invalidSheetNameCharacters[cur]) {
                    return false;
                }
                if (isWholeNumberName && /\D/.test(cur)) {
                    isWholeNumberName = false;
                }
            }
            return isWholeNumberName ? false : true;
        };
        var isProcessed = sheetName[0] === '\'' && sheetName.substr(-1) === '\'';
        if (!isProcessed) {
            var isValidSheetName = validSheetName(sheetName);
            if (!isValidSheetName) {
                return '\'' + sheetName + '\'';
            }
        }
        return sheetName;
    };
    IndexHelper._columnsInA1Letter = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
    IndexHelper._invalidSheetNameCharacters = {
        ' ': true,
        '\'': true,
        '[': true,
        ']': true,
        '?': true,
        '\\': true,
        '%': true,
        '"': true,
        '(': true,
        ')': true,
        '|': true,
        '{': true,
        '}': true,
        '#': true,
        '@': true,
        '!': true,
        '$': true,
        '^': true,
        '\uff08': true,
        '\uff09': true,
        ';': true,
        ':': true,
        ',': true,
        '+': true,
        '-': true,
        '*': true,
        '/': true,
        '&': true,
        '=': true,
        '<': true,
        '>': true,
        '\u3000': true
    };
    return IndexHelper;
}());
exports.IndexHelper = IndexHelper;
var ParsedSharedFormulaStruct = /** @class */ (function () {
    function ParsedSharedFormulaStruct() {
        var self = this;
        self.sharedFormulaType = 0;
        self.index = 0;
        self.length = 0;
        self.column1 = 0;
        self.column2 = 0;
        self.row1 = 0;
        self.row2 = 0;
        self.firstSign = keyword_null;
        self.secondSign = keyword_null;
        self.formatString = keyword_null;
    }
    return ParsedSharedFormulaStruct;
}());
var CalcHelper = /** @class */ (function () {
    function CalcHelper() {
    }
    CalcHelper._readString = function (formula, startIndex, startSign, endSign, throwError) {
        var len = formula.length;
        var startSignCount = (startSign === endSign) ? 0 : 1;
        var text = '';
        for (var index = startIndex + 1; index < len; index++) {
            var currentChar = formula.charAt(index);
            if (currentChar === startSign) {
                startSignCount++;
            }
            if (currentChar === endSign) {
                startSignCount--;
                if (startSign === endSign && index + 2 < len && formula.charAt(index + 1) === startSign) {
                    text += startSign;
                    index++;
                }
                else if (startSignCount !== 0) {
                    text += currentChar;
                }
                else {
                    return { result: text, endIndex: index };
                }
            }
            else {
                text += currentChar;
            }
        }
        if (throwError) {
            throw new Error();
        }
    };
    CalcHelper._readString2 = function (formula, startIndex, startSign, endSign, escapeSign, throwError) {
        var len = formula.length;
        var startSignCount = 0;
        var text = '';
        for (var index = startIndex; index < len; index++) {
            var currentChar = formula.charAt(index);
            if (currentChar === escapeSign) {
                text += currentChar;
                index++;
                currentChar = formula.charAt(index);
            }
            if (currentChar === startSign) {
                text += currentChar;
                startSignCount++;
            }
            else if (currentChar === endSign) {
                startSignCount--;
                if (startSignCount !== 0) {
                    text += currentChar;
                }
                else {
                    return { result: text, endIndex: index };
                }
            }
            else {
                text += currentChar;
            }
        }
        if (throwError) {
            throw new Error();
        }
    };
    CalcHelper._getSharedFormula = function (sharedFormula, columnOffset, rowOffset) {
        if (!sharedFormula.parsedSharedFormulaStructs) {
            CalcHelper._parseSharedFormulaStruct(sharedFormula, columnOffset, rowOffset, 0);
        }
        if (sharedFormula.parsedSharedFormulaStructs) {
            var result = '';
            var baseFormula = sharedFormula.baseFormula;
            if (!sharedFormula.parsedSharedFormulaStructs || sharedFormula.parsedSharedFormulaStructs.length === 0) {
                result = baseFormula;
            }
            else {
                for (var i = 0, len = sharedFormula.parsedSharedFormulaStructs.length; i < len; i++) {
                    var item = sharedFormula.parsedSharedFormulaStructs[i];
                    if (item.sharedFormulaType === 0) {
                        var colIndex = item.column1 + columnOffset;
                        if (colIndex >= CalcHelper._maxColumnCount) {
                            colIndex = item.column1;
                        }
                        var rowIndex = item.row1 + rowOffset;
                        if (rowIndex >= CalcHelper._maxRowCount) {
                            rowIndex = item.row1;
                        }
                        var tempStr = item.formatString.replace('{0}', IndexHelper._getColumnIndexInA1Letter(colIndex));
                        tempStr = tempStr.replace('{1}', rowIndex.toString());
                        result = result.concat(tempStr);
                    }
                    else if (item.sharedFormulaType === 1) {
                        var colIndex1 = item.column1 + columnOffset;
                        if (colIndex1 >= CalcHelper._maxColumnCount) {
                            colIndex1 = item.column1;
                        }
                        var colIndex2 = item.column2 + columnOffset;
                        if (colIndex2 >= CalcHelper._maxColumnCount) {
                            colIndex2 = item.column2;
                        }
                        var tempStr = item.formatString.replace('{0}', IndexHelper._getColumnIndexInA1Letter(colIndex1));
                        tempStr = tempStr.replace('{1}', IndexHelper._getColumnIndexInA1Letter(colIndex2));
                        result = result.concat(tempStr);
                    }
                    else if (item.sharedFormulaType === 2) {
                        var rowIndex = item.row1 + rowOffset;
                        if (rowIndex >= CalcHelper._maxRowCount) {
                            rowIndex = item.row1;
                        }
                        var rowIndex2 = item.row2 + rowOffset;
                        if (rowIndex2 >= CalcHelper._maxRowCount) {
                            rowIndex2 = item.row2;
                        }
                        var tempStr = item.formatString.replace('{0}', rowIndex.toString());
                        tempStr = tempStr.replace('{1}', rowIndex2.toString());
                        result = result.concat(tempStr);
                    }
                }
            }
            return result;
        }
        return '';
    };
    CalcHelper._parseSharedFormulaStruct = function (sharedFormula, columnOffset, rowOffset, index) {
        if (index >= sharedFormula.baseFormula.length) {
            return;
        }
        var lastIndex = index, lastQuoteIndex = index;
        var result;
        sharedFormula.parsedSharedFormulaStructs = [];
        while (index < sharedFormula.baseFormula.length) {
            result = false;
            var quoteIndex = sharedFormula.baseFormula.indexOf('"', lastQuoteIndex);
            if (quoteIndex === -1) {
                quoteIndex = sharedFormula.baseFormula.length;
            }
            var m = sharedFormula.baseFormula.substring(index, quoteIndex).match(CalcHelper._cellRefRegex);
            if (m !== keyword_null) {
                var isReference = true;
                var nextCharIndex = m.index + m[0].length + index;
                if (nextCharIndex < sharedFormula.baseFormula.length) {
                    var nextChar = sharedFormula.baseFormula[nextCharIndex];
                    if (isLetter(nextChar)
                        || nextChar.charCodeAt(0) > 128
                        || nextChar === '_'
                        || nextChar === '\\'
                        || nextChar === '?'
                        || nextChar === '.'
                        || nextChar === '"'
                        || nextChar === '(') {
                        isReference = false;
                    }
                }
                if (isReference) {
                    result = true;
                    var sb = '';
                    var column = m[2];
                    var row = m[4];
                    var psf = new ParsedSharedFormulaStruct();
                    psf.sharedFormulaType = 0;
                    psf.index = m.index;
                    psf.length = m[0].length;
                    psf.column1 = IndexHelper._getColumnIndexInNumber(column);
                    psf.row1 = parseInt(row, 10);
                    psf.firstSign = m[1];
                    psf.secondSign = m[3];
                    sb = sb.concat(sharedFormula.baseFormula.substring(lastIndex, m.index + index));
                    var oldValue = m[0];
                    if (psf.index > 0 && sharedFormula.baseFormula[psf.index + index - 1] === '_') {
                        sb = sb.concat(oldValue);
                    }
                    else if (psf.firstSign === psf.secondSign && psf.firstSign === '') {
                        oldValue = oldValue.replace(column, '{0}');
                        oldValue = oldValue.replace(row, '{1}');
                        sb = sb.concat(oldValue);
                    }
                    else if (psf.firstSign === '$' && psf.secondSign === '') {
                        oldValue = oldValue.replace(row, '{1}');
                        sb = sb.concat(oldValue);
                    }
                    else if (psf.secondSign === '$' && psf.firstSign === '') {
                        oldValue = oldValue.replace(column, '{0}');
                        sb = sb.concat(oldValue);
                    }
                    else {
                        sb = sb.concat(oldValue);
                    }
                    psf.formatString = sb;
                    sharedFormula.parsedSharedFormulaStructs.push(psf);
                }
            }
            else if (columnOffset === 0) {
                m = sharedFormula.baseFormula.substring(index, quoteIndex).match(CalcHelper._cellRefRegex2);
                if (m !== keyword_null) {
                    result = true;
                    var sb = '';
                    var row1 = m[2];
                    var row2 = m[4];
                    var psf = new ParsedSharedFormulaStruct();
                    psf.sharedFormulaType = 2;
                    psf.index = m.index;
                    psf.length = m[0].length;
                    psf.row1 = parseInt(row1, 10);
                    psf.row2 = parseInt(row2, 10);
                    psf.firstSign = m[1];
                    psf.secondSign = m[3];
                    sb = sb.concat(sharedFormula.baseFormula.substring(lastIndex, m.index + index));
                    var oldValue = sharedFormula.baseFormula.substring(m.index + index, m.index + index + m[0].length);
                    if (psf.index > 0 && sharedFormula.baseFormula[psf.index + index - 1] === '_') {
                        sb = sb.concat(oldValue);
                    }
                    else if (psf.firstSign === psf.secondSign && psf.firstSign === '') {
                        sb = sb.concat('{0}:{1}');
                    }
                    else {
                        sb = sb.concat(oldValue);
                    }
                    psf.formatString = sb;
                    sharedFormula.parsedSharedFormulaStructs.push(psf);
                }
            }
            else if (rowOffset === 0) {
                m = sharedFormula.baseFormula.substring(index, quoteIndex).match(CalcHelper._cellRefRegex3);
                if (m !== keyword_null) {
                    result = true;
                    var sb = '';
                    var column1 = m[2];
                    var column2 = m[4];
                    var psf = new ParsedSharedFormulaStruct();
                    psf.sharedFormulaType = 1;
                    psf.index = m.indexOf(m[0]);
                    psf.length = m[0].length;
                    psf.column1 = IndexHelper._getColumnIndexInNumber(column1);
                    psf.column2 = IndexHelper._getColumnIndexInNumber(column2);
                    psf.firstSign = m[1];
                    psf.secondSign = m[3];
                    sb = sb.concat(sharedFormula.baseFormula.substring(lastIndex, m.index + index));
                    var oldValue = sharedFormula.baseFormula.substring(m.index + index, m.index + index + m[0].length);
                    if (psf.index > 0 && sharedFormula.baseFormula[psf.index + index - 1] === '_') {
                        sb = sb.concat(oldValue);
                    }
                    else if (psf.firstSign === psf.secondSign && psf.firstSign === '') {
                        sb = sb.concat('{0}:{1}');
                    }
                    else {
                        sb = sb.concat(oldValue);
                    }
                    psf.formatString = sb;
                    sharedFormula.parsedSharedFormulaStructs.push(psf);
                }
            }
            if (m) {
                index = index + m.index + m[0].length;
                if (result) {
                    lastIndex = index;
                }
            }
            else if (quoteIndex >= sharedFormula.baseFormula.length) {
                var psf = new ParsedSharedFormulaStruct();
                psf.formatString = sharedFormula.baseFormula.substring(lastIndex);
                sharedFormula.parsedSharedFormulaStructs.push(psf);
                break;
            }
            else {
                quoteIndex = sharedFormula.baseFormula.indexOf('"', quoteIndex + 1);
                var psf = new ParsedSharedFormulaStruct();
                psf.formatString = sharedFormula.baseFormula.substring(lastIndex, quoteIndex + 1);
                sharedFormula.parsedSharedFormulaStructs.push(psf);
                lastIndex = index = lastQuoteIndex = quoteIndex + 1;
            }
        }
        if (isNullOrUndefined(sharedFormula.parsedSharedFormulaStructs)) {
            sharedFormula.parsedSharedFormulaStructs = [];
        }
        return result;
    };
    CalcHelper._contains = function (range, row, col) {
        return (range.row === -1 || (range.row <= row && row < range.row + range.rowCount)) && (range.col === -1 || (range.col <= col && col < range.col + range.colCount));
    };
    CalcHelper._cellRefRegex = /(\$?)([A-Z]+)(\$?)(\d+)/;
    CalcHelper._cellRefRegex2 = /(\$?)(\d+):(\$?)(\d+)/;
    CalcHelper._cellRefRegex3 = /(\$?)([A-Z]+):(\$?)([A-Z]+)/;
    CalcHelper._maxRowCount = 1048576;
    CalcHelper._maxColumnCount = 16384;
    CalcHelper._LatinUnicodeCategory = {
        UppercaseLetter: 0x00,
        LowercaseLetter: 0x01,
        DecimalDigitNumber: 0x08,
        OtherNumber: 0x0a,
        SpaceSeparator: 0x0b,
        Control: 0x0e,
        ConnectorPunctuation: 0x12,
        DashPunctuation: 0x13,
        OpenPunctuation: 0x14,
        ClosePunctuation: 0x15,
        InitialQuotePunctuation: 0x16,
        FinalQuotePunctuation: 0x17,
        OtherPunctuation: 0x18,
        MathSymbol: 0x19,
        currencySymbol: 0x1a,
        ModifierSymbol: 0x1b,
        OtherSymbol: 0x1c
    };
    CalcHelper._CategoryForLatin1 = [
        0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
        0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
        0xb, 0x18, 0x18, 0x18, 0x1a, 0x18, 0x18, 0x18, 0x14, 0x15, 0x18, 0x19, 0x18, 0x13, 0x18, 0x18,
        0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x18, 0x18, 0x19, 0x19, 0x19, 0x18,
        0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x14, 0x18, 0x15, 0x1b, 0x12,
        0x1b, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x14, 0x19, 0x15, 0x19, 0xe,
        0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
        0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
        0xb, 0x18, 0x1a, 0x1a, 0x1a, 0x1a, 0x1c, 0x1c, 0x1b, 0x1c, 0x1, 0x16, 0x19, 0x13, 0x1c, 0x1b,
        0x1c, 0x19, 0xa, 0xa, 0x1b, 0x1, 0x1c, 0x18, 0x1b, 0xa, 0x1, 0x17, 0xa, 0xa, 0xa, 0x18,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,
        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x19, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1
    ];
    return CalcHelper;
}());
exports._CalcHelper = CalcHelper;
function cloneBorder(border) {
    if (!border) {
        return border;
    }
    var retValue = {};
    if (!isNullOrUndefined(border.color)) {
        retValue.color = border.color;
    }
    if (!isNullOrUndefined(border.style)) {
        retValue.style = border.style;
    }
    if (!isNullOrUndefined(border.level)) {
        retValue.level = border.level;
    }
    return retValue;
}
var StyleHelper = /** @class */ (function () {
    function StyleHelper() {
    }
    StyleHelper._findName = function (namedStylesNamesIndexImp, name) {
        return namedStylesNamesIndexImp && namedStylesNamesIndexImp[name];
    };
    StyleHelper._getByName = function (arr, name) {
        if (!arr) {
            return null;
        }
        for (var i = 0, len = arr.length; i < len; i++) {
            var item = arr[i];
            if (item && item.name === name) {
                return arr[i];
            }
        }
        return null;
    };
    StyleHelper._addToNamedStyles = function (namedStyles, namedStylesNamesIndexImp, style) {
        if (!style) {
            return;
        }
        var name = style.name;
        var oldStyleIndex = StyleHelper._findName(namedStylesNamesIndexImp, style.name);
        if (!isNullOrUndefined(oldStyleIndex)) {
            namedStyles[oldStyleIndex] = style;
        }
        else {
            namedStyles.push(style);
            namedStylesNamesIndexImp[name] = namedStyles.length - 1;
        }
    };
    StyleHelper._isEmptyStyleInfo = function (style) {
        if (!style) {
            return true;
        }
        var result = style.name === undefined
            && style.parentName === undefined
            && style.locked === undefined
            && style.tabStop === undefined
            && style.themeFont === undefined
            && style.font === undefined
            && style.hAlign === undefined
            && style.vAlign === undefined
            && style.textIndent === undefined
            && style.wordWrap === undefined
            && style.shrinkToFit === undefined
            && style.borderLeft === undefined
            && style.borderTop === undefined
            && style.borderRight === undefined
            && style.borderBottom === undefined
            && style.diagonalUp === undefined
            && style.diagonalDown === undefined
            && style.backColor === undefined
            && style.foreColor === undefined
            && style.textDecoration === undefined
            && style.isVerticalText === undefined
            && style.quotePrefix === undefined
            && style.textOrientation === undefined;
        if (!result) {
            return false;
        }
        var formatterString = style.formatter;
        if (typeof formatterString === const_string && formatterString.toUpperCase() !== 'GENERAL') {
            return false;
        }
        return true;
    };
    StyleHelper._composeStyle = function (style, parentStyle, composeParentName) {
        if (!parentStyle || StyleHelper._isEmptyStyleInfo(parentStyle)) {
            return;
        }
        if (composeParentName && style.parentName === keyword_undefined && parentStyle.parentName) {
            style.parentName = parentStyle.parentName;
        }
        if (style.backColor === keyword_undefined && parentStyle.backColor !== keyword_undefined) {
            style.backColor = parentStyle.backColor;
        }
        if (style.foreColor === keyword_undefined && parentStyle.foreColor !== keyword_undefined) {
            style.foreColor = parentStyle.foreColor;
        }
        if (style.hAlign === keyword_undefined && parentStyle.hAlign !== keyword_undefined) {
            style.hAlign = parentStyle.hAlign;
        }
        if (style.vAlign === keyword_undefined && parentStyle.vAlign !== keyword_undefined) {
            style.vAlign = parentStyle.vAlign;
        }
        if (style.themeFont === keyword_undefined && style.font === keyword_undefined) {
            style.themeFont = parentStyle.themeFont;
            style.font = parentStyle.font;
        }
        else if (style.themeFont !== keyword_undefined && style.font === keyword_undefined) {
            style.font = parentStyle.font;
        }
        if (style.formatter === keyword_undefined && parentStyle.formatter !== keyword_undefined) {
            style.formatter = parentStyle.formatter;
        }
        if (style.borderLeft === keyword_undefined && parentStyle.borderLeft !== keyword_undefined) {
            style.borderLeft = cloneBorder(parentStyle.borderLeft);
        }
        if (style.borderTop === keyword_undefined && parentStyle.borderTop !== keyword_undefined) {
            style.borderTop = cloneBorder(parentStyle.borderTop);
        }
        if (style.borderRight === keyword_undefined && parentStyle.borderRight !== keyword_undefined) {
            style.borderRight = cloneBorder(parentStyle.borderRight);
        }
        if (style.borderBottom === keyword_undefined && parentStyle.borderBottom !== keyword_undefined) {
            style.borderBottom = cloneBorder(parentStyle.borderBottom);
        }
        if (style.diagonalUp === keyword_undefined && parentStyle.diagonalUp !== keyword_undefined) {
            style.diagonalUp = cloneBorder(parentStyle.diagonalUp);
        }
        if (style.diagonalDown === keyword_undefined && parentStyle.diagonalDown !== keyword_undefined) {
            style.diagonalDown = cloneBorder(parentStyle.diagonalDown);
        }
        if (style.locked === keyword_undefined) {
            style.locked = parentStyle.locked;
        }
        if (style.textIndent === keyword_undefined && parentStyle.textIndent !== keyword_undefined) {
            style.textIndent = parentStyle.textIndent;
        }
        if (style.wordWrap === keyword_undefined && parentStyle.wordWrap !== keyword_undefined) {
            style.wordWrap = parentStyle.wordWrap;
        }
        if (style.shrinkToFit === keyword_undefined && parentStyle.shrinkToFit !== keyword_undefined) {
            style.shrinkToFit = parentStyle.shrinkToFit;
        }
        if (style.textDecoration === keyword_undefined && parentStyle.textDecoration !== keyword_undefined) {
            style.textDecoration = parentStyle.textDecoration;
        }
        if (style.textOrientation === keyword_undefined && parentStyle.textOrientation !== keyword_undefined) {
            style.textOrientation = parentStyle.textOrientation;
        }
        if (style.quotePrefix === keyword_undefined && parentStyle.quotePrefix !== keyword_undefined) {
            style.quotePrefix = parentStyle.quotePrefix;
        }
        if (style.isVerticalText === keyword_undefined && parentStyle.isVerticalText !== keyword_undefined) {
            style.isVerticalText = parentStyle.isVerticalText;
        }
    };
    StyleHelper._setActualStyle = function (namedStyles, style) {
        if (!style || namedStyles.length <= 0) {
            return keyword_null;
        }
        var tempStyle = style;
        while (tempStyle.parentName) {
            tempStyle = StyleHelper._getByName(namedStyles, tempStyle.parentName);
            if (!tempStyle) {
                break;
            }
            StyleHelper._composeStyle(style, tempStyle);
        }
    };
    StyleHelper._isEqualStyleJSONObject = function (styleItem1, styleItem2) {
        if (!styleItem1 && !styleItem2) {
            return true;
        }
        function isBorderEqual(border1, border2) {
            if (!border1 && !border2) {
                return true;
            }
            if (border1 && border2) {
                return border1.color === border2.color &&
                    border1.style === border2.style;
            }
            return false;
        }
        function isFormatterEqual(formatter1, formatter2) {
            if (!formatter1 && !formatter2) {
                return true;
            }
            if (typeof formatter1 === 'string' && typeof formatter2 === 'string') {
                return formatter1 === formatter2;
            }
            if (typeof formatter1 === 'object' && formatter1 && typeof formatter2 === 'object' && formatter2) {
                return formatter1.formatCached === formatter2.formatCached &&
                    formatter1.customerCultureName === formatter2.customerCultureName;
            }
            return false;
        }
        if (styleItem1 && styleItem2) {
            return styleItem1.parentName === styleItem2.parentName &&
                styleItem1.backColor === styleItem2.backColor &&
                styleItem1.foreColor === styleItem2.foreColor &&
                styleItem1.hAlign === styleItem2.hAlign &&
                styleItem1.vAlign === styleItem2.vAlign &&
                styleItem1.themeFont === styleItem2.themeFont &&
                styleItem1.font === styleItem2.font &&
                styleItem1.locked === styleItem2.locked &&
                styleItem1.textIndent === styleItem2.textIndent &&
                styleItem1.wordWrap === styleItem2.wordWrap &&
                styleItem1.shrinkToFit === styleItem2.shrinkToFit &&
                styleItem1.textDecoration === styleItem2.textDecoration &&
                styleItem1.textOrientation === styleItem2.textOrientation &&
                styleItem1.quotePrefix === styleItem2.quotePrefix &&
                isFormatterEqual(styleItem1.formatter, styleItem2.formatter) &&
                isFormatterEqual(styleItem1.autoFormatter, styleItem2.autoFormatter) &&
                styleItem1.isVerticalText === styleItem2.isVerticalText &&
                isBorderEqual(styleItem1.borderLeft, styleItem2.borderLeft) &&
                isBorderEqual(styleItem1.borderTop, styleItem2.borderTop) &&
                isBorderEqual(styleItem1.borderRight, styleItem2.borderRight) &&
                isBorderEqual(styleItem1.borderBottom, styleItem2.borderBottom) &&
                isBorderEqual(styleItem1.diagonalDown, styleItem2.diagonalDown) &&
                isBorderEqual(styleItem1.diagonalUp, styleItem2.diagonalUp);
        }
        return false;
    };
    return StyleHelper;
}());
exports._StyleHelper = StyleHelper;
var BufferHelper = /** @class */ (function () {
    function BufferHelper() {
    }
    BufferHelper._clamp = function (val, length) {
        var valTemp = (val | 0) || 0;
        return valTemp < 0 ? Math.max(valTemp + length, 0) : Math.min(valTemp, length);
    };
    BufferHelper._slice = function (buffer, from, to) {
        if (!buffer.slice) {
            var length_1 = buffer.byteLength, clamp = BufferHelper._clamp;
            var begin = clamp(from, length_1);
            var end = length_1;
            if (to !== void 0) {
                end = clamp(to, length_1);
            }
            var bufferConstructor = buffer.constructor;
            if (begin > end) {
                return new bufferConstructor(0);
            }
            var num = end - begin;
            if (buffer instanceof ArrayBuffer) {
                var target = new ArrayBuffer(num);
                var targetArray = new Uint8Array(target);
                var sourceArray = new Uint8Array(buffer, begin, num);
                targetArray.set(sourceArray);
                return target;
            }
            else {
                var cloned = new bufferConstructor(num);
                for (var i = 0; i < num; i++) {
                    cloned[i] = buffer[begin + i];
                }
                return cloned;
            }
        }
        return buffer.slice(from, to);
    };
    return BufferHelper;
}());
exports.BufferHelper = BufferHelper;
var exp1 = /&/g;
var exp2 = /</g;
var exp3 = />/g;
var exp4 = /"/g;
var exp5 = /'/g;
var exp11 = /&amp;/g;
var exp12 = /&gt;/g;
var exp13 = /&lt;/g;
var exp14 = /&quot;/g;
var exp15 = /&apos;/g;
var specialCharacterMatchPattern = /_x00[0-1][0-9A-Fa-f]_/;
function getReplaceFunction(radix) {
    return function (match, p1) {
        return String.fromCharCode(parseInt(p1, radix));
    };
}
function pad(num) {
    if (num < 10) {
        return '0' + num;
    }
    return num + '';
}
var Util = /** @class */ (function () {
    function Util() {
    }
    Util._firstOrDefault = function (list, condition, defaultValue) {
        if (!list || list.length === 0) {
            return defaultValue;
        }
        if (!condition) {
            return list[0];
        }
        for (var i = 0, len = list.length; i < len; i++) {
            if (condition(list[i])) {
                return list[i];
            }
        }
        return defaultValue;
    };
    Util._indexOf = function (list, item) {
        if (!list) {
            return -1;
        }
        for (var i = 0, len = list.length; i < len; i++) {
            var listItem = list[i];
            if ((listItem.equals && listItem.equals(item)) || (listItem === item)) {
                return i;
            }
        }
        return -1;
    };
    Util._indexOfJSON = function (list, item) {
        if (!list) {
            return -1;
        }
        for (var i = 0, len = list.length; i < len; i++) {
            var listItem = list[i];
            if ((Util._isJSONEqual(listItem, item)) || (listItem === item)) {
                return i;
            }
        }
        return -1;
    };
    Util._isJSONEqual = function (item1, item2) {
        return JSON.stringify(item1) === JSON.stringify(item2);
    };
    Util._xmlEncode = function (string) {
        if (typeof string === const_string) {
            return string.replace(exp1, '&amp;')
                .replace(exp2, '&lt;')
                .replace(exp3, '&gt;')
                .replace(exp4, '&quot;')
                .replace(exp5, '&apos;');
        }
        if (!isNullOrUndefined(string)) {
            return '' + string;
        }
        return string;
    };
    Util._xmlDecode = function (string) {
        if (typeof string === const_string) {
            if (string.indexOf('&#') !== -1) {
                string = string.replace(expCharReferenceInDecimalForm, getReplaceFunction(10))
                    .replace(expCharReferenceInHexForm, getReplaceFunction(16));
            }
            return string
                .replace(exp12, '>')
                .replace(exp13, '<')
                .replace(exp14, '"')
                .replace(exp15, '\'')
                .replace(exp11, '&');
        }
        if (!isNullOrUndefined(string)) {
            return '' + string;
        }
        return string;
    };
    Util._joinPath = function (base, relative) {
        var baseItems = base.split('/'), relativeItems = relative.split('/');
        baseItems.pop();
        while (relativeItems.length > 0) {
            var first = relativeItems[0];
            if (first === '..') {
                relativeItems.shift();
                baseItems.pop();
            }
            else if (first === '.') {
                relativeItems.shift();
            }
            else {
                break;
            }
        }
        return baseItems.concat(relativeItems).join('/');
    };
    Util._parsePath = function (path) {
        var dir, fileName;
        if (!StringEx._isNullOrEmpty(path)) {
            var parts = path.split('/');
            fileName = parts.pop();
            dir = parts.join('/');
        }
        return { dir: dir || '', fileName: fileName || '' };
    };
    Util._isEqualObject = function (obj1, obj2, compareObjectFieldFunc) {
        function isEqualArray(arr1, arr2) {
            if (!arr1 && !arr2) {
                return true;
            }
            if (!arr1 || !arr2 || arr1.length !== arr2.length) {
                return false;
            }
            for (var i = 0; i < arr1.length; i++) {
                if (typeof arr1[i] === const_object) {
                    if (typeof arr2[i] === const_object) {
                        if (!Util._isEqualObject(arr1[i], arr2[i])) {
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
                else if (Array.isArray(arr1[i])) {
                    if (Array.isArray(arr2[i])) {
                        if (!isEqualArray(arr1[i], arr2[i])) {
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
                else if (arr1[i] !== arr2[i]) {
                    return false;
                }
            }
            return true;
        }
        if (!obj1 && !obj2) {
            return true;
        }
        else if (!obj1 || !obj2) {
            return false;
        }
        if (!compareObjectFieldFunc) {
            compareObjectFieldFunc = Util._isEqualObject;
        }
        if (Object.getOwnPropertyNames(obj1).length !== Object.getOwnPropertyNames(obj2).length) {
            return false;
        }
        var propCache = {}, prop;
        for (prop in obj1) {
            if (obj1.hasOwnProperty(prop)) {
                var propValue = obj1[prop];
                if (Array.isArray(propValue)) {
                    if (!isEqualArray(propValue, obj2[prop])) {
                        return false;
                    }
                }
                else if (typeof propValue === const_object) {
                    if (!compareObjectFieldFunc(propValue, obj2[prop])) {
                        return false;
                    }
                }
                else if (propValue !== obj2[prop]) {
                    return false;
                }
                propCache[prop] = true;
            }
        }
        for (prop in obj2) {
            if (obj2.hasOwnProperty(prop) && !propCache[prop]) {
                return false;
            }
        }
        return true;
    };
    Util._isExternalRange = function (formula, currentSheetName, sheetNames) {
        if (formula && typeof formula === const_string) {
            for (var i = 0; i < sheetNames.length; i++) {
                var sheetName = sheetNames[i];
                if (sheetName === currentSheetName) {
                    continue;
                }
                if (formula.indexOf(sheetName + '!') > -1 || formula.indexOf('\'' + sheetName + '\'!') > -1) {
                    return true;
                }
            }
        }
        return false;
    };
    Util._replaceAll = function (target, substr, replacement) {
        return target.split(substr).join(replacement);
    };
    Util._createURI = function () {
        return '{xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx}'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    };
    Util._decodeSpecialCharacterFromXML = function (text) {
        if (!isNullOrUndefined(text) && text.match(specialCharacterMatchPattern) !== keyword_null) {
            var decodeSpecialCharacterPattern = /(_x005[fF])?_x00([0-1][0-9A-Fa-f])_/g;
            return text.replace(decodeSpecialCharacterPattern, function (match, childMath1, childMath2) {
                var result = 0;
                if (childMath2) {
                    result = parseInt(childMath2, 16);
                }
                if (childMath1) {
                    return '_x00' + childMath2 + '_';
                }
                return String.fromCharCode(result);
            }).replace(/(\r)+\n/g, '\r\n');
        }
        return text;
    };
    Util._encodeSpecialCharacterToXML = function (text, ignoreWrapText) {
        if (isNullOrUndefined(text) || text === '') {
            return text;
        }
        if (text.match(specialCharacterMatchPattern) !== keyword_null) {
            var encodeSpecialCharacterPattern = /(_x00[0-1][0-9A-Fa-f]_)/g;
            text = text.replace(encodeSpecialCharacterPattern, function (match) {
                return '_x005F' + match;
            });
        }
        var specialCharTableValue = ['_x0000_', '_x0001_', '_x0002_', '_x0003_', '_x0004_', '_x0005_', '_x0006_', '_x0007_',
            '_x0008_', '_x0009_', '_x000A_', '_x000B_', '_x000C_', '_x000D_', '_x000E_', '_x000F_', '_x0010_', '_x0011_',
            '_x0012_', '_x0013_', '_x0014_', '_x0015_', '_x0016_', '_x0017_', '_x0018_', '_x0019_', '_x001A_', '_x001B_',
            '_x001C_', '_x001D_', '_x001E_', '_x001F_'];
        var sb = [];
        for (var i = 0; i < text.length; i++) {
            var charCode = text.charCodeAt(i), c = text[i];
            if (charCode > 0x1F || ((charCode === 0x0A || charCode === 0x0D) && ignoreWrapText)) {
                sb.push(c);
            }
            else {
                sb.push(specialCharTableValue[charCode]);
            }
        }
        return sb.join('');
    };
    Util._is2016Chart = function (content) {
        var Choice = content && content.Choice;
        var GraphicalObjectFrame = Choice && Choice.GraphicalObjectFrame;
        var graphic = GraphicalObjectFrame && GraphicalObjectFrame.graphic;
        var graphicData = graphic && graphic.graphicData;
        return !!(graphicData && graphicData.chart);
    };
    Util._get2016ChartSeries = function (chartModel) {
        var chartSpace = chartModel.chartSpace;
        var plotArea = chartSpace && chartSpace.chart.plotArea;
        var plotAreaRegion = plotArea && plotArea.plotAreaRegion;
        return plotAreaRegion && plotAreaRegion.series[0];
    };
    Util._is2016ChartByLayoutId = function (layoutId) {
        return layoutId === 16 || layoutId === 17 || layoutId === 18 || layoutId === 19 || layoutId === 20 || layoutId === 21 || layoutId === 22 || layoutId === 23;
    };
    Util._getDateString = function (date) {
        return date.getFullYear() +
            '-' + pad(date.getMonth() + 1) +
            '-' + pad(date.getDate()) +
            'T' + pad(date.getHours()) +
            ':' + pad(date.getMinutes()) +
            ':' + pad(date.getSeconds());
    };
    Util._isValidFormat = function (format) {
        var isVaild = true;
        var generalFormatter = exports._getRoot().GC.Spread.Formatter.GeneralFormatter;
        if (format && format[0] !== '=' && !isNullOrUndefined(generalFormatter)) {
            try {
                new generalFormatter(format);
            }
            catch (_a) {
                isVaild = false;
            }
        }
        return isVaild;
    };
    return Util;
}());
exports.Util = Util;
exports._getSheetDefaults = function () {
    return {
        colHeaderRowHeight: 20,
        rowHeaderColWidth: 40,
        rowHeight: 20,
        colWidth: 62
    };
};
exports._getCulture = function () {
    var root = getRoot();
    return root && root.gcCultureInfo;
};
exports._getCultureObj = function () {
    var root = getRoot();
    return root && root.gcCultureObj;
};
function _getRandom36Binary(sliceNumber) {
    return Math.random().toString(16).slice(-sliceNumber);
}
function getRandomID() {
    var randomStr = '{' + _getRandom36Binary(8) + '-' + _getRandom36Binary(4) + '-' + _getRandom36Binary(4) + '-' + _getRandom36Binary(4) + '-' + _getRandom36Binary(12) + '}';
    return randomStr.toUpperCase();
}
exports._getRandomID = getRandomID;
function cloneObject(obj) {
    if (!obj) {
        return obj;
    }
    if (typeof (obj) === 'number' || typeof (obj) === 'string' || typeof (obj) === 'boolean' || isNullOrUndefined(obj)) {
        return obj;
    }
    else if (obj.clone) {
        return obj.clone();
    }
    else if (obj instanceof Date) {
        return new Date(obj.valueOf());
    }
    var objClone, key, value;
    if (obj instanceof Object) {
        objClone = new obj.constructor();
    }
    else {
        objClone = new obj.constructor(obj.valueOf());
    }
    for (key in obj) {
        if (obj.hasOwnProperty(key)) {
            value = obj[key];
            if (obj.hasOwnProperty(key) && objClone[key] !== value) {
                if (typeof (value) === 'object') {
                    objClone[key] = cloneObject(value);
                }
                else {
                    objClone[key] = value;
                }
            }
        }
    }
    objClone.toString = obj.toString;
    objClone.valueOf = obj.valueOf;
    return objClone;
}
exports._cloneObject = cloneObject;
/***/ }),

/***/ './src/common/excel-types.ts':
/*!***********************************!*\
  !*** ./src/common/excel-types.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });
var common_1 = __webpack_require__(/*! ./common */ './src/common/common.ts');
var xml_parser_1 = __webpack_require__(/*! ./../xml-io/xml-parser */ './src/xml-io/xml-parser.ts');
var PaneType;
(function (PaneType) {
    PaneType[PaneType['bottomRight'] = 0] = 'bottomRight';
    PaneType[PaneType['topRight'] = 1] = 'topRight';
    PaneType[PaneType['bottomLeft'] = 2] = 'bottomLeft';
    PaneType[PaneType['topLeft'] = 3] = 'topLeft';
})(PaneType = exports.PaneType || (exports.PaneType = {}));
exports.RelationshipConstants = {
    _relationshipPrefix: 'rId',
    _relationshipDocPropsCoreType: 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties',
    _relationshipDocPropsAppType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties',
    _relationshipDocPropsCustomType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties',
    _relationshipWorkbookType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',
    _relationshipWorkbookType2: 'http://purl.oclc.org/ooxml/officeDocument/relationships/officeDocument',
    _relationshipStylesType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
    _relationshipStylesType2: 'http://purl.oclc.org/ooxml/officeDocument/relationships/styles',
    _relationshipWorksheetType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
    _relationshipSharedStringsType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
    _relationshipSharedStringsType2: 'http://purl.oclc.org/ooxml/officeDocument/relationships/sharedStrings',
    _relationshipThemeType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
    _relationshipThemeType2: 'http://purl.oclc.org/ooxml/officeDocument/relationships/theme',
    _relationshipPivotCacheDefinitionType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/pivotCacheDefinition',
    _relationshipPivotCacheRecordsType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/pivotCacheRecords',
    _relationshipPivotTableType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/pivotTable',
    _relationshipExternalLinkType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink',
    _relationshipTableType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/table',
    _relationshipCommentType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments',
    _relationshipVMLDrawingType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing',
    _relationshipDrawingType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
    _relationshipDrawingType2: 'http://purl.oclc.org/ooxml/officeDocument/relationships/drawing',
    _relationshipHyperlinkType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',
    _relationshipImageType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
    _relationshipImageType2: 'http://purl.oclc.org/ooxml/officeDocument/relationships/image',
    _relationshipSlicerType: 'http://schemas.microsoft.com/office/2007/relationships/slicer',
    _relationshipSlicerCacheType: 'http://schemas.microsoft.com/office/2007/relationships/slicerCache',
    _relationshipChartType: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart',
    _relationshipNewChartType: 'http://schemas.microsoft.com/office/2014/relationships/chartEx',
    _relationshipPurlChartType: 'http://purl.oclc.org/ooxml/officeDocument/relationships/chart',
    _realationshipChartUserShapes: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartUserShapes',
    _realationshipChartColorStyle: 'http://schemas.microsoft.com/office/2011/relationships/chartColorStyle',
    _realationshipChartStyle: 'http://schemas.microsoft.com/office/2011/relationships/chartStyle',
    _relationshipSheetMetadata: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata'
};
exports.ExcelConstants = {
    _openXmlMaxColumn: 16384,
    _openXmlMaxRow: 1048576
};
exports.DefaultSize = {
    _defaultColumnHeaderRowHeight: 20,
    _defaultRowHeaderColumnWidth: 40,
    _defaultColumnWidth: 62,
    _defaultRowHeight: 20
};
exports.MaxDigitWidthMap = {
    8: {
        'Gill Sans MT': 6,
        'Abadi': 7,
        'Abadi Extra Light': 6,
        'Agency FB': 5,
        'Aharoni': 5,
        'Aldhabi': 4,
        'Algerian': 7,
        'Ami R': 5,
        'Angsana New': 4,
        'AngsanaUPC': 4,
        'Aparajita': 4,
        'Arabic Typesetting': 4,
        'Arial': 6,
        'Arial Black': 7,
        'Arial Narrow': 5,
        'Arial Nova': 6,
        'Arial Nova Cond': 6,
        'Arial Nova Cond Light': 5,
        'Arial Nova Light': 6,
        'Arial Rounded MT Bold': 7,
        'Baskerville Old Face': 5,
        'Batang': 6,
        'BatangChe': 6,
        'Bauhaus 93': 6,
        'Bell MT': 6,
        'Bembo': 5,
        'Berlin Sans FB': 7,
        'Berlin Sans FB Demi': 7,
        'Bernard MT Condensed': 5,
        'Blackadder ITC': 4,
        'Bodoni MT': 5,
        'Bodoni MT Black': 7,
        'Bodoni MT Condensed': 4,
        'Bodoni MT Poster Compressed': 4,
        'Book Antiqua': 6,
        'Bookman Old Style': 7,
        'Bookshelf Symbol 7': 8,
        'Bradley Hand ITC': 7,
        'Britannic Bold': 7,
        'Broadway': 7,
        'Browallia New': 4,
        'BrowalliaUPC': 4,
        'Brush Script MT': 6,
        'Calibri': 6,
        'Calibri Light': 6,
        'Californian FB': 5,
        'Calisto MT': 6,
        'Cambria': 6,
        'Cambria Math': 6,
        'Candara': 6,
        'Castellar': 8,
        'Centaur': 5,
        'Century': 6,
        'Century Gothic': 6,
        'Century Schoolbook': 6,
        'Chiller': 5,
        'Colonna MT': 6,
        'Comic Sans MS': 7,
        'Consolas': 6,
        'Constantia': 6,
        'Cooper Black': 7,
        'Copperplate Gothic Bold': 8,
        'Copperplate Gothic Light': 8,
        'Corbel': 6,
        'Cordia New': 4,
        'CordiaUPC': 4,
        'Courier New': 7,
        'Curlz MT': 6,
        'Dante': 5,
        'DaunPenh': 4,
        'David': 5,
        'DilleniaUPC': 3,
        'DokChampa': 6,
        'Dotum': 6,
        'DotumChe': 6,
        'Dubai': 6,
        'Dubai Light': 6,
        'Dubai Medium': 6,
        'Ebrima': 6,
        'Edwardian Script ITC': 5,
        'Elephant': 8,
        'Engravers MT': 7,
        'Eras Bold ITC': 7,
        'Eras Demi ITC': 7,
        'Eras Light ITC': 6,
        'Eras Medium ITC': 6,
        'EucrosiaUPC': 4,
        'Euphemia': 6,
        'Expo M': 10,
        'FangSong': 6,
        'Felix Titling': 6,
        'Footlight MT Light': 6,
        'Forte': 6,
        'Franklin Gothic Book': 6,
        'Franklin Gothic Demi': 6,
        'Franklin Gothic Demi Cond': 6,
        'Franklin Gothic Heavy': 6,
        'Franklin Gothic Medium': 6,
        'Franklin Gothic Medium Cond': 6,
        'FrankRuehl': 5,
        'FreesiaUPC': 5,
        'Freestyle Script': 4,
        'French Script MT': 4,
        'Gabriola': 4,
        'Gadugi': 6,
        'Garamond': 5,
        'Gautami': 7,
        'Georgia': 8,
        'Georgia Pro': 6,
        'Georgia Pro Black': 8,
        'Georgia Pro Cond': 6,
        'Georgia Pro Cond Black': 7,
        'Georgia Pro Cond Light': 6,
        'Georgia Pro Cond Semibold': 6,
        'Georgia Pro Light': 6,
        'Georgia Pro Semibold': 7,
        'Gigi': 5,
        'Gill Sans MT Condensed': 4,
        'Gill Sans MT Ext Condensed Bold': 4,
        'Gill Sans Nova': 6,
        'Gill Sans Nova Cond': 4,
        'Gill Sans Nova Cond Lt': 3,
        'Gill Sans Nova Cond Ultra Bold': 6,
        'Gill Sans Nova Cond XBd': 6,
        'Gill Sans Nova Light': 6,
        'Gill Sans Nova Ultra Bold': 9,
        'Gill Sans Ultra Bold': 9,
        'Gill Sans Ultra Bold Condensed': 6,
        'Gisha': 6,
        'Gloucester MT Extra Condensed': 4,
        'Goudy Old Style': 6,
        'Goudy Stout': 9,
        'Grotesque': 5,
        'Grotesque Light': 5,
        'Gulim': 6,
        'GulimChe': 6,
        'Gungsuh': 6,
        'GungsuhChe': 6,
        'Hadassah Friedlaender': 6,
        'Haettenschweiler': 5,
        'Harlow Solid Italic': 5,
        'Harrington': 6,
        'Headline R': 8,
        'HGGothicE': 6,
        'HGGothicM': 6,
        'HGGyoshotai': 6,
        'HGKyokashotai': 6,
        'HGMaruGothicMPRO': 8,
        'HGMinchoB': 7,
        'HGMinchoE': 7,
        'HGPGothicE': 7,
        'HGPGothicM': 7,
        'HGPGyoshotai': 6,
        'HGPKyokashotai': 6,
        'HGPMinchoB': 6,
        'HGPMinchoE': 7,
        'HGPSoeiKakugothicUB': 8,
        'HGPSoeiKakupoptai': 8,
        'HGPSoeiPresenceEB': 7,
        'HGSeikaishotaiPRO': 7,
        'HGSGothicE': 6,
        'HGSGothicM': 6,
        'HGSGyoshotai': 5,
        'HGSKyokashotai': 5,
        'HGSMinchoB': 6,
        'HGSMinchoE': 7,
        'HGSoeiKakugothicUB': 7,
        'HGSoeiKakupoptai': 7,
        'HGSoeiPresenceEB': 7,
        'HGSSoeiKakugothicUB': 7,
        'HGSSoeiKakupoptai': 7,
        'HGSSoeiPresenceEB': 6,
        'High Tower Text': 5,
        'HYGothic-Extra': 7,
        'HYGothic-Medium': 6,
        'HYGraphic-Medium': 6,
        'HYGungSo-Bold': 6,
        'HYHeadLine-Medium': 6,
        'HYMyeongJo-Extra': 7,
        'HYPMokGak-Bold': 8,
        'HYPost-Light': 7,
        'HYPost-Medium': 8,
        'HYShortSamul-Medium': 4,
        'HYSinMyeongJo-Medium': 7,
        'Impact': 6,
        'Imprint MT Shadow': 6,
        'Informal Roman': 6,
        'Ink Free': 6,
        'IrisUPC': 6,
        'Iskoola Pota': 6,
        'JasmineUPC': 6,
        'Javanese Text': 6,
        'Jokerman': 8,
        'Juice ITC': 4,
        'KaiTi': 6,
        'Kalinga': 6,
        'Kartika': 6,
        'Khmer UI': 6,
        'KodchiangUPC': 6,
        'Kokila': 6,
        'Kristen ITC': 7,
        'Kunstler Script': 4,
        'Lao UI': 6,
        'Latha': 6,
        'Leelawadee': 6,
        'Leelawadee UI': 6,
        'Leelawadee UI Semilight': 6,
        'Levenim MT': 6,
        'LilyUPC': 6,
        'Lucida Bright': 7,
        'Lucida Calligraphy': 7,
        'Lucida Console': 8,
        'Lucida Fax': 7,
        'Lucida Handwriting': 8,
        'Lucida Sans': 7,
        'Lucida Sans Typewriter': 7,
        'Lucida Sans Unicode': 8,
        'Magic R': 7,
        'Magneto': 8,
        'Maiandra GD': 7,
        'Malgun Gothic': 6,
        'Malgun Gothic Semilight': 7,
        'Mangal': 7,
        'Marlett': 12,
        'Matura MT Script Capitals': 8,
        'Meiryo': 7,
        'Meiryo UI': 7,
        'Microsoft GothicNeo': 7,
        'Microsoft Himalaya': 5,
        'Microsoft JhengHei': 7,
        'Microsoft JhengHei Light': 7,
        'Microsoft JhengHei UI': 7,
        'Microsoft JhengHei UI Light': 7,
        'Microsoft New Tai Lue': 6,
        'Microsoft PhagsPa': 6,
        'Microsoft Sans Serif': 7,
        'Microsoft Tai Le': 6,
        'Microsoft Uighur': 4,
        'Microsoft YaHei Light': 7,
        'Microsoft YaHei UI': 7,
        'Microsoft YaHei UI Light': 7,
        'Microsoft Yi Baiti': 7,
        'MingLiU': 7,
        'MingLiU_HKSCS': 7,
        'MingLiU_HKSCS-ExtB': 7,
        'MingLiU-ExtB': 7,
        'Miriam': 7,
        'Miriam Fixed': 7,
        'Mistral': 6,
        'Modern No. 20': 6,
        'MoeumT R': 7,
        'Mongolian Baiti': 7,
        'Monotype Corsiva': 6,
        'MoolBoran': 7,
        'MS Gothic': 7,
        'MS Mincho': 7,
        'MS Outlook': 7,
        'MS PGothic': 7,
        'MS PMincho': 7,
        'MS Reference Sans Serif': 8,
        'MS Reference Specialty': 14,
        'MS UI Gothic': 7,
        'MT Extra': 12,
        'MV Boli': 9,
        'Myanmar Text': 6,
        'Narkisim': 7,
        'Neue Haas Grotesk Text Pro': 7,
        'New Gulim': 7,
        'News Gothic MT': 7,
        'Niagara Engraved': 5,
        'Niagara Solid': 5,
        'Nirmala UI': 6,
        'Nirmala UI Semilight': 7,
        'Nyala': 7,
        'OCR A Extended': 8,
        'OCRB': 8,
        'Old English Text MT': 7,
        'Onyx': 5,
        'Palace Script MT': 4,
        'Palatino Linotype': 6,
        'Papyrus': 7,
        'Parchment': 3,
        'Perpetua': 5,
        'Perpetua Titling MT': 7,
        'Plantagenet Cherokee': 7,
        'Playbill': 5,
        'PMingLiU': 6,
        'PMingLiU-ExtB': 6,
        'Poor Richard': 7,
        'Pristina': 6,
        'Pyunji R': 6,
        'Raavi': 7,
        'Rage Italic': 7,
        'Ravie': 11,
        'Rockwell': 6,
        'Rockwell Condensed': 5,
        'Rockwell Extra Bold': 8,
        'Rockwell Light': 7,
        'Rockwell Nova': 7,
        'Rockwell Nova Cond': 7,
        'Rockwell Nova Cond Light': 7,
        'Rockwell Nova Extra Bold': 7,
        'Rockwell Nova Light': 7,
        'Rod': 7,
        'Sakkal Majalla': 7,
        'Sanskrit Text': 7,
        'Script MT Bold': 6,
        'Segoe MDL2 Assets': 4,
        'Segoe Print': 8,
        'Segoe Script': 8,
        'Segoe UI': 6,
        'Segoe UI Black': 7,
        'Segoe UI Emoji': 6,
        'Segoe UI Historic': 6,
        'Segoe UI Light': 6,
        'Segoe UI Semibold': 6,
        'Segoe UI Semilight': 6,
        'Segoe UI Symbol': 6,
        'Selawik': 6,
        'Selawik Light': 6,
        'Selawik Semibold': 6,
        'Shonar Bangla': 6,
        'Showcard Gothic': 6,
        'Shruti': 6,
        'Simplified Arabic': 6,
        'Simplified Arabic Fixed': 6,
        'SimSun-ExtB': 6,
        'Sitka Banner': 6,
        'Sitka Display': 6,
        'Sitka Heading': 6,
        'Sitka Small': 8,
        'Sitka Subheading': 6,
        'Sitka Text': 7,
        'Snap ITC': 10,
        'Source Sans Pro': 6,
        'Source Sans Pro Black': 6,
        'Source Sans Pro ExtraLight': 6,
        'Source Sans Pro Light': 6,
        'Source Sans Pro SemiBold': 6,
        'Stencil': 6,
        'Sylfaen': 6,
        'Symbol': 6,
        'Tahoma': 6,
        'Tempus Sans ITC': 7,
        'TH SarabunPSK': 6,
        'Times New Roman': 6,
        'Traditional Arabic': 6,
        'Trebuchet MS': 6,
        'Tunga': 6,
        'Tw Cen MT': 6,
        'Tw Cen MT Condensed': 4,
        'Tw Cen MT Condensed Extra Bold': 5,
        'UD Digi Kyokasho N-B': 6,
        'UD Digi Kyokasho NK-B': 6,
        'UD Digi Kyokasho NK-R': 6,
        'UD Digi Kyokasho NP-B': 6,
        'UD Digi Kyokasho NP-R': 6,
        'UD Digi Kyokasho N-R': 6,
        'Univers': 6,
        'Univers Condensed': 6,
        'Univers Condensed Light': 6,
        'Univers Light': 6,
        'Urdu Typesetting': 6,
        'Utsaah': 6,
        'Vani': 6,
        'Verdana': 7,
        'Verdana Pro': 6,
        'Verdana Pro Black': 6,
        'Verdana Pro Cond': 6,
        'Verdana Pro Cond Black': 6,
        'Verdana Pro Cond Light': 6,
        'Verdana Pro Cond SemiBold': 6,
        'Verdana Pro Light': 6,
        'Verdana Pro SemiBold': 6,
        'Vijaya': 6,
        'Viner Hand ITC': 7,
        'Vivaldi': 5,
        'Vladimir Script': 5,
        'Vrinda': 6,
        'Webdings': 11,
        'Wide Latin': 14,
        'Wingdings': 15,
        'Wingdings 2': 12,
        'Wingdings 3': 10,
        'Yet R': 6,
        'Yu Gothic': 6,
        'Yu Gothic Light': 6,
        'Yu Gothic Medium': 6,
        'Yu Gothic UI': 6,
        'Yu Gothic UI Light': 6,
        'Yu Gothic UI Semibold': 6,
        'Yu Gothic UI Semilight': 6,
        'Yu Mincho': 6,
        'Yu Mincho Demibold': 6,
        'Yu Mincho Light': 6,
        '\u4eff\u5b8b': 6,
        '\u534e\u6587\u4e2d\u5b8b': 7,
        '\u534e\u6587\u4eff\u5b8b': 5,
        '\u534e\u6587\u5b8b\u4f53': 5,
        '\u534e\u6587\u5f69\u4e91': 6,
        '\u534e\u6587\u65b0\u9b4f': 6,
        '\u534e\u6587\u6977\u4f53': 5,
        '\u534e\u6587\u7425\u73c0': 6,
        '\u534e\u6587\u7ec6\u9ed1': 6,
        '\u534e\u6587\u884c\u6977': 6,
        '\u534e\u6587\u96b6\u4e66': 5,
        '\u5b8b\u4f53': 6,
        '\u5e7c\u5706': 6,
        '\u5fae\u8f6f\u96c5\u9ed1': 6,
        '\u5fae\u8f6f\u96c5\u9ed1 Light': 6,
        '\u65b0\u5b8b\u4f53': 6,
        '\u65b9\u6b63\u59da\u4f53': 6,
        '\u65b9\u6b63\u8212\u4f53': 6,
        '\u6977\u4f53': 6,
        '\u7b49\u7ebf': 6,
        '\u7b49\u7ebf Light': 6,
        '\u96b6\u4e66': 6,
        '\u9ed1\u4f53': 6,
        '\u6e38\u30b4\u30b7\u30c3\u30af': 6,
        '\uff2d\uff33 \uff30\u660e\u671d': 6,
        '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af': 6,
        '\u30e1\u30a4\u30ea\u30aa': 7,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78E': 6,
        'HG\u660e\u671dB': 6,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78M': 6
    },
    9: {
        'Gill Sans MT': 6,
        'Abadi': 7,
        'Abadi Extra Light': 7,
        'Agency FB': 5,
        'Aharoni': 5,
        'Aldhabi': 4,
        'Algerian': 7,
        'Ami R': 5,
        'Angsana New': 4,
        'AngsanaUPC': 4,
        'Aparajita': 5,
        'Arabic Typesetting': 4,
        'Arial': 7,
        'Arial Black': 8,
        'Arial Narrow': 5,
        'Arial Nova': 7,
        'Arial Nova Cond': 6,
        'Arial Nova Cond Light': 5,
        'Arial Nova Light': 7,
        'Arial Rounded MT Bold': 7,
        'Baskerville Old Face': 6,
        'Batang': 6,
        'BatangChe': 6,
        'Bauhaus 93': 7,
        'Bell MT': 6,
        'Bembo': 6,
        'Berlin Sans FB': 7,
        'Berlin Sans FB Demi': 8,
        'Bernard MT Condensed': 6,
        'Blackadder ITC': 5,
        'Bodoni MT': 6,
        'Bodoni MT Black': 8,
        'Bodoni MT Condensed': 4,
        'Bodoni MT Poster Compressed': 4,
        'Book Antiqua': 6,
        'Bookman Old Style': 7,
        'Bookshelf Symbol 7': 9,
        'Bradley Hand ITC': 8,
        'Britannic Bold': 7,
        'Broadway': 8,
        'Browallia New': 4,
        'BrowalliaUPC': 4,
        'Brush Script MT': 6,
        'Calibri': 6,
        'Calibri Light': 6,
        'Californian FB': 7,
        'Calisto MT': 6,
        'Cambria': 7,
        'Cambria Math': 7,
        'Candara': 7,
        'Castellar': 9,
        'Centaur': 6,
        'Century': 7,
        'Century Gothic': 7,
        'Century Schoolbook': 7,
        'Chiller': 6,
        'Colonna MT': 6,
        'Comic Sans MS': 7,
        'Consolas': 7,
        'Constantia': 7,
        'Cooper Black': 7,
        'Copperplate Gothic Bold': 9,
        'Copperplate Gothic Light': 9,
        'Corbel': 6,
        'Cordia New': 4,
        'CordiaUPC': 4,
        'Courier New': 7,
        'Curlz MT': 6,
        'Dante': 5,
        'DaunPenh': 4,
        'David': 5,
        'DilleniaUPC': 4,
        'DokChampa': 7,
        'Dotum': 6,
        'DotumChe': 6,
        'Dubai': 6,
        'Dubai Light': 6,
        'Dubai Medium': 6,
        'Ebrima': 6,
        'Edwardian Script ITC': 6,
        'Elephant': 9,
        'Engravers MT': 8,
        'Eras Bold ITC': 8,
        'Eras Demi ITC': 7,
        'Eras Light ITC': 6,
        'Eras Medium ITC': 7,
        'EucrosiaUPC': 5,
        'Euphemia': 7,
        'Expo M': 10,
        'FangSong': 6,
        'Felix Titling': 7,
        'Footlight MT Light': 7,
        'Forte': 6,
        'Franklin Gothic Book': 7,
        'Franklin Gothic Demi': 7,
        'Franklin Gothic Demi Cond': 6,
        'Franklin Gothic Heavy': 7,
        'Franklin Gothic Medium': 7,
        'Franklin Gothic Medium Cond': 6,
        'FrankRuehl': 5,
        'FreesiaUPC': 5,
        'Freestyle Script': 5,
        'French Script MT': 4,
        'Gabriola': 5,
        'Gadugi': 6,
        'Garamond': 6,
        'Gautami': 7,
        'Georgia': 8,
        'Georgia Pro': 7,
        'Georgia Pro Black': 9,
        'Georgia Pro Cond': 6,
        'Georgia Pro Cond Black': 8,
        'Georgia Pro Cond Light': 6,
        'Georgia Pro Cond Semibold': 7,
        'Georgia Pro Light': 7,
        'Georgia Pro Semibold': 7,
        'Gigi': 7,
        'Gill Sans MT Condensed': 4,
        'Gill Sans MT Ext Condensed Bold': 4,
        'Gill Sans Nova': 6,
        'Gill Sans Nova Cond': 4,
        'Gill Sans Nova Cond Lt': 4,
        'Gill Sans Nova Cond Ultra Bold': 7,
        'Gill Sans Nova Cond XBd': 6,
        'Gill Sans Nova Light': 6,
        'Gill Sans Nova Ultra Bold': 10,
        'Gill Sans Ultra Bold': 10,
        'Gill Sans Ultra Bold Condensed': 7,
        'Gisha': 6,
        'Gloucester MT Extra Condensed': 5,
        'Goudy Old Style': 6,
        'Goudy Stout': 10,
        'Grotesque': 6,
        'Grotesque Light': 6,
        'Gulim': 6,
        'GulimChe': 6,
        'Gungsuh': 6,
        'GungsuhChe': 6,
        'Hadassah Friedlaender': 7,
        'Haettenschweiler': 5,
        'Harlow Solid Italic': 6,
        'Harrington': 7,
        'Headline R': 9,
        'HGGothicE': 6,
        'HGGothicM': 6,
        'HGGyoshotai': 6,
        'HGKyokashotai': 6,
        'HGMaruGothicMPRO': 9,
        'HGMinchoB': 7,
        'HGMinchoE': 7,
        'HGPGothicE': 8,
        'HGPGothicM': 8,
        'HGPGyoshotai': 7,
        'HGPKyokashotai': 7,
        'HGPMinchoB': 7,
        'HGPMinchoE': 7,
        'HGPSoeiKakugothicUB': 9,
        'HGPSoeiKakupoptai': 9,
        'HGPSoeiPresenceEB': 8,
        'HGSeikaishotaiPRO': 7,
        'HGSGothicE': 7,
        'HGSGothicM': 7,
        'HGSGyoshotai': 6,
        'HGSKyokashotai': 6,
        'HGSMinchoB': 7,
        'HGSMinchoE': 7,
        'HGSoeiKakugothicUB': 7,
        'HGSoeiKakupoptai': 7,
        'HGSoeiPresenceEB': 7,
        'HGSSoeiKakugothicUB': 8,
        'HGSSoeiKakupoptai': 8,
        'HGSSoeiPresenceEB': 7,
        'High Tower Text': 6,
        'HYGothic-Extra': 8,
        'HYGothic-Medium': 7,
        'HYGraphic-Medium': 7,
        'HYGungSo-Bold': 7,
        'HYHeadLine-Medium': 7,
        'HYMyeongJo-Extra': 8,
        'HYPMokGak-Bold': 9,
        'HYPost-Light': 8,
        'HYPost-Medium': 9,
        'HYShortSamul-Medium': 5,
        'HYSinMyeongJo-Medium': 8,
        'Impact': 7,
        'Imprint MT Shadow': 6,
        'Informal Roman': 7,
        'Ink Free': 6,
        'IrisUPC': 6,
        'Iskoola Pota': 6,
        'JasmineUPC': 6,
        'Javanese Text': 7,
        'Jokerman': 9,
        'Juice ITC': 4,
        'KaiTi': 6,
        'Kalinga': 6,
        'Kartika': 6,
        'Khmer UI': 6,
        'KodchiangUPC': 6,
        'Kokila': 6,
        'Kristen ITC': 7,
        'Kunstler Script': 4,
        'Lao UI': 6,
        'Latha': 6,
        'Leelawadee': 6,
        'Leelawadee UI': 6,
        'Leelawadee UI Semilight': 7,
        'Levenim MT': 6,
        'LilyUPC': 6,
        'Lucida Bright': 7,
        'Lucida Calligraphy': 9,
        'Lucida Console': 8,
        'Lucida Fax': 8,
        'Lucida Handwriting': 9,
        'Lucida Sans': 8,
        'Lucida Sans Typewriter': 7,
        'Lucida Sans Unicode': 9,
        'Magic R': 8,
        'Magneto': 9,
        'Maiandra GD': 8,
        'Malgun Gothic': 7,
        'Malgun Gothic Semilight': 8,
        'Mangal': 7,
        'Marlett': 13,
        'Matura MT Script Capitals': 9,
        'Meiryo': 8,
        'Meiryo UI': 8,
        'Microsoft GothicNeo': 7,
        'Microsoft Himalaya': 5,
        'Microsoft JhengHei': 7,
        'Microsoft JhengHei Light': 8,
        'Microsoft JhengHei UI': 7,
        'Microsoft JhengHei UI Light': 8,
        'Microsoft New Tai Lue': 7,
        'Microsoft PhagsPa': 7,
        'Microsoft Sans Serif': 8,
        'Microsoft Tai Le': 7,
        'Microsoft Uighur': 5,
        'Microsoft YaHei Light': 8,
        'Microsoft YaHei UI': 7,
        'Microsoft YaHei UI Light': 8,
        'Microsoft Yi Baiti': 7,
        'MingLiU': 7,
        'MingLiU_HKSCS': 7,
        'MingLiU_HKSCS-ExtB': 7,
        'MingLiU-ExtB': 7,
        'Miriam': 7,
        'Miriam Fixed': 7,
        'Mistral': 6,
        'Modern No. 20': 6,
        'MoeumT R': 8,
        'Mongolian Baiti': 7,
        'Monotype Corsiva': 6,
        'MoolBoran': 7,
        'MS Gothic': 7,
        'MS Mincho': 7,
        'MS Outlook': 7,
        'MS PGothic': 7,
        'MS PMincho': 7,
        'MS Reference Sans Serif': 9,
        'MS Reference Specialty': 15,
        'MS UI Gothic': 7,
        'MT Extra': 13,
        'MV Boli': 9,
        'Myanmar Text': 7,
        'Narkisim': 7,
        'Neue Haas Grotesk Text Pro': 7,
        'New Gulim': 8,
        'News Gothic MT': 7,
        'Niagara Engraved': 5,
        'Niagara Solid': 5,
        'Nirmala UI': 7,
        'Nirmala UI Semilight': 8,
        'Nyala': 7,
        'OCR A Extended': 8,
        'OCRB': 8,
        'Old English Text MT': 7,
        'Onyx': 5,
        'Palace Script MT': 5,
        'Palatino Linotype': 6,
        'Papyrus': 8,
        'Parchment': 4,
        'Perpetua': 6,
        'Perpetua Titling MT': 8,
        'Plantagenet Cherokee': 7,
        'Playbill': 5,
        'PMingLiU': 7,
        'PMingLiU-ExtB': 7,
        'Poor Richard': 8,
        'Pristina': 6,
        'Pyunji R': 7,
        'Raavi': 7,
        'Rage Italic': 7,
        'Ravie': 12,
        'Rockwell': 7,
        'Rockwell Condensed': 5,
        'Rockwell Extra Bold': 8,
        'Rockwell Light': 7,
        'Rockwell Nova': 7,
        'Rockwell Nova Cond': 7,
        'Rockwell Nova Cond Light': 7,
        'Rockwell Nova Extra Bold': 7,
        'Rockwell Nova Light': 7,
        'Rod': 7,
        'Sakkal Majalla': 7,
        'Sanskrit Text': 7,
        'Script MT Bold': 6,
        'Segoe MDL2 Assets': 5,
        'Segoe Print': 9,
        'Segoe Script': 9,
        'Segoe UI': 6,
        'Segoe UI Black': 7,
        'Segoe UI Emoji': 6,
        'Segoe UI Historic': 6,
        'Segoe UI Light': 6,
        'Segoe UI Semibold': 7,
        'Segoe UI Semilight': 7,
        'Segoe UI Symbol': 6,
        'Selawik': 6,
        'Selawik Light': 6,
        'Selawik Semibold': 6,
        'Shonar Bangla': 6,
        'Showcard Gothic': 8,
        'Shruti': 6,
        'Simplified Arabic': 6,
        'Simplified Arabic Fixed': 6,
        'SimSun-ExtB': 6,
        'Sitka Banner': 6,
        'Sitka Display': 6,
        'Sitka Heading': 7,
        'Sitka Small': 8,
        'Sitka Subheading': 7,
        'Sitka Text': 8,
        'Snap ITC': 10,
        'Source Sans Pro': 6,
        'Source Sans Pro Black': 6,
        'Source Sans Pro ExtraLight': 6,
        'Source Sans Pro Light': 6,
        'Source Sans Pro SemiBold': 6,
        'Stencil': 7,
        'Sylfaen': 6,
        'Symbol': 6,
        'Tahoma': 7,
        'Tempus Sans ITC': 8,
        'TH SarabunPSK': 6,
        'Times New Roman': 6,
        'Traditional Arabic': 6,
        'Trebuchet MS': 6,
        'Tunga': 6,
        'Tw Cen MT': 7,
        'Tw Cen MT Condensed': 4,
        'Tw Cen MT Condensed Extra Bold': 6,
        'UD Digi Kyokasho N-B': 6,
        'UD Digi Kyokasho NK-B': 6,
        'UD Digi Kyokasho NK-R': 6,
        'UD Digi Kyokasho NP-B': 6,
        'UD Digi Kyokasho NP-R': 6,
        'UD Digi Kyokasho N-R': 6,
        'Univers': 6,
        'Univers Condensed': 6,
        'Univers Condensed Light': 6,
        'Univers Light': 6,
        'Urdu Typesetting': 6,
        'Utsaah': 6,
        'Vani': 6,
        'Verdana': 8,
        'Verdana Pro': 6,
        'Verdana Pro Black': 6,
        'Verdana Pro Cond': 6,
        'Verdana Pro Cond Black': 6,
        'Verdana Pro Cond Light': 6,
        'Verdana Pro Cond SemiBold': 6,
        'Verdana Pro Light': 6,
        'Verdana Pro SemiBold': 6,
        'Vijaya': 6,
        'Viner Hand ITC': 8,
        'Vivaldi': 5,
        'Vladimir Script': 6,
        'Vrinda': 6,
        'Webdings': 12,
        'Wide Latin': 15,
        'Wingdings': 16,
        'Wingdings 2': 14,
        'Wingdings 3': 11,
        'Yet R': 6,
        'Yu Gothic': 7,
        'Yu Gothic Light': 6,
        'Yu Gothic Medium': 7,
        'Yu Gothic UI': 6,
        'Yu Gothic UI Light': 6,
        'Yu Gothic UI Semibold': 7,
        'Yu Gothic UI Semilight': 7,
        'Yu Mincho': 7,
        'Yu Mincho Demibold': 6,
        'Yu Mincho Light': 6,
        '\u4eff\u5b8b': 6,
        '\u534e\u6587\u4e2d\u5b8b': 7,
        '\u534e\u6587\u4eff\u5b8b': 6,
        '\u534e\u6587\u5b8b\u4f53': 6,
        '\u534e\u6587\u5f69\u4e91': 7,
        '\u534e\u6587\u65b0\u9b4f': 7,
        '\u534e\u6587\u6977\u4f53': 6,
        '\u534e\u6587\u7425\u73c0': 7,
        '\u534e\u6587\u7ec6\u9ed1': 7,
        '\u534e\u6587\u884c\u6977': 6,
        '\u534e\u6587\u96b6\u4e66': 5,
        '\u5b8b\u4f53': 6,
        '\u5e7c\u5706': 6,
        '\u5fae\u8f6f\u96c5\u9ed1': 7,
        '\u5fae\u8f6f\u96c5\u9ed1 Light': 7,
        '\u65b0\u5b8b\u4f53': 6,
        '\u65b9\u6b63\u59da\u4f53': 6,
        '\u65b9\u6b63\u8212\u4f53': 7,
        '\u6977\u4f53': 6,
        '\u7b49\u7ebf': 6,
        '\u7b49\u7ebf Light': 6,
        '\u96b6\u4e66': 6,
        '\u9ed1\u4f53': 6,
        '\u6e38\u30b4\u30b7\u30c3\u30af': 7,
        '\uff2d\uff33 \uff30\u660e\u671d': 6,
        '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af': 6,
        '\u30e1\u30a4\u30ea\u30aa': 7,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78E': 6,
        'HG\u660e\u671dB': 6,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78M': 6
    },
    10: {
        'Gill Sans MT': 7,
        'Abadi': 8,
        'Abadi Extra Light': 7,
        'Agency FB': 5,
        'Aharoni': 5,
        'Aldhabi': 4,
        'Algerian': 8,
        'Ami R': 5,
        'Angsana New': 4,
        'AngsanaUPC': 4,
        'Aparajita': 5,
        'Arabic Typesetting': 4,
        'Arial': 7,
        'Arial Black': 9,
        'Arial Narrow': 6,
        'Arial Nova': 7,
        'Arial Nova Cond': 7,
        'Arial Nova Cond Light': 6,
        'Arial Nova Light': 7,
        'Arial Rounded MT Bold': 8,
        'Baskerville Old Face': 6,
        'Batang': 7,
        'BatangChe': 7,
        'Bauhaus 93': 7,
        'Bell MT': 7,
        'Bembo': 6,
        'Berlin Sans FB': 8,
        'Berlin Sans FB Demi': 8,
        'Bernard MT Condensed': 6,
        'Blackadder ITC': 5,
        'Bodoni MT': 6,
        'Bodoni MT Black': 9,
        'Bodoni MT Condensed': 4,
        'Bodoni MT Poster Compressed': 5,
        'Book Antiqua': 7,
        'Bookman Old Style': 8,
        'Bookshelf Symbol 7': 10,
        'Bradley Hand ITC': 8,
        'Britannic Bold': 8,
        'Broadway': 8,
        'Browallia New': 5,
        'BrowalliaUPC': 5,
        'Brush Script MT': 7,
        'Calibri': 7,
        'Calibri Light': 7,
        'Californian FB': 7,
        'Calisto MT': 7,
        'Cambria': 7,
        'Cambria Math': 7,
        'Candara': 7,
        'Castellar': 9,
        'Centaur': 6,
        'Century': 7,
        'Century Gothic': 7,
        'Century Schoolbook': 7,
        'Chiller': 6,
        'Colonna MT': 7,
        'Comic Sans MS': 8,
        'Consolas': 7,
        'Constantia': 7,
        'Cooper Black': 8,
        'Copperplate Gothic Bold': 9,
        'Copperplate Gothic Light': 9,
        'Corbel': 7,
        'Cordia New': 5,
        'CordiaUPC': 5,
        'Courier New': 8,
        'Curlz MT': 7,
        'Dante': 6,
        'DaunPenh': 4,
        'David': 6,
        'DilleniaUPC': 4,
        'DokChampa': 7,
        'Dotum': 6,
        'DotumChe': 7,
        'Dubai': 7,
        'Dubai Light': 7,
        'Dubai Medium': 7,
        'Ebrima': 7,
        'Edwardian Script ITC': 6,
        'Elephant': 10,
        'Engravers MT': 8,
        'Eras Bold ITC': 8,
        'Eras Demi ITC': 8,
        'Eras Light ITC': 7,
        'Eras Medium ITC': 7,
        'EucrosiaUPC': 5,
        'Euphemia': 8,
        'Expo M': 11,
        'FangSong': 7,
        'Felix Titling': 8,
        'Footlight MT Light': 7,
        'Forte': 7,
        'Franklin Gothic Book': 8,
        'Franklin Gothic Demi': 8,
        'Franklin Gothic Demi Cond': 7,
        'Franklin Gothic Heavy': 8,
        'Franklin Gothic Medium': 8,
        'Franklin Gothic Medium Cond': 7,
        'FrankRuehl': 5,
        'FreesiaUPC': 6,
        'Freestyle Script': 5,
        'French Script MT': 5,
        'Gabriola': 5,
        'Gadugi': 7,
        'Garamond': 6,
        'Gautami': 8,
        'Georgia': 9,
        'Georgia Pro': 7,
        'Georgia Pro Black': 9,
        'Georgia Pro Cond': 7,
        'Georgia Pro Cond Black': 8,
        'Georgia Pro Cond Light': 7,
        'Georgia Pro Cond Semibold': 7,
        'Georgia Pro Light': 7,
        'Georgia Pro Semibold': 8,
        'Gigi': 7,
        'Gill Sans MT Condensed': 5,
        'Gill Sans MT Ext Condensed Bold': 4,
        'Gill Sans Nova': 7,
        'Gill Sans Nova Cond': 4,
        'Gill Sans Nova Cond Lt': 4,
        'Gill Sans Nova Cond Ultra Bold': 8,
        'Gill Sans Nova Cond XBd': 7,
        'Gill Sans Nova Light': 7,
        'Gill Sans Nova Ultra Bold': 11,
        'Gill Sans Ultra Bold': 11,
        'Gill Sans Ultra Bold Condensed': 8,
        'Gisha': 7,
        'Gloucester MT Extra Condensed': 5,
        'Goudy Old Style': 7,
        'Goudy Stout': 11,
        'Grotesque': 6,
        'Grotesque Light': 6,
        'Gulim': 7,
        'GulimChe': 7,
        'Gungsuh': 6,
        'GungsuhChe': 7,
        'Hadassah Friedlaender': 7,
        'Haettenschweiler': 6,
        'Harlow Solid Italic': 6,
        'Harrington': 7,
        'Headline R': 9,
        'HGGothicE': 7,
        'HGGothicM': 7,
        'HGGyoshotai': 7,
        'HGKyokashotai': 7,
        'HGMaruGothicMPRO': 10,
        'HGMinchoB': 8,
        'HGMinchoE': 8,
        'HGPGothicE': 8,
        'HGPGothicM': 9,
        'HGPGyoshotai': 7,
        'HGPKyokashotai': 7,
        'HGPMinchoB': 7,
        'HGPMinchoE': 8,
        'HGPSoeiKakugothicUB': 9,
        'HGPSoeiKakupoptai': 9,
        'HGPSoeiPresenceEB': 8,
        'HGSeikaishotaiPRO': 8,
        'HGSGothicE': 7,
        'HGSGothicM': 8,
        'HGSGyoshotai': 6,
        'HGSKyokashotai': 6,
        'HGSMinchoB': 7,
        'HGSMinchoE': 8,
        'HGSoeiKakugothicUB': 8,
        'HGSoeiKakupoptai': 8,
        'HGSoeiPresenceEB': 8,
        'HGSSoeiKakugothicUB': 8,
        'HGSSoeiKakupoptai': 8,
        'HGSSoeiPresenceEB': 7,
        'High Tower Text': 6,
        'HYGothic-Extra': 8,
        'HYGothic-Medium': 8,
        'HYGraphic-Medium': 8,
        'HYGungSo-Bold': 8,
        'HYHeadLine-Medium': 8,
        'HYMyeongJo-Extra': 9,
        'HYPMokGak-Bold': 9,
        'HYPost-Light': 9,
        'HYPost-Medium': 9,
        'HYShortSamul-Medium': 5,
        'HYSinMyeongJo-Medium': 8,
        'Impact': 7,
        'Imprint MT Shadow': 7,
        'Informal Roman': 7,
        'Ink Free': 7,
        'IrisUPC': 7,
        'Iskoola Pota': 7,
        'JasmineUPC': 7,
        'Javanese Text': 8,
        'Jokerman': 9,
        'Juice ITC': 5,
        'KaiTi': 7,
        'Kalinga': 7,
        'Kartika': 7,
        'Khmer UI': 7,
        'KodchiangUPC': 4,
        'Kokila': 7,
        'Kristen ITC': 8,
        'Kunstler Script': 5,
        'Lao UI': 7,
        'Latha': 7,
        'Leelawadee': 7,
        'Leelawadee UI': 7,
        'Leelawadee UI Semilight': 7,
        'Levenim MT': 7,
        'LilyUPC': 7,
        'Lucida Bright': 8,
        'Lucida Calligraphy': 10,
        'Lucida Console': 9,
        'Lucida Fax': 9,
        'Lucida Handwriting': 10,
        'Lucida Sans': 9,
        'Lucida Sans Typewriter': 8,
        'Lucida Sans Unicode': 9,
        'Magic R': 8,
        'Magneto': 10,
        'Maiandra GD': 9,
        'Malgun Gothic': 8,
        'Malgun Gothic Semilight': 8,
        'Mangal': 8,
        'Marlett': 14,
        'Matura MT Script Capitals': 10,
        'Meiryo': 9,
        'Meiryo UI': 9,
        'Microsoft GothicNeo': 8,
        'Microsoft Himalaya': 5,
        'Microsoft JhengHei': 8,
        'Microsoft JhengHei Light': 8,
        'Microsoft JhengHei UI': 8,
        'Microsoft JhengHei UI Light': 8,
        'Microsoft New Tai Lue': 7,
        'Microsoft PhagsPa': 7,
        'Microsoft Sans Serif': 8,
        'Microsoft Tai Le': 7,
        'Microsoft Uighur': 5,
        'Microsoft YaHei Light': 8,
        'Microsoft YaHei UI': 8,
        'Microsoft YaHei UI Light': 8,
        'Microsoft Yi Baiti': 8,
        'MingLiU': 8,
        'MingLiU_HKSCS': 8,
        'MingLiU_HKSCS-ExtB': 8,
        'MingLiU-ExtB': 8,
        'Miriam': 8,
        'Miriam Fixed': 8,
        'Mistral': 7,
        'Modern No. 20': 7,
        'MoeumT R': 8,
        'Mongolian Baiti': 8,
        'Monotype Corsiva': 7,
        'MoolBoran': 8,
        'MS Gothic': 8,
        'MS Mincho': 8,
        'MS Outlook': 8,
        'MS PGothic': 8,
        'MS PMincho': 8,
        'MS Reference Sans Serif': 9,
        'MS Reference Specialty': 17,
        'MS UI Gothic': 8,
        'MT Extra': 14,
        'MV Boli': 10,
        'Myanmar Text': 7,
        'Narkisim': 8,
        'Neue Haas Grotesk Text Pro': 8,
        'New Gulim': 8,
        'News Gothic MT': 8,
        'Niagara Engraved': 5,
        'Niagara Solid': 5,
        'Nirmala UI': 7,
        'Nirmala UI Semilight': 8,
        'Nyala': 8,
        'OCR A Extended': 9,
        'OCRB': 9,
        'Old English Text MT': 8,
        'Onyx': 6,
        'Palace Script MT': 5,
        'Palatino Linotype': 7,
        'Papyrus': 9,
        'Parchment': 4,
        'Perpetua': 6,
        'Perpetua Titling MT': 9,
        'Plantagenet Cherokee': 8,
        'Playbill': 6,
        'PMingLiU': 7,
        'PMingLiU-ExtB': 7,
        'Poor Richard': 8,
        'Pristina': 8,
        'Pyunji R': 7,
        'Raavi': 8,
        'Rage Italic': 8,
        'Ravie': 13,
        'Rockwell': 7,
        'Rockwell Condensed': 6,
        'Rockwell Extra Bold': 9,
        'Rockwell Light': 8,
        'Rockwell Nova': 8,
        'Rockwell Nova Cond': 8,
        'Rockwell Nova Cond Light': 8,
        'Rockwell Nova Extra Bold': 8,
        'Rockwell Nova Light': 8,
        'Rod': 8,
        'Sakkal Majalla': 8,
        'Sanskrit Text': 8,
        'Script MT Bold': 7,
        'Segoe MDL2 Assets': 5,
        'Segoe Print': 10,
        'Segoe Script': 10,
        'Segoe UI': 7,
        'Segoe UI Black': 8,
        'Segoe UI Emoji': 7,
        'Segoe UI Historic': 7,
        'Segoe UI Light': 7,
        'Segoe UI Semibold': 7,
        'Segoe UI Semilight': 7,
        'Segoe UI Symbol': 7,
        'Selawik': 7,
        'Selawik Light': 7,
        'Selawik Semibold': 7,
        'Shonar Bangla': 7,
        'Showcard Gothic': 8,
        'Shruti': 7,
        'Simplified Arabic': 7,
        'Simplified Arabic Fixed': 7,
        'SimSun-ExtB': 7,
        'Sitka Banner': 7,
        'Sitka Display': 7,
        'Sitka Heading': 7,
        'Sitka Small': 9,
        'Sitka Subheading': 8,
        'Sitka Text': 8,
        'Snap ITC': 11,
        'Source Sans Pro': 7,
        'Source Sans Pro Black': 7,
        'Source Sans Pro ExtraLight': 7,
        'Source Sans Pro Light': 7,
        'Source Sans Pro SemiBold': 7,
        'Stencil': 7,
        'Sylfaen': 7,
        'Symbol': 7,
        'Tahoma': 7,
        'Tempus Sans ITC': 9,
        'TH SarabunPSK': 7,
        'Times New Roman': 7,
        'Traditional Arabic': 7,
        'Trebuchet MS': 7,
        'Tunga': 7,
        'Tw Cen MT': 7,
        'Tw Cen MT Condensed': 5,
        'Tw Cen MT Condensed Extra Bold': 6,
        'UD Digi Kyokasho N-B': 7,
        'UD Digi Kyokasho NK-B': 7,
        'UD Digi Kyokasho NK-R': 7,
        'UD Digi Kyokasho NP-B': 7,
        'UD Digi Kyokasho NP-R': 7,
        'UD Digi Kyokasho N-R': 7,
        'Univers': 7,
        'Univers Condensed': 7,
        'Univers Condensed Light': 7,
        'Univers Light': 7,
        'Urdu Typesetting': 7,
        'Utsaah': 7,
        'Vani': 7,
        'Verdana': 8,
        'Verdana Pro': 8,
        'Verdana Pro Black': 7,
        'Verdana Pro Cond': 7,
        'Verdana Pro Cond Black': 7,
        'Verdana Pro Cond Light': 7,
        'Verdana Pro Cond SemiBold': 7,
        'Verdana Pro Light': 7,
        'Verdana Pro SemiBold': 7,
        'Vijaya': 7,
        'Viner Hand ITC': 9,
        'Vivaldi': 6,
        'Vladimir Script': 6,
        'Vrinda': 7,
        'Webdings': 13,
        'Wide Latin': 16,
        'Wingdings': 17,
        'Wingdings 2': 15,
        'Wingdings 3': 12,
        'Yet R': 7,
        'Yu Gothic': 7,
        'Yu Gothic Light': 7,
        'Yu Gothic Medium': 7,
        'Yu Gothic UI': 7,
        'Yu Gothic UI Light': 7,
        'Yu Gothic UI Semibold': 7,
        'Yu Gothic UI Semilight': 7,
        'Yu Mincho': 7,
        'Yu Mincho Demibold': 7,
        'Yu Mincho Light': 7,
        '\u4eff\u5b8b': 7,
        '\u534e\u6587\u4e2d\u5b8b': 8,
        '\u534e\u6587\u4eff\u5b8b': 6,
        '\u534e\u6587\u5b8b\u4f53': 6,
        '\u534e\u6587\u5f69\u4e91': 7,
        '\u534e\u6587\u65b0\u9b4f': 8,
        '\u534e\u6587\u6977\u4f53': 6,
        '\u534e\u6587\u7425\u73c0': 7,
        '\u534e\u6587\u7ec6\u9ed1': 7,
        '\u534e\u6587\u884c\u6977': 7,
        '\u534e\u6587\u96b6\u4e66': 6,
        '\u5b8b\u4f53': 7,
        '\u5e7c\u5706': 7,
        '\u5fae\u8f6f\u96c5\u9ed1': 8,
        '\u5fae\u8f6f\u96c5\u9ed1 Light': 7,
        '\u65b0\u5b8b\u4f53': 7,
        '\u65b9\u6b63\u59da\u4f53': 7,
        '\u65b9\u6b63\u8212\u4f53': 7,
        '\u6977\u4f53': 7,
        '\u7b49\u7ebf': 7,
        '\u7b49\u7ebf Light': 7,
        '\u96b6\u4e66': 7,
        '\u9ed1\u4f53': 7,
        '\u6e38\u30b4\u30b7\u30c3\u30af': 7,
        '\uff2d\uff33 \uff30\u660e\u671d': 7,
        '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af': 7,
        '\u30e1\u30a4\u30ea\u30aa': 8,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78E': 7,
        'HG\u660e\u671dB': 7,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78M': 7
    },
    11: {
        'Gill Sans MT': 8,
        'Abadi': 9,
        'Abadi Extra Light': 8,
        'Agency FB': 6,
        'Aharoni': 6,
        'Aldhabi': 5,
        'Algerian': 9,
        'Ami R': 6,
        'Angsana New': 5,
        'AngsanaUPC': 5,
        'Aparajita': 6,
        'Arabic Typesetting': 5,
        'Arial': 8,
        'Arial Black': 10,
        'Arial Narrow': 7,
        'Arial Nova': 8,
        'Arial Nova Cond': 8,
        'Arial Nova Cond Light': 7,
        'Arial Nova Light': 8,
        'Arial Rounded MT Bold': 9,
        'Baskerville Old Face': 7,
        'Batang': 8,
        'BatangChe': 8,
        'Bauhaus 93': 9,
        'Bell MT': 8,
        'Bembo': 7,
        'Berlin Sans FB': 9,
        'Berlin Sans FB Demi': 9,
        'Bernard MT Condensed': 7,
        'Blackadder ITC': 6,
        'Bodoni MT': 7,
        'Bodoni MT Black': 10,
        'Bodoni MT Condensed': 5,
        'Bodoni MT Poster Compressed': 5,
        'Book Antiqua': 8,
        'Bookman Old Style': 9,
        'Bookshelf Symbol 7': 11,
        'Bradley Hand ITC': 10,
        'Britannic Bold': 9,
        'Broadway': 10,
        'Browallia New': 5,
        'BrowalliaUPC': 5,
        'Brush Script MT': 8,
        'Calibri': 7,
        'Calibri Light': 8,
        'Californian FB': 9,
        'Calisto MT': 8,
        'Cambria': 8,
        'Cambria Math': 8,
        'Candara': 8,
        'Castellar': 11,
        'Centaur': 7,
        'Century': 8,
        'Century Gothic': 8,
        'Century Schoolbook': 8,
        'Chiller': 7,
        'Colonna MT': 8,
        'Comic Sans MS': 9,
        'Consolas': 8,
        'Constantia': 8,
        'Cooper Black': 9,
        'Copperplate Gothic Bold': 11,
        'Copperplate Gothic Light': 11,
        'Corbel': 8,
        'Cordia New': 5,
        'CordiaUPC': 5,
        'Courier New': 9,
        'Curlz MT': 8,
        'Dante': 7,
        'DaunPenh': 5,
        'David': 7,
        'DilleniaUPC': 5,
        'DokChampa': 8,
        'Dotum': 9,
        'DotumChe': 8,
        'Dubai': 8,
        'Dubai Light': 8,
        'Dubai Medium': 8,
        'Ebrima': 8,
        'Edwardian Script ITC': 7,
        'Elephant': 11,
        'Engravers MT': 10,
        'Eras Bold ITC': 10,
        'Eras Demi ITC': 9,
        'Eras Light ITC': 8,
        'Eras Medium ITC': 9,
        'EucrosiaUPC': 6,
        'Euphemia': 9,
        'Expo M': 13,
        'FangSong': 8,
        'Felix Titling': 9,
        'Footlight MT Light': 8,
        'Forte': 8,
        'Franklin Gothic Book': 9,
        'Franklin Gothic Demi': 9,
        'Franklin Gothic Demi Cond': 8,
        'Franklin Gothic Heavy': 9,
        'Franklin Gothic Medium': 9,
        'Franklin Gothic Medium Cond': 8,
        'FrankRuehl': 6,
        'FreesiaUPC': 7,
        'Freestyle Script': 6,
        'French Script MT': 5,
        'Gabriola': 6,
        'Gadugi': 8,
        'Garamond': 7,
        'Gautami': 9,
        'Georgia': 9,
        'Georgia Pro': 8,
        'Georgia Pro Black': 11,
        'Georgia Pro Cond': 8,
        'Georgia Pro Cond Black': 10,
        'Georgia Pro Cond Light': 8,
        'Georgia Pro Cond Semibold': 8,
        'Georgia Pro Light': 8,
        'Georgia Pro Semibold': 9,
        'Gigi': 7,
        'Gill Sans MT Condensed': 5,
        'Gill Sans MT Ext Condensed Bold': 5,
        'Gill Sans Nova': 8,
        'Gill Sans Nova Cond': 5,
        'Gill Sans Nova Cond Lt': 5,
        'Gill Sans Nova Cond Ultra Bold': 9,
        'Gill Sans Nova Cond XBd': 8,
        'Gill Sans Nova Light': 8,
        'Gill Sans Nova Ultra Bold': 13,
        'Gill Sans Ultra Bold': 13,
        'Gill Sans Ultra Bold Condensed': 9,
        'Gisha': 8,
        'Gloucester MT Extra Condensed': 6,
        'Goudy Old Style': 8,
        'Goudy Stout': 12,
        'Grotesque': 7,
        'Grotesque Light': 7,
        'Gulim': 8,
        'GulimChe': 8,
        'Gungsuh': 7,
        'GungsuhChe': 8,
        'Hadassah Friedlaender': 9,
        'Haettenschweiler': 7,
        'Harlow Solid Italic': 7,
        'Harrington': 8,
        'Headline R': 11,
        'HGGothicE': 8,
        'HGGothicM': 8,
        'HGGyoshotai': 8,
        'HGKyokashotai': 8,
        'HGMaruGothicMPRO': 11,
        'HGMinchoB': 9,
        'HGMinchoE': 9,
        'HGPGothicE': 9,
        'HGPGothicM': 10,
        'HGPGyoshotai': 8,
        'HGPKyokashotai': 8,
        'HGPMinchoB': 8,
        'HGPMinchoE': 9,
        'HGPSoeiKakugothicUB': 10,
        'HGPSoeiKakupoptai': 11,
        'HGPSoeiPresenceEB': 9,
        'HGSeikaishotaiPRO': 9,
        'HGSGothicE': 8,
        'HGSGothicM': 9,
        'HGSGyoshotai': 7,
        'HGSKyokashotai': 7,
        'HGSMinchoB': 8,
        'HGSMinchoE': 9,
        'HGSoeiKakugothicUB': 9,
        'HGSoeiKakupoptai': 9,
        'HGSoeiPresenceEB': 9,
        'HGSSoeiKakugothicUB': 9,
        'HGSSoeiKakupoptai': 10,
        'HGSSoeiPresenceEB': 8,
        'High Tower Text': 7,
        'HYGothic-Extra': 9,
        'HYGothic-Medium': 9,
        'HYGraphic-Medium': 9,
        'HYGungSo-Bold': 9,
        'HYHeadLine-Medium': 9,
        'HYMyeongJo-Extra': 10,
        'HYPMokGak-Bold': 11,
        'HYPost-Light': 10,
        'HYPost-Medium': 11,
        'HYShortSamul-Medium': 6,
        'HYSinMyeongJo-Medium': 9,
        'Impact': 8,
        'Imprint MT Shadow': 8,
        'Informal Roman': 8,
        'Ink Free': 8,
        'IrisUPC': 8,
        'Iskoola Pota': 8,
        'JasmineUPC': 8,
        'Javanese Text': 9,
        'Jokerman': 11,
        'Juice ITC': 6,
        'KaiTi': 8,
        'Kalinga': 8,
        'Kartika': 8,
        'Khmer UI': 8,
        'KodchiangUPC': 5,
        'Kokila': 8,
        'Kristen ITC': 9,
        'Kunstler Script': 5,
        'Lao UI': 8,
        'Latha': 8,
        'Leelawadee': 8,
        'Leelawadee UI': 8,
        'Leelawadee UI Semilight': 8,
        'Levenim MT': 9,
        'LilyUPC': 8,
        'Lucida Bright': 9,
        'Lucida Calligraphy': 11,
        'Lucida Console': 10,
        'Lucida Fax': 10,
        'Lucida Handwriting': 11,
        'Lucida Sans': 10,
        'Lucida Sans Typewriter': 9,
        'Lucida Sans Unicode': 10,
        'Magic R': 9,
        'Magneto': 12,
        'Maiandra GD': 10,
        'Malgun Gothic': 9,
        'Malgun Gothic Semilight': 9,
        'Mangal': 9,
        'Marlett': 16,
        'Matura MT Script Capitals': 11,
        'Meiryo': 10,
        'Meiryo UI': 10,
        'Microsoft GothicNeo': 9,
        'Microsoft Himalaya': 6,
        'Microsoft JhengHei': 9,
        'Microsoft JhengHei Light': 10,
        'Microsoft JhengHei UI': 9,
        'Microsoft JhengHei UI Light': 10,
        'Microsoft New Tai Lue': 9,
        'Microsoft PhagsPa': 9,
        'Microsoft Sans Serif': 9,
        'Microsoft Tai Le': 9,
        'Microsoft Uighur': 6,
        'Microsoft YaHei Light': 10,
        'Microsoft YaHei UI': 9,
        'Microsoft YaHei UI Light': 10,
        'Microsoft Yi Baiti': 9,
        'MingLiU': 9,
        'MingLiU_HKSCS': 9,
        'MingLiU_HKSCS-ExtB': 9,
        'MingLiU-ExtB': 9,
        'Miriam': 9,
        'Miriam Fixed': 10,
        'Mistral': 8,
        'Modern No. 20': 8,
        'MoeumT R': 9,
        'Mongolian Baiti': 9,
        'Monotype Corsiva': 8,
        'MoolBoran': 9,
        'MS Gothic': 9,
        'MS Mincho': 9,
        'MS Outlook': 9,
        'MS PGothic': 9,
        'MS PMincho': 9,
        'MS Reference Sans Serif': 11,
        'MS Reference Specialty': 19,
        'MS UI Gothic': 9,
        'MT Extra': 16,
        'MV Boli': 12,
        'Myanmar Text': 9,
        'Narkisim': 7,
        'Neue Haas Grotesk Text Pro': 9,
        'New Gulim': 10,
        'News Gothic MT': 9,
        'Niagara Engraved': 5,
        'Niagara Solid': 6,
        'Nirmala UI': 9,
        'Nirmala UI Semilight': 9,
        'Nyala': 9,
        'OCR A Extended': 10,
        'OCRB': 10,
        'Old English Text MT': 9,
        'Onyx': 6,
        'Palace Script MT': 6,
        'Palatino Linotype': 8,
        'Papyrus': 10,
        'Parchment': 4,
        'Perpetua': 7,
        'Perpetua Titling MT': 10,
        'Plantagenet Cherokee': 9,
        'Playbill': 6,
        'PMingLiU': 8,
        'PMingLiU-ExtB': 8,
        'Poor Richard': 9,
        'Pristina': 9,
        'Pyunji R': 8,
        'Raavi': 9,
        'Rage Italic': 9,
        'Ravie': 15,
        'Rockwell': 8,
        'Rockwell Condensed': 6,
        'Rockwell Extra Bold': 10,
        'Rockwell Light': 9,
        'Rockwell Nova': 9,
        'Rockwell Nova Cond': 9,
        'Rockwell Nova Cond Light': 9,
        'Rockwell Nova Extra Bold': 9,
        'Rockwell Nova Light': 9,
        'Rod': 9,
        'Sakkal Majalla': 9,
        'Sanskrit Text': 9,
        'Script MT Bold': 8,
        'Segoe MDL2 Assets': 6,
        'Segoe Print': 11,
        'Segoe Script': 11,
        'Segoe UI': 8,
        'Segoe UI Black': 9,
        'Segoe UI Emoji': 8,
        'Segoe UI Historic': 8,
        'Segoe UI Light': 8,
        'Segoe UI Semibold': 9,
        'Segoe UI Semilight': 8,
        'Segoe UI Symbol': 8,
        'Selawik': 8,
        'Selawik Light': 8,
        'Selawik Semibold': 8,
        'Shonar Bangla': 8,
        'Showcard Gothic': 9,
        'Shruti': 8,
        'Simplified Arabic': 8,
        'Simplified Arabic Fixed': 8,
        'SimSun-ExtB': 8,
        'Sitka Banner': 8,
        'Sitka Display': 8,
        'Sitka Heading': 8,
        'Sitka Small': 10,
        'Sitka Subheading': 9,
        'Sitka Text': 9,
        'Snap ITC': 13,
        'Source Sans Pro': 8,
        'Source Sans Pro Black': 8,
        'Source Sans Pro ExtraLight': 8,
        'Source Sans Pro Light': 8,
        'Source Sans Pro SemiBold': 8,
        'Stencil': 9,
        'Sylfaen': 8,
        'Symbol': 8,
        'Tahoma': 8,
        'Tempus Sans ITC': 10,
        'TH SarabunPSK': 8,
        'Times New Roman': 8,
        'Traditional Arabic': 8,
        'Trebuchet MS': 8,
        'Tunga': 8,
        'Tw Cen MT': 8,
        'Tw Cen MT Condensed': 5,
        'Tw Cen MT Condensed Extra Bold': 7,
        'UD Digi Kyokasho N-B': 8,
        'UD Digi Kyokasho NK-B': 8,
        'UD Digi Kyokasho NK-R': 8,
        'UD Digi Kyokasho NP-B': 8,
        'UD Digi Kyokasho NP-R': 8,
        'UD Digi Kyokasho N-R': 8,
        'Univers': 8,
        'Univers Condensed': 8,
        'Univers Condensed Light': 8,
        'Univers Light': 8,
        'Urdu Typesetting': 8,
        'Utsaah': 8,
        'Vani': 8,
        'Verdana': 10,
        'Verdana Pro': 10,
        'Verdana Pro Black': 8,
        'Verdana Pro Cond': 8,
        'Verdana Pro Cond Black': 8,
        'Verdana Pro Cond Light': 8,
        'Verdana Pro Cond SemiBold': 8,
        'Verdana Pro Light': 8,
        'Verdana Pro SemiBold': 8,
        'Vijaya': 8,
        'Viner Hand ITC': 10,
        'Vivaldi': 6,
        'Vladimir Script': 7,
        'Vrinda': 9,
        'Webdings': 15,
        'Wide Latin': 19,
        'Wingdings': 20,
        'Wingdings 2': 17,
        'Wingdings 3': 13,
        'Yet R': 8,
        'Yu Gothic': 8,
        'Yu Gothic Light': 8,
        'Yu Gothic Medium': 8,
        'Yu Gothic UI': 8,
        'Yu Gothic UI Light': 8,
        'Yu Gothic UI Semibold': 9,
        'Yu Gothic UI Semilight': 8,
        'Yu Mincho': 8,
        'Yu Mincho Demibold': 8,
        'Yu Mincho Light': 8,
        '\u4eff\u5b8b': 8,
        '\u534e\u6587\u4e2d\u5b8b': 9,
        '\u534e\u6587\u4eff\u5b8b': 7,
        '\u534e\u6587\u5b8b\u4f53': 7,
        '\u534e\u6587\u5f69\u4e91': 9,
        '\u534e\u6587\u65b0\u9b4f': 9,
        '\u534e\u6587\u6977\u4f53': 7,
        '\u534e\u6587\u7425\u73c0': 9,
        '\u534e\u6587\u7ec6\u9ed1': 8,
        '\u534e\u6587\u884c\u6977': 8,
        '\u534e\u6587\u96b6\u4e66': 7,
        '\u5b8b\u4f53': 8,
        '\u5e7c\u5706': 8,
        '\u5fae\u8f6f\u96c5\u9ed1': 9,
        '\u5fae\u8f6f\u96c5\u9ed1 Light': 9,
        '\u65b0\u5b8b\u4f53': 8,
        '\u65b9\u6b63\u59da\u4f53': 8,
        '\u65b9\u6b63\u8212\u4f53': 8,
        '\u6977\u4f53': 8,
        '\u7b49\u7ebf': 8,
        '\u7b49\u7ebf Light': 8,
        '\u96b6\u4e66': 8,
        '\u9ed1\u4f53': 8,
        '\u6e38\u30b4\u30b7\u30c3\u30af': 8,
        '\uff2d\uff33 \uff30\u660e\u671d': 8,
        '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af': 8,
        '\u30e1\u30a4\u30ea\u30aa': 9,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78E': 8,
        'HG\u660e\u671dB': 8,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78M': 8
    },
    12: {
        'Gill Sans MT': 8,
        'Abadi': 10,
        'Abadi Extra Light': 9,
        'Agency FB': 6,
        'Aharoni': 7,
        'Aldhabi': 5,
        'Algerian': 10,
        'Ami R': 7,
        'Angsana New': 5,
        'AngsanaUPC': 5,
        'Aparajita': 6,
        'Arabic Typesetting': 5,
        'Arial': 9,
        'Arial Black': 11,
        'Arial Narrow': 7,
        'Arial Nova': 9,
        'Arial Nova Cond': 8,
        'Arial Nova Cond Light': 7,
        'Arial Nova Light': 9,
        'Arial Rounded MT Bold': 10,
        'Baskerville Old Face': 8,
        'Batang': 9,
        'BatangChe': 8,
        'Bauhaus 93': 9,
        'Bell MT': 8,
        'Bembo': 8,
        'Berlin Sans FB': 10,
        'Berlin Sans FB Demi': 10,
        'Bernard MT Condensed': 8,
        'Blackadder ITC': 6,
        'Bodoni MT': 8,
        'Bodoni MT Black': 11,
        'Bodoni MT Condensed': 5,
        'Bodoni MT Poster Compressed': 6,
        'Book Antiqua': 8,
        'Bookman Old Style': 10,
        'Bookshelf Symbol 7': 12,
        'Bradley Hand ITC': 10,
        'Britannic Bold': 10,
        'Broadway': 10,
        'Browallia New': 6,
        'BrowalliaUPC': 6,
        'Brush Script MT': 8,
        'Calibri': 8,
        'Calibri Light': 8,
        'Californian FB': 9,
        'Calisto MT': 8,
        'Cambria': 9,
        'Cambria Math': 9,
        'Candara': 9,
        'Castellar': 12,
        'Centaur': 8,
        'Century': 9,
        'Century Gothic': 9,
        'Century Schoolbook': 9,
        'Chiller': 8,
        'Colonna MT': 8,
        'Comic Sans MS': 10,
        'Consolas': 9,
        'Constantia': 9,
        'Cooper Black': 10,
        'Copperplate Gothic Bold': 11,
        'Copperplate Gothic Light': 12,
        'Corbel': 8,
        'Cordia New': 6,
        'CordiaUPC': 6,
        'Courier New': 10,
        'Curlz MT': 9,
        'Dante': 7,
        'DaunPenh': 5,
        'David': 7,
        'DilleniaUPC': 5,
        'DokChampa': 9,
        'Dotum': 8,
        'DotumChe': 8,
        'Dubai': 9,
        'Dubai Light': 9,
        'Dubai Medium': 9,
        'Ebrima': 9,
        'Edwardian Script ITC': 8,
        'Elephant': 12,
        'Engravers MT': 10,
        'Eras Bold ITC': 10,
        'Eras Demi ITC': 10,
        'Eras Light ITC': 9,
        'Eras Medium ITC': 9,
        'EucrosiaUPC': 6,
        'Euphemia': 9,
        'Expo M': 14,
        'FangSong': 8,
        'Felix Titling': 9,
        'Footlight MT Light': 9,
        'Forte': 8,
        'Franklin Gothic Book': 9,
        'Franklin Gothic Demi': 9,
        'Franklin Gothic Demi Cond': 8,
        'Franklin Gothic Heavy': 9,
        'Franklin Gothic Medium': 9,
        'Franklin Gothic Medium Cond': 8,
        'FrankRuehl': 7,
        'FreesiaUPC': 7,
        'Freestyle Script': 6,
        'French Script MT': 6,
        'Gabriola': 6,
        'Gadugi': 9,
        'Garamond': 8,
        'Gautami': 10,
        'Georgia': 10,
        'Georgia Pro': 9,
        'Georgia Pro Black': 11,
        'Georgia Pro Cond': 8,
        'Georgia Pro Cond Black': 10,
        'Georgia Pro Cond Light': 8,
        'Georgia Pro Cond Semibold': 9,
        'Georgia Pro Light': 9,
        'Georgia Pro Semibold': 10,
        'Gigi': 7,
        'Gill Sans MT Condensed': 6,
        'Gill Sans MT Ext Condensed Bold': 6,
        'Gill Sans Nova': 8,
        'Gill Sans Nova Cond': 5,
        'Gill Sans Nova Cond Lt': 5,
        'Gill Sans Nova Cond Ultra Bold': 9,
        'Gill Sans Nova Cond XBd': 8,
        'Gill Sans Nova Light': 8,
        'Gill Sans Nova Ultra Bold': 14,
        'Gill Sans Ultra Bold': 14,
        'Gill Sans Ultra Bold Condensed': 9,
        'Gisha': 9,
        'Gloucester MT Extra Condensed': 6,
        'Goudy Old Style': 8,
        'Goudy Stout': 13,
        'Grotesque': 8,
        'Grotesque Light': 8,
        'Gulim': 9,
        'GulimChe': 8,
        'Gungsuh': 9,
        'GungsuhChe': 8,
        'Hadassah Friedlaender': 9,
        'Haettenschweiler': 7,
        'Harlow Solid Italic': 7,
        'Harrington': 9,
        'Headline R': 11,
        'HGGothicE': 8,
        'HGGothicM': 8,
        'HGGyoshotai': 8,
        'HGKyokashotai': 8,
        'HGMaruGothicMPRO': 12,
        'HGMinchoB': 9,
        'HGMinchoE': 9,
        'HGPGothicE': 10,
        'HGPGothicM': 10,
        'HGPGyoshotai': 9,
        'HGPKyokashotai': 8,
        'HGPMinchoB': 9,
        'HGPMinchoE': 9,
        'HGPSoeiKakugothicUB': 11,
        'HGPSoeiKakupoptai': 11,
        'HGPSoeiPresenceEB': 10,
        'HGSeikaishotaiPRO': 10,
        'HGSGothicE': 9,
        'HGSGothicM': 9,
        'HGSGyoshotai': 8,
        'HGSKyokashotai': 7,
        'HGSMinchoB': 9,
        'HGSMinchoE': 9,
        'HGSoeiKakugothicUB': 9,
        'HGSoeiKakupoptai': 9,
        'HGSoeiPresenceEB': 9,
        'HGSSoeiKakugothicUB': 10,
        'HGSSoeiKakupoptai': 10,
        'HGSSoeiPresenceEB': 9,
        'High Tower Text': 8,
        'HYGothic-Extra': 10,
        'HYGothic-Medium': 9,
        'HYGraphic-Medium': 9,
        'HYGungSo-Bold': 9,
        'HYHeadLine-Medium': 9,
        'HYMyeongJo-Extra': 11,
        'HYPMokGak-Bold': 11,
        'HYPost-Light': 11,
        'HYPost-Medium': 11,
        'HYShortSamul-Medium': 6,
        'HYSinMyeongJo-Medium': 10,
        'Impact': 9,
        'Imprint MT Shadow': 8,
        'Informal Roman': 9,
        'Ink Free': 8,
        'IrisUPC': 8,
        'Iskoola Pota': 8,
        'JasmineUPC': 8,
        'Javanese Text': 9,
        'Jokerman': 11,
        'Juice ITC': 6,
        'KaiTi': 8,
        'Kalinga': 9,
        'Kartika': 8,
        'Khmer UI': 8,
        'KodchiangUPC': 5,
        'Kokila': 8,
        'Kristen ITC': 10,
        'Kunstler Script': 6,
        'Lao UI': 8,
        'Latha': 8,
        'Leelawadee': 9,
        'Leelawadee UI': 9,
        'Leelawadee UI Semilight': 9,
        'Levenim MT': 9,
        'LilyUPC': 7,
        'Lucida Bright': 10,
        'Lucida Calligraphy': 12,
        'Lucida Console': 11,
        'Lucida Fax': 11,
        'Lucida Handwriting': 12,
        'Lucida Sans': 11,
        'Lucida Sans Typewriter': 10,
        'Lucida Sans Unicode': 11,
        'Magic R': 10,
        'Magneto': 12,
        'Maiandra GD': 10,
        'Malgun Gothic': 9,
        'Malgun Gothic Semilight': 10,
        'Mangal': 9,
        'Marlett': 17,
        'Matura MT Script Capitals': 12,
        'Meiryo': 11,
        'Meiryo UI': 11,
        'Microsoft GothicNeo': 9,
        'Microsoft Himalaya': 6,
        'Microsoft JhengHei': 10,
        'Microsoft JhengHei Light': 10,
        'Microsoft JhengHei UI': 10,
        'Microsoft JhengHei UI Light': 10,
        'Microsoft New Tai Lue': 9,
        'Microsoft PhagsPa': 9,
        'Microsoft Sans Serif': 10,
        'Microsoft Tai Le': 9,
        'Microsoft Uighur': 6,
        'Microsoft YaHei Light': 10,
        'Microsoft YaHei UI': 10,
        'Microsoft YaHei UI Light': 10,
        'Microsoft Yi Baiti': 9,
        'MingLiU': 9,
        'MingLiU_HKSCS': 9,
        'MingLiU_HKSCS-ExtB': 9,
        'MingLiU-ExtB': 9,
        'Miriam': 9,
        'Miriam Fixed': 11,
        'Mistral': 8,
        'Modern No. 20': 8,
        'MoeumT R': 10,
        'Mongolian Baiti': 9,
        'Monotype Corsiva': 8,
        'MoolBoran': 7,
        'MS Gothic': 9,
        'MS Mincho': 9,
        'MS Outlook': 9,
        'MS PGothic': 9,
        'MS PMincho': 9,
        'MS Reference Sans Serif': 11,
        'MS Reference Specialty': 20,
        'MS UI Gothic': 9,
        'MT Extra': 17,
        'MV Boli': 12,
        'Myanmar Text': 9,
        'Narkisim': 8,
        'Neue Haas Grotesk Text Pro': 9,
        'New Gulim': 10,
        'News Gothic MT': 9,
        'Niagara Engraved': 6,
        'Niagara Solid': 6,
        'Nirmala UI': 9,
        'Nirmala UI Semilight': 10,
        'Nyala': 9,
        'OCR A Extended': 11,
        'OCRB': 11,
        'Old English Text MT': 9,
        'Onyx': 7,
        'Palace Script MT': 6,
        'Palatino Linotype': 8,
        'Papyrus': 10,
        'Parchment': 4,
        'Perpetua': 7,
        'Perpetua Titling MT': 11,
        'Plantagenet Cherokee': 9,
        'Playbill': 7,
        'PMingLiU': 9,
        'PMingLiU-ExtB': 9,
        'Poor Richard': 10,
        'Pristina': 9,
        'Pyunji R': 9,
        'Raavi': 8,
        'Rage Italic': 9,
        'Ravie': 16,
        'Rockwell': 9,
        'Rockwell Condensed': 7,
        'Rockwell Extra Bold': 11,
        'Rockwell Light': 10,
        'Rockwell Nova': 9,
        'Rockwell Nova Cond': 9,
        'Rockwell Nova Cond Light': 9,
        'Rockwell Nova Extra Bold': 9,
        'Rockwell Nova Light': 9,
        'Rod': 9,
        'Sakkal Majalla': 9,
        'Sanskrit Text': 9,
        'Script MT Bold': 8,
        'Segoe MDL2 Assets': 7,
        'Segoe Print': 12,
        'Segoe Script': 12,
        'Segoe UI': 9,
        'Segoe UI Black': 10,
        'Segoe UI Emoji': 9,
        'Segoe UI Historic': 9,
        'Segoe UI Light': 8,
        'Segoe UI Semibold': 9,
        'Segoe UI Semilight': 9,
        'Segoe UI Symbol': 9,
        'Selawik': 8,
        'Selawik Light': 8,
        'Selawik Semibold': 8,
        'Shonar Bangla': 8,
        'Showcard Gothic': 9,
        'Shruti': 8,
        'Simplified Arabic': 8,
        'Simplified Arabic Fixed': 8,
        'SimSun-ExtB': 8,
        'Sitka Banner': 8,
        'Sitka Display': 8,
        'Sitka Heading': 9,
        'Sitka Small': 11,
        'Sitka Subheading': 9,
        'Sitka Text': 10,
        'Snap ITC': 14,
        'Source Sans Pro': 8,
        'Source Sans Pro Black': 8,
        'Source Sans Pro ExtraLight': 8,
        'Source Sans Pro Light': 8,
        'Source Sans Pro SemiBold': 8,
        'Stencil': 9,
        'Sylfaen': 8,
        'Symbol': 8,
        'Tahoma': 9,
        'Tempus Sans ITC': 11,
        'TH SarabunPSK': 8,
        'Times New Roman': 8,
        'Traditional Arabic': 8,
        'Trebuchet MS': 8,
        'Tunga': 8,
        'Tw Cen MT': 9,
        'Tw Cen MT Condensed': 6,
        'Tw Cen MT Condensed Extra Bold': 8,
        'UD Digi Kyokasho N-B': 8,
        'UD Digi Kyokasho NK-B': 8,
        'UD Digi Kyokasho NK-R': 8,
        'UD Digi Kyokasho NP-B': 8,
        'UD Digi Kyokasho NP-R': 8,
        'UD Digi Kyokasho N-R': 8,
        'Univers': 8,
        'Univers Condensed': 8,
        'Univers Condensed Light': 8,
        'Univers Light': 8,
        'Urdu Typesetting': 8,
        'Utsaah': 6,
        'Vani': 8,
        'Verdana': 10,
        'Verdana Pro': 10,
        'Verdana Pro Black': 8,
        'Verdana Pro Cond': 8,
        'Verdana Pro Cond Black': 8,
        'Verdana Pro Cond Light': 8,
        'Verdana Pro Cond SemiBold': 8,
        'Verdana Pro Light': 8,
        'Verdana Pro SemiBold': 8,
        'Vijaya': 8,
        'Viner Hand ITC': 11,
        'Vivaldi': 7,
        'Vladimir Script': 7,
        'Vrinda': 9,
        'Webdings': 16,
        'Wide Latin': 20,
        'Wingdings': 22,
        'Wingdings 2': 18,
        'Wingdings 3': 14,
        'Yet R': 9,
        'Yu Gothic': 9,
        'Yu Gothic Light': 9,
        'Yu Gothic Medium': 9,
        'Yu Gothic UI': 9,
        'Yu Gothic UI Light': 9,
        'Yu Gothic UI Semibold': 9,
        'Yu Gothic UI Semilight': 9,
        'Yu Mincho': 9,
        'Yu Mincho Demibold': 8,
        'Yu Mincho Light': 8,
        '\u4eff\u5b8b': 8,
        '\u534e\u6587\u4e2d\u5b8b': 10,
        '\u534e\u6587\u4eff\u5b8b': 8,
        '\u534e\u6587\u5b8b\u4f53': 8,
        '\u534e\u6587\u5f69\u4e91': 9,
        '\u534e\u6587\u65b0\u9b4f': 9,
        '\u534e\u6587\u6977\u4f53': 8,
        '\u534e\u6587\u7425\u73c0': 9,
        '\u534e\u6587\u7ec6\u9ed1': 9,
        '\u534e\u6587\u884c\u6977': 8,
        '\u534e\u6587\u96b6\u4e66': 7,
        '\u5b8b\u4f53': 8,
        '\u5e7c\u5706': 8,
        '\u5fae\u8f6f\u96c5\u9ed1': 9,
        '\u5fae\u8f6f\u96c5\u9ed1 Light': 9,
        '\u65b0\u5b8b\u4f53': 8,
        '\u65b9\u6b63\u59da\u4f53': 8,
        '\u65b9\u6b63\u8212\u4f53': 9,
        '\u6977\u4f53': 8,
        '\u7b49\u7ebf': 8,
        '\u7b49\u7ebf Light': 8,
        '\u96b6\u4e66': 8,
        '\u9ed1\u4f53': 8,
        '\u6e38\u30b4\u30b7\u30c3\u30af': 9,
        '\uff2d\uff33 \uff30\u660e\u671d': 8,
        '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af': 8,
        '\u30e1\u30a4\u30ea\u30aa': 10,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78E': 8,
        'HG\u660e\u671dB': 8,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78M': 8
    },
    14: {
        'Gill Sans MT': 10,
        'Abadi': 11,
        'Abadi Extra Light': 11,
        'Agency FB': 8,
        'Aharoni': 8,
        'Aldhabi': 6,
        'Algerian': 11,
        'Ami R': 8,
        'Angsana New': 6,
        'AngsanaUPC': 6,
        'Aparajita': 8,
        'Arabic Typesetting': 6,
        'Arial': 11,
        'Arial Black': 13,
        'Arial Narrow': 9,
        'Arial Nova': 11,
        'Arial Nova Cond': 10,
        'Arial Nova Cond Light': 9,
        'Arial Nova Light': 11,
        'Arial Rounded MT Bold': 11,
        'Baskerville Old Face': 9,
        'Batang': 10,
        'BatangChe': 10,
        'Bauhaus 93': 11,
        'Bell MT': 10,
        'Bembo': 9,
        'Berlin Sans FB': 11,
        'Berlin Sans FB Demi': 12,
        'Bernard MT Condensed': 9,
        'Blackadder ITC': 8,
        'Bodoni MT': 9,
        'Bodoni MT Black': 12,
        'Bodoni MT Condensed': 6,
        'Bodoni MT Poster Compressed': 6,
        'Book Antiqua': 10,
        'Bookman Old Style': 12,
        'Bookshelf Symbol 7': 14,
        'Bradley Hand ITC': 12,
        'Britannic Bold': 12,
        'Broadway': 12,
        'Browallia New': 7,
        'BrowalliaUPC': 7,
        'Brush Script MT': 10,
        'Calibri': 10,
        'Calibri Light': 10,
        'Californian FB': 11,
        'Calisto MT': 10,
        'Cambria': 11,
        'Cambria Math': 11,
        'Candara': 10,
        'Castellar': 14,
        'Centaur': 9,
        'Century': 11,
        'Century Gothic': 11,
        'Century Schoolbook': 11,
        'Chiller': 9,
        'Colonna MT': 10,
        'Comic Sans MS': 12,
        'Consolas': 10,
        'Constantia': 10,
        'Cooper Black': 11,
        'Copperplate Gothic Bold': 14,
        'Copperplate Gothic Light': 14,
        'Corbel': 10,
        'Cordia New': 7,
        'CordiaUPC': 7,
        'Courier New': 11,
        'Curlz MT': 10,
        'Dante': 9,
        'DaunPenh': 6,
        'David': 8,
        'DilleniaUPC': 6,
        'DokChampa': 11,
        'Dotum': 10,
        'DotumChe': 10,
        'Dubai': 10,
        'Dubai Light': 10,
        'Dubai Medium': 10,
        'Ebrima': 10,
        'Edwardian Script ITC': 9,
        'Elephant': 14,
        'Engravers MT': 12,
        'Eras Bold ITC': 12,
        'Eras Demi ITC': 12,
        'Eras Light ITC': 10,
        'Eras Medium ITC': 11,
        'EucrosiaUPC': 8,
        'Euphemia': 11,
        'Expo M': 16,
        'FangSong': 10,
        'Felix Titling': 11,
        'Footlight MT Light': 11,
        'Forte': 10,
        'Franklin Gothic Book': 11,
        'Franklin Gothic Demi': 11,
        'Franklin Gothic Demi Cond': 10,
        'Franklin Gothic Heavy': 11,
        'Franklin Gothic Medium': 11,
        'Franklin Gothic Medium Cond': 10,
        'FrankRuehl': 8,
        'FreesiaUPC': 8,
        'Freestyle Script': 7,
        'French Script MT': 7,
        'Gabriola': 8,
        'Gadugi': 10,
        'Garamond': 9,
        'Gautami': 11,
        'Georgia': 12,
        'Georgia Pro': 11,
        'Georgia Pro Black': 13,
        'Georgia Pro Cond': 10,
        'Georgia Pro Cond Black': 12,
        'Georgia Pro Cond Light': 10,
        'Georgia Pro Cond Semibold': 11,
        'Georgia Pro Light': 10,
        'Georgia Pro Semibold': 12,
        'Gigi': 10,
        'Gill Sans MT Condensed': 7,
        'Gill Sans MT Ext Condensed Bold': 7,
        'Gill Sans Nova': 10,
        'Gill Sans Nova Cond': 6,
        'Gill Sans Nova Cond Lt': 6,
        'Gill Sans Nova Cond Ultra Bold': 11,
        'Gill Sans Nova Cond XBd': 10,
        'Gill Sans Nova Light': 10,
        'Gill Sans Nova Ultra Bold': 16,
        'Gill Sans Ultra Bold': 16,
        'Gill Sans Ultra Bold Condensed': 11,
        'Gisha': 10,
        'Gloucester MT Extra Condensed': 7,
        'Goudy Old Style': 10,
        'Goudy Stout': 16,
        'Grotesque': 9,
        'Grotesque Light': 9,
        'Gulim': 10,
        'GulimChe': 10,
        'Gungsuh': 10,
        'GungsuhChe': 10,
        'Hadassah Friedlaender': 11,
        'Haettenschweiler': 8,
        'Harlow Solid Italic': 9,
        'Harrington': 11,
        'Headline R': 14,
        'HGGothicE': 10,
        'HGGothicM': 10,
        'HGGyoshotai': 10,
        'HGKyokashotai': 10,
        'HGMaruGothicMPRO': 14,
        'HGMinchoB': 11,
        'HGMinchoE': 11,
        'HGPGothicE': 11,
        'HGPGothicM': 12,
        'HGPGyoshotai': 10,
        'HGPKyokashotai': 10,
        'HGPMinchoB': 10,
        'HGPMinchoE': 11,
        'HGPSoeiKakugothicUB': 13,
        'HGPSoeiKakupoptai': 13,
        'HGPSoeiPresenceEB': 12,
        'HGSeikaishotaiPRO': 11,
        'HGSGothicE': 10,
        'HGSGothicM': 11,
        'HGSGyoshotai': 9,
        'HGSKyokashotai': 9,
        'HGSMinchoB': 10,
        'HGSMinchoE': 11,
        'HGSoeiKakugothicUB': 11,
        'HGSoeiKakupoptai': 11,
        'HGSoeiPresenceEB': 11,
        'HGSSoeiKakugothicUB': 12,
        'HGSSoeiKakupoptai': 12,
        'HGSSoeiPresenceEB': 11,
        'High Tower Text': 9,
        'HYGothic-Extra': 12,
        'HYGothic-Medium': 11,
        'HYGraphic-Medium': 11,
        'HYGungSo-Bold': 11,
        'HYHeadLine-Medium': 11,
        'HYMyeongJo-Extra': 13,
        'HYPMokGak-Bold': 13,
        'HYPost-Light': 13,
        'HYPost-Medium': 13,
        'HYShortSamul-Medium': 7,
        'HYSinMyeongJo-Medium': 12,
        'Impact': 10,
        'Imprint MT Shadow': 10,
        'Informal Roman': 10,
        'Ink Free': 10,
        'IrisUPC': 10,
        'Iskoola Pota': 10,
        'JasmineUPC': 10,
        'Javanese Text': 11,
        'Jokerman': 14,
        'Juice ITC': 7,
        'KaiTi': 10,
        'Kalinga': 11,
        'Kartika': 11,
        'Khmer UI': 10,
        'KodchiangUPC': 7,
        'Kokila': 10,
        'Kristen ITC': 11,
        'Kunstler Script': 7,
        'Lao UI': 10,
        'Latha': 10,
        'Leelawadee': 10,
        'Leelawadee UI': 10,
        'Leelawadee UI Semilight': 10,
        'Levenim MT': 11,
        'LilyUPC': 8,
        'Lucida Bright': 12,
        'Lucida Calligraphy': 14,
        'Lucida Console': 12,
        'Lucida Fax': 13,
        'Lucida Handwriting': 14,
        'Lucida Sans': 13,
        'Lucida Sans Typewriter': 11,
        'Lucida Sans Unicode': 13,
        'Magic R': 12,
        'Magneto': 15,
        'Maiandra GD': 12,
        'Malgun Gothic': 11,
        'Malgun Gothic Semilight': 12,
        'Mangal': 11,
        'Marlett': 20,
        'Matura MT Script Capitals': 13,
        'Meiryo': 13,
        'Meiryo UI': 13,
        'Microsoft GothicNeo': 11,
        'Microsoft Himalaya': 7,
        'Microsoft JhengHei': 11,
        'Microsoft JhengHei Light': 12,
        'Microsoft JhengHei UI': 11,
        'Microsoft JhengHei UI Light': 12,
        'Microsoft New Tai Lue': 11,
        'Microsoft PhagsPa': 11,
        'Microsoft Sans Serif': 11,
        'Microsoft Tai Le': 11,
        'Microsoft Uighur': 7,
        'Microsoft YaHei Light': 12,
        'Microsoft YaHei UI': 12,
        'Microsoft YaHei UI Light': 12,
        'Microsoft Yi Baiti': 11,
        'MingLiU': 11,
        'MingLiU_HKSCS': 11,
        'MingLiU_HKSCS-ExtB': 11,
        'MingLiU-ExtB': 11,
        'Miriam': 10,
        'Miriam Fixed': 12,
        'Mistral': 10,
        'Modern No. 20': 10,
        'MoeumT R': 11,
        'Mongolian Baiti': 11,
        'Monotype Corsiva': 9,
        'MoolBoran': 8,
        'MS Gothic': 11,
        'MS Mincho': 11,
        'MS Outlook': 11,
        'MS PGothic': 11,
        'MS PMincho': 11,
        'MS Reference Sans Serif': 13,
        'MS Reference Specialty': 24,
        'MS UI Gothic': 11,
        'MT Extra': 20,
        'MV Boli': 14,
        'Myanmar Text': 11,
        'Narkisim': 9,
        'Neue Haas Grotesk Text Pro': 11,
        'New Gulim': 12,
        'News Gothic MT': 12,
        'Niagara Engraved': 7,
        'Niagara Solid': 7,
        'Nirmala UI': 11,
        'Nirmala UI Semilight': 11,
        'Nyala': 11,
        'OCR A Extended': 12,
        'OCRB': 12,
        'Old English Text MT': 11,
        'Onyx': 7,
        'Palace Script MT': 7,
        'Palatino Linotype': 10,
        'Papyrus': 12,
        'Parchment': 5,
        'Perpetua': 9,
        'Perpetua Titling MT': 13,
        'Plantagenet Cherokee': 11,
        'Playbill': 8,
        'PMingLiU': 10,
        'PMingLiU-ExtB': 10,
        'Poor Richard': 11,
        'Pristina': 10,
        'Pyunji R': 10,
        'Raavi': 10,
        'Rage Italic': 11,
        'Ravie': 19,
        'Rockwell': 10,
        'Rockwell Condensed': 8,
        'Rockwell Extra Bold': 13,
        'Rockwell Light': 11,
        'Rockwell Nova': 11,
        'Rockwell Nova Cond': 11,
        'Rockwell Nova Cond Light': 11,
        'Rockwell Nova Extra Bold': 11,
        'Rockwell Nova Light': 11,
        'Rod': 11,
        'Sakkal Majalla': 11,
        'Sanskrit Text': 12,
        'Script MT Bold': 10,
        'Segoe MDL2 Assets': 8,
        'Segoe Print': 14,
        'Segoe Script': 14,
        'Segoe UI': 10,
        'Segoe UI Black': 12,
        'Segoe UI Emoji': 10,
        'Segoe UI Historic': 10,
        'Segoe UI Light': 10,
        'Segoe UI Semibold': 11,
        'Segoe UI Semilight': 10,
        'Segoe UI Symbol': 10,
        'Selawik': 10,
        'Selawik Light': 10,
        'Selawik Semibold': 10,
        'Shonar Bangla': 10,
        'Showcard Gothic': 11,
        'Shruti': 11,
        'Simplified Arabic': 10,
        'Simplified Arabic Fixed': 11,
        'SimSun-ExtB': 10,
        'Sitka Banner': 10,
        'Sitka Display': 10,
        'Sitka Heading': 11,
        'Sitka Small': 13,
        'Sitka Subheading': 11,
        'Sitka Text': 12,
        'Snap ITC': 16,
        'Source Sans Pro': 9,
        'Source Sans Pro Black': 10,
        'Source Sans Pro ExtraLight': 9,
        'Source Sans Pro Light': 10,
        'Source Sans Pro SemiBold': 10,
        'Stencil': 11,
        'Sylfaen': 10,
        'Symbol': 10,
        'Tahoma': 10,
        'Tempus Sans ITC': 13,
        'TH SarabunPSK': 7,
        'Times New Roman': 10,
        'Traditional Arabic': 10,
        'Trebuchet MS': 10,
        'Tunga': 10,
        'Tw Cen MT': 10,
        'Tw Cen MT Condensed': 7,
        'Tw Cen MT Condensed Extra Bold': 9,
        'UD Digi Kyokasho N-B': 10,
        'UD Digi Kyokasho NK-B': 10,
        'UD Digi Kyokasho NK-R': 10,
        'UD Digi Kyokasho NP-B': 10,
        'UD Digi Kyokasho NP-R': 10,
        'UD Digi Kyokasho N-R': 10,
        'Univers': 10,
        'Univers Condensed': 10,
        'Univers Condensed Light': 8,
        'Univers Light': 10,
        'Urdu Typesetting': 10,
        'Utsaah': 8,
        'Vani': 11,
        'Verdana': 12,
        'Verdana Pro': 12,
        'Verdana Pro Black': 10,
        'Verdana Pro Cond': 10,
        'Verdana Pro Cond Black': 10,
        'Verdana Pro Cond Light': 10,
        'Verdana Pro Cond SemiBold': 10,
        'Verdana Pro Light': 10,
        'Verdana Pro SemiBold': 10,
        'Vijaya': 10,
        'Viner Hand ITC': 13,
        'Vivaldi': 8,
        'Vladimir Script': 9,
        'Vrinda': 11,
        'Webdings': 19,
        'Wide Latin': 24,
        'Wingdings': 26,
        'Wingdings 2': 22,
        'Wingdings 3': 17,
        'Yet R': 10,
        'Yu Gothic': 11,
        'Yu Gothic Light': 10,
        'Yu Gothic Medium': 11,
        'Yu Gothic UI': 10,
        'Yu Gothic UI Light': 10,
        'Yu Gothic UI Semibold': 11,
        'Yu Gothic UI Semilight': 10,
        'Yu Mincho': 10,
        'Yu Mincho Demibold': 10,
        'Yu Mincho Light': 10,
        '\u4eff\u5b8b': 10,
        '\u534e\u6587\u4e2d\u5b8b': 12,
        '\u534e\u6587\u4eff\u5b8b': 9,
        '\u534e\u6587\u5b8b\u4f53': 9,
        '\u534e\u6587\u5f69\u4e91': 11,
        '\u534e\u6587\u65b0\u9b4f': 11,
        '\u534e\u6587\u6977\u4f53': 9,
        '\u534e\u6587\u7425\u73c0': 11,
        '\u534e\u6587\u7ec6\u9ed1': 11,
        '\u534e\u6587\u884c\u6977': 10,
        '\u534e\u6587\u96b6\u4e66': 8,
        '\u5b8b\u4f53': 10,
        '\u5e7c\u5706': 10,
        '\u5fae\u8f6f\u96c5\u9ed1': 11,
        '\u5fae\u8f6f\u96c5\u9ed1 Light': 11,
        '\u65b0\u5b8b\u4f53': 10,
        '\u65b9\u6b63\u59da\u4f53': 10,
        '\u65b9\u6b63\u8212\u4f53': 10,
        '\u6977\u4f53': 10,
        '\u7b49\u7ebf': 10,
        '\u7b49\u7ebf Light': 10,
        '\u96b6\u4e66': 10,
        '\u9ed1\u4f53': 10,
        '\u6e38\u30b4\u30b7\u30c3\u30af': 11,
        '\uff2d\uff33 \uff30\u660e\u671d': 10,
        '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af': 10,
        '\u30e1\u30a4\u30ea\u30aa': 12,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78E': 10,
        'HG\u660e\u671dB': 10,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78M': 10
    },
    16: {
        'Gill Sans MT': 11,
        'Abadi': 13,
        'Abadi Extra Light': 12,
        'Agency FB': 9,
        'Aharoni': 9,
        'Aldhabi': 7,
        'Algerian': 13,
        'Ami R': 9,
        'Angsana New': 7,
        'AngsanaUPC': 7,
        'Aparajita': 8,
        'Arabic Typesetting': 7,
        'Arial': 12,
        'Arial Black': 14,
        'Arial Narrow': 10,
        'Arial Nova': 12,
        'Arial Nova Cond': 11,
        'Arial Nova Cond Light': 9,
        'Arial Nova Light': 12,
        'Arial Rounded MT Bold': 12,
        'Baskerville Old Face': 10,
        'Batang': 10,
        'BatangChe': 11,
        'Bauhaus 93': 12,
        'Bell MT': 11,
        'Bembo': 10,
        'Berlin Sans FB': 13,
        'Berlin Sans FB Demi': 13,
        'Bernard MT Condensed': 10,
        'Blackadder ITC': 8,
        'Bodoni MT': 10,
        'Bodoni MT Black': 14,
        'Bodoni MT Condensed': 7,
        'Bodoni MT Poster Compressed': 7,
        'Book Antiqua': 11,
        'Bookman Old Style': 13,
        'Bookshelf Symbol 7': 16,
        'Bradley Hand ITC': 14,
        'Britannic Bold': 13,
        'Broadway': 14,
        'Browallia New': 8,
        'BrowalliaUPC': 8,
        'Brush Script MT': 11,
        'Calibri': 11,
        'Calibri Light': 11,
        'Californian FB': 12,
        'Calisto MT': 11,
        'Cambria': 12,
        'Cambria Math': 12,
        'Candara': 12,
        'Castellar': 15,
        'Centaur': 10,
        'Century': 12,
        'Century Gothic': 12,
        'Century Schoolbook': 12,
        'Chiller': 10,
        'Colonna MT': 11,
        'Comic Sans MS': 13,
        'Consolas': 12,
        'Constantia': 11,
        'Cooper Black': 13,
        'Copperplate Gothic Bold': 15,
        'Copperplate Gothic Light': 15,
        'Corbel': 11,
        'Cordia New': 8,
        'CordiaUPC': 8,
        'Courier New': 13,
        'Curlz MT': 11,
        'Dante': 9,
        'DaunPenh': 7,
        'David': 9,
        'DilleniaUPC': 7,
        'DokChampa': 12,
        'Dotum': 11,
        'DotumChe': 11,
        'Dubai': 11,
        'Dubai Light': 11,
        'Dubai Medium': 11,
        'Ebrima': 11,
        'Edwardian Script ITC': 10,
        'Elephant': 16,
        'Engravers MT': 14,
        'Eras Bold ITC': 14,
        'Eras Demi ITC': 13,
        'Eras Light ITC': 11,
        'Eras Medium ITC': 12,
        'EucrosiaUPC': 9,
        'Euphemia': 12,
        'Expo M': 18,
        'FangSong': 11,
        'Felix Titling': 12,
        'Footlight MT Light': 12,
        'Forte': 11,
        'Franklin Gothic Book': 12,
        'Franklin Gothic Demi': 12,
        'Franklin Gothic Demi Cond': 11,
        'Franklin Gothic Heavy': 12,
        'Franklin Gothic Medium': 12,
        'Franklin Gothic Medium Cond': 11,
        'FrankRuehl': 9,
        'FreesiaUPC': 9,
        'Freestyle Script': 8,
        'French Script MT': 8,
        'Gabriola': 8,
        'Gadugi': 11,
        'Garamond': 10,
        'Gautami': 13,
        'Georgia': 13,
        'Georgia Pro': 12,
        'Georgia Pro Black': 15,
        'Georgia Pro Cond': 11,
        'Georgia Pro Cond Black': 13,
        'Georgia Pro Cond Light': 11,
        'Georgia Pro Cond Semibold': 12,
        'Georgia Pro Light': 12,
        'Georgia Pro Semibold': 13,
        'Gigi': 12,
        'Gill Sans MT Condensed': 8,
        'Gill Sans MT Ext Condensed Bold': 7,
        'Gill Sans Nova': 11,
        'Gill Sans Nova Cond': 7,
        'Gill Sans Nova Cond Lt': 6,
        'Gill Sans Nova Cond Ultra Bold': 12,
        'Gill Sans Nova Cond XBd': 11,
        'Gill Sans Nova Light': 11,
        'Gill Sans Nova Ultra Bold': 18,
        'Gill Sans Ultra Bold': 18,
        'Gill Sans Ultra Bold Condensed': 12,
        'Gisha': 11,
        'Gloucester MT Extra Condensed': 8,
        'Goudy Old Style': 11,
        'Goudy Stout': 17,
        'Grotesque': 10,
        'Grotesque Light': 10,
        'Gulim': 11,
        'GulimChe': 11,
        'Gungsuh': 11,
        'GungsuhChe': 11,
        'Hadassah Friedlaender': 12,
        'Haettenschweiler': 9,
        'Harlow Solid Italic': 10,
        'Harrington': 12,
        'Headline R': 15,
        'HGGothicE': 11,
        'HGGothicM': 11,
        'HGGyoshotai': 11,
        'HGKyokashotai': 11,
        'HGMaruGothicMPRO': 16,
        'HGMinchoB': 12,
        'HGMinchoE': 12,
        'HGPGothicE': 12,
        'HGPGothicM': 13,
        'HGPGyoshotai': 11,
        'HGPKyokashotai': 11,
        'HGPMinchoB': 11,
        'HGPMinchoE': 12,
        'HGPSoeiKakugothicUB': 14,
        'HGPSoeiKakupoptai': 15,
        'HGPSoeiPresenceEB': 13,
        'HGSeikaishotaiPRO': 12,
        'HGSGothicE': 11,
        'HGSGothicM': 12,
        'HGSGyoshotai': 10,
        'HGSKyokashotai': 10,
        'HGSMinchoB': 11,
        'HGSMinchoE': 12,
        'HGSoeiKakugothicUB': 12,
        'HGSoeiKakupoptai': 12,
        'HGSoeiPresenceEB': 12,
        'HGSSoeiKakugothicUB': 13,
        'HGSSoeiKakupoptai': 14,
        'HGSSoeiPresenceEB': 12,
        'High Tower Text': 10,
        'HYGothic-Extra': 13,
        'HYGothic-Medium': 12,
        'HYGraphic-Medium': 12,
        'HYGungSo-Bold': 12,
        'HYHeadLine-Medium': 12,
        'HYMyeongJo-Extra': 14,
        'HYPMokGak-Bold': 15,
        'HYPost-Light': 14,
        'HYPost-Medium': 15,
        'HYShortSamul-Medium': 8,
        'HYSinMyeongJo-Medium': 13,
        'Impact': 11,
        'Imprint MT Shadow': 11,
        'Informal Roman': 11,
        'Ink Free': 11,
        'IrisUPC': 11,
        'Iskoola Pota': 11,
        'JasmineUPC': 10,
        'Javanese Text': 12,
        'Jokerman': 15,
        'Juice ITC': 8,
        'KaiTi': 11,
        'Kalinga': 12,
        'Kartika': 12,
        'Khmer UI': 11,
        'KodchiangUPC': 7,
        'Kokila': 8,
        'Kristen ITC': 13,
        'Kunstler Script': 7,
        'Lao UI': 11,
        'Latha': 11,
        'Leelawadee': 11,
        'Leelawadee UI': 11,
        'Leelawadee UI Semilight': 12,
        'Levenim MT': 12,
        'LilyUPC': 9,
        'Lucida Bright': 13,
        'Lucida Calligraphy': 15,
        'Lucida Console': 14,
        'Lucida Fax': 14,
        'Lucida Handwriting': 15,
        'Lucida Sans': 14,
        'Lucida Sans Typewriter': 13,
        'Lucida Sans Unicode': 14,
        'Magic R': 13,
        'Magneto': 16,
        'Maiandra GD': 13,
        'Malgun Gothic': 12,
        'Malgun Gothic Semilight': 13,
        'Mangal': 12,
        'Marlett': 22,
        'Matura MT Script Capitals': 15,
        'Meiryo': 14,
        'Meiryo UI': 14,
        'Microsoft GothicNeo': 12,
        'Microsoft Himalaya': 8,
        'Microsoft JhengHei': 13,
        'Microsoft JhengHei Light': 13,
        'Microsoft JhengHei UI': 13,
        'Microsoft JhengHei UI Light': 13,
        'Microsoft New Tai Lue': 12,
        'Microsoft PhagsPa': 12,
        'Microsoft Sans Serif': 13,
        'Microsoft Tai Le': 12,
        'Microsoft Uighur': 8,
        'Microsoft YaHei Light': 13,
        'Microsoft YaHei UI': 13,
        'Microsoft YaHei UI Light': 13,
        'Microsoft Yi Baiti': 12,
        'MingLiU': 12,
        'MingLiU_HKSCS': 12,
        'MingLiU_HKSCS-ExtB': 12,
        'MingLiU-ExtB': 12,
        'Miriam': 11,
        'Miriam Fixed': 14,
        'Mistral': 10,
        'Modern No. 20': 11,
        'MoeumT R': 13,
        'Mongolian Baiti': 12,
        'Monotype Corsiva': 10,
        'MoolBoran': 8,
        'MS Gothic': 12,
        'MS Mincho': 12,
        'MS Outlook': 12,
        'MS PGothic': 12,
        'MS PMincho': 12,
        'MS Reference Sans Serif': 14,
        'MS Reference Specialty': 26,
        'MS UI Gothic': 12,
        'MT Extra': 22,
        'MV Boli': 16,
        'Myanmar Text': 12,
        'Narkisim': 10,
        'Neue Haas Grotesk Text Pro': 12,
        'New Gulim': 13,
        'News Gothic MT': 14,
        'Niagara Engraved': 8,
        'Niagara Solid': 8,
        'Nirmala UI': 12,
        'Nirmala UI Semilight': 13,
        'Nyala': 12,
        'OCR A Extended': 14,
        'OCRB': 14,
        'Old English Text MT': 12,
        'Onyx': 8,
        'Palace Script MT': 8,
        'Palatino Linotype': 11,
        'Papyrus': 14,
        'Parchment': 5,
        'Perpetua': 10,
        'Perpetua Titling MT': 14,
        'Plantagenet Cherokee': 12,
        'Playbill': 8,
        'PMingLiU': 11,
        'PMingLiU-ExtB': 11,
        'Poor Richard': 13,
        'Pristina': 11,
        'Pyunji R': 11,
        'Raavi': 11,
        'Rage Italic': 12,
        'Ravie': 21,
        'Rockwell': 11,
        'Rockwell Condensed': 9,
        'Rockwell Extra Bold': 14,
        'Rockwell Light': 12,
        'Rockwell Nova': 12,
        'Rockwell Nova Cond': 12,
        'Rockwell Nova Cond Light': 12,
        'Rockwell Nova Extra Bold': 12,
        'Rockwell Nova Light': 12,
        'Rod': 12,
        'Sakkal Majalla': 12,
        'Sanskrit Text': 13,
        'Script MT Bold': 11,
        'Segoe MDL2 Assets': 8,
        'Segoe Print': 15,
        'Segoe Script': 15,
        'Segoe UI': 11,
        'Segoe UI Black': 13,
        'Segoe UI Emoji': 11,
        'Segoe UI Historic': 11,
        'Segoe UI Light': 11,
        'Segoe UI Semibold': 12,
        'Segoe UI Semilight': 11,
        'Segoe UI Symbol': 11,
        'Selawik': 11,
        'Selawik Light': 11,
        'Selawik Semibold': 12,
        'Shonar Bangla': 11,
        'Showcard Gothic': 12,
        'Shruti': 13,
        'Simplified Arabic': 11,
        'Simplified Arabic Fixed': 13,
        'SimSun-ExtB': 11,
        'Sitka Banner': 11,
        'Sitka Display': 11,
        'Sitka Heading': 12,
        'Sitka Small': 14,
        'Sitka Subheading': 12,
        'Sitka Text': 13,
        'Snap ITC': 18,
        'Source Sans Pro': 10,
        'Source Sans Pro Black': 11,
        'Source Sans Pro ExtraLight': 10,
        'Source Sans Pro Light': 11,
        'Source Sans Pro SemiBold': 11,
        'Stencil': 12,
        'Sylfaen': 11,
        'Symbol': 11,
        'Tahoma': 11,
        'Tempus Sans ITC': 14,
        'TH SarabunPSK': 8,
        'Times New Roman': 11,
        'Traditional Arabic': 10,
        'Trebuchet MS': 11,
        'Tunga': 11,
        'Tw Cen MT': 12,
        'Tw Cen MT Condensed': 8,
        'Tw Cen MT Condensed Extra Bold': 10,
        'UD Digi Kyokasho N-B': 11,
        'UD Digi Kyokasho NK-B': 11,
        'UD Digi Kyokasho NK-R': 11,
        'UD Digi Kyokasho NP-B': 11,
        'UD Digi Kyokasho NP-R': 11,
        'UD Digi Kyokasho N-R': 11,
        'Univers': 11,
        'Univers Condensed': 11,
        'Univers Condensed Light': 9,
        'Univers Light': 11,
        'Urdu Typesetting': 11,
        'Utsaah': 8,
        'Vani': 13,
        'Verdana': 13,
        'Verdana Pro': 13,
        'Verdana Pro Black': 11,
        'Verdana Pro Cond': 11,
        'Verdana Pro Cond Black': 11,
        'Verdana Pro Cond Light': 11,
        'Verdana Pro Cond SemiBold': 11,
        'Verdana Pro Light': 11,
        'Verdana Pro SemiBold': 11,
        'Vijaya': 11,
        'Viner Hand ITC': 14,
        'Vivaldi': 9,
        'Vladimir Script': 10,
        'Vrinda': 12,
        'Webdings': 21,
        'Wide Latin': 26,
        'Wingdings': 28,
        'Wingdings 2': 24,
        'Wingdings 3': 19,
        'Yet R': 11,
        'Yu Gothic': 12,
        'Yu Gothic Light': 11,
        'Yu Gothic Medium': 12,
        'Yu Gothic UI': 11,
        'Yu Gothic UI Light': 11,
        'Yu Gothic UI Semibold': 12,
        'Yu Gothic UI Semilight': 12,
        'Yu Mincho': 11,
        'Yu Mincho Demibold': 11,
        'Yu Mincho Light': 11,
        '\u4eff\u5b8b': 11,
        '\u534e\u6587\u4e2d\u5b8b': 13,
        '\u534e\u6587\u4eff\u5b8b': 10,
        '\u534e\u6587\u5b8b\u4f53': 10,
        '\u534e\u6587\u5f69\u4e91': 12,
        '\u534e\u6587\u65b0\u9b4f': 12,
        '\u534e\u6587\u6977\u4f53': 10,
        '\u534e\u6587\u7425\u73c0': 12,
        '\u534e\u6587\u7ec6\u9ed1': 12,
        '\u534e\u6587\u884c\u6977': 11,
        '\u534e\u6587\u96b6\u4e66': 9,
        '\u5b8b\u4f53': 11,
        '\u5e7c\u5706': 11,
        '\u5fae\u8f6f\u96c5\u9ed1': 12,
        '\u5fae\u8f6f\u96c5\u9ed1 Light': 12,
        '\u65b0\u5b8b\u4f53': 11,
        '\u65b9\u6b63\u59da\u4f53': 11,
        '\u65b9\u6b63\u8212\u4f53': 11,
        '\u6977\u4f53': 11,
        '\u7b49\u7ebf': 11,
        '\u7b49\u7ebf Light': 11,
        '\u96b6\u4e66': 11,
        '\u9ed1\u4f53': 11,
        '\u6e38\u30b4\u30b7\u30c3\u30af': 12,
        '\uff2d\uff33 \uff30\u660e\u671d': 11,
        '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af': 11,
        '\u30e1\u30a4\u30ea\u30aa': 13,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78E': 11,
        'HG\u660e\u671dB': 11,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78M': 11
    },
    18: {
        'Gill Sans MT': 12,
        'Abadi': 15,
        'Abadi Extra Light': 13,
        'Agency FB': 10,
        'Aharoni': 10,
        'Aldhabi': 8,
        'Algerian': 14,
        'Ami R': 10,
        'Angsana New': 8,
        'AngsanaUPC': 8,
        'Aparajita': 10,
        'Arabic Typesetting': 8,
        'Arial': 13,
        'Arial Black': 16,
        'Arial Narrow': 11,
        'Arial Nova': 13,
        'Arial Nova Cond': 12,
        'Arial Nova Cond Light': 11,
        'Arial Nova Light': 13,
        'Arial Rounded MT Bold': 14,
        'Baskerville Old Face': 12,
        'Batang': 12,
        'BatangChe': 12,
        'Bauhaus 93': 14,
        'Bell MT': 12,
        'Bembo': 12,
        'Berlin Sans FB': 14,
        'Berlin Sans FB Demi': 15,
        'Bernard MT Condensed': 12,
        'Blackadder ITC': 9,
        'Bodoni MT': 12,
        'Bodoni MT Black': 16,
        'Bodoni MT Condensed': 8,
        'Bodoni MT Poster Compressed': 8,
        'Book Antiqua': 12,
        'Bookman Old Style': 15,
        'Bookshelf Symbol 7': 18,
        'Bradley Hand ITC': 15,
        'Britannic Bold': 15,
        'Broadway': 16,
        'Browallia New': 9,
        'BrowalliaUPC': 9,
        'Brush Script MT': 12,
        'Calibri': 12,
        'Calibri Light': 12,
        'Californian FB': 13,
        'Calisto MT': 12,
        'Cambria': 13,
        'Cambria Math': 13,
        'Candara': 13,
        'Castellar': 17,
        'Centaur': 12,
        'Century': 13,
        'Century Gothic': 13,
        'Century Schoolbook': 13,
        'Chiller': 11,
        'Colonna MT': 12,
        'Comic Sans MS': 15,
        'Consolas': 13,
        'Constantia': 13,
        'Cooper Black': 14,
        'Copperplate Gothic Bold': 17,
        'Copperplate Gothic Light': 17,
        'Corbel': 13,
        'Cordia New': 9,
        'CordiaUPC': 9,
        'Courier New': 14,
        'Curlz MT': 13,
        'Dante': 11,
        'DaunPenh': 8,
        'David': 11,
        'DilleniaUPC': 7,
        'DokChampa': 13,
        'Dotum': 13,
        'DotumChe': 12,
        'Dubai': 13,
        'Dubai Light': 13,
        'Dubai Medium': 13,
        'Ebrima': 13,
        'Edwardian Script ITC': 11,
        'Elephant': 18,
        'Engravers MT': 16,
        'Eras Bold ITC': 16,
        'Eras Demi ITC': 15,
        'Eras Light ITC': 13,
        'Eras Medium ITC': 14,
        'EucrosiaUPC': 10,
        'Euphemia': 14,
        'Expo M': 21,
        'FangSong': 12,
        'Felix Titling': 14,
        'Footlight MT Light': 13,
        'Forte': 13,
        'Franklin Gothic Book': 14,
        'Franklin Gothic Demi': 14,
        'Franklin Gothic Demi Cond': 12,
        'Franklin Gothic Heavy': 14,
        'Franklin Gothic Medium': 14,
        'Franklin Gothic Medium Cond': 12,
        'FrankRuehl': 10,
        'FreesiaUPC': 11,
        'Freestyle Script': 9,
        'French Script MT': 9,
        'Gabriola': 10,
        'Gadugi': 13,
        'Garamond': 11,
        'Gautami': 14,
        'Georgia': 15,
        'Georgia Pro': 14,
        'Georgia Pro Black': 17,
        'Georgia Pro Cond': 13,
        'Georgia Pro Cond Black': 15,
        'Georgia Pro Cond Light': 12,
        'Georgia Pro Cond Semibold': 13,
        'Georgia Pro Light': 13,
        'Georgia Pro Semibold': 15,
        'Gigi': 12,
        'Gill Sans MT Condensed': 9,
        'Gill Sans MT Ext Condensed Bold': 8,
        'Gill Sans Nova': 12,
        'Gill Sans Nova Cond': 8,
        'Gill Sans Nova Cond Lt': 7,
        'Gill Sans Nova Cond Ultra Bold': 14,
        'Gill Sans Nova Cond XBd': 13,
        'Gill Sans Nova Light': 12,
        'Gill Sans Nova Ultra Bold': 20,
        'Gill Sans Ultra Bold': 21,
        'Gill Sans Ultra Bold Condensed': 14,
        'Gisha': 13,
        'Gloucester MT Extra Condensed': 9,
        'Goudy Old Style': 12,
        'Goudy Stout': 20,
        'Grotesque': 12,
        'Grotesque Light': 12,
        'Gulim': 13,
        'GulimChe': 12,
        'Gungsuh': 13,
        'GungsuhChe': 12,
        'Hadassah Friedlaender': 14,
        'Haettenschweiler': 11,
        'Harlow Solid Italic': 11,
        'Harrington': 13,
        'Headline R': 17,
        'HGGothicE': 12,
        'HGGothicM': 12,
        'HGGyoshotai': 12,
        'HGKyokashotai': 12,
        'HGMaruGothicMPRO': 18,
        'HGMinchoB': 13,
        'HGMinchoE': 13,
        'HGPGothicE': 14,
        'HGPGothicM': 15,
        'HGPGyoshotai': 12,
        'HGPKyokashotai': 12,
        'HGPMinchoB': 12,
        'HGPMinchoE': 13,
        'HGPSoeiKakugothicUB': 16,
        'HGPSoeiKakupoptai': 17,
        'HGPSoeiPresenceEB': 14,
        'HGSeikaishotaiPRO': 14,
        'HGSGothicE': 13,
        'HGSGothicM': 14,
        'HGSGyoshotai': 11,
        'HGSKyokashotai': 11,
        'HGSMinchoB': 12,
        'HGSMinchoE': 13,
        'HGSoeiKakugothicUB': 13,
        'HGSoeiKakupoptai': 13,
        'HGSoeiPresenceEB': 13,
        'HGSSoeiKakugothicUB': 15,
        'HGSSoeiKakupoptai': 16,
        'HGSSoeiPresenceEB': 13,
        'High Tower Text': 12,
        'HYGothic-Extra': 15,
        'HYGothic-Medium': 14,
        'HYGraphic-Medium': 14,
        'HYGungSo-Bold': 14,
        'HYHeadLine-Medium': 14,
        'HYMyeongJo-Extra': 16,
        'HYPMokGak-Bold': 17,
        'HYPost-Light': 16,
        'HYPost-Medium': 17,
        'HYShortSamul-Medium': 9,
        'HYSinMyeongJo-Medium': 15,
        'Impact': 13,
        'Imprint MT Shadow': 12,
        'Informal Roman': 13,
        'Ink Free': 12,
        'IrisUPC': 12,
        'Iskoola Pota': 12,
        'JasmineUPC': 11,
        'Javanese Text': 14,
        'Jokerman': 17,
        'Juice ITC': 8,
        'KaiTi': 12,
        'Kalinga': 13,
        'Kartika': 14,
        'Khmer UI': 13,
        'KodchiangUPC': 8,
        'Kokila': 9,
        'Kristen ITC': 14,
        'Kunstler Script': 8,
        'Lao UI': 13,
        'Latha': 12,
        'Leelawadee': 13,
        'Leelawadee UI': 13,
        'Leelawadee UI Semilight': 13,
        'Levenim MT': 14,
        'LilyUPC': 11,
        'Lucida Bright': 15,
        'Lucida Calligraphy': 17,
        'Lucida Console': 15,
        'Lucida Fax': 16,
        'Lucida Handwriting': 17,
        'Lucida Sans': 16,
        'Lucida Sans Typewriter': 14,
        'Lucida Sans Unicode': 16,
        'Magic R': 14,
        'Magneto': 19,
        'Maiandra GD': 15,
        'Malgun Gothic': 14,
        'Malgun Gothic Semilight': 14,
        'Mangal': 14,
        'Marlett': 25,
        'Matura MT Script Capitals': 17,
        'Meiryo': 16,
        'Meiryo UI': 16,
        'Microsoft GothicNeo': 13,
        'Microsoft Himalaya': 9,
        'Microsoft JhengHei': 14,
        'Microsoft JhengHei Light': 15,
        'Microsoft JhengHei UI': 14,
        'Microsoft JhengHei UI Light': 15,
        'Microsoft New Tai Lue': 14,
        'Microsoft PhagsPa': 14,
        'Microsoft Sans Serif': 14,
        'Microsoft Tai Le': 14,
        'Microsoft Uighur': 9,
        'Microsoft YaHei Light': 15,
        'Microsoft YaHei UI': 15,
        'Microsoft YaHei UI Light': 15,
        'Microsoft Yi Baiti': 13,
        'MingLiU': 13,
        'MingLiU_HKSCS': 13,
        'MingLiU_HKSCS-ExtB': 13,
        'MingLiU-ExtB': 13,
        'Miriam': 12,
        'Miriam Fixed': 15,
        'Mistral': 12,
        'Modern No. 20': 12,
        'MoeumT R': 14,
        'Mongolian Baiti': 13,
        'Monotype Corsiva': 12,
        'MoolBoran': 9,
        'MS Gothic': 13,
        'MS Mincho': 13,
        'MS Outlook': 13,
        'MS PGothic': 13,
        'MS PMincho': 13,
        'MS Reference Sans Serif': 16,
        'MS Reference Specialty': 30,
        'MS UI Gothic': 13,
        'MT Extra': 25,
        'MV Boli': 18,
        'Myanmar Text': 14,
        'Narkisim': 11,
        'Neue Haas Grotesk Text Pro': 13,
        'New Gulim': 15,
        'News Gothic MT': 16,
        'Niagara Engraved': 9,
        'Niagara Solid': 9,
        'Nirmala UI': 14,
        'Nirmala UI Semilight': 14,
        'Nyala': 13,
        'OCR A Extended': 15,
        'OCRB': 15,
        'Old English Text MT': 13,
        'Onyx': 9,
        'Palace Script MT': 9,
        'Palatino Linotype': 12,
        'Papyrus': 15,
        'Parchment': 6,
        'Perpetua': 11,
        'Perpetua Titling MT': 16,
        'Plantagenet Cherokee': 13,
        'Playbill': 10,
        'PMingLiU': 12,
        'PMingLiU-ExtB': 12,
        'Poor Richard': 14,
        'Pristina': 13,
        'Pyunji R': 13,
        'Raavi': 12,
        'Rage Italic': 13,
        'Ravie': 24,
        'Rockwell': 13,
        'Rockwell Condensed': 10,
        'Rockwell Extra Bold': 17,
        'Rockwell Light': 14,
        'Rockwell Nova': 13,
        'Rockwell Nova Cond': 13,
        'Rockwell Nova Cond Light': 13,
        'Rockwell Nova Extra Bold': 13,
        'Rockwell Nova Light': 13,
        'Rod': 15,
        'Sakkal Majalla': 10,
        'Sanskrit Text': 15,
        'Script MT Bold': 13,
        'Segoe MDL2 Assets': 10,
        'Segoe Print': 18,
        'Segoe Script': 18,
        'Segoe UI': 13,
        'Segoe UI Black': 15,
        'Segoe UI Emoji': 13,
        'Segoe UI Historic': 13,
        'Segoe UI Light': 12,
        'Segoe UI Semibold': 14,
        'Segoe UI Semilight': 13,
        'Segoe UI Symbol': 13,
        'Selawik': 12,
        'Selawik Light': 13,
        'Selawik Semibold': 14,
        'Shonar Bangla': 12,
        'Showcard Gothic': 14,
        'Shruti': 14,
        'Simplified Arabic': 13,
        'Simplified Arabic Fixed': 14,
        'SimSun-ExtB': 12,
        'Sitka Banner': 12,
        'Sitka Display': 13,
        'Sitka Heading': 13,
        'Sitka Small': 16,
        'Sitka Subheading': 14,
        'Sitka Text': 15,
        'Snap ITC': 21,
        'Source Sans Pro': 12,
        'Source Sans Pro Black': 12,
        'Source Sans Pro ExtraLight': 11,
        'Source Sans Pro Light': 12,
        'Source Sans Pro SemiBold': 12,
        'Stencil': 14,
        'Sylfaen': 12,
        'Symbol': 12,
        'Tahoma': 13,
        'Tempus Sans ITC': 16,
        'TH SarabunPSK': 9,
        'Times New Roman': 12,
        'Traditional Arabic': 12,
        'Trebuchet MS': 13,
        'Tunga': 13,
        'Tw Cen MT': 13,
        'Tw Cen MT Condensed': 9,
        'Tw Cen MT Condensed Extra Bold': 12,
        'UD Digi Kyokasho N-B': 12,
        'UD Digi Kyokasho NK-B': 12,
        'UD Digi Kyokasho NK-R': 12,
        'UD Digi Kyokasho NP-B': 17,
        'UD Digi Kyokasho NP-R': 12,
        'UD Digi Kyokasho N-R': 12,
        'Univers': 12,
        'Univers Condensed': 12,
        'Univers Condensed Light': 11,
        'Univers Light': 12,
        'Urdu Typesetting': 12,
        'Utsaah': 10,
        'Vani': 15,
        'Verdana': 15,
        'Verdana Pro': 15,
        'Verdana Pro Black': 12,
        'Verdana Pro Cond': 12,
        'Verdana Pro Cond Black': 12,
        'Verdana Pro Cond Light': 12,
        'Verdana Pro Cond SemiBold': 12,
        'Verdana Pro Light': 12,
        'Verdana Pro SemiBold': 12,
        'Vijaya': 12,
        'Viner Hand ITC': 16,
        'Vivaldi': 10,
        'Vladimir Script': 11,
        'Vrinda': 14,
        'Webdings': 24,
        'Wide Latin': 30,
        'Wingdings': 32,
        'Wingdings 2': 27,
        'Wingdings 3': 21,
        'Yet R': 13,
        'Yu Gothic': 13,
        'Yu Gothic Light': 13,
        'Yu Gothic Medium': 13,
        'Yu Gothic UI': 13,
        'Yu Gothic UI Light': 13,
        'Yu Gothic UI Semibold': 14,
        'Yu Gothic UI Semilight': 13,
        'Yu Mincho': 13,
        'Yu Mincho Demibold': 13,
        'Yu Mincho Light': 12,
        '\u4eff\u5b8b': 12,
        '\u534e\u6587\u4e2d\u5b8b': 15,
        '\u534e\u6587\u4eff\u5b8b': 11,
        '\u534e\u6587\u5b8b\u4f53': 11,
        '\u534e\u6587\u5f69\u4e91': 14,
        '\u534e\u6587\u65b0\u9b4f': 14,
        '\u534e\u6587\u6977\u4f53': 11,
        '\u534e\u6587\u7425\u73c0': 14,
        '\u534e\u6587\u7ec6\u9ed1': 13,
        '\u534e\u6587\u884c\u6977': 12,
        '\u534e\u6587\u96b6\u4e66': 11,
        '\u5b8b\u4f53': 12,
        '\u5e7c\u5706': 12,
        '\u5fae\u8f6f\u96c5\u9ed1': 14,
        '\u5fae\u8f6f\u96c5\u9ed1 Light': 14,
        '\u65b0\u5b8b\u4f53': 12,
        '\u65b9\u6b63\u59da\u4f53': 12,
        '\u65b9\u6b63\u8212\u4f53': 13,
        '\u6977\u4f53': 12,
        '\u7b49\u7ebf': 13,
        '\u7b49\u7ebf Light': 12,
        '\u96b6\u4e66': 12,
        '\u9ed1\u4f53': 12,
        '\u6e38\u30b4\u30b7\u30c3\u30af': 13,
        '\uff2d\uff33 \uff30\u660e\u671d': 12,
        '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af': 12,
        '\u30e1\u30a4\u30ea\u30aa': 15,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78E': 12,
        'HG\u660e\u671dB': 12,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78M': 12
    },
    20: {
        'Gill Sans MT': 14,
        'Abadi': 16,
        'Abadi Extra Light': 15,
        'Agency FB': 11,
        'Aharoni': 11,
        'Aldhabi': 9,
        'Algerian': 16,
        'Ami R': 11,
        'Angsana New': 9,
        'AngsanaUPC': 9,
        'Aparajita': 11,
        'Arabic Typesetting': 9,
        'Arial': 15,
        'Arial Black': 18,
        'Arial Narrow': 12,
        'Arial Nova': 15,
        'Arial Nova Cond': 14,
        'Arial Nova Cond Light': 12,
        'Arial Nova Light': 15,
        'Arial Rounded MT Bold': 16,
        'Baskerville Old Face': 13,
        'Batang': 16,
        'BatangChe': 14,
        'Bauhaus 93': 15,
        'Bell MT': 14,
        'Bembo': 13,
        'Berlin Sans FB': 16,
        'Berlin Sans FB Demi': 17,
        'Bernard MT Condensed': 13,
        'Blackadder ITC': 11,
        'Bodoni MT': 13,
        'Bodoni MT Black': 18,
        'Bodoni MT Condensed': 9,
        'Bodoni MT Poster Compressed': 8,
        'Book Antiqua': 14,
        'Bookman Old Style': 17,
        'Bookshelf Symbol 7': 20,
        'Bradley Hand ITC': 17,
        'Britannic Bold': 17,
        'Broadway': 17,
        'Browallia New': 10,
        'BrowalliaUPC': 10,
        'Brush Script MT': 14,
        'Calibri': 14,
        'Calibri Light': 14,
        'Californian FB': 14,
        'Calisto MT': 14,
        'Cambria': 15,
        'Cambria Math': 15,
        'Candara': 15,
        'Castellar': 19,
        'Centaur': 13,
        'Century': 15,
        'Century Gothic': 15,
        'Century Schoolbook': 15,
        'Chiller': 13,
        'Colonna MT': 14,
        'Comic Sans MS': 16,
        'Consolas': 15,
        'Constantia': 15,
        'Cooper Black': 16,
        'Copperplate Gothic Bold': 19,
        'Copperplate Gothic Light': 19,
        'Corbel': 14,
        'Cordia New': 10,
        'CordiaUPC': 10,
        'Courier New': 16,
        'Curlz MT': 15,
        'Dante': 12,
        'DaunPenh': 9,
        'David': 12,
        'DilleniaUPC': 8,
        'DokChampa': 15,
        'Dotum': 16,
        'DotumChe': 14,
        'Dubai': 15,
        'Dubai Light': 15,
        'Dubai Medium': 15,
        'Ebrima': 15,
        'Edwardian Script ITC': 13,
        'Elephant': 20,
        'Engravers MT': 17,
        'Eras Bold ITC': 18,
        'Eras Demi ITC': 16,
        'Eras Light ITC': 14,
        'Eras Medium ITC': 15,
        'EucrosiaUPC': 11,
        'Euphemia': 16,
        'Expo M': 23,
        'FangSong': 14,
        'Felix Titling': 16,
        'Footlight MT Light': 15,
        'Forte': 14,
        'Franklin Gothic Book': 16,
        'Franklin Gothic Demi': 16,
        'Franklin Gothic Demi Cond': 14,
        'Franklin Gothic Heavy': 16,
        'Franklin Gothic Medium': 16,
        'Franklin Gothic Medium Cond': 14,
        'FrankRuehl': 11,
        'FreesiaUPC': 12,
        'Freestyle Script': 10,
        'French Script MT': 10,
        'Gabriola': 11,
        'Gadugi': 15,
        'Garamond': 13,
        'Gautami': 16,
        'Georgia': 17,
        'Georgia Pro': 15,
        'Georgia Pro Black': 19,
        'Georgia Pro Cond': 14,
        'Georgia Pro Cond Black': 17,
        'Georgia Pro Cond Light': 14,
        'Georgia Pro Cond Semibold': 15,
        'Georgia Pro Light': 15,
        'Georgia Pro Semibold': 17,
        'Gigi': 14,
        'Gill Sans MT Condensed': 10,
        'Gill Sans MT Ext Condensed Bold': 9,
        'Gill Sans Nova': 14,
        'Gill Sans Nova Cond': 9,
        'Gill Sans Nova Cond Lt': 8,
        'Gill Sans Nova Cond Ultra Bold': 16,
        'Gill Sans Nova Cond XBd': 14,
        'Gill Sans Nova Light': 14,
        'Gill Sans Nova Ultra Bold': 23,
        'Gill Sans Ultra Bold': 23,
        'Gill Sans Ultra Bold Condensed': 16,
        'Gisha': 15,
        'Gloucester MT Extra Condensed': 10,
        'Goudy Old Style': 14,
        'Goudy Stout': 22,
        'Grotesque': 13,
        'Grotesque Light': 13,
        'Gulim': 16,
        'GulimChe': 14,
        'Gungsuh': 16,
        'GungsuhChe': 14,
        'Hadassah Friedlaender': 15,
        'Haettenschweiler': 12,
        'Harlow Solid Italic': 13,
        'Harrington': 15,
        'Headline R': 19,
        'HGGothicE': 14,
        'HGGothicM': 14,
        'HGGyoshotai': 14,
        'HGKyokashotai': 14,
        'HGMaruGothicMPRO': 20,
        'HGMinchoB': 15,
        'HGMinchoE': 15,
        'HGPGothicE': 16,
        'HGPGothicM': 17,
        'HGPGyoshotai': 14,
        'HGPKyokashotai': 14,
        'HGPMinchoB': 14,
        'HGPMinchoE': 15,
        'HGPSoeiKakugothicUB': 18,
        'HGPSoeiKakupoptai': 19,
        'HGPSoeiPresenceEB': 16,
        'HGSeikaishotaiPRO': 16,
        'HGSGothicE': 15,
        'HGSGothicM': 16,
        'HGSGyoshotai': 13,
        'HGSKyokashotai': 13,
        'HGSMinchoB': 14,
        'HGSMinchoE': 15,
        'HGSoeiKakugothicUB': 15,
        'HGSoeiKakupoptai': 15,
        'HGSoeiPresenceEB': 15,
        'HGSSoeiKakugothicUB': 17,
        'HGSSoeiKakupoptai': 18,
        'HGSSoeiPresenceEB': 15,
        'High Tower Text': 13,
        'HYGothic-Extra': 17,
        'HYGothic-Medium': 16,
        'HYGraphic-Medium': 16,
        'HYGungSo-Bold': 16,
        'HYHeadLine-Medium': 16,
        'HYMyeongJo-Extra': 18,
        'HYPMokGak-Bold': 19,
        'HYPost-Light': 18,
        'HYPost-Medium': 19,
        'HYShortSamul-Medium': 10,
        'HYSinMyeongJo-Medium': 17,
        'Impact': 15,
        'Imprint MT Shadow': 14,
        'Informal Roman': 15,
        'Ink Free': 14,
        'IrisUPC': 14,
        'Iskoola Pota': 14,
        'JasmineUPC': 12,
        'Javanese Text': 16,
        'Jokerman': 19,
        'Juice ITC': 10,
        'KaiTi': 14,
        'Kalinga': 15,
        'Kartika': 16,
        'Khmer UI': 15,
        'KodchiangUPC': 9,
        'Kokila': 10,
        'Kristen ITC': 16,
        'Kunstler Script': 10,
        'Lao UI': 15,
        'Latha': 14,
        'Leelawadee': 15,
        'Leelawadee UI': 15,
        'Leelawadee UI Semilight': 15,
        'Levenim MT': 15,
        'LilyUPC': 12,
        'Lucida Bright': 16,
        'Lucida Calligraphy': 19,
        'Lucida Console': 17,
        'Lucida Fax': 18,
        'Lucida Handwriting': 19,
        'Lucida Sans': 18,
        'Lucida Sans Typewriter': 16,
        'Lucida Sans Unicode': 18,
        'Magic R': 16,
        'Magneto': 21,
        'Maiandra GD': 17,
        'Malgun Gothic': 16,
        'Malgun Gothic Semilight': 16,
        'Mangal': 16,
        'Marlett': 28,
        'Matura MT Script Capitals': 19,
        'Meiryo': 18,
        'Meiryo UI': 18,
        'Microsoft GothicNeo': 15,
        'Microsoft Himalaya': 10,
        'Microsoft JhengHei': 16,
        'Microsoft JhengHei Light': 17,
        'Microsoft JhengHei UI': 16,
        'Microsoft JhengHei UI Light': 17,
        'Microsoft New Tai Lue': 16,
        'Microsoft PhagsPa': 16,
        'Microsoft Sans Serif': 16,
        'Microsoft Tai Le': 16,
        'Microsoft Uighur': 10,
        'Microsoft YaHei Light': 16,
        'Microsoft YaHei UI': 17,
        'Microsoft YaHei UI Light': 16,
        'Microsoft Yi Baiti': 15,
        'MingLiU': 15,
        'MingLiU_HKSCS': 15,
        'MingLiU_HKSCS-ExtB': 15,
        'MingLiU-ExtB': 15,
        'Miriam': 14,
        'Miriam Fixed': 17,
        'Mistral': 13,
        'Modern No. 20': 13,
        'MoeumT R': 16,
        'Mongolian Baiti': 15,
        'Monotype Corsiva': 13,
        'MoolBoran': 10,
        'MS Gothic': 15,
        'MS Mincho': 15,
        'MS Outlook': 15,
        'MS PGothic': 15,
        'MS PMincho': 15,
        'MS Reference Sans Serif': 18,
        'MS Reference Specialty': 33,
        'MS UI Gothic': 15,
        'MT Extra': 29,
        'MV Boli': 20,
        'Myanmar Text': 16,
        'Narkisim': 12,
        'Neue Haas Grotesk Text Pro': 15,
        'New Gulim': 17,
        'News Gothic MT': 18,
        'Niagara Engraved': 9,
        'Niagara Solid': 9,
        'Nirmala UI': 16,
        'Nirmala UI Semilight': 16,
        'Nyala': 15,
        'OCR A Extended': 17,
        'OCRB': 17,
        'Old English Text MT': 15,
        'Onyx': 9,
        'Palace Script MT': 9,
        'Palatino Linotype': 14,
        'Papyrus': 16,
        'Parchment': 7,
        'Perpetua': 12,
        'Perpetua Titling MT': 18,
        'Plantagenet Cherokee': 15,
        'Playbill': 11,
        'PMingLiU': 14,
        'PMingLiU-ExtB': 14,
        'Poor Richard': 16,
        'Pristina': 14,
        'Pyunji R': 14,
        'Raavi': 14,
        'Rage Italic': 15,
        'Ravie': 27,
        'Rockwell': 15,
        'Rockwell Condensed': 12,
        'Rockwell Extra Bold': 19,
        'Rockwell Light': 15,
        'Rockwell Nova': 15,
        'Rockwell Nova Cond': 15,
        'Rockwell Nova Cond Light': 15,
        'Rockwell Nova Extra Bold': 15,
        'Rockwell Nova Light': 15,
        'Rod': 17,
        'Sakkal Majalla': 11,
        'Sanskrit Text': 17,
        'Script MT Bold': 14,
        'Segoe MDL2 Assets': 11,
        'Segoe Print': 20,
        'Segoe Script': 20,
        'Segoe UI': 15,
        'Segoe UI Black': 17,
        'Segoe UI Emoji': 15,
        'Segoe UI Historic': 15,
        'Segoe UI Light': 14,
        'Segoe UI Semibold': 15,
        'Segoe UI Semilight': 15,
        'Segoe UI Symbol': 15,
        'Selawik': 14,
        'Selawik Light': 14,
        'Selawik Semibold': 15,
        'Shonar Bangla': 14,
        'Showcard Gothic': 16,
        'Shruti': 16,
        'Simplified Arabic': 14,
        'Simplified Arabic Fixed': 16,
        'SimSun-ExtB': 14,
        'Sitka Banner': 14,
        'Sitka Display': 14,
        'Sitka Heading': 15,
        'Sitka Small': 18,
        'Sitka Subheading': 16,
        'Sitka Text': 17,
        'Snap ITC': 23,
        'Source Sans Pro': 13,
        'Source Sans Pro Black': 14,
        'Source Sans Pro ExtraLight': 12,
        'Source Sans Pro Light': 12,
        'Source Sans Pro SemiBold': 14,
        'Stencil': 16,
        'Sylfaen': 14,
        'Symbol': 14,
        'Tahoma': 15,
        'Tempus Sans ITC': 18,
        'TH SarabunPSK': 10,
        'Times New Roman': 14,
        'Traditional Arabic': 13,
        'Trebuchet MS': 14,
        'Tunga': 14,
        'Tw Cen MT': 15,
        'Tw Cen MT Condensed': 10,
        'Tw Cen MT Condensed Extra Bold': 13,
        'UD Digi Kyokasho N-B': 14,
        'UD Digi Kyokasho NK-B': 14,
        'UD Digi Kyokasho NK-R': 14,
        'UD Digi Kyokasho NP-B': 19,
        'UD Digi Kyokasho NP-R': 14,
        'UD Digi Kyokasho N-R': 14,
        'Univers': 14,
        'Univers Condensed': 14,
        'Univers Condensed Light': 12,
        'Univers Light': 14,
        'Urdu Typesetting': 14,
        'Utsaah': 11,
        'Vani': 17,
        'Verdana': 17,
        'Verdana Pro': 17,
        'Verdana Pro Black': 14,
        'Verdana Pro Cond': 14,
        'Verdana Pro Cond Black': 14,
        'Verdana Pro Cond Light': 14,
        'Verdana Pro Cond SemiBold': 14,
        'Verdana Pro Light': 14,
        'Verdana Pro SemiBold': 14,
        'Vijaya': 14,
        'Viner Hand ITC': 18,
        'Vivaldi': 12,
        'Vladimir Script': 13,
        'Vrinda': 16,
        'Webdings': 27,
        'Wide Latin': 33,
        'Wingdings': 36,
        'Wingdings 2': 31,
        'Wingdings 3': 24,
        'Yet R': 14,
        'Yu Gothic': 15,
        'Yu Gothic Light': 14,
        'Yu Gothic Medium': 15,
        'Yu Gothic UI': 15,
        'Yu Gothic UI Light': 14,
        'Yu Gothic UI Semibold': 16,
        'Yu Gothic UI Semilight': 15,
        'Yu Mincho': 15,
        'Yu Mincho Demibold': 14,
        'Yu Mincho Light': 14,
        '\u4eff\u5b8b': 14,
        '\u534e\u6587\u4e2d\u5b8b': 17,
        '\u534e\u6587\u4eff\u5b8b': 13,
        '\u534e\u6587\u5b8b\u4f53': 13,
        '\u534e\u6587\u5f69\u4e91': 15,
        '\u534e\u6587\u65b0\u9b4f': 16,
        '\u534e\u6587\u6977\u4f53': 13,
        '\u534e\u6587\u7425\u73c0': 15,
        '\u534e\u6587\u7ec6\u9ed1': 15,
        '\u534e\u6587\u884c\u6977': 14,
        '\u534e\u6587\u96b6\u4e66': 12,
        '\u5b8b\u4f53': 14,
        '\u5e7c\u5706': 14,
        '\u5fae\u8f6f\u96c5\u9ed1': 16,
        '\u5fae\u8f6f\u96c5\u9ed1 Light': 15,
        '\u65b0\u5b8b\u4f53': 14,
        '\u65b9\u6b63\u59da\u4f53': 14,
        '\u65b9\u6b63\u8212\u4f53': 15,
        '\u6977\u4f53': 14,
        '\u7b49\u7ebf': 14,
        '\u7b49\u7ebf Light': 14,
        '\u96b6\u4e66': 14,
        '\u9ed1\u4f53': 14,
        '\u6e38\u30b4\u30b7\u30c3\u30af': 15,
        '\uff2d\uff33 \uff30\u660e\u671d': 14,
        '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af': 14,
        '\u30e1\u30a4\u30ea\u30aa': 17,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78E': 14,
        'HG\u660e\u671dB': 14,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78M': 14
    },
    22: {
        'Gill Sans MT': 15,
        'Abadi': 18,
        'Abadi Extra Light': 16,
        'Agency FB': 11,
        'Aharoni': 12,
        'Aldhabi': 9,
        'Algerian': 17,
        'Ami R': 12,
        'Angsana New': 10,
        'AngsanaUPC': 10,
        'Aparajita': 12,
        'Arabic Typesetting': 10,
        'Arial': 16,
        'Arial Black': 19,
        'Arial Narrow': 13,
        'Arial Nova': 16,
        'Arial Nova Cond': 15,
        'Arial Nova Cond Light': 13,
        'Arial Nova Light': 16,
        'Arial Rounded MT Bold': 17,
        'Baskerville Old Face': 14,
        'Batang': 17,
        'BatangChe': 15,
        'Bauhaus 93': 16,
        'Bell MT': 15,
        'Bembo': 14,
        'Berlin Sans FB': 17,
        'Berlin Sans FB Demi': 18,
        'Bernard MT Condensed': 14,
        'Blackadder ITC': 11,
        'Bodoni MT': 14,
        'Bodoni MT Black': 19,
        'Bodoni MT Condensed': 10,
        'Bodoni MT Poster Compressed': 9,
        'Book Antiqua': 15,
        'Bookman Old Style': 18,
        'Bookshelf Symbol 7': 21,
        'Bradley Hand ITC': 19,
        'Britannic Bold': 18,
        'Broadway': 19,
        'Browallia New': 11,
        'BrowalliaUPC': 11,
        'Brush Script MT': 15,
        'Calibri': 15,
        'Calibri Light': 15,
        'Californian FB': 15,
        'Calisto MT': 15,
        'Cambria': 16,
        'Cambria Math': 16,
        'Candara': 16,
        'Castellar': 21,
        'Centaur': 14,
        'Century': 16,
        'Century Gothic': 16,
        'Century Schoolbook': 16,
        'Chiller': 14,
        'Colonna MT': 15,
        'Comic Sans MS': 18,
        'Consolas': 16,
        'Constantia': 16,
        'Cooper Black': 17,
        'Copperplate Gothic Bold': 21,
        'Copperplate Gothic Light': 21,
        'Corbel': 15,
        'Cordia New': 11,
        'CordiaUPC': 11,
        'Courier New': 17,
        'Curlz MT': 16,
        'Dante': 13,
        'DaunPenh': 10,
        'David': 13,
        'DilleniaUPC': 9,
        'DokChampa': 16,
        'Dotum': 17,
        'DotumChe': 15,
        'Dubai': 16,
        'Dubai Light': 16,
        'Dubai Medium': 16,
        'Ebrima': 16,
        'Edwardian Script ITC': 14,
        'Elephant': 22,
        'Engravers MT': 19,
        'Eras Bold ITC': 19,
        'Eras Demi ITC': 18,
        'Eras Light ITC': 16,
        'Eras Medium ITC': 17,
        'EucrosiaUPC': 12,
        'Euphemia': 17,
        'Expo M': 25,
        'FangSong': 15,
        'Felix Titling': 17,
        'Footlight MT Light': 16,
        'Forte': 15,
        'Franklin Gothic Book': 17,
        'Franklin Gothic Demi': 17,
        'Franklin Gothic Demi Cond': 15,
        'Franklin Gothic Heavy': 17,
        'Franklin Gothic Medium': 17,
        'Franklin Gothic Medium Cond': 15,
        'FrankRuehl': 12,
        'FreesiaUPC': 13,
        'Freestyle Script': 10,
        'French Script MT': 11,
        'Gabriola': 12,
        'Gadugi': 16,
        'Garamond': 14,
        'Gautami': 17,
        'Georgia': 18,
        'Georgia Pro': 16,
        'Georgia Pro Black': 21,
        'Georgia Pro Cond': 15,
        'Georgia Pro Cond Black': 18,
        'Georgia Pro Cond Light': 15,
        'Georgia Pro Cond Semibold': 16,
        'Georgia Pro Light': 16,
        'Georgia Pro Semibold': 18,
        'Gigi': 14,
        'Gill Sans MT Condensed': 11,
        'Gill Sans MT Ext Condensed Bold': 10,
        'Gill Sans Nova': 15,
        'Gill Sans Nova Cond': 10,
        'Gill Sans Nova Cond Lt': 9,
        'Gill Sans Nova Cond Ultra Bold': 17,
        'Gill Sans Nova Cond XBd': 15,
        'Gill Sans Nova Light': 15,
        'Gill Sans Nova Ultra Bold': 25,
        'Gill Sans Ultra Bold': 25,
        'Gill Sans Ultra Bold Condensed': 17,
        'Gisha': 16,
        'Gloucester MT Extra Condensed': 11,
        'Goudy Old Style': 15,
        'Goudy Stout': 24,
        'Grotesque': 14,
        'Grotesque Light': 14,
        'Gulim': 17,
        'GulimChe': 15,
        'Gungsuh': 17,
        'GungsuhChe': 15,
        'Hadassah Friedlaender': 17,
        'Haettenschweiler': 13,
        'Harlow Solid Italic': 14,
        'Harrington': 16,
        'Headline R': 21,
        'HGGothicE': 15,
        'HGGothicM': 15,
        'HGGyoshotai': 15,
        'HGKyokashotai': 15,
        'HGMaruGothicMPRO': 22,
        'HGMinchoB': 16,
        'HGMinchoE': 16,
        'HGPGothicE': 17,
        'HGPGothicM': 18,
        'HGPGyoshotai': 15,
        'HGPKyokashotai': 14,
        'HGPMinchoB': 15,
        'HGPMinchoE': 16,
        'HGPSoeiKakugothicUB': 19,
        'HGPSoeiKakupoptai': 20,
        'HGPSoeiPresenceEB': 17,
        'HGSeikaishotaiPRO': 17,
        'HGSGothicE': 16,
        'HGSGothicM': 17,
        'HGSGyoshotai': 14,
        'HGSKyokashotai': 13,
        'HGSMinchoB': 15,
        'HGSMinchoE': 16,
        'HGSoeiKakugothicUB': 16,
        'HGSoeiKakupoptai': 16,
        'HGSoeiPresenceEB': 16,
        'HGSSoeiKakugothicUB': 18,
        'HGSSoeiKakupoptai': 19,
        'HGSSoeiPresenceEB': 16,
        'High Tower Text': 14,
        'HYGothic-Extra': 18,
        'HYGothic-Medium': 17,
        'HYGraphic-Medium': 17,
        'HYGungSo-Bold': 17,
        'HYHeadLine-Medium': 17,
        'HYMyeongJo-Extra': 19,
        'HYPMokGak-Bold': 21,
        'HYPost-Light': 19,
        'HYPost-Medium': 21,
        'HYShortSamul-Medium': 11,
        'HYSinMyeongJo-Medium': 18,
        'Impact': 16,
        'Imprint MT Shadow': 15,
        'Informal Roman': 16,
        'Ink Free': 15,
        'IrisUPC': 15,
        'Iskoola Pota': 15,
        'JasmineUPC': 13,
        'Javanese Text': 17,
        'Jokerman': 21,
        'Juice ITC': 11,
        'KaiTi': 15,
        'Kalinga': 16,
        'Kartika': 17,
        'Khmer UI': 16,
        'KodchiangUPC': 10,
        'Kokila': 11,
        'Kristen ITC': 17,
        'Kunstler Script': 10,
        'Lao UI': 16,
        'Latha': 15,
        'Leelawadee': 16,
        'Leelawadee UI': 16,
        'Leelawadee UI Semilight': 16,
        'Levenim MT': 17,
        'LilyUPC': 13,
        'Lucida Bright': 18,
        'Lucida Calligraphy': 20,
        'Lucida Console': 18,
        'Lucida Fax': 19,
        'Lucida Handwriting': 21,
        'Lucida Sans': 19,
        'Lucida Sans Typewriter': 17,
        'Lucida Sans Unicode': 19,
        'Magic R': 17,
        'Magneto': 22,
        'Maiandra GD': 18,
        'Malgun Gothic': 17,
        'Malgun Gothic Semilight': 17,
        'Mangal': 17,
        'Marlett': 30,
        'Matura MT Script Capitals': 20,
        'Meiryo': 20,
        'Meiryo UI': 20,
        'Microsoft GothicNeo': 16,
        'Microsoft Himalaya': 11,
        'Microsoft JhengHei': 17,
        'Microsoft JhengHei Light': 18,
        'Microsoft JhengHei UI': 17,
        'Microsoft JhengHei UI Light': 18,
        'Microsoft New Tai Lue': 17,
        'Microsoft PhagsPa': 17,
        'Microsoft Sans Serif': 17,
        'Microsoft Tai Le': 17,
        'Microsoft Uighur': 11,
        'Microsoft YaHei Light': 18,
        'Microsoft YaHei UI': 18,
        'Microsoft YaHei UI Light': 18,
        'Microsoft Yi Baiti': 16,
        'MingLiU': 16,
        'MingLiU_HKSCS': 16,
        'MingLiU_HKSCS-ExtB': 16,
        'MingLiU-ExtB': 16,
        'Miriam': 15,
        'Miriam Fixed': 18,
        'Mistral': 14,
        'Modern No. 20': 14,
        'MoeumT R': 17,
        'Mongolian Baiti': 16,
        'Monotype Corsiva': 14,
        'MoolBoran': 11,
        'MS Gothic': 16,
        'MS Mincho': 16,
        'MS Outlook': 16,
        'MS PGothic': 16,
        'MS PMincho': 16,
        'MS Reference Sans Serif': 19,
        'MS Reference Specialty': 36,
        'MS UI Gothic': 16,
        'MT Extra': 31,
        'MV Boli': 21,
        'Myanmar Text': 17,
        'Narkisim': 13,
        'Neue Haas Grotesk Text Pro': 16,
        'New Gulim': 18,
        'News Gothic MT': 19,
        'Niagara Engraved': 10,
        'Niagara Solid': 10,
        'Nirmala UI': 17,
        'Nirmala UI Semilight': 17,
        'Nyala': 16,
        'OCR A Extended': 19,
        'OCRB': 18,
        'Old English Text MT': 16,
        'Onyx': 10,
        'Palace Script MT': 10,
        'Palatino Linotype': 15,
        'Papyrus': 18,
        'Parchment': 7,
        'Perpetua': 13,
        'Perpetua Titling MT': 20,
        'Plantagenet Cherokee': 16,
        'Playbill': 11,
        'PMingLiU': 15,
        'PMingLiU-ExtB': 15,
        'Poor Richard': 17,
        'Pristina': 15,
        'Pyunji R': 15,
        'Raavi': 15,
        'Rage Italic': 16,
        'Ravie': 29,
        'Rockwell': 16,
        'Rockwell Condensed': 12,
        'Rockwell Extra Bold': 20,
        'Rockwell Light': 16,
        'Rockwell Nova': 16,
        'Rockwell Nova Cond': 16,
        'Rockwell Nova Cond Light': 16,
        'Rockwell Nova Extra Bold': 16,
        'Rockwell Nova Light': 16,
        'Rod': 18,
        'Sakkal Majalla': 12,
        'Sanskrit Text': 18,
        'Script MT Bold': 15,
        'Segoe MDL2 Assets': 12,
        'Segoe Print': 21,
        'Segoe Script': 21,
        'Segoe UI': 16,
        'Segoe UI Black': 18,
        'Segoe UI Emoji': 16,
        'Segoe UI Historic': 16,
        'Segoe UI Light': 15,
        'Segoe UI Semibold': 17,
        'Segoe UI Semilight': 16,
        'Segoe UI Symbol': 16,
        'Selawik': 15,
        'Selawik Light': 15,
        'Selawik Semibold': 16,
        'Shonar Bangla': 15,
        'Showcard Gothic': 17,
        'Shruti': 17,
        'Simplified Arabic': 15,
        'Simplified Arabic Fixed': 17,
        'SimSun-ExtB': 15,
        'Sitka Banner': 15,
        'Sitka Display': 15,
        'Sitka Heading': 16,
        'Sitka Small': 20,
        'Sitka Subheading': 17,
        'Sitka Text': 18,
        'Snap ITC': 25,
        'Source Sans Pro': 14,
        'Source Sans Pro Black': 15,
        'Source Sans Pro ExtraLight': 13,
        'Source Sans Pro Light': 13,
        'Source Sans Pro SemiBold': 14,
        'Stencil': 17,
        'Sylfaen': 15,
        'Symbol': 15,
        'Tahoma': 16,
        'Tempus Sans ITC': 19,
        'TH SarabunPSK': 11,
        'Times New Roman': 15,
        'Traditional Arabic': 14,
        'Trebuchet MS': 15,
        'Tunga': 15,
        'Tw Cen MT': 16,
        'Tw Cen MT Condensed': 11,
        'Tw Cen MT Condensed Extra Bold': 14,
        'UD Digi Kyokasho N-B': 15,
        'UD Digi Kyokasho NK-B': 15,
        'UD Digi Kyokasho NK-R': 15,
        'UD Digi Kyokasho NP-B': 21,
        'UD Digi Kyokasho NP-R': 15,
        'UD Digi Kyokasho N-R': 15,
        'Univers': 15,
        'Univers Condensed': 15,
        'Univers Condensed Light': 13,
        'Univers Light': 15,
        'Urdu Typesetting': 15,
        'Utsaah': 12,
        'Vani': 18,
        'Verdana': 18,
        'Verdana Pro': 18,
        'Verdana Pro Black': 15,
        'Verdana Pro Cond': 15,
        'Verdana Pro Cond Black': 15,
        'Verdana Pro Cond Light': 15,
        'Verdana Pro Cond SemiBold': 15,
        'Verdana Pro Light': 15,
        'Verdana Pro SemiBold': 15,
        'Vijaya': 12,
        'Viner Hand ITC': 20,
        'Vivaldi': 12,
        'Vladimir Script': 13,
        'Vrinda': 17,
        'Webdings': 29,
        'Wide Latin': 36,
        'Wingdings': 39,
        'Wingdings 2': 33,
        'Wingdings 3': 26,
        'Yet R': 16,
        'Yu Gothic': 16,
        'Yu Gothic Light': 16,
        'Yu Gothic Medium': 16,
        'Yu Gothic UI': 16,
        'Yu Gothic UI Light': 15,
        'Yu Gothic UI Semibold': 17,
        'Yu Gothic UI Semilight': 16,
        'Yu Mincho': 16,
        'Yu Mincho Demibold': 15,
        'Yu Mincho Light': 15,
        '\u4eff\u5b8b': 15,
        '\u534e\u6587\u4e2d\u5b8b': 18,
        '\u534e\u6587\u4eff\u5b8b': 14,
        '\u534e\u6587\u5b8b\u4f53': 14,
        '\u534e\u6587\u5f69\u4e91': 16,
        '\u534e\u6587\u65b0\u9b4f': 17,
        '\u534e\u6587\u6977\u4f53': 14,
        '\u534e\u6587\u7425\u73c0': 16,
        '\u534e\u6587\u7ec6\u9ed1': 16,
        '\u534e\u6587\u884c\u6977': 15,
        '\u534e\u6587\u96b6\u4e66': 13,
        '\u5b8b\u4f53': 15,
        '\u5e7c\u5706': 15,
        '\u5fae\u8f6f\u96c5\u9ed1': 17,
        '\u5fae\u8f6f\u96c5\u9ed1 Light': 17,
        '\u65b0\u5b8b\u4f53': 15,
        '\u65b9\u6b63\u59da\u4f53': 15,
        '\u65b9\u6b63\u8212\u4f53': 16,
        '\u6977\u4f53': 15,
        '\u7b49\u7ebf': 15,
        '\u7b49\u7ebf Light': 15,
        '\u96b6\u4e66': 15,
        '\u9ed1\u4f53': 15,
        '\u6e38\u30b4\u30b7\u30c3\u30af': 16,
        '\uff2d\uff33 \uff30\u660e\u671d': 15,
        '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af': 15,
        '\u30e1\u30a4\u30ea\u30aa': 18,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78E': 15,
        'HG\u660e\u671dB': 15,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78M': 15
    },
    24: {
        'Gill Sans MT': 16,
        'Abadi': 19,
        'Abadi Extra Light': 18,
        'Agency FB': 14,
        'Aharoni': 13,
        'Aldhabi': 10,
        'Algerian': 19,
        'Ami R': 13,
        'Angsana New': 11,
        'AngsanaUPC': 11,
        'Aparajita': 13,
        'Arabic Typesetting': 11,
        'Arial': 18,
        'Arial Black': 21,
        'Arial Narrow': 15,
        'Arial Nova': 18,
        'Arial Nova Cond': 16,
        'Arial Nova Cond Light': 14,
        'Arial Nova Light': 18,
        'Arial Rounded MT Bold': 19,
        'Baskerville Old Face': 16,
        'Batang': 19,
        'BatangChe': 16,
        'Bauhaus 93': 18,
        'Bell MT': 16,
        'Bembo': 16,
        'Berlin Sans FB': 19,
        'Berlin Sans FB Demi': 20,
        'Bernard MT Condensed': 16,
        'Blackadder ITC': 13,
        'Bodoni MT': 16,
        'Bodoni MT Black': 21,
        'Bodoni MT Condensed': 11,
        'Bodoni MT Poster Compressed': 9,
        'Book Antiqua': 16,
        'Bookman Old Style': 20,
        'Bookshelf Symbol 7': 24,
        'Bradley Hand ITC': 21,
        'Britannic Bold': 20,
        'Broadway': 21,
        'Browallia New': 12,
        'BrowalliaUPC': 12,
        'Brush Script MT': 16,
        'Calibri': 16,
        'Calibri Light': 16,
        'Californian FB': 17,
        'Calisto MT': 16,
        'Cambria': 18,
        'Cambria Math': 18,
        'Candara': 18,
        'Castellar': 23,
        'Centaur': 16,
        'Century': 18,
        'Century Gothic': 18,
        'Century Schoolbook': 18,
        'Chiller': 15,
        'Colonna MT': 16,
        'Comic Sans MS': 20,
        'Consolas': 18,
        'Constantia': 17,
        'Cooper Black': 19,
        'Copperplate Gothic Bold': 23,
        'Copperplate Gothic Light': 23,
        'Corbel': 17,
        'Cordia New': 12,
        'CordiaUPC': 12,
        'Courier New': 19,
        'Curlz MT': 17,
        'Dante': 14,
        'DaunPenh': 11,
        'David': 14,
        'DilleniaUPC': 10,
        'DokChampa': 18,
        'Dotum': 19,
        'DotumChe': 16,
        'Dubai': 17,
        'Dubai Light': 17,
        'Dubai Medium': 17,
        'Ebrima': 17,
        'Edwardian Script ITC': 15,
        'Elephant': 24,
        'Engravers MT': 21,
        'Eras Bold ITC': 21,
        'Eras Demi ITC': 20,
        'Eras Light ITC': 17,
        'Eras Medium ITC': 18,
        'EucrosiaUPC': 13,
        'Euphemia': 19,
        'Expo M': 28,
        'FangSong': 16,
        'Felix Titling': 19,
        'Footlight MT Light': 18,
        'Forte': 17,
        'Franklin Gothic Book': 19,
        'Franklin Gothic Demi': 19,
        'Franklin Gothic Demi Cond': 16,
        'Franklin Gothic Heavy': 19,
        'Franklin Gothic Medium': 19,
        'Franklin Gothic Medium Cond': 16,
        'FrankRuehl': 13,
        'FreesiaUPC': 14,
        'Freestyle Script': 12,
        'French Script MT': 12,
        'Gabriola': 13,
        'Gadugi': 17,
        'Garamond': 15,
        'Gautami': 19,
        'Georgia': 20,
        'Georgia Pro': 18,
        'Georgia Pro Black': 23,
        'Georgia Pro Cond': 17,
        'Georgia Pro Cond Black': 20,
        'Georgia Pro Cond Light': 16,
        'Georgia Pro Cond Semibold': 18,
        'Georgia Pro Light': 18,
        'Georgia Pro Semibold': 20,
        'Gigi': 17,
        'Gill Sans MT Condensed': 12,
        'Gill Sans MT Ext Condensed Bold': 11,
        'Gill Sans Nova': 16,
        'Gill Sans Nova Cond': 11,
        'Gill Sans Nova Cond Lt': 10,
        'Gill Sans Nova Cond Ultra Bold': 19,
        'Gill Sans Nova Cond XBd': 17,
        'Gill Sans Nova Light': 16,
        'Gill Sans Nova Ultra Bold': 27,
        'Gill Sans Ultra Bold': 27,
        'Gill Sans Ultra Bold Condensed': 19,
        'Gisha': 17,
        'Gloucester MT Extra Condensed': 12,
        'Goudy Old Style': 16,
        'Goudy Stout': 26,
        'Grotesque': 15,
        'Grotesque Light': 15,
        'Gulim': 18,
        'GulimChe': 16,
        'Gungsuh': 19,
        'GungsuhChe': 16,
        'Hadassah Friedlaender': 18,
        'Haettenschweiler': 14,
        'Harlow Solid Italic': 15,
        'Harrington': 18,
        'Headline R': 23,
        'HGGothicE': 16,
        'HGGothicM': 16,
        'HGGyoshotai': 16,
        'HGKyokashotai': 16,
        'HGMaruGothicMPRO': 24,
        'HGMinchoB': 17,
        'HGMinchoE': 17,
        'HGPGothicE': 18,
        'HGPGothicM': 20,
        'HGPGyoshotai': 16,
        'HGPKyokashotai': 16,
        'HGPMinchoB': 16,
        'HGPMinchoE': 18,
        'HGPSoeiKakugothicUB': 21,
        'HGPSoeiKakupoptai': 22,
        'HGPSoeiPresenceEB': 19,
        'HGSeikaishotaiPRO': 19,
        'HGSGothicE': 17,
        'HGSGothicM': 19,
        'HGSGyoshotai': 15,
        'HGSKyokashotai': 15,
        'HGSMinchoB': 16,
        'HGSMinchoE': 18,
        'HGSoeiKakugothicUB': 17,
        'HGSoeiKakupoptai': 17,
        'HGSoeiPresenceEB': 17,
        'HGSSoeiKakugothicUB': 20,
        'HGSSoeiKakupoptai': 21,
        'HGSSoeiPresenceEB': 18,
        'High Tower Text': 15,
        'HYGothic-Extra': 20,
        'HYGothic-Medium': 19,
        'HYGraphic-Medium': 19,
        'HYGungSo-Bold': 19,
        'HYHeadLine-Medium': 19,
        'HYMyeongJo-Extra': 21,
        'HYPMokGak-Bold': 23,
        'HYPost-Light': 21,
        'HYPost-Medium': 23,
        'HYShortSamul-Medium': 12,
        'HYSinMyeongJo-Medium': 20,
        'Impact': 17,
        'Imprint MT Shadow': 16,
        'Informal Roman': 17,
        'Ink Free': 16,
        'IrisUPC': 16,
        'Iskoola Pota': 16,
        'JasmineUPC': 15,
        'Javanese Text': 19,
        'Jokerman': 23,
        'Juice ITC': 11,
        'KaiTi': 16,
        'Kalinga': 18,
        'Kartika': 18,
        'Khmer UI': 17,
        'KodchiangUPC': 11,
        'Kokila': 12,
        'Kristen ITC': 19,
        'Kunstler Script': 11,
        'Lao UI': 17,
        'Latha': 16,
        'Leelawadee': 17,
        'Leelawadee UI': 17,
        'Leelawadee UI Semilight': 18,
        'Levenim MT': 18,
        'LilyUPC': 14,
        'Lucida Bright': 19,
        'Lucida Calligraphy': 22,
        'Lucida Console': 20,
        'Lucida Fax': 21,
        'Lucida Handwriting': 23,
        'Lucida Sans': 21,
        'Lucida Sans Typewriter': 19,
        'Lucida Sans Unicode': 21,
        'Magic R': 19,
        'Magneto': 25,
        'Maiandra GD': 20,
        'Malgun Gothic': 19,
        'Malgun Gothic Semilight': 19,
        'Mangal': 18,
        'Marlett': 33,
        'Matura MT Script Capitals': 22,
        'Meiryo': 22,
        'Meiryo UI': 22,
        'Microsoft GothicNeo': 17,
        'Microsoft Himalaya': 12,
        'Microsoft JhengHei': 19,
        'Microsoft JhengHei Light': 19,
        'Microsoft JhengHei UI': 19,
        'Microsoft JhengHei UI Light': 19,
        'Microsoft New Tai Lue': 18,
        'Microsoft PhagsPa': 18,
        'Microsoft Sans Serif': 19,
        'Microsoft Tai Le': 18,
        'Microsoft Uighur': 12,
        'Microsoft YaHei Light': 19,
        'Microsoft YaHei UI': 20,
        'Microsoft YaHei UI Light': 19,
        'Microsoft Yi Baiti': 17,
        'MingLiU': 17,
        'MingLiU_HKSCS': 17,
        'MingLiU_HKSCS-ExtB': 17,
        'MingLiU-ExtB': 17,
        'Miriam': 16,
        'Miriam Fixed': 20,
        'Mistral': 15,
        'Modern No. 20': 16,
        'MoeumT R': 19,
        'Mongolian Baiti': 17,
        'Monotype Corsiva': 15,
        'MoolBoran': 12,
        'MS Gothic': 17,
        'MS Mincho': 17,
        'MS Outlook': 17,
        'MS PGothic': 17,
        'MS PMincho': 17,
        'MS Reference Sans Serif': 21,
        'MS Reference Specialty': 39,
        'MS UI Gothic': 17,
        'MT Extra': 34,
        'MV Boli': 23,
        'Myanmar Text': 18,
        'Narkisim': 14,
        'Neue Haas Grotesk Text Pro': 17,
        'New Gulim': 19,
        'News Gothic MT': 21,
        'Niagara Engraved': 11,
        'Niagara Solid': 11,
        'Nirmala UI': 18,
        'Nirmala UI Semilight': 19,
        'Nyala': 17,
        'OCR A Extended': 20,
        'OCRB': 20,
        'Old English Text MT': 17,
        'Onyx': 10,
        'Palace Script MT': 11,
        'Palatino Linotype': 16,
        'Papyrus': 20,
        'Parchment': 8,
        'Perpetua': 15,
        'Perpetua Titling MT': 22,
        'Plantagenet Cherokee': 18,
        'Playbill': 12,
        'PMingLiU': 16,
        'PMingLiU-ExtB': 16,
        'Poor Richard': 19,
        'Pristina': 16,
        'Pyunji R': 17,
        'Raavi': 16,
        'Rage Italic': 18,
        'Ravie': 31,
        'Rockwell': 17,
        'Rockwell Condensed': 14,
        'Rockwell Extra Bold': 22,
        'Rockwell Light': 18,
        'Rockwell Nova': 17,
        'Rockwell Nova Cond': 17,
        'Rockwell Nova Cond Light': 17,
        'Rockwell Nova Extra Bold': 17,
        'Rockwell Nova Light': 17,
        'Rod': 20,
        'Sakkal Majalla': 13,
        'Sanskrit Text': 19,
        'Script MT Bold': 17,
        'Segoe MDL2 Assets': 13,
        'Segoe Print': 23,
        'Segoe Script': 23,
        'Segoe UI': 17,
        'Segoe UI Black': 20,
        'Segoe UI Emoji': 17,
        'Segoe UI Historic': 17,
        'Segoe UI Light': 16,
        'Segoe UI Semibold': 18,
        'Segoe UI Semilight': 17,
        'Segoe UI Symbol': 17,
        'Selawik': 17,
        'Selawik Light': 17,
        'Selawik Semibold': 18,
        'Shonar Bangla': 13,
        'Showcard Gothic': 19,
        'Shruti': 19,
        'Simplified Arabic': 17,
        'Simplified Arabic Fixed': 19,
        'SimSun-ExtB': 16,
        'Sitka Banner': 16,
        'Sitka Display': 17,
        'Sitka Heading': 18,
        'Sitka Small': 22,
        'Sitka Subheading': 19,
        'Sitka Text': 20,
        'Snap ITC': 28,
        'Source Sans Pro': 15,
        'Source Sans Pro Black': 17,
        'Source Sans Pro ExtraLight': 15,
        'Source Sans Pro Light': 15,
        'Source Sans Pro SemiBold': 16,
        'Stencil': 18,
        'Sylfaen': 16,
        'Symbol': 16,
        'Tahoma': 17,
        'Tempus Sans ITC': 21,
        'TH SarabunPSK': 12,
        'Times New Roman': 16,
        'Traditional Arabic': 16,
        'Trebuchet MS': 17,
        'Tunga': 17,
        'Tw Cen MT': 18,
        'Tw Cen MT Condensed': 12,
        'Tw Cen MT Condensed Extra Bold': 16,
        'UD Digi Kyokasho N-B': 16,
        'UD Digi Kyokasho NK-B': 16,
        'UD Digi Kyokasho NK-R': 16,
        'UD Digi Kyokasho NP-B': 23,
        'UD Digi Kyokasho NP-R': 16,
        'UD Digi Kyokasho N-R': 16,
        'Univers': 16,
        'Univers Condensed': 16,
        'Univers Condensed Light': 14,
        'Univers Light': 16,
        'Urdu Typesetting': 16,
        'Utsaah': 13,
        'Vani': 20,
        'Verdana': 20,
        'Verdana Pro': 20,
        'Verdana Pro Black': 16,
        'Verdana Pro Cond': 16,
        'Verdana Pro Cond Black': 16,
        'Verdana Pro Cond Light': 16,
        'Verdana Pro Cond SemiBold': 16,
        'Verdana Pro Light': 16,
        'Verdana Pro SemiBold': 16,
        'Vijaya': 13,
        'Viner Hand ITC': 22,
        'Vivaldi': 14,
        'Vladimir Script': 15,
        'Vrinda': 18,
        'Webdings': 32,
        'Wide Latin': 40,
        'Wingdings': 43,
        'Wingdings 2': 36,
        'Wingdings 3': 29,
        'Yet R': 17,
        'Yu Gothic': 18,
        'Yu Gothic Light': 17,
        'Yu Gothic Medium': 18,
        'Yu Gothic UI': 17,
        'Yu Gothic UI Light': 17,
        'Yu Gothic UI Semibold': 18,
        'Yu Gothic UI Semilight': 18,
        'Yu Mincho': 17,
        'Yu Mincho Demibold': 17,
        'Yu Mincho Light': 16,
        '\u4eff\u5b8b': 16,
        '\u534e\u6587\u4e2d\u5b8b': 20,
        '\u534e\u6587\u4eff\u5b8b': 15,
        '\u534e\u6587\u5b8b\u4f53': 15,
        '\u534e\u6587\u5f69\u4e91': 18,
        '\u534e\u6587\u65b0\u9b4f': 19,
        '\u534e\u6587\u6977\u4f53': 15,
        '\u534e\u6587\u7425\u73c0': 18,
        '\u534e\u6587\u7ec6\u9ed1': 18,
        '\u534e\u6587\u884c\u6977': 16,
        '\u534e\u6587\u96b6\u4e66': 14,
        '\u5b8b\u4f53': 16,
        '\u5e7c\u5706': 16,
        '\u5fae\u8f6f\u96c5\u9ed1': 19,
        '\u5fae\u8f6f\u96c5\u9ed1 Light': 18,
        '\u65b0\u5b8b\u4f53': 16,
        '\u65b9\u6b63\u59da\u4f53': 16,
        '\u65b9\u6b63\u8212\u4f53': 18,
        '\u6977\u4f53': 16,
        '\u7b49\u7ebf': 17,
        '\u7b49\u7ebf Light': 16,
        '\u96b6\u4e66': 16,
        '\u9ed1\u4f53': 16,
        '\u6e38\u30b4\u30b7\u30c3\u30af': 18,
        '\uff2d\uff33 \uff30\u660e\u671d': 16,
        '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af': 16,
        '\u30e1\u30a4\u30ea\u30aa': 20,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78E': 16,
        'HG\u660e\u671dB': 16,
        'HG\uff7a\uff9e\uff7c\uff6f\uff78M': 16
    }
};
exports.XFileConstants = {
    _relationshipFileFolder: '_rels',
    _dataFileRootFolder: '/xl',
    _contentTypeFileName: '[Content_Types].xml',
    _binExtension: 'bin',
    _binType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings',
    _relsExtension: 'rels',
    _relsType: 'application/vnd.openxmlformats-package.relationships+xml',
    _sharedStringType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml',
    _stylesType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml',
    _themeType: 'application/vnd.openxmlformats-officedocument.theme+xml',
    _workbookType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml',
    _worksheetType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml',
    _externalLinkType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml',
    _tableType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml',
    _drawingType: 'application/vnd.openxmlformats-officedocument.drawing+xml',
    _chartType: 'application/vnd.openxmlformats-officedocument.drawingml.chart+xml',
    _chart2016Type: 'application/vnd.ms-office.chartex+xml',
    _chart2016Style: 'application/vnd.ms-office.chartstyle+xml',
    _chart2016Colors: 'application/vnd.ms-office.chartcolorstyle+xml',
    _chartShapes: 'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml',
    _diagramColorsType: 'application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml',
    _diagramDataType: 'application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml',
    _diagramDrawingType: 'application/vnd.ms-office.drawingml.diagramDrawing+xml',
    _diagramLayoutType: 'application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml',
    _diagramStyleType: 'application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml',
    _commentsType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml',
    _threadedCommentsType: 'application/vnd.ms-excel.threadedcomments+xml',
    _personType: 'application/vnd.ms-excel.person+xml',
    _pivotDefinitionType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml',
    _pivotCacheRecordsType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml',
    _pivotTableType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml',
    _slicerType: 'application/vnd.ms-excel.slicer+xml',
    _slicerCacheType: 'application/vnd.ms-excel.slicerCache+xml',
    _vbaType: 'application/vnd.ms-office.vbaProject',
    _vmlDrawingsType: 'application/vnd.openxmlformats-officedocument.vmlDrawing',
    _controlProperties: 'application/vnd.ms-excel.controlproperties+xml',
    _xmlExtension: 'xml',
    _vmlExtension: 'vml',
    _xmlType: 'application/xml',
    _jpgExtension: 'jpg',
    _jpgType: 'image/jpg',
    _tiffExtension: 'tiff',
    _tiffType: 'image/tiff',
    _jpegExtension: 'jpeg',
    _jpegType: 'image/jpeg',
    _svgExtension: 'svg',
    _svgType: 'image/svg+xml',
    _pngExtension: 'png',
    _pngType: 'image/png',
    _bmpExtension: 'bmp',
    _bmpType: 'image/bmp',
    _gifExtension: 'gif',
    _gifType: 'image/gif',
    _emfExtension: 'emf',
    _emfType: 'image/x-emf',
    _wmfExtension: 'wmf',
    _wmfType: 'image/x-wmf',
    _drawings: 'drawings',
    _vmlDrawingsFileNamePrefix: 'vmlDrawing',
    _chartsFileFolder: '/xl/charts',
    _drawingsFileFolder: '/xl/drawings',
    _personsFileFolder: '/xl/persons',
    _mediaFileFolder: '/xl/media',
    _threadedCommentsFileFolder: '/xl/threadedComments',
    _worksheetFolder: '/xl/worksheets',
    _tableFilesFolder: '/xl/tables',
    _slicerFilesFolder: '/xl/slicers',
    _slicerCacheFilesFolder: '/xl/slicerCaches',
    _pivotCacheFilesFolder: '/xl/pivotCache',
    _pivotTablesFolder: '/xl/pivotTables',
    _worksheetNamePrefix: 'sheet',
    _commentFileNamePrefix: 'comments',
    _chartFileNamePrefix: 'chart',
    _chartExtensionFileNamePrefix: 'chartEx',
    _chartStyleFileName: 'style',
    _personFileNamePrefix: 'person',
    _chartColorsStyleFileName: 'colors',
    _drawingFileNamePrefix: 'drawing',
    _threadedCommentsFilePerfix: 'threadedComment',
    _imageFileNamePrefix: 'image',
    _tableFileNamePrefix: 'table',
    _slicerFileNamePrefix: 'slicer',
    _slicerCacheFileNamePrefix: 'slicerCache',
    _pivotCacheDefinitionPrefix: 'pivotCacheDefinition',
    _pivotCacheRecordPrefix: 'pivotCacheRecords',
    _pivotTablePrefix: 'pivotTable',
    _sharedStringsDefaultFileName: '/xl/sharedStrings.xml',
    _themeDefaultFileName: '/xl/theme/theme1.xml',
    _worksheetFilePath: '/xl/worksheets',
    _workbook_default_fileName: '/xl/workbook.xml',
    _docPropsCore_default_fileName: '/docProps/core.xml',
    _docPropsApp_default_fileName: '/docProps/app.xml',
    _docPropsCustom_default_fileName: '/docProps/custom.xml',
    _style_fileName: '/xl/styles.xml',
    _theme_default_fileName: '/xl/theme/theme1.xml',
    _metadata_fileName: 'metadata.xml',
    _workbookRels: '/xl/_rels/workbook.xml.rels',
    _workbookNameSpace: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
    _markupCompatibility: 'http://schemas.openxmlformats.org/markup-compatibility/2006',
    _drawingNameSpace: 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
    _drawingNameSpace2: 'http://schemas.openxmlformats.org/drawingml/2006/main',
    _tableNameSpace: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
    _ac: 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',
    _ignorable_style: 'x14ac',
    _ignorable_worksheet: 'x14ac xr xr2 xr3',
    _ignorableXR: 'xr',
    _xr: 'http://schemas.microsoft.com/office/spreadsheetml/2014/revision',
    _xr2: 'http://schemas.microsoft.com/office/spreadsheetml/2015/revision2',
    _xr3: 'http://schemas.microsoft.com/office/spreadsheetml/2016/revision3',
    _relationShipNameSpace: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
    _contentTypeNameSpace: 'http://schemas.openxmlformats.org/package/2006/content-types',
    _relationshipNameSpace: 'http://schemas.openxmlformats.org/package/2006/relationships',
    _themeNameSpace: 'http://schemas.openxmlformats.org/drawingml/2006/main',
    _a14: 'http://schemas.microsoft.com/office/drawing/2010/main',
    _asvg: 'http://schemas.microsoft.com/office/drawing/2016/SVG/main',
    _extensionListNameSpace: 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
    _sparklineGroupsNameSpace: 'http://schemas.microsoft.com/office/excel/2006/main',
    _slicerCompatibility: 'http://schemas.openxmlformats.org/markup-compatibility/2006',
    _slicerNameSpaceX: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
    _slicerNameSpace: 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
    _relationship_spreadsheetml_201011: 'http://schemas.microsoft.com/office/spreadsheetml/2010/11/main',
    _sheetMetadata: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml',
    _dynamicArrayNameSpace: 'http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray',
    _richDataNameSpace: 'http://schemas.microsoft.com/office/spreadsheetml/2017/richdata',
    _personsNameSpace: 'http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments',
    _personsNameSpaceX: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
    _threadedCommentsNameSpace: 'http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments',
    _threadedCommentsNameSpaceX: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
    _revision: 'http://schemas.microsoft.com/office/spreadsheetml/2014/revision',
    _docPropsCoreRootNameSpace: 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',
    _docPropsElementsNameSpace: 'http://purl.org/dc/elements/1.1/',
    _docPropsTermsNameSpace: 'http://purl.org/dc/terms/',
    _docPropsDcmitypeNameSpace: 'http://purl.org/dc/dcmitype/',
    _docPropsXMLSchemaNameSpace: 'http://www.w3.org/2001/XMLSchema-instance',
    _docPropsCore: 'application/vnd.openxmlformats-package.core-properties+xml',
    _docPropsAppRootNameSpace: 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',
    _docPropsAppVTypesNameSpace: 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',
    _docPropsApp: 'application/vnd.openxmlformats-officedocument.extended-properties+xml',
    _docPropsCustomNameSpace: 'http://schemas.openxmlformats.org/officeDocument/2006/custom-properties',
    _docPropsCustomVTypesNameSpace: 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',
    _docPropsCustom: 'application/vnd.openxmlformats-officedocument.custom-properties+xml'
};
var FontLanguage;
(function (FontLanguage) {
    FontLanguage[FontLanguage['latin'] = 0] = 'latin';
    FontLanguage[FontLanguage['cs'] = 1] = 'cs';
    FontLanguage[FontLanguage['ea'] = 2] = 'ea';
    FontLanguage[FontLanguage['sym'] = 3] = 'sym';
})(FontLanguage = exports.FontLanguage || (exports.FontLanguage = {}));
var ExcelCell = /** @class */ (function () {
    function ExcelCell(row, col) {
        this.row = row;
        this.col = col;
    }
    return ExcelCell;
}());
exports.ExcelCell = ExcelCell;
var ExcelColumn = /** @class */ (function () {
    function ExcelColumn(index) {
        this.index = index;
    }
    return ExcelColumn;
}());
exports.ExcelColumn = ExcelColumn;
var ExcelRow = /** @class */ (function () {
    function ExcelRow(index) {
        this.index = index;
    }
    return ExcelRow;
}());
exports.ExcelRow = ExcelRow;
var ExcelTheme = /** @class */ (function () {
    function ExcelTheme(name, colorScheme, fontScheme) {
        this.name = name;
        this.colorScheme = colorScheme;
        this.fontScheme = fontScheme;
    }
    return ExcelTheme;
}());
exports.ExcelTheme = ExcelTheme;
var ColorScheme = /** @class */ (function () {
    function ColorScheme(name, schemeColors) {
        this.name = name;
        this.schemeColors = schemeColors;
    }
    return ColorScheme;
}());
exports.ColorScheme = ColorScheme;
var FontScheme = /** @class */ (function () {
    function FontScheme(name, majorFont, minorFont) {
        this.name = name;
        this.majorFont = majorFont;
        this.minorFont = minorFont;
    }
    return FontScheme;
}());
exports.FontScheme = FontScheme;
var ThemeFont = /** @class */ (function () {
    function ThemeFont(script, typeface) {
        this.script = script;
        this.typeface = typeface;
    }
    return ThemeFont;
}());
exports.ThemeFont = ThemeFont;
var ThemeFonts = /** @class */ (function () {
    function ThemeFonts(runFormats, themesFonts) {
        this.runFormattings = runFormats;
        this.themesFonts = themesFonts;
    }
    return ThemeFonts;
}());
exports.ThemeFonts = ThemeFonts;
var RunFormatting = /** @class */ (function () {
    function RunFormatting(language, typeface) {
        this.fontLanguage = language;
        this.typeface = typeface;
    }
    return RunFormatting;
}());
exports.RunFormatting = RunFormatting;
var SheetInfo = /** @class */ (function () {
    function SheetInfo() {
    }
    return SheetInfo;
}());
exports.SheetInfo = SheetInfo;
var DefaultContentType = /** @class */ (function () {
    function DefaultContentType() {
    }
    return DefaultContentType;
}());
exports.DefaultContentType = DefaultContentType;
var OverrideContentType = /** @class */ (function () {
    function OverrideContentType() {
    }
    return OverrideContentType;
}());
exports.OverrideContentType = OverrideContentType;
var Relationship = /** @class */ (function () {
    function Relationship() {
    }
    return Relationship;
}());
var XFile = /** @class */ (function () {
    function XFile(fileName, fileType) {
        this.fileName = fileName;
        this.fileType = fileType;
        this.relationFiles = { count: 0 };
    }
    XFile.prototype._addRelationFile = function (file) {
        if (!file) {
            return '';
        }
        var key = exports.RelationshipConstants._relationshipPrefix + (++this.relationFiles.count);
        this.relationFiles[key] = file;
        return key;
    };
    XFile.prototype._loadPackageRelationFiles = function (filesData) {
        if (!filesData) {
            return;
        }
        var relationships = this._getRelationshipsByBaseName(this.fileName, filesData);
        if (relationships) {
            for (var i = 0, len = relationships.length; i < len; i++) {
                var item = relationships[i];
                var fileName = item.target;
                var HYPERLINK = 'hyperlink';
                var isHyperlink = item.type.substring(item.type.length - HYPERLINK.length, item.type.length) === HYPERLINK;
                if (!isHyperlink) {
                    if (fileName[0] !== '/') {
                        fileName = common_1.Util._joinPath(this.fileName, fileName);
                    }
                    else {
                        fileName = fileName.substr(1);
                    }
                }
                var relationFile = new XFile(fileName, item.type);
                relationFile.targetMode = item.targetMode;
                relationFile._loadPackageRelationFiles(filesData);
                if (!this.relationFiles[item.id]) {
                    this.relationFiles.count++;
                }
                this.relationFiles[item.id] = relationFile;
            }
        }
    };
    XFile.prototype._getRelationshipsByBaseName = function (baseName, filesData) {
        if (baseName === null || !filesData) {
            return null;
        }
        var relationshipName = this._getRelationshipsNameByBaseName(baseName);
        if (!relationshipName) {
            return null;
        }
        return this._readRelationships(filesData[relationshipName.toLowerCase()]);
    };
    XFile.prototype._getRelationshipsNameByBaseName = function (baseName) {
        if (baseName === null || baseName === undefined) {
            return '';
        }
        if (baseName.length === 0) {
            return exports.XFileConstants._relationshipFileFolder + '/.' + exports.XFileConstants._relsExtension;
        }
        return baseName.substring(baseName.charAt(0) === '/' ? 1 : 0, baseName.lastIndexOf('/')) +
            '/' + exports.XFileConstants._relationshipFileFolder +
            '/' + baseName.substring(baseName.lastIndexOf('/') + 1) +
            '.' + exports.XFileConstants._relsExtension;
    };
    XFile.prototype._getFileByType = function (type) {
        if (!this.relationFiles || this.relationFiles.count === 0) {
            return null;
        }
        if (common_1.StringEx._isNullOrEmpty(type)) {
            return null;
        }
        for (var key in this.relationFiles) {
            if (key !== 'count') {
                var relationFile = this.relationFiles[key];
                if (relationFile.fileType === type) {
                    return relationFile;
                }
            }
        }
        return null;
    };
    XFile.prototype._getFilesByType = function (type) {
        if (!this.relationFiles || this.relationFiles.count === 0) {
            return null;
        }
        if (common_1.StringEx._isNullOrEmpty(type)) {
            return null;
        }
        var files = [];
        for (var key in this.relationFiles) {
            if (key !== 'count') {
                var relationFile = this.relationFiles[key];
                if (relationFile.fileType === type) {
                    files.push({
                        id: key,
                        file: relationFile
                    });
                }
            }
        }
        return files;
    };
    XFile.prototype._getFileByRelationID = function (id) {
        if (!this.relationFiles || this.relationFiles.count === 0 || common_1.StringEx._isNullOrWhiteSpace(id)) {
            return null;
        }
        return this.relationFiles[id];
    };
    XFile.prototype._readRelationships = function (dataString) {
        if (!dataString) {
            return;
        }
        var list = [];
        var obj = xml_parser_1.parseXmlToObject(dataString);
        var relationships = obj.Relationships;
        if (relationships) {
            var rels = relationships.Relationship;
            if (!Array.isArray(rels)) {
                rels = [rels];
            }
            for (var i = 0, len = rels.length; i < len; i++) {
                var rel = rels[i];
                if (rel) {
                    var r = new Relationship();
                    if (rel._attr.Id) {
                        r.id = rel._attr.Id;
                    }
                    if (rel._attr.Target) {
                        r.target = rel._attr.Target;
                    }
                    if (rel._attr.Type) {
                        r.type = rel._attr.Type;
                    }
                    if (rel._attr.TargetMode) {
                        r.targetMode = rel._attr.TargetMode;
                    }
                    list.push(r);
                }
            }
        }
        return list;
    };
    return XFile;
}());
exports.XFile = XFile;
exports.PivotSharedItemType = {
    B: 'b',
    D: 'd',
    E: 'e',
    M: 'm',
    N: 'n',
    S: 's',
    X: 'x'
};
/***/ }),

/***/ './src/common/range-parser.ts':
/*!************************************!*\
  !*** ./src/common/range-parser.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });
var common_1 = __webpack_require__(/*! ./common */ './src/common/common.ts');
var excel_types_1 = __webpack_require__(/*! ./../common/excel-types */ './src/common/excel-types.ts');
function getRangesFromString(sqref, keepOriginalLayout) {
    var result = [];
    if (sqref === null) {
        return result;
    }
    var ranges = sqref.replace(/('.+')/g, '').split(' ');
    ranges.forEach(function (range) {
        var tempRange = getRange(range, keepOriginalLayout);
        if (!tempRange || tempRange.row > excel_types_1.ExcelConstants._openXmlMaxRow || tempRange.col > excel_types_1.ExcelConstants._openXmlMaxColumn
            || tempRange.rowCount > excel_types_1.ExcelConstants._openXmlMaxRow || tempRange.col > excel_types_1.ExcelConstants._openXmlMaxColumn) {
            return;
        }
        result.push(tempRange);
    });
    return result;
}
exports.getRangesFromString = getRangesFromString;
function getRange(sqref, keepOriginalLayout) {
    var range = {};
    var index = sqref.indexOf('!');
    if (index > -1) {
        sqref = sqref.substr(index + 1);
    }
    var qref = sqref.split('$').join('');
    qref = qref.split(':');
    var row, column, row2, column2, leftQref, rightQref;
    if (qref.length === 1) {
        leftQref = qref[0];
        row = common_1.IndexHelper._getRowIndexInNumber(leftQref);
        column = common_1.IndexHelper._getColumnIndexInNumber(leftQref);
        if (row === -1 && column === -1) {
            return null;
        }
        range.row = row;
        range.col = column;
        range.rowCount = 1;
        range.colCount = 1;
    }
    else if (qref.length === 2) {
        leftQref = qref[0];
        rightQref = qref[1];
        row = common_1.IndexHelper._getRowIndexInNumber(leftQref);
        column = common_1.IndexHelper._getColumnIndexInNumber(leftQref);
        row2 = common_1.IndexHelper._getRowIndexInNumber(rightQref);
        column2 = common_1.IndexHelper._getColumnIndexInNumber(rightQref);
        range.row = row;
        range.col = column;
        range.rowCount = (row2 - row + 1);
        range.colCount = (column2 - column + 1);
        if (!keepOriginalLayout && row === 0 && range.rowCount === excel_types_1.ExcelConstants._openXmlMaxRow) {
            range.row = -1;
            range.rowCount = -1;
        }
        if (!keepOriginalLayout && column === 0 && range.colCount === excel_types_1.ExcelConstants._openXmlMaxColumn) {
            range.col = -1;
            range.colCount = -1;
        }
    }
    return range;
}
function getRangeString(ranges) {
    var rangeStrList = [];
    for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (common_1.isRangeWholeRow(range)) {
            range.col = 0;
            range.colCount = excel_types_1.ExcelConstants._openXmlMaxColumn;
        }
        if (common_1.isRangeWholeColumn(range)) {
            range.row = 0;
            range.rowCount = excel_types_1.ExcelConstants._openXmlMaxRow;
        }
        var firstRow = range.row;
        var lastRow = range.row + range.rowCount - 1;
        var firstCol = range.col;
        var lastCol = range.col + range.colCount - 1;
        var rangeStr = common_1.IndexHelper._getColumnIndexInA1Letter(firstCol) + (firstRow + 1);
        if (range.rowCount > 1 || range.colCount > 1) {
            rangeStr += (':' + common_1.IndexHelper._getColumnIndexInA1Letter(lastCol) + (lastRow + 1));
        }
        rangeStrList.push(rangeStr);
    }
    return rangeStrList.join(' ');
}
exports.getRangeString = getRangeString;
/***/ }),

/***/ './src/common/tuple.ts':
/*!*****************************!*\
  !*** ./src/common/tuple.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });
var Tuple = /** @class */ (function () {
    function Tuple() {
        var arg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arg[_i] = arguments[_i];
        }
        this.equals = function (other) {
            for (var i = 1, len = this.count; i <= len; i++) {
                var currentItem = this['item' + i], otherItem = other['item' + i];
                if ((currentItem.equals && currentItem.equals(otherItem)) || currentItem === otherItem) {
                    continue;
                }
                else {
                    return false;
                }
            }
            return true;
        };
        var len = arg.length;
        for (var i = 1; i <= len; i++) {
            this['item' + i] = arg[i - 1];
        }
        this.count = len;
    }
    return Tuple;
}());
exports.Tuple = Tuple;
/***/ }),

/***/ './src/datamodel/chart-model.ts':
/*!**************************************!*\
  !*** ./src/datamodel/chart-model.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });
var keyword_undefined = void 0;
function generateEnumObject(enumObj) {
    for (var prop in enumObj) {
        if (enumObj[prop] !== keyword_undefined) {
            enumObj[enumObj[prop]] = prop;
        }
    }
}
exports.Charts = {};
var ST_FontCollectionIndex = {
    major: 0,
    minor: 1,
    none: 2
};
generateEnumObject(ST_FontCollectionIndex);
exports.Charts.ST_FontCollectionIndex = ST_FontCollectionIndex;
var ST_ColorSchemeIndex = {
    dk1: 0,
    lt1: 1,
    dk2: 2,
    lt2: 3,
    accent1: 4,
    accent2: 5,
    accent3: 6,
    accent4: 7,
    accent5: 8,
    accent6: 9,
    hlink: 10,
    folHlink: 11
};
generateEnumObject(ST_ColorSchemeIndex);
exports.Charts.ST_ColorSchemeIndex = ST_ColorSchemeIndex;
var ST_SystemColorVal = {
    scrollBar: 0,
    background: 1,
    activeCaption: 2,
    inactiveCaption: 3,
    menu: 4,
    window: 5,
    windowFrame: 6,
    menuText: 7,
    windowText: 8,
    captionText: 9,
    activeBorder: 10,
    inactiveBorder: 11,
    appWorkspace: 12,
    highlight: 13,
    highlightText: 14,
    btnFace: 15,
    btnShadow: 16,
    grayText: 17,
    btnText: 18,
    inactiveCaptionText: 19,
    btnHighlight: 20,
    Item3dDkShadow: 21,
    Item3dLight: 22,
    infoText: 23,
    infoBk: 24,
    hotLight: 25,
    gradientActiveCaption: 26,
    gradientInactiveCaption: 27,
    menuHighlight: 28,
    menuBar: 29
};
generateEnumObject(ST_SystemColorVal);
exports.Charts.ST_SystemColorVal = ST_SystemColorVal;
var ST_SchemeColorVal = {
    bg1: 0,
    tx1: 1,
    bg2: 2,
    tx2: 3,
    accent1: 4,
    accent2: 5,
    accent3: 6,
    accent4: 7,
    accent5: 8,
    accent6: 9,
    hlink: 10,
    folHlink: 11,
    phClr: 12,
    dk1: 13,
    lt1: 14,
    dk2: 15,
    lt2: 16
};
generateEnumObject(ST_SchemeColorVal);
exports.Charts.ST_SchemeColorVal = ST_SchemeColorVal;
var ST_PresetColorVal = {
    aliceBlue: 0,
    antiqueWhite: 1,
    aqua: 2,
    aquamarine: 3,
    azure: 4,
    beige: 5,
    bisque: 6,
    black: 7,
    blanchedAlmond: 8,
    blue: 9,
    blueViolet: 10,
    brown: 11,
    burlyWood: 12,
    cadetBlue: 13,
    chartreuse: 14,
    chocolate: 15,
    coral: 16,
    cornflowerBlue: 17,
    cornsilk: 18,
    crimson: 19,
    cyan: 20,
    darkBlue: 21,
    darkCyan: 22,
    darkGoldenrod: 23,
    darkGray: 24,
    darkGreen: 25,
    darkGrey: 26,
    darkKhaki: 27,
    darkMagenta: 28,
    darkOliveGreen: 29,
    darkOrange: 30,
    darkOrchid: 31,
    darkRed: 32,
    darkSalmon: 33,
    darkSeaGreen: 34,
    darkSlateBlue: 35,
    darkSlateGray: 36,
    darkSlateGrey: 37,
    darkTurquoise: 38,
    darkViolet: 39,
    deepPink: 40,
    deepSkyBlue: 41,
    dimGray: 42,
    dimGrey: 43,
    dkBlue: 44,
    dkCyan: 45,
    dkGoldenrod: 46,
    dkGray: 47,
    dkGreen: 48,
    dkGrey: 49,
    dkKhaki: 50,
    dkMagenta: 51,
    dkOliveGreen: 52,
    dkOrange: 53,
    dkOrchid: 54,
    dkRed: 55,
    dkSalmon: 56,
    dkSeaGreen: 57,
    dkSlateBlue: 58,
    dkSlateGray: 59,
    dkSlateGrey: 60,
    dkTurquoise: 61,
    dkViolet: 62,
    dodgerBlue: 63,
    firebrick: 64,
    floralWhite: 65,
    forestGreen: 66,
    fuchsia: 67,
    gainsboro: 68,
    ghostWhite: 69,
    gold: 70,
    goldenrod: 71,
    gray: 72,
    green: 73,
    greenYellow: 74,
    grey: 75,
    honeydew: 76,
    hotPink: 77,
    indianRed: 78,
    indigo: 79,
    ivory: 80,
    khaki: 81,
    lavender: 82,
    lavenderBlush: 83,
    lawnGreen: 84,
    lemonChiffon: 85,
    lightBlue: 86,
    lightCoral: 87,
    lightCyan: 88,
    lightGoldenrodYellow: 89,
    lightGray: 90,
    lightGreen: 91,
    lightGrey: 92,
    lightPink: 93,
    lightSalmon: 94,
    lightSeaGreen: 95,
    lightSkyBlue: 96,
    lightSlateGray: 97,
    lightSlateGrey: 98,
    lightSteelBlue: 99,
    lightYellow: 100,
    lime: 101,
    limeGreen: 102,
    linen: 103,
    ltBlue: 104,
    ltCoral: 105,
    ltCyan: 106,
    ltGoldenrodYellow: 107,
    ltGray: 108,
    ltGreen: 109,
    ltGrey: 110,
    ltPink: 111,
    ltSalmon: 112,
    ltSeaGreen: 113,
    ltSkyBlue: 114,
    ltSlateGray: 115,
    ltSlateGrey: 116,
    ltSteelBlue: 117,
    ltYellow: 118,
    magenta: 119,
    maroon: 120,
    medAquamarine: 121,
    medBlue: 122,
    mediumAquamarine: 123,
    mediumBlue: 124,
    mediumOrchid: 125,
    mediumPurple: 126,
    mediumSeaGreen: 127,
    mediumSlateBlue: 128,
    mediumSpringGreen: 129,
    mediumTurquoise: 130,
    mediumVioletRed: 131,
    medOrchid: 132,
    medPurple: 133,
    medSeaGreen: 134,
    medSlateBlue: 135,
    medSpringGreen: 136,
    medTurquoise: 137,
    medVioletRed: 138,
    midnightBlue: 139,
    mintCream: 140,
    mistyRose: 141,
    moccasin: 142,
    navajoWhite: 143,
    navy: 144,
    oldLace: 145,
    olive: 146,
    oliveDrab: 147,
    orange: 148,
    orangeRed: 149,
    orchid: 150,
    paleGoldenrod: 151,
    paleGreen: 152,
    paleTurquoise: 153,
    paleVioletRed: 154,
    papayaWhip: 155,
    peachPuff: 156,
    peru: 157,
    pink: 158,
    plum: 159,
    powderBlue: 160,
    purple: 161,
    red: 162,
    rosyBrown: 163,
    royalBlue: 164,
    saddleBrown: 165,
    salmon: 166,
    sandyBrown: 167,
    seaGreen: 168,
    seaShell: 169,
    sienna: 170,
    silver: 171,
    skyBlue: 172,
    slateBlue: 173,
    slateGray: 174,
    slateGrey: 175,
    snow: 176,
    springGreen: 177,
    steelBlue: 178,
    tan: 179,
    teal: 180,
    thistle: 181,
    tomato: 182,
    turquoise: 183,
    violet: 184,
    wheat: 185,
    white: 186,
    whiteSmoke: 187,
    yellow: 188,
    yellowGreen: 189
};
generateEnumObject(ST_PresetColorVal);
exports.Charts.ST_PresetColorVal = ST_PresetColorVal;
var ST_RectAlignment = {
    tl: 0,
    t: 1,
    tr: 2,
    l: 3,
    ctr: 4,
    r: 5,
    bl: 6,
    b: 7,
    br: 8
};
generateEnumObject(ST_RectAlignment);
exports.Charts.ST_RectAlignment = ST_RectAlignment;
var ST_BlackWhiteMode = {
    clr: 0,
    auto: 1,
    gray: 2,
    ltGray: 3,
    invGray: 4,
    grayWhite: 5,
    blackGray: 6,
    blackWhite: 7,
    black: 8,
    white: 9,
    hidden: 10
};
generateEnumObject(ST_BlackWhiteMode);
exports.Charts.ST_BlackWhiteMode = ST_BlackWhiteMode;
var ST_LayoutTarget = {
    inner: 0,
    outer: 1
};
generateEnumObject(ST_LayoutTarget);
exports.Charts.ST_LayoutTarget = ST_LayoutTarget;
var ST_LayoutMode = {
    edge: 0,
    factor: 1
};
generateEnumObject(ST_LayoutMode);
exports.Charts.ST_LayoutMode = ST_LayoutMode;
var ST_SizeRepresents = {
    area: 0,
    w: 1
};
generateEnumObject(ST_SizeRepresents);
exports.Charts.ST_SizeRepresents = ST_SizeRepresents;
var ST_SplitType = {
    auto: 0,
    cust: 1,
    percent: 2,
    pos: 3,
    val: 4
};
generateEnumObject(ST_SplitType);
exports.Charts.ST_SplitType = ST_SplitType;
var ST_LblAlgn = {
    ctr: 0,
    l: 1,
    r: 2
};
generateEnumObject(ST_LblAlgn);
exports.Charts.ST_LblAlgn = ST_LblAlgn;
var ST_DLblPos = {
    bestFit: 0,
    b: 1,
    ctr: 2,
    inBase: 3,
    inEnd: 4,
    l: 5,
    outEnd: 6,
    r: 7,
    t: 8
};
generateEnumObject(ST_DLblPos);
exports.Charts.ST_DLblPos = ST_DLblPos;
var ST_MarkerStyle = {
    circle: 0,
    dash: 1,
    diamond: 2,
    dot: 3,
    none: 4,
    picture: 5,
    plus: 6,
    square: 7,
    star: 8,
    triangle: 9,
    x: 10
};
generateEnumObject(ST_MarkerStyle);
exports.Charts.ST_MarkerStyle = ST_MarkerStyle;
var ST_TrendlineType = {
    exp: 0,
    linear: 1,
    log: 2,
    movingAvg: 3,
    poly: 4,
    power: 5
};
generateEnumObject(ST_TrendlineType);
exports.Charts.ST_TrendlineType = ST_TrendlineType;
var ST_ErrDir = {
    x: 0,
    y: 1
};
generateEnumObject(ST_ErrDir);
exports.Charts.ST_ErrDir = ST_ErrDir;
var ST_ErrBarType = {
    both: 0,
    minus: 1,
    plus: 2
};
generateEnumObject(ST_ErrBarType);
exports.Charts.ST_ErrBarType = ST_ErrBarType;
var ST_ErrValType = {
    cust: 0,
    fixedVal: 1,
    percentage: 2,
    stdDev: 3,
    stdErr: 4
};
generateEnumObject(ST_ErrValType);
exports.Charts.ST_ErrValType = ST_ErrValType;
var ST_Grouping = {
    percentStacked: 0,
    standard: 1,
    stacked: 2
};
generateEnumObject(ST_Grouping);
exports.Charts.ST_Grouping = ST_Grouping;
var ST_ScatterStyle = {
    none: 0,
    line: 1,
    lineMarker: 2,
    marker: 3,
    smooth: 4,
    smoothMarker: 5
};
generateEnumObject(ST_ScatterStyle);
exports.Charts.ST_ScatterStyle = ST_ScatterStyle;
var ST_RadarStyle = {
    standard: 0,
    marker: 1,
    filled: 2
};
generateEnumObject(ST_RadarStyle);
exports.Charts.ST_RadarStyle = ST_RadarStyle;
var ST_BarGrouping = {
    percentStacked: 0,
    clustered: 1,
    standard: 2,
    stacked: 3
};
generateEnumObject(ST_BarGrouping);
exports.Charts.ST_BarGrouping = ST_BarGrouping;
var ST_BarDir = {
    bar: 0,
    col: 1
};
generateEnumObject(ST_BarDir);
exports.Charts.ST_BarDir = ST_BarDir;
var ST_Shape = {
    cone: 0,
    coneToMax: 1,
    box: 2,
    cylinder: 3,
    pyramid: 4,
    pyramidToMax: 5
};
generateEnumObject(ST_Shape);
exports.Charts.ST_Shape = ST_Shape;
var ST_OfPieType = {
    pie: 0,
    bar: 1
};
generateEnumObject(ST_OfPieType);
exports.Charts.ST_OfPieType = ST_OfPieType;
var ST_AxPos = {
    b: 0,
    l: 1,
    r: 2,
    t: 3
};
generateEnumObject(ST_AxPos);
exports.Charts.ST_AxPos = ST_AxPos;
var ST_Crosses = {
    autoZero: 0,
    max: 1,
    min: 2
};
generateEnumObject(ST_Crosses);
exports.Charts.ST_Crosses = ST_Crosses;
var ST_CrossBetween = {
    between: 0,
    midCat: 1
};
generateEnumObject(ST_CrossBetween);
exports.Charts.ST_CrossBetween = ST_CrossBetween;
var ST_TickMark = {
    cross: 0,
    in: 1,
    none: 2,
    out: 3
};
generateEnumObject(ST_TickMark);
exports.Charts.ST_TickMark = ST_TickMark;
var ST_TickLblPos = {
    high: 0,
    low: 1,
    nextTo: 2,
    none: 3
};
generateEnumObject(ST_TickLblPos);
exports.Charts.ST_TickLblPos = ST_TickLblPos;
var ST_TimeUnit = {
    days: 0,
    months: 1,
    years: 2
};
generateEnumObject(ST_TimeUnit);
exports.Charts.ST_TimeUnit = ST_TimeUnit;
var ST_BuiltInUnit = {
    hundreds: 0,
    thousands: 1,
    tenThousands: 2,
    hundredThousands: 3,
    millions: 4,
    tenMillions: 5,
    hundredMillions: 6,
    billions: 7,
    trillions: 8
};
generateEnumObject(ST_BuiltInUnit);
exports.Charts.ST_BuiltInUnit = ST_BuiltInUnit;
var ST_PictureFormat = {
    stretch: 0,
    stack: 1,
    stackScale: 2
};
generateEnumObject(ST_PictureFormat);
exports.Charts.ST_PictureFormat = ST_PictureFormat;
var ST_Orientation = {
    maxMin: 0,
    minMax: 1
};
generateEnumObject(ST_Orientation);
exports.Charts.ST_Orientation = ST_Orientation;
var ST_LegendPos = {
    b: 0,
    tr: 1,
    l: 2,
    r: 3,
    t: 4
};
generateEnumObject(ST_LegendPos);
exports.Charts.ST_LegendPos = ST_LegendPos;
var ST_DispBlanksAs = {
    span: 0,
    gap: 1,
    zero: 2
};
generateEnumObject(ST_DispBlanksAs);
exports.Charts.ST_DispBlanksAs = ST_DispBlanksAs;
var ST_PageSetupOrientation = {
    default: 0,
    portrait: 1,
    landscape: 2
};
generateEnumObject(ST_PageSetupOrientation);
exports.Charts.ST_PageSetupOrientation = ST_PageSetupOrientation;
var ST_PresetCameraType = {
    legacyObliqueTopLeft: 0,
    legacyObliqueTop: 1,
    legacyObliqueTopRight: 2,
    legacyObliqueLeft: 3,
    legacyObliqueFront: 4,
    legacyObliqueRight: 5,
    legacyObliqueBottomLeft: 6,
    legacyObliqueBottom: 7,
    legacyObliqueBottomRight: 8,
    legacyPerspectiveTopLeft: 9,
    legacyPerspectiveTop: 10,
    legacyPerspectiveTopRight: 11,
    legacyPerspectiveLeft: 12,
    legacyPerspectiveFront: 13,
    legacyPerspectiveRight: 14,
    legacyPerspectiveBottomLeft: 15,
    legacyPerspectiveBottom: 16,
    legacyPerspectiveBottomRight: 17,
    orthographicFront: 18,
    isometricTopUp: 19,
    isometricTopDown: 20,
    isometricBottomUp: 21,
    isometricBottomDown: 22,
    isometricLeftUp: 23,
    isometricLeftDown: 24,
    isometricRightUp: 25,
    isometricRightDown: 26,
    isometricOffAxis1Left: 27,
    isometricOffAxis1Right: 28,
    isometricOffAxis1Top: 29,
    isometricOffAxis2Left: 30,
    isometricOffAxis2Right: 31,
    isometricOffAxis2Top: 32,
    isometricOffAxis3Left: 33,
    isometricOffAxis3Right: 34,
    isometricOffAxis3Bottom: 35,
    isometricOffAxis4Left: 36,
    isometricOffAxis4Right: 37,
    isometricOffAxis4Bottom: 38,
    obliqueTopLeft: 39,
    obliqueTop: 40,
    obliqueTopRight: 41,
    obliqueLeft: 42,
    obliqueRight: 43,
    obliqueBottomLeft: 44,
    obliqueBottom: 45,
    obliqueBottomRight: 46,
    perspectiveFront: 47,
    perspectiveLeft: 48,
    perspectiveRight: 49,
    perspectiveAbove: 50,
    perspectiveBelow: 51,
    perspectiveAboveLeftFacing: 52,
    perspectiveAboveRightFacing: 53,
    perspectiveContrastingLeftFacing: 54,
    perspectiveContrastingRightFacing: 55,
    perspectiveHeroicLeftFacing: 56,
    perspectiveHeroicRightFacing: 57,
    perspectiveHeroicExtremeLeftFacing: 58,
    perspectiveHeroicExtremeRightFacing: 59,
    perspectiveRelaxed: 60,
    perspectiveRelaxedModerately: 61
};
generateEnumObject(ST_PresetCameraType);
exports.Charts.ST_PresetCameraType = ST_PresetCameraType;
var ST_LightRigDirection = {
    tl: 0,
    t: 1,
    tr: 2,
    l: 3,
    r: 4,
    bl: 5,
    b: 6,
    br: 7
};
generateEnumObject(ST_LightRigDirection);
exports.Charts.ST_LightRigDirection = ST_LightRigDirection;
var ST_LightRigType = {
    legacyFlat1: 0,
    legacyFlat2: 1,
    legacyFlat3: 2,
    legacyFlat4: 3,
    legacyNormal1: 4,
    legacyNormal2: 5,
    legacyNormal3: 6,
    legacyNormal4: 7,
    legacyHarsh1: 8,
    legacyHarsh2: 9,
    legacyHarsh3: 10,
    legacyHarsh4: 11,
    threePt: 12,
    balanced: 13,
    soft: 14,
    harsh: 15,
    flood: 16,
    contrasting: 17,
    morning: 18,
    sunrise: 19,
    sunset: 20,
    chilly: 21,
    freezing: 22,
    flat: 23,
    twoPt: 24,
    glow: 25,
    brightRoom: 26
};
generateEnumObject(ST_LightRigType);
exports.Charts.ST_LightRigType = ST_LightRigType;
var ST_BevelPresetType = {
    relaxedInset: 0,
    circle: 1,
    slope: 2,
    cross: 3,
    angle: 4,
    softRound: 5,
    convex: 6,
    coolSlant: 7,
    divot: 8,
    riblet: 9,
    hardEdge: 10,
    artDeco: 11
};
generateEnumObject(ST_BevelPresetType);
exports.Charts.ST_BevelPresetType = ST_BevelPresetType;
var ST_PresetMaterialType = {
    legacyMatte: 0,
    legacyPlastic: 1,
    legacyMetal: 2,
    legacyWireframe: 3,
    matte: 4,
    plastic: 5,
    metal: 6,
    warmMatte: 7,
    translucentPowder: 8,
    powder: 9,
    dkEdge: 10,
    softEdge: 11,
    clear: 12,
    flat: 13,
    softmetal: 14
};
generateEnumObject(ST_PresetMaterialType);
exports.Charts.ST_PresetMaterialType = ST_PresetMaterialType;
var ST_PresetShadowVal = {
    shdw1: 0,
    shdw2: 1,
    shdw3: 2,
    shdw4: 3,
    shdw5: 4,
    shdw6: 5,
    shdw7: 6,
    shdw8: 7,
    shdw9: 8,
    shdw10: 9,
    shdw11: 10,
    shdw12: 11,
    shdw13: 12,
    shdw14: 13,
    shdw15: 14,
    shdw16: 15,
    shdw17: 16,
    shdw18: 17,
    shdw19: 18,
    shdw20: 19
};
generateEnumObject(ST_PresetShadowVal);
exports.Charts.ST_PresetShadowVal = ST_PresetShadowVal;
var ST_PathShadeType = {
    shape: 0,
    circle: 1,
    rect: 2
};
generateEnumObject(ST_PathShadeType);
exports.Charts.ST_PathShadeType = ST_PathShadeType;
var ST_TileFlipMode = {
    none: 0,
    x: 1,
    y: 2,
    xy: 3
};
generateEnumObject(ST_TileFlipMode);
exports.Charts.ST_TileFlipMode = ST_TileFlipMode;
var ST_BlipCompression = {
    email: 0,
    screen: 1,
    print: 2,
    hqprint: 3,
    none: 4
};
generateEnumObject(ST_BlipCompression);
exports.Charts.ST_BlipCompression = ST_BlipCompression;
var ST_PresetPatternVal = {
    pct5: 0,
    pct10: 1,
    pct20: 2,
    pct25: 3,
    pct30: 4,
    pct40: 5,
    pct50: 6,
    pct60: 7,
    pct70: 8,
    pct75: 9,
    pct80: 10,
    pct90: 11,
    horz: 12,
    vert: 13,
    ltHorz: 14,
    ltVert: 15,
    dkHorz: 16,
    dkVert: 17,
    narHorz: 18,
    narVert: 19,
    dashHorz: 20,
    dashVert: 21,
    cross: 22,
    dnDiag: 23,
    upDiag: 24,
    ltDnDiag: 25,
    ltUpDiag: 26,
    dkDnDiag: 27,
    dkUpDiag: 28,
    wdDnDiag: 29,
    wdUpDiag: 30,
    dashDnDiag: 31,
    dashUpDiag: 32,
    diagCross: 33,
    smCheck: 34,
    lgCheck: 35,
    smGrid: 36,
    lgGrid: 37,
    dotGrid: 38,
    smConfetti: 39,
    lgConfetti: 40,
    horzBrick: 41,
    diagBrick: 42,
    solidDmnd: 43,
    openDmnd: 44,
    dotDmnd: 45,
    plaid: 46,
    sphere: 47,
    weave: 48,
    divot: 49,
    shingle: 50,
    wave: 51,
    trellis: 52,
    zigZag: 53
};
generateEnumObject(ST_PresetPatternVal);
exports.Charts.ST_PresetPatternVal = ST_PresetPatternVal;
var ST_BobType = {
    png: 0,
    jpg: 1,
    jpeg: 2,
    emf: 3
};
generateEnumObject(ST_BobType);
exports.Charts.ST_BobType = ST_BobType;
var ST_BlendMode = {
    over: 0,
    mult: 1,
    screen: 2,
    darken: 3,
    lighten: 4
};
generateEnumObject(ST_BlendMode);
exports.Charts.ST_BlendMode = ST_BlendMode;
var ST_EffectContainerType = {
    sib: 0,
    tree: 1
};
generateEnumObject(ST_EffectContainerType);
exports.Charts.ST_EffectContainerType = ST_EffectContainerType;
exports.Charts.ST_PathToType = {
    PathLine: 0,
    PathMove: 1,
    PathQuadBez: 2,
    PathCubicBez: 3
};
var ST_ShapeType = {
    line: 0,
    lineInv: 1,
    triangle: 2,
    rtTriangle: 3,
    rect: 4,
    diamond: 5,
    parallelogram: 6,
    trapezoid: 7,
    nonIsoscelesTrapezoid: 8,
    pentagon: 9,
    hexagon: 10,
    heptagon: 11,
    octagon: 12,
    decagon: 13,
    dodecagon: 14,
    star4: 15,
    star5: 16,
    star6: 17,
    star7: 18,
    star8: 19,
    star10: 20,
    star12: 21,
    star16: 22,
    star24: 23,
    star32: 24,
    roundRect: 25,
    round1Rect: 26,
    round2SameRect: 27,
    round2DiagRect: 28,
    snipRoundRect: 29,
    snip1Rect: 30,
    snip2SameRect: 31,
    snip2DiagRect: 32,
    plaque: 33,
    ellipse: 34,
    teardrop: 35,
    homePlate: 36,
    chevron: 37,
    pieWedge: 38,
    pie: 39,
    blockArc: 40,
    donut: 41,
    noSmoking: 42,
    rightArrow: 43,
    leftArrow: 44,
    upArrow: 45,
    downArrow: 46,
    stripedRightArrow: 47,
    notchedRightArrow: 48,
    bentUpArrow: 49,
    leftRightArrow: 50,
    upDownArrow: 51,
    leftUpArrow: 52,
    leftRightUpArrow: 53,
    quadArrow: 54,
    leftArrowCallout: 55,
    rightArrowCallout: 56,
    upArrowCallout: 57,
    downArrowCallout: 58,
    leftRightArrowCallout: 59,
    upDownArrowCallout: 60,
    quadArrowCallout: 61,
    bentArrow: 62,
    uturnArrow: 63,
    circularArrow: 64,
    leftCircularArrow: 65,
    leftRightCircularArrow: 66,
    curvedRightArrow: 67,
    curvedLeftArrow: 68,
    curvedUpArrow: 69,
    curvedDownArrow: 70,
    swooshArrow: 71,
    cube: 72,
    can: 73,
    lightningBolt: 74,
    heart: 75,
    sun: 76,
    moon: 77,
    smileyFace: 78,
    irregularSeal1: 79,
    irregularSeal2: 80,
    foldedCorner: 81,
    bevel: 82,
    frame: 83,
    halfFrame: 84,
    corner: 85,
    diagStripe: 86,
    chord: 87,
    arc: 88,
    leftBracket: 89,
    rightBracket: 90,
    leftBrace: 91,
    rightBrace: 92,
    bracketPair: 93,
    bracePair: 94,
    straightConnector1: 95,
    bentConnector2: 96,
    bentConnector3: 97,
    bentConnector4: 98,
    bentConnector5: 99,
    curvedConnector2: 100,
    curvedConnector3: 101,
    curvedConnector4: 102,
    curvedConnector5: 103,
    callout1: 104,
    callout2: 105,
    callout3: 106,
    accentCallout1: 107,
    accentCallout2: 108,
    accentCallout3: 109,
    borderCallout1: 110,
    borderCallout2: 111,
    borderCallout3: 112,
    accentBorderCallout1: 113,
    accentBorderCallout2: 114,
    accentBorderCallout3: 115,
    wedgeRectCallout: 116,
    wedgeRoundRectCallout: 117,
    wedgeEllipseCallout: 118,
    cloudCallout: 119,
    cloud: 120,
    ribbon: 121,
    ribbon2: 122,
    ellipseRibbon: 123,
    ellipseRibbon2: 124,
    leftRightRibbon: 125,
    verticalScroll: 126,
    horizontalScroll: 127,
    wave: 128,
    doubleWave: 129,
    plus: 130,
    flowChartProcess: 131,
    flowChartDecision: 132,
    flowChartInputOutput: 133,
    flowChartPredefinedProcess: 134,
    flowChartInternalStorage: 135,
    flowChartDocument: 136,
    flowChartMultidocument: 137,
    flowChartTerminator: 138,
    flowChartPreparation: 139,
    flowChartManualInput: 140,
    flowChartManualOperation: 141,
    flowChartConnector: 142,
    flowChartPunchedCard: 143,
    flowChartPunchedTape: 144,
    flowChartSummingJunction: 145,
    flowChartOr: 146,
    flowChartCollate: 147,
    flowChartSort: 148,
    flowChartExtract: 149,
    flowChartMerge: 150,
    flowChartOfflineStorage: 151,
    flowChartOnlineStorage: 152,
    flowChartMagneticTape: 153,
    flowChartMagneticDisk: 154,
    flowChartMagneticDrum: 155,
    flowChartDisplay: 156,
    flowChartDelay: 157,
    flowChartAlternateProcess: 158,
    flowChartOffpageConnector: 159,
    actionButtonBlank: 160,
    actionButtonHome: 161,
    actionButtonHelp: 162,
    actionButtonInformation: 163,
    actionButtonForwardNext: 164,
    actionButtonBackPrevious: 165,
    actionButtonEnd: 166,
    actionButtonBeginning: 167,
    actionButtonReturn: 168,
    actionButtonDocument: 169,
    actionButtonSound: 170,
    actionButtonMovie: 171,
    gear6: 172,
    gear9: 173,
    funnel: 174,
    mathPlus: 175,
    mathMinus: 176,
    mathMultiply: 177,
    mathDivide: 178,
    mathEqual: 179,
    mathNotEqual: 180,
    cornerTabs: 181,
    squareTabs: 182,
    plaqueTabs: 183,
    chartX: 184,
    chartStar: 185,
    chartPlus: 186
};
generateEnumObject(ST_ShapeType);
exports.Charts.ST_ShapeType = ST_ShapeType;
var ST_TextShapeType = {
    textNoShape: 0,
    textPlain: 1,
    textStop: 2,
    textTriangle: 3,
    textTriangleInverted: 4,
    textChevron: 5,
    textChevronInverted: 6,
    textRingInside: 7,
    textRingOutside: 8,
    textArchUp: 9,
    textArchDown: 10,
    textCircle: 11,
    textButton: 12,
    textArchUpPour: 13,
    textArchDownPour: 14,
    textCirclePour: 15,
    textButtonPour: 16,
    textCurveUp: 17,
    textCurveDown: 18,
    textCanUp: 19,
    textCanDown: 20,
    textWave1: 21,
    textWave2: 22,
    textDoubleWave1: 23,
    textWave4: 24,
    textInflate: 25,
    textDeflate: 26,
    textInflateBottom: 27,
    textDeflateBottom: 28,
    textInflateTop: 29,
    textDeflateTop: 30,
    textDeflateInflate: 31,
    textDeflateInflateDeflate: 32,
    textFadeRight: 33,
    textFadeLeft: 34,
    textFadeUp: 35,
    textFadeDown: 36,
    textSlantUp: 37,
    textSlantDown: 38,
    textCascadeUp: 39,
    textCascadeDown: 40
};
generateEnumObject(ST_TextShapeType);
exports.Charts.ST_TextShapeType = ST_TextShapeType;
var ST_PathFillMode = {
    none: 0,
    norm: 1,
    lighten: 2,
    lightenLess: 3,
    darken: 4,
    darkenLess: 5
};
generateEnumObject(ST_PathFillMode);
exports.Charts.ST_PathFillMode = ST_PathFillMode;
var ST_LineEndType = {
    none: 0,
    triangle: 1,
    stealth: 2,
    diamond: 3,
    oval: 4,
    arrow: 5
};
generateEnumObject(ST_LineEndType);
exports.Charts.ST_LineEndType = ST_LineEndType;
var ST_LineEndWidth = {
    sm: 0,
    med: 1,
    lg: 2
};
generateEnumObject(ST_LineEndWidth);
exports.Charts.ST_LineEndWidth = ST_LineEndWidth;
var ST_LineEndLength = {
    sm: 0,
    med: 1,
    lg: 2
};
generateEnumObject(ST_LineEndLength);
exports.Charts.ST_LineEndLength = ST_LineEndLength;
var ST_PresetLineDashVal = {
    solid: 0,
    dot: 1,
    dash: 2,
    lgDash: 3,
    dashDot: 4,
    lgDashDot: 5,
    lgDashDotDot: 6,
    sysDash: 7,
    sysDot: 8,
    sysDashDot: 9,
    sysDashDotDot: 10
};
generateEnumObject(ST_PresetLineDashVal);
exports.Charts.ST_PresetLineDashVal = ST_PresetLineDashVal;
var ST_LineCap = {
    rnd: 0,
    sq: 1,
    flat: 2
};
generateEnumObject(ST_LineCap);
exports.Charts.ST_LineCap = ST_LineCap;
var ST_PenAlignment = {
    ctr: 0,
    in: 1
};
generateEnumObject(ST_PenAlignment);
exports.Charts.ST_PenAlignment = ST_PenAlignment;
var ST_CompoundLine = {
    sng: 0,
    dbl: 1,
    thickThin: 2,
    thinThick: 3,
    tri: 4
};
generateEnumObject(ST_CompoundLine);
exports.Charts.ST_CompoundLine = ST_CompoundLine;
var ST_EditAs = {
    twoCell: 0,
    oneCell: 1,
    absolute: 2
};
generateEnumObject(ST_EditAs);
exports.Charts.ST_EditAs = ST_EditAs;
var ST_TextAnchoringType = {
    t: 0,
    ctr: 1,
    b: 2,
    just: 3,
    dist: 4
};
generateEnumObject(ST_TextAnchoringType);
exports.Charts.ST_TextAnchoringType = ST_TextAnchoringType;
var ST_TextVertOverflowType = {
    overflow: 0,
    ellipsis: 1,
    clip: 2
};
generateEnumObject(ST_TextVertOverflowType);
exports.Charts.ST_TextVertOverflowType = ST_TextVertOverflowType;
var ST_TextHorzOverflowType = {
    overflow: 0,
    clip: 1
};
generateEnumObject(ST_TextHorzOverflowType);
exports.Charts.ST_TextHorzOverflowType = ST_TextHorzOverflowType;
var ST_TextVerticalType = {
    horz: 0,
    vert: 1,
    vert270: 2,
    wordArtVert: 3,
    eaVert: 4,
    mongolianVert: 5,
    wordArtVertRtl: 6
};
generateEnumObject(ST_TextVerticalType);
exports.Charts.ST_TextVerticalType = ST_TextVerticalType;
var ST_TextWrappingType = {
    none: 0,
    square: 1
};
generateEnumObject(ST_TextWrappingType);
exports.Charts.ST_TextWrappingType = ST_TextWrappingType;
var ST_TextAutonumberScheme = {
    alphaLcParenBoth: 0,
    alphaUcParenBoth: 1,
    alphaLcParenR: 2,
    alphaUcParenR: 3,
    alphaLcPeriod: 4,
    alphaUcPeriod: 5,
    arabicParenBoth: 6,
    arabicParenR: 7,
    arabicPeriod: 8,
    arabicPlain: 9,
    romanLcParenBoth: 10,
    romanUcParenBoth: 11,
    romanLcParenR: 12,
    romanUcParenR: 13,
    romanLcPeriod: 14,
    romanUcPeriod: 15,
    circleNumDbPlain: 16,
    circleNumWdBlackPlain: 17,
    circleNumWdWhitePlain: 18,
    arabicDbPeriod: 19,
    arabicDbPlain: 20,
    ea1ChsPeriod: 21,
    ea1ChsPlain: 22,
    ea1ChtPeriod: 23,
    ea1ChtPlain: 24,
    ea1JpnChsDbPeriod: 25,
    ea1JpnKorPlain: 26,
    ea1JpnKorPeriod: 27,
    arabic1Minus: 28,
    arabic2Minus: 29,
    hebrew2Minus: 30,
    thaiAlphaPeriod: 31,
    thaiAlphaParenR: 32,
    thaiAlphaParenBoth: 33,
    thaiNumPeriod: 34,
    thaiNumParenR: 35,
    thaiNumParenBoth: 36,
    hindiAlphaPeriod: 37,
    hindiNumPeriod: 38,
    hindiNumParenR: 39,
    hindiAlpha1Period: 40
};
generateEnumObject(ST_TextAutonumberScheme);
exports.Charts.ST_TextAutonumberScheme = ST_TextAutonumberScheme;
var ST_TextUnderlineType = {
    none: 0,
    words: 1,
    sng: 2,
    dbl: 3,
    heavy: 4,
    dotted: 5,
    dottedHeavy: 6,
    dash: 7,
    dashHeavy: 8,
    dashLong: 9,
    dashLongHeavy: 10,
    dotDash: 11,
    dotDashHeavy: 12,
    dotDotDash: 13,
    dotDotDashHeavy: 14,
    wavy: 15,
    wavyHeavy: 16,
    wavyDbl: 17
};
generateEnumObject(ST_TextUnderlineType);
exports.Charts.ST_TextUnderlineType = ST_TextUnderlineType;
var ST_TextStrikeType = {
    noStrike: 0,
    sngStrike: 1,
    dblStrike: 2
};
generateEnumObject(ST_TextStrikeType);
exports.Charts.ST_TextStrikeType = ST_TextStrikeType;
var ST_TextCapsType = {
    none: 0,
    small: 1,
    all: 2
};
generateEnumObject(ST_TextCapsType);
exports.Charts.ST_TextCapsType = ST_TextCapsType;
var ST_TextTabAlignType = {
    l: 0,
    ctr: 1,
    r: 2,
    dec: 3
};
generateEnumObject(ST_TextTabAlignType);
exports.Charts.ST_TextTabAlignType = ST_TextTabAlignType;
var ST_TextAlignType = {
    l: 0,
    ctr: 1,
    r: 2,
    just: 3,
    justLow: 4,
    dist: 5,
    thaiDist: 6
};
generateEnumObject(ST_TextAlignType);
exports.Charts.ST_TextAlignType = ST_TextAlignType;
var ST_TextFontAlignType = {
    auto: 0,
    t: 1,
    ctr: 2,
    base: 3,
    b: 4
};
generateEnumObject(ST_TextFontAlignType);
exports.Charts.ST_TextFontAlignType = ST_TextFontAlignType;
var ST_StyleColorVal = {
    auto: 0
};
generateEnumObject(ST_StyleColorVal);
exports.Charts.ST_StyleColorVal = ST_StyleColorVal;
exports.Charts.CT_PathType = {
    CT_PathToList: 0,
    CT_Path2DArcTo: 1,
    CT_Path2DClose: 2
};
var ST_FormulaDirection = {
    col: 0,
    row: 1
};
generateEnumObject(ST_FormulaDirection);
exports.Charts.ST_FormulaDirection = ST_FormulaDirection;
var ST_StringDimensionType = {
    cat: 0,
    colorStr: 1
};
generateEnumObject(ST_StringDimensionType);
exports.Charts.ST_StringDimensionType = ST_StringDimensionType;
var ST_NumericDimensionType = {
    val: 0,
    x: 1,
    y: 2,
    size: 3,
    colorVal: 4
};
generateEnumObject(ST_NumericDimensionType);
exports.Charts.ST_NumericDimensionType = ST_NumericDimensionType;
var ST_SidePos = {
    l: 0,
    t: 1,
    r: 2,
    b: 3
};
generateEnumObject(ST_SidePos);
exports.Charts.ST_SidePos = ST_SidePos;
var ST_2016ChartPosLegend = {
    t: 1,
    r: 2,
    l: 3,
    b: 4
};
generateEnumObject(ST_2016ChartPosLegend);
exports.Charts.ST_2016ChartPosLegend = ST_2016ChartPosLegend;
var ST_PosAlign = {
    min: 0,
    ctr: 1,
    max: 2
};
generateEnumObject(ST_PosAlign);
exports.Charts.ST_PosAlign = ST_PosAlign;
var ST_AxisUnit = {
    hundreds: 0,
    thousands: 1,
    tenThousands: 2,
    hundredThousands: 3,
    millions: 4,
    tenMillions: 5,
    hundredMillions: 6,
    billions: 7,
    trillions: 8,
    percentage: 9
};
generateEnumObject(ST_AxisUnit);
exports.Charts.ST_AxisUnit = ST_AxisUnit;
var ST_TickMarksType = {
    in: 1,
    out: 3,
    cross: 0,
    none: 2
};
generateEnumObject(ST_TickMarksType);
exports.Charts.ST_TickMarksType = ST_TickMarksType;
var ST_SeriesLayout = {
    boxWhisker: 0,
    funnel: 1,
    paretoLine: 2,
    regionMap: 3,
    sunburst: 4,
    treemap: 5,
    waterfall: 6,
    clusteredColumn: 7
};
generateEnumObject(ST_SeriesLayout);
exports.Charts.ST_SeriesLayout = ST_SeriesLayout;
var ST_ParentLabelLayout = {
    none: 0,
    banner: 1,
    overlapping: 2
};
generateEnumObject(ST_ParentLabelLayout);
exports.Charts.ST_ParentLabelLayout = ST_ParentLabelLayout;
var ST_RegionLabelLayout = {
    none: 0,
    bestFitOnly: 1,
    showAll: 2
};
generateEnumObject(ST_RegionLabelLayout);
exports.Charts.ST_RegionLabelLayout = ST_RegionLabelLayout;
var ST_IntervalClosedSide = {
    l: 0,
    r: 1
};
generateEnumObject(ST_IntervalClosedSide);
exports.Charts.ST_IntervalClosedSide = ST_IntervalClosedSide;
var ST_EntityType = {
    Address: 0,
    AdminDistrict: 1,
    AdminDistrict2: 2,
    AdminDistrict3: 3,
    Continent: 4,
    CountryRegion: 5,
    Locality: 6,
    Ocean: 7,
    Planet: 8,
    PostalCode: 9,
    Region: 10,
    Unsupported: 11
};
generateEnumObject(ST_EntityType);
exports.Charts.ST_EntityType = ST_EntityType;
var ST_GeoProjectionType = {
    mercator: 0,
    miller: 1,
    robinson: 2,
    albers: 3
};
generateEnumObject(ST_GeoProjectionType);
exports.Charts.ST_GeoProjectionType = ST_GeoProjectionType;
var ST_GeoMappingLevel = {
    dataOnly: 0,
    postalCode: 1,
    county: 2,
    state: 3,
    countryRegion: 4,
    countryRegionList: 5,
    world: 6
};
generateEnumObject(ST_GeoMappingLevel);
exports.Charts.ST_GeoMappingLevel = ST_GeoMappingLevel;
var ST_QuartileMethod = {
    inclusive: 0,
    exclusive: 1
};
generateEnumObject(ST_QuartileMethod);
exports.Charts.ST_QuartileMethod = ST_QuartileMethod;
var ST_DataLabelPos = {
    bestFit: 0,
    b: 1,
    ctr: 2,
    inBase: 3,
    inEnd: 4,
    l: 5,
    outEnd: 6,
    r: 7,
    t: 8
};
generateEnumObject(ST_DataLabelPos);
exports.Charts.ST_DataLabelPos = ST_DataLabelPos;
var ST_PageOrientation = {
    default: 0,
    portrait: 1,
    landscape: 2
};
generateEnumObject(ST_PageOrientation);
exports.Charts.ST_PageOrientation = ST_PageOrientation;
/***/ }),

/***/ './src/datamodel/datamodel-reader.ts':
/*!*******************************************!*\
  !*** ./src/datamodel/datamodel-reader.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });
var common_1 = __webpack_require__(/*! ./../common/common */ './src/common/common.ts');
var excel_types_1 = __webpack_require__(/*! ./../common/excel-types */ './src/common/excel-types.ts');
var excel_style_1 = __webpack_require__(/*! ./excel-style */ './src/datamodel/excel-style.ts');
var excel_helper_1 = __webpack_require__(/*! ./excel-helper */ './src/datamodel/excel-helper.ts');
var datetime_helper_1 = __webpack_require__(/*! ./datetime-helper */ './src/datamodel/datetime-helper.ts');
var range_parser_1 = __webpack_require__(/*! ./../common/range-parser */ './src/common/range-parser.ts');
var node_helper_1 = __webpack_require__(/*! ./../xml-io/node-helper */ './src/xml-io/node-helper.ts');
var isNullOrWhiteSpace = common_1.StringEx._isNullOrWhiteSpace;
var convertDxfToStyle = excel_style_1.ConverterHelper.convertDxfToStyle;
var getAsArray = node_helper_1.XmlNodeHelper._getAsArray;
var keyword_null = null, keyword_undefined = void 0, CONST_NORMAL = 'Normal';
function modifyOutlineCollapsed(outlines, index, outlineLevel, summaryFlag, hidden, previousHidden) {
    var itemsData = outlines.itemsData;
    if (!itemsData) {
        return;
    }
    var lastItemData = itemsData[itemsData.length - 1];
    var lastSecondItemData = itemsData[itemsData.length - 2];
    var lastItemDataInfo = lastItemData && lastItemData.info;
    var lastSecondItemdataInfo = lastSecondItemData && lastSecondItemData.info;
    if (!lastItemDataInfo) {
        return;
    }
    if (summaryFlag && hidden && lastItemData.count === 1) {
        if (lastSecondItemdataInfo && lastSecondItemData.index === lastItemData.index - 1 && lastSecondItemdataInfo.level === lastItemDataInfo.level - 1) {
            lastSecondItemdataInfo.collapsed = true;
        }
        else if (index > 0) {
            itemsData.splice(itemsData.length - 2, 0, {
                index: lastItemData.index - 1,
                count: 1,
                info: {
                    level: lastItemDataInfo.level - 1,
                    collapsed: true
                }
            });
        }
        else {
            outlines.head = {
                collapsed: true,
                level: outlineLevel - 1
            };
        }
    }
    else if (!summaryFlag && previousHidden) {
        if (lastSecondItemdataInfo && lastItemData.index === lastSecondItemData.index + 1 && lastItemDataInfo.level === lastSecondItemdataInfo.level - 1) {
            lastItemData.collapsed = true;
        }
        else if (index >= lastItemData.index + lastItemData.count) {
            itemsData.push({
                index: lastItemData.index + lastItemData.count,
                count: 1,
                info: {
                    level: lastItemDataInfo.level - 1,
                    collapsed: true
                }
            });
        }
    }
}
function createCondition(conType, compareType, expected, ignoreBlank, type, isPercent, item1, item2, ranges, expectTypeId) {
    var condition = {};
    condition.conType = conType;
    if (!common_1._isNullOrUndefined(compareType)) {
        condition.compareType = compareType;
    }
    if (!common_1._isNullOrUndefined(expected)) {
        condition.expected = expected;
    }
    if (!common_1._isNullOrUndefined(ignoreBlank)) {
        condition.ignoreBlank = ignoreBlank;
    }
    if (!common_1._isNullOrUndefined(type)) {
        condition.type = type;
    }
    if (!common_1._isNullOrUndefined(isPercent)) {
        condition.isPercent = isPercent;
    }
    if (!common_1._isNullOrUndefined(item1)) {
        condition.item1 = item1;
    }
    if (!common_1._isNullOrUndefined(item2)) {
        condition.item2 = item2;
    }
    if (!common_1._isNullOrUndefined(ranges)) {
        condition.ranges = ranges;
    }
    if (!common_1._isNullOrUndefined(expectTypeId)) {
        condition.expectTypeId = expectTypeId;
    }
    if (conType === 2) {
        condition.ignoreCase = true;
    }
    return condition;
}
function createColorFilterCondition(colorFilter, conditionColor) {
    var compareType = colorFilter.cellColor ? 0 : 1, fill = conditionColor.fill, color;
    if (fill) {
        if (fill.patternType === 0) {
            color = '';
        }
        else {
            var style = {};
            excel_style_1.ConverterHelper._setStyleInfoFill(fill, style);
            color = style.backColor;
        }
    }
    return createCondition(3, compareType, color);
}
function getAutoFilterRangeType(rangeData) {
    if (rangeData.length > 0) {
        var data = rangeData[0];
        if (typeof data === 'number') {
            return 'number';
        }
        else if (typeof data === 'string' && data.indexOf('/OADate(') === 0 && data.indexOf(')') === data.length - 2) {
            return 'date';
        }
        else if (typeof data === 'boolean') {
            return 'boolean';
        }
    }
    return '';
}
function createConditionByCellValue(dataType, operator, value) {
    var conType;
    var ComparisonOperators = {
        none: 0,
        equal: 0,
        lessThan: 4,
        lessThanOrEqual: 5,
        notEqual: 1,
        greaterThan: 2,
        greaterThanOrEqual: 3
    };
    switch (dataType) {
        case 'string':
            conType = 2;
            break;
        case 'number':
            conType = 1;
            value = parseFloat(value);
            break;
        case 'date':
            conType = 5;
            if (typeof value === 'string' && value.indexOf('/OADate(') === 0) {
                var dataNumber = parseInt(value.replace('/OADate(', ''), 10);
                value = datetime_helper_1.DateTimeHelper._fromOADate(dataNumber);
            }
            else {
                value = datetime_helper_1.DateTimeHelper._fromOADate(parseInt(value, 10));
            }
            ComparisonOperators = {
                none: 0,
                equal: 0,
                lessThan: 2,
                lessThanOrEqual: 3,
                notEqual: 1,
                greaterThan: 4,
                greaterThanOrEqual: 5
            };
            break;
        case 'boolean':
        default:
            conType = 11;
            break;
    }
    return createCondition(conType, ComparisonOperators[operator || true], value);
}
function createCustomFilterCondition(customFilters, rangeData) {
    function identifyTextAndCellValueCondition(customFilter) {
        var retCondition, op, isNotEqual = customFilter.operator === 'notEqual';
        var value = customFilter.value;
        var startIndex = value.indexOf('*'), endIndex = value.lastIndexOf('*');
        if (startIndex !== -1) {
            if (startIndex === value.length - 1 && startIndex !== 0) {
                op = isNotEqual ? 3 : 2;
                retCondition = createCondition(2, op, value.substring(0, value.length - 1));
            }
            else if (startIndex === 0 && startIndex === endIndex) {
                op = isNotEqual ? 5 : 4;
                retCondition = createCondition(2, op, value.substring(1));
            }
            else {
                var textCompareType = isNotEqual ? 7 : 6;
                if (startIndex !== -1 && endIndex !== -1) {
                    value = value.substr(1, value.length - 2);
                }
                retCondition = createCondition(2, textCompareType, value);
            }
        }
        else {
            var dataType = getAutoFilterRangeType(rangeData);
            retCondition = createConditionByCellValue(dataType, customFilter.operator, value);
        }
        return retCondition;
    }
    var condition;
    if (customFilters.filter1) {
        condition = identifyTextAndCellValueCondition(customFilters.filter1);
    }
    if (customFilters.filter2) {
        var relationType = customFilters.and ? 1 : 0;
        condition = createCondition(0, relationType, keyword_null, keyword_null, keyword_null, keyword_null, condition, identifyTextAndCellValueCondition(customFilters.filter2));
    }
    return condition;
}
function createPivotCustomFilterCondition(customFilters, typeInfos) {
    function identifyTextAndCellValueCondition(customFilter) {
        var retCondition;
        var value = customFilter.value;
        var startIndex = value.indexOf('*'), endIndex = value.lastIndexOf('*');
        if (startIndex !== -1) {
            if (startIndex === value.length - 1 && startIndex !== 0) {
                retCondition = createCondition(typeInfos.conType, typeInfos.compareType, value.substring(0, value.length - 1));
            }
            else if (startIndex === 0 && startIndex === endIndex) {
                retCondition = createCondition(typeInfos.conType, typeInfos.compareType, value.substring(1));
            }
            else {
                if (startIndex !== -1 && endIndex !== -1) {
                    value = value.substr(1, value.length - 2);
                }
                retCondition = createCondition(typeInfos.conType, typeInfos.compareType, value);
            }
        }
        else {
            if (!common_1._isNullOrUndefined(typeInfos)) {
                retCondition = createCondition(typeInfos.conType, typeInfos.compareType, value);
            }
        }
        return retCondition;
    }
    var condition;
    if (customFilters.filter1) {
        condition = identifyTextAndCellValueCondition(customFilters.filter1);
    }
    if (customFilters.filter2) {
        condition = createCondition(typeInfos.conType, typeInfos.compareType, keyword_null, keyword_null, keyword_null, keyword_null, condition, identifyTextAndCellValueCondition(customFilters.filter2));
    }
    else {
        condition = createCondition(typeInfos.conType, typeInfos.compareType, keyword_null, keyword_null, keyword_null, keyword_null, condition, keyword_null);
    }
    return condition;
}
function createDynamicFilterCondition(dynamicFilter, filterRange, columnId) {
    var condition;
    var range = new common_1.Range(filterRange.row, columnId, filterRange.rowCount, 1);
    var type = dynamicFilter.type;
    if (type === 100 || type === 101) {
        condition = createCondition(10, keyword_null, keyword_null, keyword_null, type - 100, keyword_null, keyword_null, keyword_null, range);
    }
    else if (type === 16) {
        condition = createCondition(6, keyword_null, 0, keyword_null, keyword_null, keyword_null, keyword_null, keyword_null, keyword_null, 6);
    }
    else if (type >= 17 && type <= 20) {
        condition = createCondition(6, keyword_null, type - 17, keyword_null, keyword_null, keyword_null, keyword_null, keyword_null, keyword_null, 2);
    }
    else if (type >= 21 && type <= 32) {
        condition = createCondition(6, keyword_null, type - 21, keyword_null, keyword_null, keyword_null, keyword_null, keyword_null, keyword_null, 3);
    }
    else if (type >= 0 && type <= 15) {
        condition = createCondition(6, keyword_null, type);
    }
    return condition;
}
function createPivotDynamicFilterCondition(dynamicFilter, typeInfos) {
    var condition;
    var conType = typeInfos.conType;
    if (conType === 1) {
        condition = createCondition(1, typeInfos.compareType, keyword_null);
    }
    return condition;
}
function createTop10FilterCondition(top10Filter) {
    var top10Type = top10Filter.top ? 0 : 1;
    return createCondition(8, keyword_null, top10Filter.value, keyword_null, top10Type, top10Filter.percent);
}
function createPivotTop10FilterCondition(top10Filter, typeInfos) {
    var top10Type = top10Filter.top ? 1 : -1;
    return createCondition(3, typeInfos.compareType, top10Filter.value, keyword_null, top10Type, top10Filter.percent);
}
function addFormulaPrefixSymbol(formula) {
    if (isNullOrWhiteSpace(formula)) {
        return formula;
    }
    return '=' + formula;
}
function addStringPrefixSymbol(formula) {
    if (isNullOrWhiteSpace(formula) || formula.length <= 2) {
        return formula;
    }
    return formula.substr(1, formula.length - 2);
}
function getTableName(tableId, tables) {
    var tableName = null;
    tables.forEach(function (table) {
        if (table.id === tableId) {
            tableName = table.name;
        }
    });
    return tableName;
}
function getTableColumnName(tableId, columnId, tables) {
    var columnName = null;
    tables.forEach(function (table) {
        if (table.id === tableId) {
            table.columns.forEach(function (column) {
                if (column.id === columnId) {
                    columnName = column.name;
                }
            });
        }
    });
    return columnName;
}
function getDataValidationRangesAsString(ranges, separator) {
    separator = separator || ' ';
    return ranges.map(getDataValidationRangeString).join(separator);
}
function getDataValidationRangeString(range) {
    var firstRow = range.row, firstCol = range.col;
    var rowCount = range.rowCount, colCount = range.colCount;
    var lastCol = firstCol + colCount - 1, lastRow = firstRow + rowCount - 1;
    var rangeStr;
    if (common_1.isRangeWholeRow(range) && common_1.isRangeWholeColumn(range)) {
        rangeStr = '$1:$' + excel_types_1.ExcelConstants._openXmlMaxRow;
    }
    else if (common_1.isRangeWholeRow(range)) {
        rangeStr = (firstRow + 1) + ':' + (lastRow + 1);
    }
    else if (common_1.isRangeWholeColumn(range)) {
        rangeStr = common_1.IndexHelper._getColumnIndexInA1Letter(firstCol) + ':' + common_1.IndexHelper._getColumnIndexInA1Letter(lastCol);
    }
    else {
        rangeStr = common_1.IndexHelper._getColumnIndexInA1Letter(firstCol) + (firstRow + 1);
        if (rowCount > 1 || colCount > 1) {
            rangeStr += (':' + common_1.IndexHelper._getColumnIndexInA1Letter(lastCol) + (lastRow + 1));
        }
    }
    return rangeStr;
}
var fmtThemeItemNames = ['fillStyleLst', 'lnStyleLst', 'effectStyleLst', 'bgFillStyleLst'];
var lineFormatPropertyNames = ['w', 'cap', 'cmpd', 'algn', 'prstDash', 'custDash', 'round', 'bevel', 'miter', 'headEnd', 'tailEnd'];
function composeLineProperties(src, target) {
    lineFormatPropertyNames.forEach(function (prop) {
        if (target[prop] === undefined && src[prop] !== undefined) {
            target[prop] = src[prop];
        }
    });
}
function composeLineStyle(refObj, lineFormat) {
    if (refObj) {
        composeLineProperties(refObj, lineFormat);
    }
}
function isExist(cache, styleName) {
    return !!cache[styleName];
}
function resetStyleInfoOfCellInTableRange(readerDataModel, spread, dataTable, row, col, cache) {
    var defaultStyle = readerDataModel._normalStyleInfo;
    if (dataTable[row] && dataTable[row][col]) {
        var styleInfo = dataTable[row][col].style;
        if (!styleInfo) {
            return;
        }
        var style = common_1._StyleHelper._getByName(spread.namedStyles, styleInfo);
        if (style) {
            var newStyle = excel_helper_1.processTableCellStyle(style, defaultStyle);
            newStyle.name = '__builtInTableStyle' + readerDataModel._builtInTableStylesCount + style.name;
            common_1._StyleHelper._addToNamedStyles(spread.namedStyles, readerDataModel._namedStylesNamesIndexImp, newStyle);
            readerDataModel._builtInTableStylesCount++;
            dataTable[row][col].style = newStyle.name;
            cache[styleInfo] = newStyle.name;
        }
    }
}
function getFutureMetadataByName(item, name) {
    var result = item.filter(function (i) {
        return i._attr.name === name;
    });
    return result && result[0];
}
function getBlockItem(parent, index) {
    var blocks = getAsArray(parent.bk);
    return blocks[index];
}
var ReaderDataModel = /** @class */ (function () {
    function ReaderDataModel() {
        var self = this;
        self._spread = { version: '14.2.5' };
        self._normalStyleInfo = keyword_null;
        self._defaultExcelExtendedFormat = keyword_null;
        self._cellStyleInfos = [];
        self._dateTimeFormatter = [];
        self._textFormatter = [];
        self._builtInStyleNames = [];
        self._builtInStyleLength = 1;
        self._builtInTableStylesCount = 0;
        self._builtInValidatorStylesCount = 0;
        self._normalStyleIndex = 0;
        self._styleNames = [];
        self._extendedFormats = [];
        self._extendedFormatsIdCaches = {};
        self._namedStylesExtendedFormats = {};
        self._initStyle = true;
        self._builtInStyles = keyword_null;
        self._styles = [];
        self._isDate1904 = false;
        self._activePaneType = 3;
        self._columnDataArray = [];
        self._rowDataArray = [];
        self._headingFont = 'Calibri Light';
        self._bodyFont = 'Calibri';
        self._dxfRecords = [];
        self._rowInfos = [];
        self._colInfos = [];
        self._namedStylesNamesIndexImp = {};
        self._verticalTextColumns = [];
    }
    ReaderDataModel.prototype._setThemeInfo = function (themeInfo) {
        this._themeInfo = themeInfo;
        this._fmtThemeItemCache = {};
    };
    ReaderDataModel.prototype._getFormatSchemeItem = function (listType, index) {
        var fmtThemeItemCache = this._fmtThemeItemCache, key = listType + ',' + index, cacheItem = fmtThemeItemCache[key];
        if (cacheItem) {
            return cacheItem;
        }
        var themeInfo = this._themeInfo, result, formatScheme = themeInfo && themeInfo.themeElements && themeInfo.themeElements.fmtScheme;
        if (formatScheme) {
            var name_1 = fmtThemeItemNames[listType];
            var item = name_1 && formatScheme[name_1];
            result = item;
            if (item) {
                if (listType === 1) {
                    item = item.ln;
                }
                else if (listType === 0) {
                    item = item.items;
                }
                result = item[index];
            }
        }
        fmtThemeItemCache[key] = result;
        return result;
    };
    ReaderDataModel.prototype._setTheme = function (theme) {
        if (!theme) {
            return;
        }
        var spreadJSTheme = { name: theme.name };
        if (theme.colorScheme) {
            var colorScheme = theme.colorScheme;
            spreadJSTheme.themeColor = {
                name: colorScheme.name,
                text1: colorScheme.schemeColors[1],
                text2: colorScheme.schemeColors[3],
                background1: colorScheme.schemeColors[0],
                background2: colorScheme.schemeColors[2],
                accent1: colorScheme.schemeColors[4],
                accent2: colorScheme.schemeColors[5],
                accent3: colorScheme.schemeColors[6],
                accent4: colorScheme.schemeColors[7],
                accent5: colorScheme.schemeColors[8],
                accent6: colorScheme.schemeColors[9],
                hyperlink: colorScheme.schemeColors[10],
                followedHyperlink: colorScheme.schemeColors[11]
            };
        }
        if (theme.fontScheme) {
            var fontScheme = theme.fontScheme;
            var majorRunFormattings = fontScheme.majorFont.runFormattings, minorRunFormattings = fontScheme.minorFont.runFormattings;
            for (var i = 0, len = majorRunFormattings.length; i < len; i++) {
                var runFormatting = majorRunFormattings[i];
                if (runFormatting && runFormatting.fontLanguage === 0) {
                    spreadJSTheme.headingFont = runFormatting.typeface;
                    this._headingFont = runFormatting.typeface;
                }
            }
            for (var i = 0, len = minorRunFormattings.length; i < len; i++) {
                var runFormatting = minorRunFormattings[i];
                if (runFormatting && runFormatting.fontLanguage === 0) {
                    spreadJSTheme.bodyFont = runFormatting.typeface;
                    this._bodyFont = runFormatting.typeface;
                }
            }
        }
        this._theme = spreadJSTheme;
    };
    ReaderDataModel.prototype._setExcelDefaultCellFormat = function (format) {
        if (!format) {
            return;
        }
        var self = this;
        self._normalStyleInfo = excel_style_1.ConverterHelper.toCellStyle(format, self._headingFont, self._bodyFont);
        var fontInfoForColumnWidth = {};
        excel_style_1.ConverterHelper.setStyleInfoFont(format.font, fontInfoForColumnWidth, keyword_undefined, keyword_undefined);
        self._normalStyleInfo.fontForColumnWidth = fontInfoForColumnWidth.font;
        self._defaultExcelExtendedFormat = format;
    };
    ReaderDataModel.prototype._setExcelCellFormat = function (format, index) {
        if (!format) {
            return;
        }
        var self = this, spread = self._spread;
        var styleInfo = excel_style_1.ConverterHelper.toCellStyle(format, self._headingFont, self._bodyFont);
        if (!common_1._isNullOrUndefined(styleInfo.formatter)) {
            var reg = new RegExp('\\[DBNum\\d+\\]', 'ig');
            var dbNumArray = void 0;
            var formatter = styleInfo.formatter;
            while ((dbNumArray = reg.exec(styleInfo.formatter)) !== null) {
                var dbStr = dbNumArray[0];
                var numType = parseInt(dbStr.substring(dbStr.indexOf('m') + 1, dbStr.indexOf(']')), 10);
                if (numType > 4 || (numType === 4 && (formatter.indexOf('[$-412]') < 0 && common_1._getCulture() !== 'ko-kr'))) {
                    formatter = formatter.replace(dbStr, '[DBNum3]');
                }
            }
            styleInfo.formatter = formatter;
        }
        self._cellStyleInfos.push(styleInfo);
        var formatCode = excel_style_1.ExtendedNumberFormatHelper.getFormatCode(format);
        self._dateTimeFormatter.push(datetime_helper_1.DateTimeHelper._isDatesOrTimesNumberFormat(formatCode));
        if (formatCode === '@') {
            self._textFormatter.push(true);
        }
        else {
            self._textFormatter.push(false);
        }
        if (format.isStyleFormat) {
            var styleIndex = self._getExtendedFormatIndex(index);
            if (styleIndex === -1) {
                styleIndex = self._normalStyleIndex;
            }
            if (self._styleNames.length > styleIndex) {
                self._builtInStyleNames[self._builtInStyleNames.length] = self._styleNames[styleIndex];
            }
            else {
                self._builtInStyleNames[self._builtInStyleNames.length] = '__builtInStyle' + self._builtInStyleLength++;
            }
        }
        else {
            var name_2 = '';
            if (format.parentFormatID !== keyword_undefined && self._builtInStyleNames.length > format.parentFormatID) {
                name_2 = self._builtInStyleNames[format.parentFormatID];
            }
            if (name_2 === CONST_NORMAL || name_2.substring(0, 14) === '__builtInStyle' || common_1.StringEx._isNullOrEmpty(name_2)) {
                name_2 = '__builtInStyle' + self._builtInStyleLength++;
            }
            styleInfo.name = name_2;
            var namedStyleExtendedFormat = void 0;
            if (!(name_2.substring(0, 14) === '__builtInStyle') && (namedStyleExtendedFormat = self._namedStylesExtendedFormats[name_2]) !== keyword_undefined && !format.equals(namedStyleExtendedFormat)) {
                styleInfo.parentName = name_2;
                name_2 = '__builtInStyle' + self._builtInStyleLength++;
                styleInfo.name = name_2;
            }
            if (!spread.namedStyles) {
                spread.namedStyles = [];
            }
            common_1._StyleHelper._addToNamedStyles(spread.namedStyles, self._namedStylesNamesIndexImp, styleInfo);
            self._builtInStyleNames[self._builtInStyleNames.length] = name_2;
        }
    };
    ReaderDataModel.prototype._getExtendedFormatIndex = function (index) {
        return this._extendedFormatsIdCaches[index] ? this._extendedFormatsIdCaches[index] : -1;
    };
    ReaderDataModel.prototype._setExcelStyle = function (style, id) {
        if (!style) {
            return;
        }
        var self = this, spread = self._spread;
        if (self._initStyle) {
            self._initExcelDefaultBuiltInStyles();
            self._initStyle = false;
        }
        var styleName = style.name, buildInStyles = self._builtInStyles;
        if (buildInStyles && style.isBuiltInStyle()) {
            for (var i = 0, len = buildInStyles.length; i < len; i++) {
                var item = buildInStyles[i];
                if (item.builtInStyle === style.builtInStyle) {
                    styleName = item.name;
                    break;
                }
            }
        }
        if (!common_1._StyleHelper._findName(self._namedStylesNamesIndexImp, styleName)) {
            self._namedStylesExtendedFormats[styleName] = style.format();
            self._styles.push(style);
            self._extendedFormats.push(style.format());
            self._extendedFormatsIdCaches[id] = self._extendedFormats.length - 1;
            self._styleNames.push(styleName);
            if (!spread.namedStyles) {
                spread.namedStyles = [];
            }
            var namedStyle = excel_style_1.ConverterHelper.toCellStyle(style.format(), self._headingFont, self._bodyFont);
            namedStyle.name = styleName;
            common_1._StyleHelper._addToNamedStyles(spread.namedStyles, self._namedStylesNamesIndexImp, namedStyle);
        }
        else {
            for (var i = 0, len = self._styles.length; i < len; i++) {
                var st = self._styles[i];
                if (st.name === styleName) {
                    self._styles[i] = style;
                    self._extendedFormats[i] = style.format();
                    self._extendedFormatsIdCaches[id] = i;
                    break;
                }
            }
            self._namedStylesExtendedFormats[styleName] = style.format();
            var namedStyle = excel_style_1.ConverterHelper.toCellStyle(style.format(), self._headingFont, self._bodyFont);
            namedStyle.name = styleName;
            common_1._StyleHelper._addToNamedStyles(spread.namedStyles, self._namedStylesNamesIndexImp, namedStyle);
        }
    };
    ReaderDataModel.prototype._initExcelDefaultBuiltInStyles = function () {
        var self = this, spread = self._spread;
        if (self._initStyle) {
            if (!spread.namedStyles) {
                spread.namedStyles = [];
            }
            self._builtInStyles = excel_style_1.BuiltInExcelStyles.getBuiltInStyles();
            for (var i = 0, len = self._builtInStyles.length; i < len; i++) {
                var item = self._builtInStyles[i];
                if (item && item.name === CONST_NORMAL) {
                    self._normalStyleIndex = self._extendedFormats.length;
                }
                self._styles.push(item);
                self._extendedFormats.push(item.format());
                self._styleNames.push(item.name);
                self._namedStylesExtendedFormats[item.name] = item.format();
                var namedStyle = excel_style_1.ConverterHelper.toCellStyle(item.format(), self._headingFont, self._bodyFont);
                namedStyle.name = item.name;
                common_1._StyleHelper._addToNamedStyles(spread.namedStyles, self._namedStylesNamesIndexImp, namedStyle);
            }
        }
    };
    ReaderDataModel.prototype._setExcelWorkbookProperty = function (workbookProperty) {
        this._isDate1904 = workbookProperty;
    };
    ReaderDataModel.prototype._setScroll = function (showHorizontalScrollbar, showVerticalScrollbar) {
        var spread = this._spread;
        if (!showHorizontalScrollbar) {
            spread.showHorizontalScrollbar = showHorizontalScrollbar;
        }
        if (!showVerticalScrollbar) {
            spread.showVerticalScrollbar = showVerticalScrollbar;
        }
    };
    ReaderDataModel.prototype._setTabs = function (showSheetTabs, activeTab, firstSheet, tabRatio) {
        var spread = this._spread;
        if (!showSheetTabs) {
            spread.tabStripVisible = showSheetTabs;
        }
        spread.startSheetIndex = firstSheet;
        spread.activeSheetIndex = activeTab;
        spread.tabStripRatio = tabRatio / 1000;
    };
    ReaderDataModel.prototype._addSheet = function (name, index, hidden) {
        var sheet = {}, spread = this._spread;
        sheet.name = name;
        sheet.index = index;
        if (hidden === 1 || hidden === 2) {
            sheet.visible = false;
        }
        sheet.allowCellOverflow = true;
        sheet.theme = this._theme;
        sheet.defaults = common_1._getSheetDefaults();
        if (common_1._isNullOrUndefined(spread.sheetCount)) {
            spread.sheetCount = 0;
        }
        spread.sheetCount++;
        if (!spread.sheets) {
            spread.sheets = {};
        }
        spread.sheets[name] = sheet;
    };
    ReaderDataModel.prototype._setCalculationProperty = function (isR1C1, iterativeCalculation) {
        var spread = this._spread;
        if (isR1C1) {
            spread.referenceStyle = 1;
            if (spread.sheets) {
                for (var item in spread.sheets) {
                    if (spread.sheets.hasOwnProperty(item)) {
                        var sheet = spread.sheets[item];
                        sheet.referenceStyle = 1;
                        sheet.colHeaderAutoText = 1;
                    }
                }
            }
        }
        spread.iterativeCalculation = iterativeCalculation.iterate === '1';
        spread.iterativeCalculationMaximumIterations = common_1._isNullOrUndefined(iterativeCalculation.count) ? 100 : parseInt(iterativeCalculation.count, 10);
        spread.iterativeCalculationMaximumChange = common_1._isNullOrUndefined(iterativeCalculation.delta) ? 0.001 : parseFloat(iterativeCalculation.delta);
    };
    ReaderDataModel.prototype._setOutlineDirection = function (sheetName, summaryRight, summaryBelow) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (summaryBelow === false) {
            if (!sheet.rowOutlines) {
                sheet.rowOutlines = {};
            }
            sheet.rowOutlines.direction = 0;
        }
        if (summaryRight === false) {
            if (!sheet.columnOutlines) {
                sheet.columnOutlines = {};
            }
            sheet.columnOutlines.direction = 0;
        }
    };
    ReaderDataModel.prototype._setSheetTabColor = function (sheetName, color) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (color !== excel_style_1.ExcelColor.EmptyColor) {
            if (color.isThemeColor()) {
                sheet.sheetTabColor = excel_style_1.ColorHelper.getThemeColorName(color);
            }
            else {
                sheet.sheetTabColor = excel_style_1.ColorHelper.toRGBColor(color);
            }
        }
    };
    ReaderDataModel.prototype._setDimensions = function (sheetName, rowCount, columnCount) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        sheet.rowCount = rowCount;
        sheet.columnCount = columnCount;
    };
    ReaderDataModel.prototype._setDisplayElements = function (sheetName, gridLineColor, showGridLine, showRowColHeaders, zoom, showFormulas, tabSelected) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (!showRowColHeaders) {
            sheet.rowHeaderVisible = showRowColHeaders;
            sheet.colHeaderVisible = showRowColHeaders;
        }
        if (showFormulas) {
            sheet.showFormulas = true;
        }
        if (zoom !== 100) {
            sheet.zoomFactor = zoom / 100;
        }
        if (gridLineColor && gridLineColor.isIndexedColor() && gridLineColor.value() === 64) {
            gridLineColor = null;
        }
        if (gridLineColor !== null || !showGridLine) {
            var gridline = {};
            if (gridLineColor !== null) {
                gridline.color = excel_style_1.ColorHelper.toRGBColor(gridLineColor).toString();
            }
            if (!showGridLine) {
                gridline.showVerticalGridline = showGridLine;
                gridline.showHorizontalGridline = showGridLine;
            }
            sheet.gridline = gridline;
        }
        sheet.isSelected = tabSelected;
    };
    ReaderDataModel.prototype._setSelection = function (sheetName, paneType, rowActive, columnActive, refCount, rowFirst, rowLast, colFirst, colLast) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (this._activePaneType === paneType) {
            if (sheet.rowCount <= rowActive) {
                sheet.rowCount = rowActive + 1;
            }
            if (sheet.columnCount <= columnActive) {
                sheet.columnCount = columnActive + 1;
            }
            for (var i = 0, len = rowFirst.length; i < len; i++) {
                var firstRow = rowFirst[i], lastRow = rowLast[i], firstCol = colFirst[i], lastCol = colLast[i];
                if (lastRow === -1) {
                    lastRow = sheet.rowCount - 1;
                }
                if (lastCol === -1) {
                    lastCol = sheet.columnCount - 1;
                }
                firstRow = firstRow >= 0 ? firstRow : 0;
                lastRow = lastRow >= 0 ? lastRow : 0;
                firstCol = firstCol >= 0 ? firstCol : 0;
                lastCol = lastCol >= 0 ? lastCol : 0;
                if (firstRow < sheet.rowCount && firstCol < sheet.columnCount) {
                    var rowCount = Math.min(sheet.rowCount - firstRow, lastRow - firstRow + 1);
                    var columnCount = Math.min(sheet.columnCount - firstCol, lastCol - firstCol + 1);
                    if (rowCount >= 1 && columnCount >= 1) {
                        sheet.selections = sheet.selections || {};
                        sheet.selections[i] = {
                            row: firstRow,
                            rowCount: rowCount,
                            col: firstCol,
                            colCount: columnCount
                        };
                    }
                }
            }
            if (sheet.selections) {
                sheet.selections.length = rowFirst.length;
            }
            sheet.activeRow = (rowActive >= 0 && rowActive < sheet.rowCount) ? rowActive : 0;
            sheet.activeCol = (columnActive >= 0 && columnActive < sheet.columnCount) ? columnActive : 0;
        }
    };
    ReaderDataModel.prototype._setPane = function (sheetName, xSplit, ySplit, topLeftCell, isFrozen) {
        if (isFrozen) {
            var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
            var _sheetViewTopLeftCell = this._sheetViewTopLeftCell;
            var topVisibleRow = common_1.IndexHelper._getRowIndexInNumber(_sheetViewTopLeftCell), topVisibleColumn = common_1.IndexHelper._getColumnIndexInNumber(_sheetViewTopLeftCell), row = common_1.IndexHelper._getRowIndexInNumber(topLeftCell), col = common_1.IndexHelper._getColumnIndexInNumber(topLeftCell);
            if (ySplit && xSplit) {
                this._setTopLeftCell(row, col, sheetName);
            }
            else if (ySplit && !xSplit) {
                this._setTopLeftCell(row, topVisibleColumn, sheetName);
            }
            else if (!ySplit && xSplit) {
                this._setTopLeftCell(topVisibleRow, col, sheetName);
            }
            if (ySplit) {
                var frozenRow = ySplit + topVisibleRow;
                if (sheet.rowCount <= frozenRow) {
                    sheet.rowCount = frozenRow + 1;
                }
                sheet.frozenRowCount = frozenRow;
            }
            if (xSplit) {
                var frozenColumn = xSplit + topVisibleColumn;
                if (sheet.columnCount <= frozenColumn) {
                    sheet.columnCount = frozenColumn + 1;
                }
                sheet.frozenColCount = frozenColumn;
            }
        }
    };
    ReaderDataModel.prototype._setDefaults = function (sheetName, defaultRowHeight, defaultColumnWidth) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        sheet.defaults = {
            colHeaderRowHeight: 20,
            rowHeaderColWidth: 40,
            rowHeight: defaultRowHeight,
            colWidth: defaultColumnWidth
        };
    };
    ReaderDataModel.prototype._setDefaultRowHeight = function (sheetName, defaultRowHeight) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        sheet.defaults.rowHeight = excel_style_1.UnitHelper.pointToPixel(defaultRowHeight);
    };
    ReaderDataModel.prototype._setDefaultColumnWidth = function (sheetName, baseColumnWidth, defaultColumnWidth) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var defaultWidth;
        if (isNaN(defaultColumnWidth)) {
            defaultWidth = this._getDefaultColumnWidthInPixel(baseColumnWidth);
            sheet.defaults._isExcelDefaultColumnWidth = true;
        }
        else {
            defaultWidth = this._getColumnWidthInPixel(defaultColumnWidth);
        }
        sheet.defaults.colWidth = defaultWidth;
    };
    ReaderDataModel.prototype._getDefaultColumnWidthInPixel = function (baseColumnWidth) {
        var defaultStyle = this._normalStyleInfo;
        var maxDigitWidth = this.getMaxiumDigitWidth(defaultStyle.fontForColumnWidth ? defaultStyle.fontForColumnWidth : defaultStyle.font);
        var margin = Math.ceil(maxDigitWidth / 4) * 2 + 1;
        var pixel = this._getColumnWidthInPixel(baseColumnWidth, maxDigitWidth) + margin;
        return Math.ceil(pixel / 8) * 8;
    };
    ReaderDataModel.prototype._getColumnWidthInPixel = function (width, maxDigitWidth) {
        if (width === 0.0) {
            return 0;
        }
        var defaultStyle = this._normalStyleInfo, defaultFont = defaultStyle.fontForColumnWidth ? defaultStyle.fontForColumnWidth : defaultStyle.font;
        return Math.floor((Math.floor(width * 256) / 256) * (!common_1._isNullOrUndefined(maxDigitWidth) ? maxDigitWidth : this.getMaxiumDigitWidth(defaultFont)) + 0.5);
    };
    ReaderDataModel.prototype.getMaxiumDigitWidth = function (font) {
        if (this._maxiumDigitWidth === keyword_undefined) {
            this._maxiumDigitWidth = excel_style_1.UnitHelper.getMaxiumDigitWidth(font);
        }
        return this._maxiumDigitWidth;
    };
    ReaderDataModel.prototype._setMissedRowColumnCount = function (sheetName) {
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var colCount = sheet.columnCount || 0;
        var rowCount = sheet.rowCount || 0;
        var lastColumn = self._lastReadColumn;
        var lastRow = self._lastReadRow;
        sheet.columnCount = Math.max(colCount, lastColumn + 1);
        sheet.rowCount = Math.max(rowCount, lastRow + 1);
    };
    ReaderDataModel.prototype._setColumnInfo = function (sheetName, colFirst, colLast, formatIndex, width, hidden, outlineLevel, collapsed) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName], summaryLeft = sheet.columnOutlines && sheet.columnOutlines.direction === 0, colInfos = this._colInfos;
        var actualWidth = this._getColumnWidthInPixel(width);
        var maxColumnCount = common_1._CalcHelper._maxColumnCount;
        if (colLast >= maxColumnCount - 1) {
            colLast = maxColumnCount - 1;
        }
        var invalidCollapsed = false;
        for (var column = colFirst; column <= colLast; column++) {
            var isHiddenOutlineItem = false;
            if (outlineLevel > 0 || collapsed) {
                if ((column + 2) > sheet.columnCount) {
                    var tempItems = sheet.columnOutlines && sheet.columnOutlines.items;
                    if (outlineLevel <= 0 && (!tempItems || !tempItems[column - 1] || tempItems[column - 1].level < 0)) {
                        invalidCollapsed = true;
                    }
                    if (!invalidCollapsed) {
                        sheet.columnCount = column + 2;
                    }
                }
                if (!invalidCollapsed) {
                    if (!sheet.columnOutlines) {
                        sheet.columnOutlines = {};
                    }
                    if (!sheet.columnOutlines.items) {
                        sheet.columnOutlines.items = [];
                    }
                    if (!sheet.columnOutlines.itemsData) {
                        sheet.columnOutlines.itemsData = [];
                    }
                    var items = sheet.columnOutlines.items;
                    items[column] = {
                        level: outlineLevel - 1,
                        collapsed: collapsed,
                        viewCollapsed: hidden
                    };
                    if (hidden) {
                        isHiddenOutlineItem = true;
                    }
                    var itemsData = sheet.columnOutlines.itemsData;
                    var itemData = itemsData[itemsData.length - 1];
                    if (itemData && column === itemData.index + itemData.count && itemData.info.level === outlineLevel - 1 && itemData.info.collapsed === collapsed) {
                        itemData.count++;
                    }
                    else {
                        itemsData.push({
                            index: column,
                            count: 1,
                            info: {
                                level: outlineLevel - 1,
                                collapsed: collapsed
                            }
                        });
                    }
                }
            }
            if (sheet.columnOutlines && sheet.columnOutlines.itemsData) {
                var columnOutlinesItemsData = sheet.columnOutlines.itemsData;
                modifyOutlineCollapsed(columnOutlinesItemsData, column, outlineLevel, summaryLeft, hidden, colInfos[column - 1] && colInfos[column - 1].hidden);
            }
            if (actualWidth !== -1 || hidden) {
                if (!sheet.columns) {
                    sheet.columns = [];
                }
                var columnLength = sheet.columns.length;
                for (var c = columnLength; c < column; c++) {
                    sheet.columns[c] = keyword_null;
                    colInfos[c] = keyword_null;
                }
                var colInfo = {};
                if (hidden && outlineLevel === 0) {
                    colInfo.visible = false;
                }
                if (actualWidth !== -1) {
                    colInfo.size = actualWidth;
                }
                if ((colInfo.visible === false || isHiddenOutlineItem === true) && colInfo.size === 0) {
                    colInfo.size = keyword_undefined;
                }
                colInfos[column] = colInfo;
                sheet.columns[column] = colInfo;
            }
            if (formatIndex !== 1) {
                var styleName = this._builtInStyleNames[formatIndex];
                if (styleName !== keyword_undefined) {
                    this._columnDataArray[column] = { style: styleName };
                }
                else if (formatIndex < this._cellStyleInfos.length) {
                    this._columnDataArray[column] = { style: this._cellStyleInfos[formatIndex] };
                }
                var cellStyleInfo = this._cellStyleInfos[formatIndex];
                if (cellStyleInfo && cellStyleInfo.isVerticalText === true) {
                    this._verticalTextColumns.push(column);
                }
            }
        }
        if (sheet.columnCount > maxColumnCount) {
            sheet.columnCount = maxColumnCount;
        }
    };
    ReaderDataModel.prototype._recheckRowColInfo = function (sheetName) {
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName], sheetDefault = sheet.defaults, sheetData = sheet.data;
        var sheetColumns = sheet.columns, sheetColumnCount = sheet.columnCount, defaultColumnWidth = sheetDefault.colWidth;
        if (sheetColumns) {
            var colLength = sheetColumns.length;
            if (sheetColumnCount < colLength && (sheetColumns[sheetColumnCount] && sheetColumns[sheetColumnCount].size === defaultColumnWidth)) {
                var newColumns = sheetColumns.slice(0, sheetColumnCount);
                self._colInfos = newColumns;
                sheet.columns = newColumns;
                if (sheetData && sheetData.columnDataArray) {
                    sheetData.columnDataArray = sheetData.columnDataArray.slice(0, sheetColumnCount);
                }
            }
        }
        var sheetRows = sheet.rows, sheetRowCount = sheet.rowCount, defaultRowHeight = sheetDefault.rowHeight;
        if (sheetRows) {
            var rowLength = sheetRows.length;
            if (sheetRowCount < rowLength && (sheetRows[sheetRowCount] && sheetRows[sheetRowCount].size === defaultRowHeight)) {
                var newRows = sheetRows.slice(0, sheetRowCount);
                self._rowInfos = newRows;
                sheet.rows = newRows;
                if (sheetData && sheetData.rowDataArray) {
                    sheetData.rowDataArray = sheetData.rowDataArray.slice(0, sheetRowCount);
                }
            }
        }
    };
    ReaderDataModel.prototype._setMergeCells = function (sheetName, startRow, endRow, startCol, endCol) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (!sheet.spans) {
            sheet.spans = [];
        }
        if (endRow >= sheet.rowCount) {
            endRow = sheet.rowCount - 1;
        }
        if (endCol >= sheet.columnCount) {
            endCol = sheet.columnCount - 1;
        }
        sheet.spans.push(new common_1.Range(startRow, startCol, endRow - startRow + 1, endCol - startCol + 1));
    };
    ReaderDataModel.prototype._setProtect = function (sheetName, isProtect) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        sheet.isProtected = isProtect;
    };
    ReaderDataModel.prototype._setProtectionOptions = function (sheetName, protectionOptions, isSheetProtect) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        sheet.protectionOptions = sheet.protectionOptions || {};
        for (var i = 0; i < protectionOptions.length; i++) {
            var name_3 = protectionOptions[i].name, value = protectionOptions[i].value;
            var protectionOptionsName = excel_helper_1.toProtectionOptions[name_3];
            if (protectionOptionsName) {
                sheet.protectionOptions[protectionOptionsName] = value;
            }
            else {
                sheet.protectionOptions[name_3] = value;
            }
        }
        if (isSheetProtect && sheet.protectionOptions.allowEditObjects === keyword_undefined) {
            sheet.protectionOptions.allowEditObjects = true;
        }
    };
    ReaderDataModel.prototype._setSheetData = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (!sheet.data) {
            sheet.data = {};
        }
        var data = sheet.data;
        if (this._rowDataArray.length > 0) {
            data.rowDataArray = this._rowDataArray;
            this._rowDataArray = [];
        }
        if (this._columnDataArray.length > 0) {
            data.columnDataArray = this._columnDataArray;
            this._columnDataArray = [];
        }
        if (this._normalStyleInfo) {
            data.defaultDataNode = { style: this._normalStyleInfo };
        }
        if (this._theme) {
            sheet.theme = this._theme;
        }
        this._setMissedRowColumnCount(sheetName);
    };
    ReaderDataModel.prototype._setRowInfo = function (sheetName, rowIndex, formatIndex, height, outlineLevel, collapsed, hidden) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName], summaryTop = sheet.rowOutlines && sheet.rowOutlines.direction === 0, rowInfos = this._rowInfos;
        if (outlineLevel > 0 || collapsed) {
            if ((rowIndex + 2) > sheet.rowCount) {
                sheet.rowCount = rowIndex + 2;
            }
            if (!sheet.rowOutlines) {
                sheet.rowOutlines = {};
            }
            if (!sheet.rowOutlines.items) {
                sheet.rowOutlines.items = [];
            }
            if (!sheet.rowOutlines.itemsData) {
                sheet.rowOutlines.itemsData = [];
            }
            var items = sheet.rowOutlines.items;
            items[rowIndex] = {
                level: outlineLevel - 1,
                collapsed: collapsed,
                viewCollapsed: hidden
            };
            var itemsData = sheet.rowOutlines.itemsData;
            var itemData = itemsData[itemsData.length - 1];
            if (itemData && rowIndex === itemData.index + itemData.count && itemData.info.level === outlineLevel - 1 && itemData.info.collapsed === collapsed) {
                itemData.count++;
            }
            else {
                itemsData.push({
                    index: rowIndex,
                    count: 1,
                    info: {
                        level: outlineLevel - 1,
                        collapsed: collapsed
                    }
                });
            }
        }
        var preRowHidden = rowInfos[rowIndex - 1] && rowInfos[rowIndex - 1].hidden;
        if (sheet.rowOutlines && sheet.rowOutlines.itemsData) {
            modifyOutlineCollapsed(sheet.rowOutlines, rowIndex, outlineLevel, summaryTop, hidden, preRowHidden);
        }
        if (outlineLevel <= 0 && (rowIndex + 1) > sheet.rowCount) {
            sheet.rowCount = rowIndex + 1;
        }
        if (formatIndex !== -1 && rowIndex < sheet.rowCount) {
            var styleName = this._builtInStyleNames[formatIndex];
            if (styleName !== keyword_undefined) {
                this._rowDataArray[rowIndex] = { style: styleName };
            }
            else if (formatIndex < this._cellStyleInfos.length) {
                this._rowDataArray[rowIndex] = { style: this._cellStyleInfos[formatIndex] };
            }
        }
        if (height !== -1 || hidden) {
            if (!sheet.rows) {
                sheet.rows = [];
            }
            for (var r = sheet.rows.length; r < rowIndex; r++) {
                sheet.rows.push(keyword_null);
                rowInfos.push(keyword_null);
            }
            var rowInfo = {};
            if (hidden && outlineLevel === 0) {
                rowInfo.visible = false;
            }
            if (height !== -1) {
                rowInfo.size = Math.round(excel_style_1.UnitHelper.pointToPixel(height));
            }
            if (rowInfo.visible === false && rowInfo.size === 0) {
                rowInfo.size = keyword_undefined;
            }
            rowInfos.push(rowInfo);
            sheet.rows.push(rowInfo);
        }
    };
    ReaderDataModel.prototype._initDataTable = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (!sheet.data) {
            sheet.data = {};
        }
        var data = sheet.data;
        if (!data.dataTable) {
            data.dataTable = {};
        }
    };
    ReaderDataModel.prototype._initRow = function (sheetName, rowIndex) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var dataTable = sheet.data.dataTable;
        if (!dataTable[rowIndex]) {
            dataTable[rowIndex] = {};
        }
    };
    ReaderDataModel.prototype._setCellStyle = function (sheetName, rowIndex, columnIndex, formatIndex) {
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var row = sheet.data.dataTable[rowIndex];
        if (!row[columnIndex]) {
            row[columnIndex] = {};
        }
        var cell = row[columnIndex];
        var styleName = self._builtInStyleNames[formatIndex];
        if (styleName !== keyword_undefined) {
            cell.style = styleName;
        }
        else if (formatIndex < self._cellStyleInfos.length) {
            cell.style = self._cellStyleInfos[formatIndex];
        }
        if (self._verticalTextColumns.indexOf(columnIndex) > -1) {
            var currentCellStyleInfo = self._cellStyleInfos[formatIndex];
            if (currentCellStyleInfo && common_1._isNullOrUndefined(currentCellStyleInfo.isVerticalText)) {
                self._cellStyleInfos[formatIndex].isVerticalText = false;
            }
        }
    };
    ReaderDataModel.prototype._setHyperlink = function (sheetName, rowIndex, columnIndex, hyperlinkInfo) {
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var row = sheet.data.dataTable[rowIndex];
        if (!row) {
            sheet.data.dataTable[rowIndex] = row = {};
        }
        if (!row[columnIndex]) {
            row[columnIndex] = {};
        }
        var cell = row[columnIndex];
        var style = cell.style;
        if (typeof style === 'string') {
            style = self._cellStyleInfos[self._builtInStyleNames.indexOf(cell.style)];
        }
        if (style && style.foreColor) {
            hyperlinkInfo.linkColor = style.foreColor;
        }
        cell.hyperlink = hyperlinkInfo;
    };
    ReaderDataModel.prototype._setCell = function (sheetName, rowIndex, columnIndex, formatIndex, value, formula, arrayFormula, richText) {
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var row = sheet.data.dataTable[rowIndex];
        if (!row[columnIndex]) {
            row[columnIndex] = {};
        }
        var cell = row[columnIndex];
        if (formatIndex < self._dateTimeFormatter.length && self._dateTimeFormatter[formatIndex] && typeof value === 'number') {
            value = self._convertToOADateString(value);
        }
        if (value !== undefined) {
            cell.value = value;
        }
        if (formula !== undefined) {
            cell.formula = formula;
        }
        if (arrayFormula) {
            cell.arrayInfo = arrayFormula;
        }
        if (richText) {
            var cellRichText = [];
            for (var i = 0; i < richText.length; i++) {
                if (richText[i].style) {
                    cellRichText.push({
                        style: excel_style_1.ConverterHelper.toRichTextStyle(richText[i].style, self._headingFont, self._bodyFont),
                        text: richText[i].text
                    });
                }
                else {
                    cellRichText.push(richText[i]);
                }
            }
            cell.value = {
                richText: cellRichText
            };
        }
    };
    ReaderDataModel.prototype._convertToOADateString = function (value) {
        if (this._isDate1904) {
            value += 1462;
        }
        value = datetime_helper_1.DateTimeHelper._fromOADate(value);
        if (value instanceof Date) {
            value = datetime_helper_1.DateTimeHelper._toOADate(value);
        }
        return datetime_helper_1.DateTimeHelper._addOADateString(value);
    };
    ReaderDataModel.prototype._setColorPalette = function (palette) {
        if (palette && palette.length > 0) {
            excel_style_1.ColorHelper.useCustomPalette = true;
            var customPalette = {};
            for (var i = 0, len = palette.length; i < len; i++) {
                customPalette[i] = excel_style_1.ColorHelper.fromArgb(palette[i]);
            }
            excel_style_1.ColorHelper.customPalette = customPalette;
        }
    };
    ReaderDataModel.prototype._resetActivePaneType = function () {
        this._activePaneType = 3;
    };
    ReaderDataModel.prototype._setActivePaneType = function (value) {
        this._activePaneType = value;
    };
    ReaderDataModel.prototype._setTopLeftCell = function (row, col, sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        sheet.topCellIndex = row;
        sheet.leftCellIndex = col;
    };
    ReaderDataModel.prototype._initDefinedNames = function () {
        this._spread.names = [];
        for (var sheetName in this._spread.sheets) {
            if (this._spread.sheets.hasOwnProperty(sheetName)) {
                this._spread.sheets[sheetName].names = [];
            }
        }
    };
    ReaderDataModel.prototype._addDefinedName = function (name, formula, sheetIndex, comment) {
        if (sheetIndex === -1) {
            this._spread.names.push({ name: name, formula: formula, row: 0, col: 0, comment: comment });
        }
        else {
            for (var sheetName in this._spread.sheets) {
                if (this._spread.sheets.hasOwnProperty(sheetName)) {
                    var sheet = this._spread.sheets[sheetName];
                    if (sheet.index === sheetIndex) {
                        sheet.names.push({ name: name, formula: formula, row: 0, col: 0, comment: comment });
                    }
                }
            }
        }
    };
    ReaderDataModel.prototype._getExtStyleByDxfId = function (dxfId) {
        var dxf = this._extDxfRecords[dxfId];
        return convertDxfToStyle(dxf, this._headingFont, this._bodyFont);
    };
    ReaderDataModel.prototype._getStyleByDxfId = function (dxfId) {
        var dxf = this._dxfRecords[dxfId];
        return convertDxfToStyle(dxf, this._headingFont, this._bodyFont);
    };
    ReaderDataModel.prototype._getStyleByDxf = function (dxf) {
        return convertDxfToStyle(dxf, this._headingFont, this._bodyFont);
    };
    ReaderDataModel.prototype._addConditionalFormatting = function (sheetName, conditionalFormatting) {
        var sheet = this._spread.sheets[sheetName];
        if (!sheet.conditionalFormats) {
            sheet.conditionalFormats = { rules: [] };
        }
        for (var i = 0; i < conditionalFormatting.rules.length; i++) {
            var rule = conditionalFormatting.rules[i];
            if (!common_1._isNullOrUndefined(rule.dxfId) && rule.dxfId > -1) {
                var tempStyle = this._getStyleByDxfId(rule.dxfId);
                if (tempStyle.font && tempStyle.font.indexOf('normal normal') === 0) {
                    delete tempStyle.font;
                }
                rule.style = tempStyle;
                delete rule.dxfId;
            }
            sheet.conditionalFormats.rules.push(rule);
        }
    };
    ReaderDataModel.prototype._getConditionalFormatting = function (sheetName) {
        return this._spread.sheets[sheetName].conditionalFormats;
    };
    ReaderDataModel.prototype._setComments = function (comments, sheetName) {
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        sheet.comments = comments.map(function (item) {
            return excel_helper_1.convertFromExcelComment(sheet, item);
        });
    };
    ReaderDataModel.prototype._setPivotTables = function (pivotTables, sheetName) {
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        sheet.pivotTables = pivotTables;
    };
    ReaderDataModel.prototype._addDrawingObjects = function (drawingInfo, sheetName) {
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var pictures = drawingInfo.pictures, charts = drawingInfo.charts, shapes = drawingInfo.shapes;
        if (pictures) {
            this._addPictures(pictures, sheet);
        }
        if (charts) {
            this._addCharts(charts, sheet);
        }
        if (shapes) {
            this._addShapes(shapes, sheet);
        }
    };
    ReaderDataModel.prototype._addPictures = function (pictures, sheet) {
        sheet.floatingObjects = sheet.floatingObjects || [];
        var floatingObjects = sheet.floatingObjects;
        pictures.forEach(function (excelPicture) {
            var picture = excel_helper_1.convertFromExcelPicture(sheet, excelPicture, floatingObjects);
            picture.typeName = '1';
            floatingObjects.push(picture);
        });
    };
    ReaderDataModel.prototype._addCharts = function (charts, sheet) {
        sheet.charts = sheet.charts || [];
        charts.map(function (chartData) {
            var chart = excel_helper_1.convertFromExcelChart(sheet, chartData);
            sheet.charts.push(chart);
        });
    };
    ReaderDataModel.prototype._getPivotCache = function (key, value) {
        var self = this, pivotCaches = self._spread.pivotCaches;
        if (!pivotCaches) {
            return;
        }
        for (var i in pivotCaches) {
            if (pivotCaches.hasOwnProperty(i)) {
                if (pivotCaches[i] && pivotCaches[i][key] === value) {
                    return pivotCaches[i];
                }
            }
        }
    };
    ReaderDataModel.prototype._composeShapeStyle = function (shapeData) {
        var self = this;
        var sp = shapeData.sp || shapeData.cxnSp, style = sp && sp.style, spPr = sp && sp.spPr;
        if (style) {
            var lnRef = style.lnRef, index = void 0, refObj = void 0, ln = spPr.ln;
            if (!ln) {
                ln = {};
            }
            if (lnRef) {
                index = lnRef.idx;
                if (index) {
                    refObj = self._getFormatSchemeItem(1, index - 1);
                    composeLineStyle(refObj, ln);
                    spPr.ln = ln;
                }
            }
        }
        var grpSp = shapeData.grpSp;
        if (grpSp) {
            var sps = grpSp.sp;
            if (sps && sps.length) {
                sps.forEach(function (item) {
                    self._composeShapeStyle({
                        sp: item
                    });
                });
            }
        }
    };
    ReaderDataModel.prototype._addShapes = function (shapes, sheet) {
        var self = this;
        sheet.shapes = sheet.shapes || [];
        shapes.map(function (shapeData) {
            self._composeShapeStyle(shapeData);
            var shape = excel_helper_1.convertFromExcelShape(sheet, shapeData);
            sheet.shapes.push(shape);
        });
    };
    ReaderDataModel.prototype._setSparkLineGroups = function (sparklineGroups, sheetName) {
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        sheet.sparklineGroups = sparklineGroups;
        for (var i = 0; i < sparklineGroups.length; i++) {
            var sparklines = sparklineGroups[i].sparklines;
            for (var j = 0; j < sparklines.length; j++) {
                if (sparklines[j].row >= sheet.rowCount) {
                    sheet.rowCount = sparklines[j].row + 1;
                }
                if (sparklines[j].col >= sheet.columnCount) {
                    sheet.columnCount = sparklines[j].col + 1;
                }
            }
        }
    };
    ReaderDataModel.prototype._setTables = function (tables, sheetName) {
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        sheet.tables = tables;
        for (var i = 0; i < tables.length; i++) {
            if (tables[i].row + tables[i].rowCount > sheet.rowCount) {
                sheet.rowCount = tables[i].row + tables[i].rowCount;
            }
            if (tables[i].col + tables[i].colCount > sheet.columnCount) {
                sheet.columnCount = tables[i].col + tables[i].colCount;
            }
            var dataTable = sheet.data && sheet.data.dataTable;
            var table = tables[i];
            var sheetDefaultFont = sheet.data && sheet.data.defaultDataNode
                && sheet.data.defaultDataNode.style
                && sheet.data.defaultDataNode.style.font;
            for (var styleItem in table.style) {
                if (table.style.hasOwnProperty(styleItem)) {
                    if (table.style[styleItem] && table.style[styleItem].font) {
                        table.style[styleItem].font = excel_style_1.ConverterHelper.composeFontWeightAndFontStyleToDestFont(table.style[styleItem].font, sheetDefaultFont);
                    }
                }
            }
            var cache = {};
            var tableEndRow = table.row + table.rowCount;
            var tableEndCol = table.col + table.colCount;
            for (var row = table.row; row < tableEndRow; row++) {
                for (var col = table.col; col < tableEndCol; col++) {
                    if (dataTable[row] && dataTable[row][col]) {
                        var buildInStyleName = dataTable[row][col].style;
                        if (isExist(cache, buildInStyleName)) {
                            dataTable[row][col].style = cache[buildInStyleName];
                        }
                        else {
                            resetStyleInfoOfCellInTableRange(self, spread, dataTable, row, col, cache);
                        }
                    }
                }
            }
        }
    };
    ReaderDataModel.prototype._getRangeData = function (sheetName, range, column, dataLength) {
        var sheet = this._spread.sheets[sheetName], dataTable, data = [], index = 0, temp;
        if (sheet && sheet.data && sheet.data.dataTable) {
            dataTable = sheet.data.dataTable;
            if (dataTable) {
                while (dataLength > 0 && index < range.rowCount) {
                    if (dataTable[range.row + index]) {
                        temp = dataTable[range.row + index][column];
                        if (!common_1._isNullOrUndefined(temp.value)) {
                            data.push(temp.value);
                            dataLength--;
                        }
                    }
                    index++;
                }
            }
        }
        return data;
    };
    ReaderDataModel.prototype._convertAutoFilterToJSON = function (autoFilter, sheetName) {
        var self = this;
        if (common_1._isNullOrUndefined(autoFilter) || common_1._isNullOrUndefined(autoFilter.range)) {
            return;
        }
        var rowFilter = {};
        rowFilter.filterItemMap = [];
        rowFilter.filteredColumns = [];
        var filterRange = autoFilter.range;
        filterRange = new common_1.Range(filterRange.row + 1, filterRange.col, filterRange.rowCount - 1, filterRange.colCount);
        rowFilter.range = filterRange;
        autoFilter.filterColumns.forEach(function (filterColumn) {
            var columnId = filterColumn.autoFilterColumnId + filterRange.col;
            var filterConditions = [];
            var colorFilter = filterColumn.colorFilter;
            if (colorFilter) {
                filterConditions.push(createColorFilterCondition(colorFilter, self._dxfRecords[colorFilter.dxfId]));
            }
            var filters = filterColumn.filters;
            if (filters) {
                filters.filter.forEach(function (filterItem) {
                    filterConditions.push(createCondition(2, 0, filterItem, filters.blank));
                });
                filters.dateGroupItem.forEach(function (dateItem) {
                    var dt = new Date(dateItem.year, dateItem.month > 0 ? dateItem.month - 1 : dateItem.month, dateItem.day, dateItem.hour, dateItem.minute, dateItem.second);
                    filterConditions.push(createCondition(5, 0, dt, !filters.blank));
                });
            }
            if (filterColumn.customFilters) {
                filterConditions.push(createCustomFilterCondition(filterColumn.customFilters, !common_1._isNullOrUndefined(sheetName) ? self._getRangeData(sheetName, filterRange, columnId, 1) : filterRange));
            }
            if (filterColumn.dynamicFilter) {
                filterConditions.push(createDynamicFilterCondition(filterColumn.dynamicFilter, filterRange, columnId));
            }
            if (filterColumn.top10Filter) {
                filterConditions.push(createTop10FilterCondition(filterColumn.top10Filter));
            }
            rowFilter.filteredColumns.push(columnId);
            rowFilter.filterItemMap.push({ index: columnId, conditions: filterConditions });
        });
        var sortInfo = autoFilter.sortInfo;
        if (sortInfo && sortInfo.dxfId === keyword_undefined) {
            rowFilter.sortInfo = sortInfo;
        }
        else if (sortInfo && sortInfo.dxfId !== keyword_undefined) {
            var color = void 0, isBackColor = autoFilter.sortInfo.isBackColor, fill = self._dxfRecords[sortInfo.dxfId] && self._dxfRecords[sortInfo.dxfId].fill;
            if (fill) {
                if (fill.patternType === 0) {
                    color = '';
                }
                else {
                    var style = {};
                    excel_style_1.ConverterHelper._setStyleInfoFill(fill, style);
                    if (typeof style.backColor === 'object') {
                        color = JSON.stringify(style.backColor);
                    }
                    else {
                        color = style.backColor;
                    }
                }
            }
            rowFilter.sortInfo = {
                ascending: sortInfo.ascending,
                index: sortInfo.index,
                isBackColor: isBackColor,
                color: color
            };
        }
        return rowFilter;
    };
    ReaderDataModel.prototype._convertPivotAutoFilterToJSON = function (autoFilter, typeInfos) {
        if (common_1._isNullOrUndefined(autoFilter)) {
            return;
        }
        var rowFilter = {};
        rowFilter.filterItemMap = [];
        autoFilter.filterColumns.forEach(function (filterColumn) {
            var filterConditions = [];
            var filters = filterColumn.filters;
            if (filters) {
                filters.filter.forEach(function (filterItem) {
                    filterConditions.push(createCondition(typeInfos.conType, 0, filterItem, filters.blank));
                });
                filters.dateGroupItem.forEach(function (dateItem) {
                    var dt = new Date(dateItem.year, dateItem.month > 0 ? dateItem.month - 1 : dateItem.month, dateItem.day, dateItem.hour, dateItem.minute, dateItem.second);
                    filterConditions.push(createCondition(typeInfos.conType, 0, dt, !filters.blank));
                });
            }
            if (filterColumn.customFilters) {
                filterConditions.push(createPivotCustomFilterCondition(filterColumn.customFilters, typeInfos));
            }
            if (filterColumn.dynamicFilter) {
                filterConditions.push(createPivotDynamicFilterCondition(filterColumn.dynamicFilter, typeInfos));
            }
            if (filterColumn.top10Filter) {
                filterConditions.push(createPivotTop10FilterCondition(filterColumn.top10Filter, typeInfos));
            }
            rowFilter.filterItemMap.push({ conditions: filterConditions });
        });
        return rowFilter;
    };
    ReaderDataModel.prototype._setAutoFilter = function (sheetName, autoFilter) {
        if (!common_1._isNullOrUndefined(sheetName)) {
            var self_1 = this, spread = self_1._spread, sheet = spread.sheets && spread.sheets[sheetName];
            sheet.rowFilter = self_1._convertAutoFilterToJSON(autoFilter, sheetName);
        }
    };
    ReaderDataModel.prototype._addSlicers = function (slicers, sheetName) {
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        sheet.slicers = sheet.slicers || [];
        var sheetSlicers = sheet.slicers;
        var tables = [];
        for (var name_4 in spread.sheets) {
            if (spread.sheets[name_4].tables) {
                tables = tables.concat(spread.sheets[name_4].tables);
            }
        }
        slicers.forEach(function (slicer) {
            slicer.tableName = getTableName(slicer.tableId, tables);
            slicer.columnName = getTableColumnName(slicer.tableId, slicer.columnId, tables);
            delete slicer.tableId;
            delete slicer.columnId;
            excel_helper_1.inflateWorksheetByAnchor(sheet, slicer);
            sheetSlicers.push(slicer);
        });
    };
    ReaderDataModel.prototype._setDataValidation = function (sheetName, dataValidation) {
        if (common_1._isNullOrUndefined(sheetName)) {
            return;
        }
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var validator = self._toDataValidator(dataValidation);
        var validations = sheet.validations;
        if (!validations) {
            validations = sheet.validations = [];
        }
        validator.ranges = getDataValidationRangesAsString(dataValidation.ranges, ', ');
        validations.push(validator);
    };
    ReaderDataModel.prototype._toDataValidator = function (dataValidation) {
        if (common_1._isNullOrUndefined(dataValidation)) {
            return keyword_null;
        }
        var criteriaType = dataValidation.type, cp = dataValidation.compareOperator;
        var firstFormula = dataValidation.firstFormula;
        var secondFormula = dataValidation.secondFormula;
        var result = { type: criteriaType }, validatorInfo;
        switch (criteriaType) {
            case 0: break;
            case 1:
            case 2:
            case 6:
                validatorInfo = {
                    operator: cp,
                    value1: addFormulaPrefixSymbol(firstFormula),
                    value2: addFormulaPrefixSymbol(secondFormula)
                };
                break;
            case 3:
                var formula = firstFormula;
                if (common_1._isNullOrUndefined(formula)) {
                    formula = secondFormula;
                }
                if (formula) {
                    if (formula[0] === '"' && formula[formula.length - 1] === '"') {
                        validatorInfo = { value: addStringPrefixSymbol(formula) };
                    }
                    else {
                        validatorInfo = { formula: addFormulaPrefixSymbol(formula) };
                    }
                }
                break;
            case 4:
            case 5:
                var temp = void 0;
                if (!common_1._isNullOrUndefined(firstFormula)) {
                    temp = parseFloat(firstFormula);
                    if (!isNaN(temp)) {
                        firstFormula = this._convertToOADateString(temp);
                    }
                }
                if (!common_1._isNullOrUndefined(secondFormula)) {
                    temp = parseFloat(secondFormula);
                    if (!isNaN(temp)) {
                        secondFormula = this._convertToOADateString(temp);
                    }
                }
                validatorInfo = {
                    operator: cp,
                    value1: firstFormula && firstFormula.indexOf('/OADate(') !== -1 ? firstFormula : addFormulaPrefixSymbol(firstFormula),
                    value2: secondFormula && secondFormula.indexOf('/OADate(') !== -1 ? secondFormula : addFormulaPrefixSymbol(secondFormula)
                };
                break;
            case 7:
                validatorInfo = { formula: addFormulaPrefixSymbol(firstFormula) };
                break;
            default:
                break;
        }
        if (validatorInfo) {
            result.validatorInfo = validatorInfo;
        }
        if (result !== keyword_null) {
            result.errorStyle = dataValidation.errorType;
            result.errorMessage = dataValidation.error;
            result.errorTitle = dataValidation.errorTitle;
            result.ignoreBlank = dataValidation.allowBlank;
            result.inCellDropdown = dataValidation.showPromptBox;
            result.inputMessage = dataValidation.prompt;
            result.inputTitle = dataValidation.promptTitle;
            result.showErrorMessage = dataValidation.showErrorMessage;
            result.showInputMessage = dataValidation.showInputMessage;
        }
        return result;
    };
    ReaderDataModel.prototype._setPrintPageMargin = function (sheetName, printMargin) {
        function getPageMarginInSpread(margin) {
            margin = margin || 0;
            return parseInt(Math.round(margin * 96), 10);
        }
        if (common_1._isNullOrUndefined(sheetName)) {
            return;
        }
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (!sheet.printInfo) {
            sheet.printInfo = {};
        }
        var printInfo = sheet.printInfo;
        printInfo.margin = {
            top: getPageMarginInSpread(printMargin.top),
            bottom: getPageMarginInSpread(printMargin.bottom),
            left: getPageMarginInSpread(printMargin.left),
            right: getPageMarginInSpread(printMargin.right),
            header: getPageMarginInSpread(printMargin.header),
            footer: getPageMarginInSpread(printMargin.footer)
        };
    };
    ReaderDataModel.prototype._setPrintOption = function (sheetName, printOption) {
        if (common_1._isNullOrUndefined(sheetName)) {
            return;
        }
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (!sheet.printInfo) {
            sheet.printInfo = {};
        }
        var printInfo = sheet.printInfo;
        printInfo.showGridLine = printOption.printGridLine;
        var horizontalCentered = printOption.horizontalCentered, verticalCentered = printOption.verticalCentered;
        var centering = 0;
        if (horizontalCentered && verticalCentered) {
            centering = 3;
        }
        else if (horizontalCentered) {
            centering = 1;
        }
        else if (verticalCentered) {
            centering = 2;
        }
        printInfo.centering = centering;
        var headerVisibility = printOption.printRowColumnsHeaders ? 2 : 1;
        printInfo.showColumnHeader = headerVisibility;
        printInfo.showRowHeader = headerVisibility;
    };
    ReaderDataModel.prototype._setRowPageBreak = function (sheet, row, value) {
        if (!sheet.rows) {
            sheet.rows = [];
        }
        var info = sheet.rows[row];
        if (info) {
            info.pageBreak = value;
        }
        else {
            sheet.rows[row] = { pageBreak: value };
        }
    };
    ReaderDataModel.prototype._setColumnPageBreak = function (sheet, column, value) {
        if (!sheet.columns) {
            sheet.columns = [];
        }
        var info = sheet.columns[column];
        if (info) {
            info.pageBreak = value;
        }
        else {
            sheet.columns[column] = { pageBreak: value };
        }
    };
    ReaderDataModel.prototype._setPrintPageSetting = function (sheetName, pageSetting) {
        function parseExcelPrintHeader(header) {
            if (header === keyword_undefined) {
                return keyword_null;
            }
            var result = ['', '', ''];
            if (header === keyword_null || header === '') {
                return result;
            }
            var i = 0;
            var area = 1;
            var headerLength = header.length;
            while (i < headerLength) {
                if (i < headerLength - 1) {
                    var flag = header.substr(i, 2);
                    if (flag === '&L') {
                        area = 0;
                        i += 2;
                        continue;
                    }
                    else if (flag === '&C') {
                        area = 1;
                        i += 2;
                        continue;
                    }
                    else if (flag === '&R') {
                        area = 2;
                        i += 2;
                        continue;
                    }
                }
                result[area] = result[area].concat(header[i]);
                i++;
            }
            return result;
        }
        if (common_1._isNullOrUndefined(sheetName)) {
            return;
        }
        var self = this, spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (!sheet.printInfo) {
            sheet.printInfo = {};
        }
        var printInfo = sheet.printInfo;
        var paperKind = pageSetting.paperSizeIndex;
        if (paperKind !== 0) {
            printInfo.paperSize = { kind: paperKind };
        }
        if (pageSetting.useCustomStartingPage) {
            printInfo.firstPageNumber = pageSetting.firstPageNumber;
        }
        if (!common_1._isNullOrUndefined(pageSetting.showColor)) {
            printInfo.blackAndWhite = !pageSetting.showColor;
        }
        printInfo.orientation = pageSetting.orientation === 2 ? 2 : 1;
        printInfo.pageOrder = pageSetting.pageOrder === 2 ? 2 : 1;
        if (pageSetting.zoomFactor > 0) {
            printInfo.zoomFactor = pageSetting.zoomFactor;
        }
        if (pageSetting.useSmartPrint) {
            if (pageSetting.smartPrintPagesWidth >= 1) {
                printInfo.fitPagesWide = pageSetting.smartPrintPagesWidth;
            }
            if (pageSetting.smartPrintPagesHeight >= 1) {
                printInfo.fitPagesTall = pageSetting.smartPrintPagesHeight;
            }
        }
        var advancedHeadFooterSetting = pageSetting.advancedHeadFooterSetting;
        if (advancedHeadFooterSetting) {
            var oddHeaders = parseExcelPrintHeader(advancedHeadFooterSetting.headerOddPage);
            if (oddHeaders) {
                printInfo.headerLeft = oddHeaders[0];
                printInfo.headerCenter = oddHeaders[1];
                printInfo.headerRight = oddHeaders[2];
            }
            var oddFooters = parseExcelPrintHeader(advancedHeadFooterSetting.footerOddPage);
            if (oddFooters) {
                printInfo.footerLeft = oddFooters[0];
                printInfo.footerCenter = oddFooters[1];
                printInfo.footerRight = oddFooters[2];
            }
            if (advancedHeadFooterSetting.headerLeftImage) {
                printInfo.headerLeftImage = advancedHeadFooterSetting.headerLeftImage;
            }
            if (advancedHeadFooterSetting.headerCenterImage) {
                printInfo.headerCenterImage = advancedHeadFooterSetting.headerCenterImage;
            }
            if (advancedHeadFooterSetting.headerRightImage) {
                printInfo.headerRightImage = advancedHeadFooterSetting.headerRightImage;
            }
            if (advancedHeadFooterSetting.footerLeftImage) {
                printInfo.footerLeftImage = advancedHeadFooterSetting.footerLeftImage;
            }
            if (advancedHeadFooterSetting.footerCenterImage) {
                printInfo.footerCenterImage = advancedHeadFooterSetting.footerCenterImage;
            }
            if (advancedHeadFooterSetting.footerRightImage) {
                printInfo.footerRightImage = advancedHeadFooterSetting.footerRightImage;
            }
        }
        var rowBreakLines = pageSetting.rowBreakLines;
        if (rowBreakLines && rowBreakLines.length > 0) {
            rowBreakLines.forEach(function (rowIndex) {
                self._setRowPageBreak(sheet, rowIndex, true);
            });
        }
        var columnBreakLines = pageSetting.columnBreakLines;
        if (columnBreakLines && columnBreakLines.length > 0) {
            columnBreakLines.forEach(function (columnIndex) {
                self._setColumnPageBreak(sheet, columnIndex, true);
            });
        }
    };
    ReaderDataModel.prototype._setPrintArea = function (sheetIndex, formula) {
        if (sheetIndex < 0) {
            return;
        }
        var self = this;
        var sheet = self._getSheetByIndex(sheetIndex);
        if (!sheet.printInfo) {
            sheet.printInfo = {};
        }
        var ranges = range_parser_1.getRangesFromString(formula);
        if (ranges.length === 1) {
            var range = ranges[0];
            if (range.row > -1) {
                sheet.printInfo.rowStart = range.row;
            }
            if (range.rowCount > 0) {
                sheet.printInfo.rowEnd = range.row + range.rowCount - 1;
            }
            if (range.col > -1) {
                sheet.printInfo.columnStart = range.col;
            }
            if (range.colCount > 0) {
                sheet.printInfo.columnEnd = range.col + range.colCount - 1;
            }
        }
    };
    ReaderDataModel.prototype._setPrintTitles = function (sheetIndex, formula) {
        if (sheetIndex < 0) {
            return;
        }
        var self = this;
        var sheet = self._getSheetByIndex(sheetIndex);
        if (!sheet.printInfo) {
            sheet.printInfo = {};
        }
        var ranges = range_parser_1.getRangesFromString(formula.replace(',', ' '));
        for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (common_1.isRangeWholeRow(range)) {
                sheet.printInfo.repeatRowStart = range.row;
                sheet.printInfo.repeatRowEnd = range.row + range.rowCount - 1;
            }
            else if (common_1.isRangeWholeColumn(range)) {
                sheet.printInfo.repeatColumnStart = range.col;
                sheet.printInfo.repeatColumnEnd = range.col + range.colCount - 1;
            }
        }
    };
    ReaderDataModel.prototype._getSheetByIndex = function (index) {
        var sheets = this._spread.sheets;
        for (var sheetName in sheets) {
            if (sheets.hasOwnProperty(sheetName)) {
                var sheet = sheets[sheetName];
                if (sheet.index === index) {
                    return sheet;
                }
            }
        }
        return keyword_undefined;
    };
    ReaderDataModel.prototype._setSheetMetadata = function (metadata) {
        this._metadata = metadata;
        this._cellMetadataCache = {};
        this._valueMetadataCache = {};
    };
    ReaderDataModel.prototype._getMetadataRef = function (name, strValue, needCheckDetail) {
        var metadata = this._metadata;
        var index = +strValue - 1;
        var group, cache;
        if (metadata) {
            if (name === 'cm') {
                group = metadata.cellMetadata;
                cache = this._cellMetadataCache;
            }
            else if (name === 'vm') {
                group = metadata.valueMetadata;
                cache = this._valueMetadataCache;
            }
        }
        if (group) {
            if (!needCheckDetail) {
                return { name: metadata.typeNames[index] };
            }
            var key = [name, index].join(','), cacheItem = cache[key];
            if (cacheItem) {
                return cacheItem;
            }
            var item = getBlockItem(group, index);
            if (item) {
                var record = item.rc, attr = record._attr, typeIndex = +attr.t - 1, valueIndex = +attr.v;
                try {
                    var metadataTypes = getAsArray(metadata.metadataTypes.metadataType), futureMetadatas = getAsArray(metadata.futureMetadata);
                    var typeItem = metadataTypes[typeIndex], idName = typeItem && typeItem._attr.name;
                    var futureMetadata = getFutureMetadataByName(futureMetadatas, idName);
                    if (futureMetadata) {
                        cacheItem = {
                            name: idName,
                            detail: getBlockItem(futureMetadata, valueIndex)
                        };
                        cache[key] = cacheItem;
                        return cacheItem;
                    }
                }
                catch (ex) {
                }
            }
        }
    };
    ReaderDataModel.prototype._isDynamicArray = function (value) {
        var result = this._getMetadataRef('cm', value);
        return result && result.name === 'XLDAPR';
    };
    ReaderDataModel.prototype._setDocPropsCore = function (key, value) {
        var self = this;
        if (common_1._isNullOrUndefined(self._spread.docProps)) {
            self._spread.docProps = {};
        }
        if (common_1._isNullOrUndefined(self._spread.docProps.docPropsCore)) {
            self._spread.docProps.docPropsCore = {};
        }
        self._spread.docProps.docPropsCore[key] = value;
    };
    ReaderDataModel.prototype._setDocPropsApp = function (key, value) {
        var self = this;
        if (common_1._isNullOrUndefined(self._spread.docProps)) {
            self._spread.docProps = {};
        }
        if (common_1._isNullOrUndefined(self._spread.docProps.docPropsApp)) {
            self._spread.docProps.docPropsApp = {};
        }
        self._spread.docProps.docPropsApp[key] = value;
    };
    ReaderDataModel.prototype._setDocPropsCustom = function (customPropertyItemArray) {
        var self = this;
        if (common_1._isNullOrUndefined(self._spread.docProps)) {
            self._spread.docProps = {};
        }
        if (common_1._isNullOrUndefined(self._spread.docProps.docPropsCustom)) {
            self._spread.docProps.docPropsCustom = [];
        }
        self._spread.docProps.docPropsCustom = customPropertyItemArray;
    };
    return ReaderDataModel;
}());
exports.ReaderDataModel = ReaderDataModel;
/***/ }),

/***/ './src/datamodel/datamodel-writer.ts':
/*!*******************************************!*\
  !*** ./src/datamodel/datamodel-writer.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });
var common_1 = __webpack_require__(/*! ./../common/common */ './src/common/common.ts');
var excel_types_1 = __webpack_require__(/*! ./../common/excel-types */ './src/common/excel-types.ts');
var excel_style_1 = __webpack_require__(/*! ./excel-style */ './src/datamodel/excel-style.ts');
var excel = __webpack_require__(/*! ./../common/excel-types */ './src/common/excel-types.ts');
var excel_helper_1 = __webpack_require__(/*! ./excel-helper */ './src/datamodel/excel-helper.ts');
var tuple_1 = __webpack_require__(/*! ./../common/tuple */ './src/common/tuple.ts');
var fromColorToExcelColor = excel_style_1.ColorHelper.fromColorToExcelColor;
var toExcelColor = excel_style_1.ColorHelper.toExcelColor;
var isEqualObject = common_1.Util._isEqualObject;
var isExternalRange = common_1.Util._isExternalRange;
var keyword_undefined = void 0, keyword_null = null, const_builtInStyle = '__builtInStyle', const_builtInValidatorStyle = '__builtInValidatorStyle', const_builtInTableStyle = '__builtInTableStyle';
var builtInStyleRegex = /^(__builtInTableStyle\d+)?__builtInStyle\d+$/;
function isString(value) {
    return typeof value === 'string';
}
function isStringOrNull(value) {
    return typeof value === 'string' || !value;
}
function isObject(value) {
    return typeof value === 'object';
}
function isBuiltInTableStyle(name) {
    return name.substring(0, 19) === const_builtInTableStyle;
}
function isBuiltInValidatorStyle(name) {
    return name.substring(0, 23) === const_builtInValidatorStyle;
}
function getDateConditionFormula(condition) {
    var formula = condition.formula;
    if (common_1._isNullOrUndefined(formula)) {
        formula = condition.expected;
        if (isString(formula)) {
            formula = '"' + formula + '"';
        }
    }
    return formula;
}
function convertToExcelOADate(value) {
    if (isString(value)) {
        var startIndex = value.indexOf('/OADate(') + 1, endIndex = value.indexOf(')');
        if (startIndex !== 0 && endIndex > startIndex) {
            var oaDateFloat = parseFloat(value.substring(startIndex + 7, endIndex));
            if (!isNaN(oaDateFloat)) {
                value = '' + oaDateFloat;
            }
        }
    }
    return value;
}
function findTable(sheet, row, col) {
    var table;
    var tables = sheet.tables || [];
    tables.every(function (sheetTable) {
        if (sheetTable.row <= row && row <= sheetTable.row + sheetTable.rowCount - 1 && sheetTable.col <= col && col <= sheetTable.col + sheetTable.colCount - 1) {
            table = sheetTable;
            return false;
        }
        return true;
    });
    return table;
}
function findSpan(sheet, row, col) {
    var span;
    var spans = sheet.spans || [];
    spans.every(function (tempSpan) {
        if (tempSpan.row <= row && row <= tempSpan.row + tempSpan.rowCount - 1 && tempSpan.col <= col && col <= tempSpan.col + tempSpan.colCount - 1) {
            span = tempSpan;
            return false;
        }
        return true;
    });
    return span;
}
function removeSpan(sheet, span) {
    var spans = sheet.spans || [];
    for (var i = 0; i < spans.length; i++) {
        if (span.row === spans[i].row && span.col === spans[i].col) {
            spans.splice(i, 1);
            break;
        }
    }
}
function _fromOADateString(oadateString) {
    if (oadateString.substr(0, 8) === '/OADate(') {
        var oadate = parseFloat(oadateString.substr(8, oadateString.length - 10));
        var offsetDay = oadate - 25569;
        var date = new Date(offsetDay * 86400000);
        var adjustValue = offsetDay >= 0 ? 1 : -1;
        var oldDateTimezoneOffset = _getTimezoneOffset(date);
        var ms = (oadate * 86400000 * 1440 + adjustValue - 25569 * 86400000 * 1440 + oldDateTimezoneOffset * 86400000) / 1440;
        var firstResult = new Date(ms);
        var fixHourSign = oldDateTimezoneOffset >= 0 ? 1 : -1;
        var nextHour = new Date(ms + fixHourSign * 3600000);
        var nextHourTimezoneOffset = _getTimezoneOffset(nextHour);
        if (oldDateTimezoneOffset !== nextHourTimezoneOffset) {
            var newResult = new Date(ms + (nextHourTimezoneOffset - oldDateTimezoneOffset) * 60 * 1000);
            if (oldDateTimezoneOffset > nextHourTimezoneOffset) {
                if (fixHourSign === -1 || nextHourTimezoneOffset === _getTimezoneOffset(firstResult)) {
                    newResult = newResult.getMilliseconds() === 999 ? new Date(newResult.valueOf() + 1) : newResult;
                    return newResult;
                }
            }
            else if (oldDateTimezoneOffset < nextHourTimezoneOffset) {
                if (fixHourSign === 1 || nextHourTimezoneOffset === _getTimezoneOffset(firstResult)) {
                    newResult = newResult.getMilliseconds() === 999 ? new Date(newResult.valueOf() + 1) : newResult;
                    return newResult;
                }
            }
        }
        firstResult = firstResult.getMilliseconds() === 999 ? new Date(firstResult.valueOf() + 1) : firstResult;
        return firstResult;
    }
}
function _getTimezoneOffset(date) {
    var offset = date.getTimezoneOffset();
    if (offset === -485) {
        offset = -485 - 43 / 60;
    }
    if (offset === -321) {
        offset = -321 - 10 / 60;
    }
    return offset;
}
function addNamedStyleToStyleCache(context, styleName, styleInfo) {
    if (!context._namedStyleCache) {
        context._namedStyleCache = {};
    }
    context._namedStyleCache[styleName] = styleInfo;
}
function getSheetDefaultRowHeight(sheet) {
    return sheet.defaults ? sheet.defaults.rowHeight : excel_types_1.DefaultSize._defaultRowHeight;
}
function getSheetDefaultColumnWidth(sheet) {
    return sheet.defaults ? sheet.defaults.colWidth : excel_types_1.DefaultSize._defaultColumnWidth;
}
function getCellData(sheet, row, col) {
    var rowData = sheet.data.dataTable[row];
    if (rowData && rowData[col]) {
        return rowData[col].value;
    }
}
function getFilterRange(sheet, range, frozenRowCount) {
    if (frozenRowCount === void 0) { frozenRowCount = 0; }
    var row = range.row, col = range.col, rowCount = range.rowCount, colCount = range.colCount;
    if (row === -1) {
        row = frozenRowCount;
        rowCount = sheet.rowCount;
    }
    if (col === -1) {
        col = 0;
        colCount = sheet.columnCount;
    }
    if (row <= 0) {
        row = 0;
    }
    else {
        row--;
        rowCount += 1;
    }
    return new common_1.Range(row, col, rowCount, colCount);
}
exports.getFilterRange = getFilterRange;
function removeFormulaSymbolIfExists(expression) {
    if (common_1._isNullOrUndefined(expression)) {
        return expression;
    }
    if (expression.length >= 2 && expression[0] === '=') {
        return expression.substring(1);
    }
    else if (expression === '=') {
        return '';
    }
    return expression;
}
function getMaxOrMinValue(sheet, rank, range, isMax) {
    if (range.colCount !== 1) {
        return;
    }
    var dataArray = [], data;
    for (var row = range.row; row < range.row + range.rowCount; row++) {
        data = getCellData(sheet, row, range.col);
        if (!common_1._isNullOrUndefined(data)) {
            dataArray.push(data);
        }
    }
    dataArray.sort(function (v1, v2) {
        return isMax ? (v2 - v1) : (v1 - v2);
    });
    return dataArray[rank - 1];
}
function getTop10Filter(sheet, condition, filterRange) {
    var top10Filter = { filterType: 1 };
    top10Filter.isBottom = condition.type === 1;
    if (condition.percent) {
        top10Filter.percent = true;
    }
    var rank = condition.expected;
    if (!common_1._isNullOrUndefined(rank)) {
        top10Filter.value = rank;
        if (top10Filter.percent) {
            rank = Math.ceil(filterRange.rowCount % rank / 100.0);
        }
        if (!common_1._isNullOrUndefined(filterRange)) {
            top10Filter.filterValue = getMaxOrMinValue(sheet, rank, filterRange, !top10Filter.isBottom);
        }
        else {
            top10Filter.filterValue = NaN;
        }
        return top10Filter;
    }
}
function getPivotTop10Filter(condition) {
    var top10Filter = { filterType: 1 };
    top10Filter.isBottom = condition.type === -1;
    top10Filter.percent = condition.compareType === 1;
    var rank = condition.expected;
    if (!common_1._isNullOrUndefined(rank)) {
        top10Filter.value = rank;
        top10Filter.filterValue = rank;
    }
    return top10Filter;
}
function getAverageFilter(sheet, condition, filterRange) {
    var dynamicFilter = { filterType: 2 };
    if (condition.type === 0) {
        dynamicFilter.type = 100;
    }
    else if (condition.type === 1) {
        dynamicFilter.type = 101;
    }
    if (filterRange === keyword_null) {
        return keyword_null;
    }
    var sum = 0, count = 0;
    for (var i = 0; i < filterRange.rowCount; i++) {
        var d = parseFloat(getCellData(sheet, filterRange.row + i, filterRange.col));
        if (!isNaN(d)) {
            sum += d;
            count++;
        }
    }
    if (count > 0) {
        dynamicFilter.value = sum / count;
    }
    return dynamicFilter;
}
function getDateExConditionRange(dateOccurringType) {
    var currentDate = new Date(), weekday = currentDate.getDay(), currrenDay = currentDate.getDate();
    var from = new Date(currentDate), to = new Date(currentDate);
    switch (dateOccurringType) {
        case 3:
            from.setDate(currrenDay - 6);
            break;
        case 1:
            from.setDate(currrenDay - 1);
            break;
        case 0: break;
        case 2:
            from.setDate(currrenDay + 1);
            break;
        case 8:
            from.setDate(currrenDay - weekday - 7);
            to.setDate(currrenDay - weekday - 1);
            break;
        case 7:
            from.setDate(currrenDay - weekday);
            to.setDate(currrenDay - weekday + 6);
            break;
        case 9:
            from.setDate(currrenDay - weekday + 7);
            to.setDate(currrenDay - weekday + 13);
            break;
        case 5:
            from.setDate(1);
            from.setMonth(from.getMonth() - 1);
            to.setDate(0);
            break;
        case 4:
            from.setDate(1);
            to.setMonth(to.getMonth() + 1);
            to.setDate(0);
            break;
        case 6:
            from.setDate(1);
            from.setMonth(from.getMonth() + 1);
            to.setMonth(to.getMonth() + 2);
            to.setDate(0);
            break;
    }
    from.setHours(0);
    from.setMinutes(0);
    from.setSeconds(0);
    to.setHours(23);
    to.setMinutes(59);
    to.setSeconds(59);
    return { from: from, to: to };
}
function getPivotDateExConditionRange(dateCompareType) {
    var currentDate = new Date(), weekday = currentDate.getDay(), currrenDay = currentDate.getDate();
    var from = new Date(currentDate), to = new Date(currentDate);
    switch (dateCompareType) {
        case 11:
            from.setDate(currrenDay - 6);
            break;
        case 9:
            from.setDate(currrenDay - 1);
            break;
        case 8: break;
        case 10:
            from.setDate(currrenDay + 1);
            break;
        case 16:
            from.setDate(currrenDay - weekday - 7);
            to.setDate(currrenDay - weekday - 1);
            break;
        case 15:
            from.setDate(currrenDay - weekday);
            to.setDate(currrenDay - weekday + 6);
            break;
        case 17:
            from.setDate(currrenDay - weekday + 7);
            to.setDate(currrenDay - weekday + 13);
            break;
        case 13:
            from.setDate(1);
            from.setMonth(from.getMonth() - 1);
            to.setDate(0);
            break;
        case 12:
            from.setDate(1);
            to.setMonth(to.getMonth() + 1);
            to.setDate(0);
            break;
        case 14:
            from.setDate(1);
            from.setMonth(from.getMonth() + 1);
            to.setMonth(to.getMonth() + 2);
            to.setDate(0);
            break;
        case 18:
            var nextQuarterFromMonth = from.getMonth() - from.getMonth() % 3 + 1 + 3;
            var nextQuarterEndMonth = nextQuarterFromMonth + 3 + 3;
            from.setDate(1);
            from.setMonth(nextQuarterFromMonth);
            to.setMonth(nextQuarterEndMonth);
            to.setDate(0);
            break;
        case 19:
            var thisQuarterFromMonth = from.getMonth() - from.getMonth() % 3 + 1;
            var thisQuarterEndMonth = thisQuarterFromMonth + 3;
            from.setDate(1);
            from.setMonth(thisQuarterFromMonth);
            to.setMonth(thisQuarterEndMonth);
            to.setDate(0);
            break;
        case 20:
            var lastQuarterFromMonth = from.getMonth() - from.getMonth() % 3 + 1 - 3;
            var lastQuarterEndMonth = thisQuarterFromMonth + 3 - 3;
            from.setDate(1);
            from.setMonth(lastQuarterFromMonth);
            to.setMonth(lastQuarterEndMonth);
            to.setDate(0);
            break;
        case 21:
            from.setDate(1);
            from.setMonth(1);
            from.setFullYear(from.getFullYear() + 1);
            to.setFullYear(to.getFullYear() + 2);
            to.setMonth(0);
            to.setDate(0);
            break;
        case 22:
            from.setDate(1);
            from.setMonth(1);
            to.setFullYear(to.getFullYear() + 1);
            to.setMonth(0);
            to.setDate(0);
            break;
        case 23:
            from.setDate(1);
            from.setMonth(1);
            from.setMonth(from.getFullYear() - 1);
            to.setMonth(0);
            to.setDate(0);
            break;
    }
    from.setHours(0);
    from.setMinutes(0);
    from.setSeconds(0);
    to.setHours(23);
    to.setMinutes(59);
    to.setSeconds(59);
    return { from: from, to: to };
}
function getDateExFilter(condition) {
    var expectedType = condition.expected;
    var dynamicFilter = {
        filterType: 2,
        type: expectedType,
        conType: condition.conType,
        expectTypeId: condition.expectTypeId
    };
    if (expectedType >= 0 && expectedType <= 15 || expectedType >= 21 && expectedType <= 32) {
        var conditionRange = getDateExConditionRange(expectedType);
        if (conditionRange.from && conditionRange.to) {
            dynamicFilter.value = conditionRange.from;
            dynamicFilter.maxValue = conditionRange.to;
        }
    }
    else {
        dynamicFilter.type = -1;
    }
    return dynamicFilter;
}
function getCellValueFilter(condition) {
    if (!common_1._isNullOrUndefined(condition.compareType)) {
        var filters = { filterType: 4 };
        filters.filter1 = {};
        filters.filter1.operator = condition.compareType;
        if (!common_1._isNullOrUndefined(condition.expected)) {
            filters.filter1.value = condition.expected;
        }
        else {
            filters.filter1.value = removeFormulaSymbolIfExists(condition.formula);
        }
        return filters;
    }
}
function getCellValuePivotFilter(condition) {
    if (!common_1._isNullOrUndefined(condition.compareType)) {
        var filters = { filterType: 4 };
        filters.filter1 = {};
        filters.filter1.operator = condition.compareType;
        if (condition.item1 && !common_1._isNullOrUndefined(condition.item1.expected)) {
            filters.filter1.value = condition.item1.expected;
        }
        if (condition.item2 && !common_1._isNullOrUndefined(condition.item2.expected)) {
            filters.filter2 = {};
            filters.filter2.operator = condition.compareType;
            filters.filter2.value = condition.item2.expected;
        }
        return filters;
    }
}
function getTextFilter(condition) {
    var expectedValue = condition.expected;
    var op = -1;
    switch (condition.compareType) {
        case 0: return { filterType: 3, filter: [expectedValue] };
        case 1:
            op = 1;
            break;
        case 2:
            expectedValue += '*';
            break;
        case 3:
            op = 1;
            expectedValue += '*';
            break;
        case 4:
            expectedValue = '*' + expectedValue;
            break;
        case 5:
            op = 1;
            expectedValue = '*' + expectedValue;
            break;
        case 6:
            expectedValue = '*' + expectedValue + '*';
            break;
        case 7:
            op = 1;
            expectedValue = '*' + expectedValue + '*';
            break;
        default:
            break;
    }
    return { filterType: 4, filter1: { operator: op, value: expectedValue } };
}
function getPivotTextFilter(condition) {
    var expectedValue1, expectedValue2;
    if (!common_1._isNullOrUndefined(condition.value1)) {
        expectedValue1 = condition.value1;
    }
    else if (!common_1._isNullOrUndefined(condition.item1)) {
        expectedValue1 = condition.item1.expected;
    }
    if (!common_1._isNullOrUndefined(condition.value2)) {
        expectedValue2 = condition.value2;
    }
    else if (!common_1._isNullOrUndefined(condition.item2)) {
        expectedValue2 = condition.item2.expected;
    }
    if (expectedValue2) {
        if (condition.compareType === 12) {
            return { filterType: 4, filter1: { operator: 3, value: expectedValue1 }, filter2: { operator: 5, value: expectedValue2 } };
        }
        else if (condition.compareType === 13) {
            return { filterType: 4, filter1: { operator: 4, value: expectedValue1 }, filter2: { operator: 2, value: expectedValue2 } };
        }
    }
    else {
        var op = -1;
        switch (condition.compareType) {
            case 0: return { filterType: 3, filter: [expectedValue1] };
            case 1:
                op = 1;
                break;
            case 2:
                expectedValue1 += '*';
                break;
            case 3:
                op = 1;
                expectedValue1 += '*';
                break;
            case 4:
                expectedValue1 = '*' + expectedValue1;
                break;
            case 5:
                op = 1;
                expectedValue1 = '*' + expectedValue1;
                break;
            case 6:
                expectedValue1 = '*' + expectedValue1 + '*';
                break;
            case 7:
                op = 1;
                expectedValue1 = '*' + expectedValue1 + '*';
                break;
            default:
                break;
        }
        return { filterType: 4, filter1: { operator: op, value: expectedValue1 } };
    }
}
function getDateGroupItem(condition, filters) {
    var expectedTime;
    if (condition.expected.substring(0, 7) === '/OADate') {
        expectedTime = _fromOADateString(condition.expected);
    }
    else {
        expectedTime = new Date(condition.expected);
    }
    filters.dateGroupItem = filters.dateGroupItem || [];
    filters.dateGroupItem.push({
        year: expectedTime.getFullYear(),
        month: expectedTime.getMonth() + 1,
        day: expectedTime.getDate(),
        hour: expectedTime.getHours(),
        minute: expectedTime.getMinutes(),
        second: expectedTime.getSeconds(),
        dateTimeGrouping: 2
    });
}
function getPivotDateFilter(condition, type) {
    var compareType = condition.compareType;
    var dynamicFilter;
    if (compareType >= 8 && compareType <= 23) {
        dynamicFilter = {
            filterType: 2,
            type: type
        };
        var conditionRange = getPivotDateExConditionRange(compareType);
        if (conditionRange.from && conditionRange.to) {
            dynamicFilter.value = conditionRange.from;
            dynamicFilter.maxValue = conditionRange.to;
        }
    }
    else if (compareType >= 24 && compareType <= 39) {
        dynamicFilter = {
            filterType: 2,
            type: type,
        };
    }
    else if (compareType >= 0 && compareType <= 7) {
        return getCellValuePivotFilter(condition);
    }
    return dynamicFilter;
}
function getDateFilter(condition) {
    if (condition.compareType === 0) {
        var filters = { filterType: 3 };
        getDateGroupItem(condition, filters);
        return filters;
    }
    var op = -1;
    switch (condition.compareType) {
        case 0: break;
        case 1:
            op = 1;
            break;
        case 2:
            op = 4;
            break;
        case 3:
            op = 5;
            break;
        case 4:
            op = 2;
            break;
        case 5:
            op = 3;
            break;
        default:
            break;
    }
    if (op !== -1) {
        var formula = getDateConditionFormula(condition);
        formula = convertToExcelOADate(formula);
        return { filterType: 4, filter1: { operator: op, value: formula } };
    }
}
function expandRelationCondition(relationCondtion) {
    var result = [], conditions = [];
    conditions.push(relationCondtion);
    while (conditions.length > 0) {
        var cond = conditions.shift();
        if (cond.conType === 0) {
            var relCond = cond;
            if (!common_1._isNullOrUndefined(relCond.item1)) {
                conditions.push(relCond.item1);
            }
            if (!common_1._isNullOrUndefined(relCond.item2)) {
                conditions.push(relCond.item2);
            }
        }
        else {
            result.push(cond);
        }
    }
    return result;
}
function getTextConditonOperator(compareType) {
    var op = -1;
    switch (compareType) {
        case 0:
        case 2:
        case 4:
        case 6:
            op = 0;
            break;
        case 1:
        case 3:
        case 5:
        case 7:
            op = 1;
            break;
        default:
            op = 0;
            break;
    }
    return op;
}
function getTextConditionValue(originalValue, compareType) {
    switch (compareType) {
        case 0:
        case 1: return originalValue;
        case 2:
        case 3: return originalValue.concat('*');
        case 4:
        case 5: return '*'.concat(originalValue);
        case 6:
        case 7: return '*'.concat(originalValue).concat('*');
        default:
            return originalValue;
    }
}
function getCellValueConditionValue(conditions) {
    var filters = { filterType: 3, filter: [] };
    conditions.forEach(function (cellValueCondtion) {
        if (!common_1._isNullOrUndefined(cellValueCondtion.expected)) {
            filters.filter.push(cellValueCondtion.expected);
        }
    });
    return filters;
}
function isAllSpecificCondition(conditionArray, conType) {
    return conditionArray.every(function (item) {
        return item.conType === conType;
    });
}
function getRelationFilter(relationCondtion, sheet, filterRange) {
    var conditions, filters, op, customFilters;
    if (relationCondtion.compareType === 0) {
        conditions = expandRelationCondition(relationCondtion);
        if (isAllSpecificCondition(conditions, 5)) {
            filters = { filterType: 3 };
            conditions.forEach(function (dateCondtion) {
                getDateGroupItem(dateCondtion, filters);
            });
            return filters;
        }
        if (isAllSpecificCondition(conditions, 2)) {
            var isCustomFilter = false;
            if (conditions.length <= 2) {
                for (var i = 0; i < conditions.length; i++) {
                    if (conditions[i].compareType !== 0) {
                        isCustomFilter = true;
                        break;
                    }
                }
            }
            if (isCustomFilter) {
                customFilters = { filterType: 4 };
                var textCondition = conditions[0];
                op = getTextConditonOperator(textCondition.compareType);
                customFilters.filter1 = {};
                customFilters.filter1.operator = op;
                if (!common_1._isNullOrUndefined(textCondition.expected)) {
                    customFilters.filter1.value = getTextConditionValue(textCondition.expected, textCondition.compareType);
                }
                else {
                    customFilters.filter1.value = removeFormulaSymbolIfExists(textCondition.formula);
                }
                if (conditions.length === 2) {
                    textCondition = conditions[1];
                    op = getTextConditonOperator(textCondition.compareType);
                    customFilters.filter2 = {};
                    customFilters.filter2.operator = op;
                    if (!common_1._isNullOrUndefined(textCondition.expected)) {
                        customFilters.filter2.value = getTextConditionValue(textCondition.expected, textCondition.compareType);
                    }
                    else {
                        customFilters.filter2.value = removeFormulaSymbolIfExists(textCondition.formula);
                    }
                }
                customFilters.and = false;
                return customFilters;
            }
            return getCellValueConditionValue(conditions);
        }
        if (isAllSpecificCondition(conditions, 11)) {
            var isFilters = true;
            if (conditions.length <= 2) {
                isFilters = false;
            }
            if (isFilters) {
                return getCellValueConditionValue(conditions);
            }
            else if (conditions.length > 0) {
                var cellValueConditon = conditions[0];
                customFilters = { filterType: 4, filter1: { operator: cellValueConditon.compareType } };
                if (!common_1._isNullOrUndefined(cellValueConditon.expected)) {
                    customFilters.filter1.value = cellValueConditon.expected;
                }
                else {
                    customFilters.filter1.value = removeFormulaSymbolIfExists(cellValueConditon.formula);
                }
                if (conditions.length === 2) {
                    cellValueConditon = conditions[1];
                    customFilters.filter2 = { operator: cellValueConditon.compareType };
                    if (!common_1._isNullOrUndefined(cellValueConditon.expected)) {
                        customFilters.filter2.value = cellValueConditon.expected;
                    }
                    else {
                        customFilters.filter2.value = removeFormulaSymbolIfExists(cellValueConditon.formula);
                    }
                }
                customFilters.and = false;
                return customFilters;
            }
        }
        customFilters = { filterType: 4, and: false };
        var tempFilter1 = toExcelFilter(sheet, conditions[0], filterRange);
        customFilters.filter1 = tempFilter1.filter1;
        if (conditions.length > 1) {
            var tempFilter2 = toExcelFilter(sheet, conditions[1], filterRange);
            customFilters.filter2 = tempFilter2.filter1;
        }
        return customFilters;
    }
    else {
        conditions = expandRelationCondition(relationCondtion);
        if (conditions.length === 2) {
            customFilters = { filterType: 4 };
            customFilters.and = true;
            var filter1 = toExcelFilter(sheet, conditions[0], filterRange);
            if (!common_1._isNullOrUndefined(filter1) && filter1.filter1) {
                customFilters.filter1 = filter1.filter1;
            }
            else {
                return keyword_null;
            }
            var filter2 = toExcelFilter(sheet, conditions[1], filterRange);
            if (!common_1._isNullOrUndefined(filter2) && filter2.filter1) {
                customFilters.filter2 = filter2.filter1;
            }
            else {
                return keyword_null;
            }
            return customFilters;
        }
    }
}
function toExcelFilter(sheet, condition, filterRange) {
    if (sheet === keyword_null) {
        return keyword_null;
    }
    var conType = condition.conType;
    if (conType === 3) {
    }
    else if (conType === 8) {
        return getTop10Filter(sheet, condition, filterRange);
    }
    else if (conType === 10) {
        return getAverageFilter(sheet, condition, filterRange);
    }
    else if (conType === 6) {
        return getDateExFilter(condition);
    }
    else if (conType === 11 || conType === 1) {
        return getCellValueFilter(condition);
    }
    else if (conType === 2) {
        return getTextFilter(condition);
    }
    else if (conType === 5) {
        return getDateFilter(condition);
    }
    else if (conType === 0) {
        return getRelationFilter(condition, sheet, filterRange);
    }
}
function toExcelPivotFilter(condition, type) {
    var conType = condition.conType;
    if (conType === 3) {
        return getPivotTop10Filter(condition);
    }
    else if (conType === 2) {
        return getCellValuePivotFilter(condition);
    }
    else if (conType === 0) {
        return getPivotTextFilter(condition);
    }
    else if (conType === 1) {
        return getPivotDateFilter(condition, type);
    }
}
function unpackRelationCondition(condition) {
    if (common_1._isNullOrUndefined(condition)) {
        return keyword_null;
    }
    var item1 = keyword_null, item2 = keyword_null;
    var op = 0;
    if (condition.compareType === 1) {
        op = 6;
    }
    else {
        op = 7;
    }
    if (condition.item1) {
        if (condition.item1.conType === 0) {
            item1 = unpackRelationCondition(condition.item1);
        }
        else {
            item1 = unpackConditionBack(condition.item1);
        }
    }
    if (condition.item2) {
        if (condition.item2.conType === 0) {
            item2 = unpackRelationCondition(condition.item2);
        }
        else {
            item2 = unpackConditionBack(condition.item2);
        }
    }
    return new tuple_1.Tuple(item1, item2, op);
}
function unpackConditionBack(condition) {
    if (common_1._isNullOrUndefined(condition)) {
        return;
    }
    var conType = condition.conType, op, item1;
    if (conType === 0) {
        return unpackRelationCondition(condition);
    }
    else if (conType === 1 || conType === 7) {
        op = condition.compareType;
        item1 = condition.formula;
        if (common_1._isNullOrUndefined(item1)) {
            item1 = condition.expected;
        }
        return new tuple_1.Tuple(item1, keyword_null, op);
    }
    else if (conType === 4) {
        return new tuple_1.Tuple(common_1._isNullOrUndefined(condition.formula) ? condition.expected : condition.formula, keyword_null, 1);
    }
    else if (conType === 12 || conType === 5 || conType === 13) {
        item1 = getDateConditionFormula(condition);
        return new tuple_1.Tuple(item1, keyword_null, 1);
    }
    return keyword_null;
}
function getFormula(info) {
    if (info instanceof tuple_1.Tuple) {
        var complexObject = info;
        if (!common_1._isNullOrUndefined(complexObject.item1)) {
            return getFormula(complexObject.item1);
        }
    }
    else if (!common_1._isNullOrUndefined(info)) {
        return removeFormulaSymbolIfExists(info.toString());
    }
    return '';
}
function toExcelDataValidation(dataValidator, sheetName, sheetNames) {
    if (common_1._isNullOrUndefined(dataValidator)) {
        return keyword_null;
    }
    var unpackedCondition = unpackConditionBack(dataValidator.condition);
    var firstFormula = keyword_null, secondFormula = keyword_null;
    if (!common_1._isNullOrUndefined(unpackedCondition)) {
        if (!common_1._isNullOrUndefined(unpackedCondition.item1)) {
            firstFormula = getFormula(unpackedCondition.item1);
        }
        if (!common_1._isNullOrUndefined(unpackedCondition.item2)) {
            secondFormula = getFormula(unpackedCondition.item2);
        }
    }
    var result = {};
    if (isExternalRange(firstFormula, sheetName, sheetNames) || isExternalRange(secondFormula, sheetName, sheetNames)) {
        result.external = true;
    }
    var validatorType = dataValidator.type;
    result.type = validatorType;
    result.firstFormula = firstFormula;
    result.secondFormula = secondFormula;
    if (validatorType === 4 || validatorType === 5) {
        if (!common_1._isNullOrUndefined(result.firstFormula)) {
            result.firstFormula = convertToExcelOADate(result.firstFormula);
        }
        if (!common_1._isNullOrUndefined(result.secondFormula)) {
            result.secondFormula = convertToExcelOADate(result.secondFormula);
        }
    }
    result.compareOperator = dataValidator.comparisonOperator;
    result.allowBlank = dataValidator.ignoreBlank;
    result.error = dataValidator.errorMessage;
    result.errorTitle = dataValidator.errorTitle;
    result.errorStyle = dataValidator.errorStyle;
    result.prompt = dataValidator.inputMessage;
    result.showPromptBox = dataValidator.inCellDropdown;
    result.promptTitle = dataValidator.inputTitle;
    result.showErrorBox = dataValidator.showErrorMessage;
    result.showInputMessage = dataValidator.showInputMessage;
    return result;
}
function getStyleByName(styleName, spread, sheet) {
    if (sheet._namedStyleCache && sheet._namedStyleCache[styleName]) {
        return sheet._namedStyleCache[styleName];
    }
    var retStyle = common_1._StyleHelper._getByName(sheet.namedStyles, styleName);
    if (retStyle) {
        addNamedStyleToStyleCache(sheet, styleName, retStyle);
        return retStyle;
    }
    if (spread._namedStyleCache && spread._namedStyleCache[styleName]) {
        return spread._namedStyleCache[styleName];
    }
    retStyle = common_1._StyleHelper._getByName(spread.namedStyles, styleName);
    if (retStyle) {
        addNamedStyleToStyleCache(spread, styleName, retStyle);
    }
    return retStyle;
}
function processDataValidator(validators, retValue, sheetName, sheetNames) {
    validators.forEach(function (item) {
        var excelValidator = toExcelDataValidation(item, sheetName, sheetNames);
        excelValidator.ranges = item.ranges.split(', ').join(' ');
        retValue.push(excelValidator);
    });
}
var ExcelBorderStyle = {
    double: 6,
    dotted: 4,
    dashed: 3,
    solid: 1
};
function getExcelBorderStyle(slicerBorderStyle) {
    if (!slicerBorderStyle) {
        return;
    }
    var retStyle = {};
    if (slicerBorderStyle.borderColor) {
        retStyle.color = slicerBorderStyle.borderColor;
    }
    if (slicerBorderStyle.borderStyle) {
        retStyle.style = ExcelBorderStyle[slicerBorderStyle.borderStyle];
    }
    return retStyle;
}
function getExcelSlicerStyle(slicerStyle, isSlicerHeader) {
    if (!slicerStyle) {
        return;
    }
    for (var prop in slicerStyle) {
        if (slicerStyle.hasOwnProperty(prop) && prop.indexOf('border') >= 0) {
            var borderStyle = slicerStyle[prop];
            if (borderStyle) {
                slicerStyle[prop] = getExcelBorderStyle(borderStyle);
            }
        }
    }
    if (isSlicerHeader) {
        slicerStyle.isSlicerHeader = true;
    }
    return slicerStyle;
}
function setSheetDefaults(spread) {
    var sheets = spread.sheets;
    if (sheets) {
        for (var sheetName in sheets) {
            if (sheets.hasOwnProperty(sheetName)) {
                var sheet = sheets[sheetName];
                sheet.defaults = sheet.defaults || common_1._getSheetDefaults();
            }
        }
    }
}
function getPlainTextFromRichText(richText) {
    if (common_1._isNullOrUndefined(richText) || !Array.isArray(richText)) {
        return keyword_null;
    }
    var plainTextArr = [];
    for (var i = 0; i < richText.length; i++) {
        plainTextArr.push(richText[i].text ? richText[i].text : '');
    }
    return plainTextArr.join('');
}
function getTableId(tableName, tables) {
    var tableId = null;
    tables.forEach(function (table) {
        if (table.name === tableName) {
            tableId = table.id;
        }
    });
    return tableId;
}
function setStripSizeByName(customerTableStyle, name, size) {
    for (var i = 0; i < customerTableStyle.styleElements.length; i++) {
        if (customerTableStyle.styleElements[i].type === name) {
            customerTableStyle.styleElements[i].size = size;
        }
    }
}
function isTableStyleEqual(tableStyle1, tableStyle2) {
    return isEqualObject(tableStyle1, tableStyle2, excel_helper_1.isBorderEqual);
}
function hasThemeExist(stylesCache, tableStyle) {
    return stylesCache[tableStyle.name] &&
        isEqualObject(stylesCache[tableStyle.name], tableStyle, isTableStyleEqual);
}
function getDifferentStyleName(stylesCache, name) {
    var diffName = name, index = 1;
    while (stylesCache[diffName]) {
        diffName = name + '_' + index;
        index++;
    }
    return diffName;
}
function getPageMarginInExcel(margin, defaultValue) {
    var value = defaultValue;
    if (value !== null && value !== undefined) {
        value = margin;
    }
    return (margin / 96).toFixed(2);
}
function handleTableSheetCustomNames(currentSheetTab) {
    var currentCustomNames = currentSheetTab.names;
    if (currentCustomNames) {
        for (var index = 0; index < currentCustomNames.length; index++) {
            if (currentCustomNames[index].name === '@') {
                currentCustomNames.splice(index, 1);
                break;
            }
        }
    }
}
function moveTableSheetColumnHeaderToViewport(currentSheetTab) {
    currentSheetTab.rowCount += 1;
    var sheetModelJson = currentSheetTab.data;
    var dataTable = sheetModelJson.dataTable;
    if (!dataTable) {
        dataTable = sheetModelJson.dataTable = {};
    }
    for (var r = currentSheetTab.rowCount - 1; r >= 0; r--) {
        if (dataTable[r]) {
            dataTable[r + 1] = dataTable[r];
        }
    }
    var colHeaderData_dataTable = currentSheetTab.colHeaderData.dataTable;
    if (colHeaderData_dataTable) {
        dataTable[0] = colHeaderData_dataTable[0];
    }
    else {
        dataTable[0] = {};
    }
    if (currentSheetTab.frozenRowCount > 0) {
        currentSheetTab.frozenRowCount += 1;
        currentSheetTab.topCellIndex += 1;
    }
}
function addTableForWholeTableSheet(currentSheetTab) {
    var columns = [];
    var sheetModelJson = currentSheetTab.data;
    var dataTable = sheetModelJson.dataTable;
    var columnHeaderRowJson = dataTable[0];
    for (var columnIndex = 0; columnIndex < currentSheetTab.columnCount; columnIndex++) {
        var columnObject = { id: columnIndex + 1 };
        var currentHeaderJson = columnHeaderRowJson[columnIndex];
        columnObject.name = currentHeaderJson && currentHeaderJson.value || ('Column' + (columnIndex + 1));
        columns.push(columnObject);
    }
    currentSheetTab.tables = [{
            name: currentSheetTab.name,
            row: 0,
            col: 0,
            rowCount: currentSheetTab.rowCount,
            colCount: currentSheetTab.columnCount,
            rowFilter: {
                range: {
                    row: 1,
                    col: 0,
                    rowCount: currentSheetTab.rowCount - 1,
                    colCount: currentSheetTab.columnCount,
                },
                showFilterButton: true
            },
            columns: columns
        }];
}
function generateStyleName(styleName, sheetName) {
    var tmp = styleName;
    if (tmp.length > 255) {
        tmp = tmp.slice(-240);
    }
    else {
        tmp = sheetName + ' ' + tmp;
        if (tmp.length > 250) {
            tmp = styleName + ' ' + Math.random().toString(36).slice(-6);
        }
    }
    return tmp;
}
function convertTableSheetToTable(currentSheetTab) {
    moveTableSheetColumnHeaderToViewport(currentSheetTab);
    delete currentSheetTab.rowFilter;
    addTableForWholeTableSheet(currentSheetTab);
}
var WriterDataModel = /** @class */ (function () {
    function WriterDataModel(spread) {
        var self = this;
        self._handleTableSheetJson(spread);
        self._spread = spread;
        self._namedStyleTable = {};
        self._customerTableStyles = [];
        self._customerTableStylesCache = {};
        self._customerSlicerStyles = [];
        self._customerSlicerStylesCache = {};
        self._composeStylesCache = {};
        self._styles = [];
        self._namedStyles = [];
        self._workbookCells = {};
        self._stylesForXfidCache = {};
        self._cellStyleTable = {};
        self._rowStyleTable = {};
        self._columnStyleTable = {};
        self._autoRowHeight = {};
        self._notEmptyRows = {};
        self._dxfRecords = [];
        self._dxfSlicerRecords = [];
        self._dynamicArrayLevel = 0;
        self._persons = {};
        self._threadedCommentIds = {};
        self._hyperlinks = {};
        self._pivotNumberFormats = [];
    }
    WriterDataModel.prototype._handleTableSheetJson = function (spread) {
        spread.sheetCount = (spread.sheetCount || 0) + (spread.sheetTabCount || 0);
        var activeSheetIndex = spread.activeSheetIndex, activeSheetTabIndex = spread.activeSheetTabIndex;
        if ((activeSheetIndex === undefined || activeSheetIndex < 0) && (activeSheetTabIndex !== undefined && activeSheetTabIndex >= 0)) {
            spread.activeSheetIndex = activeSheetTabIndex;
        }
        var sheetTabs = spread.sheetTabs;
        if (sheetTabs) {
            for (var name_1 in sheetTabs) {
                if (sheetTabs.hasOwnProperty(name_1)) {
                    var currentSheetTab = sheetTabs[name_1];
                    convertTableSheetToTable(currentSheetTab);
                    handleTableSheetCustomNames(currentSheetTab);
                }
            }
            var sheets = spread.sheets;
            if (sheets) {
                for (var name_2 in sheetTabs) {
                    if (sheetTabs.hasOwnProperty(name_2)) {
                        sheets[name_2] = sheetTabs[name_2];
                    }
                }
            }
            else {
                spread.sheets = sheetTabs;
            }
        }
        if (spread.startSheetIndex === undefined) {
            spread.startSheetIndex = 0;
        }
    };
    WriterDataModel.prototype._initStyle = function () {
        var defaultStyle = excel_style_1.DefaultStyle._getDefaultStyle(this._spread);
        this._namedStyleTable.Normal = 0;
        this._styles.push(defaultStyle);
        this._namedStyles.push(defaultStyle);
        this._stylesForXfidCache[defaultStyle.name] = this._styles.length - 1;
    };
    WriterDataModel.prototype._initCacheCollections = function (sheet) {
        var sheetIndex = sheet.index;
        if (!this._workbookCells[sheetIndex]) {
            this._workbookCells[sheetIndex] = {};
        }
        if (!this._cellStyleTable[sheetIndex]) {
            this._cellStyleTable[sheetIndex] = {};
        }
        if (!this._rowStyleTable[sheetIndex]) {
            this._rowStyleTable[sheetIndex] = {};
        }
        if (!this._columnStyleTable[sheetIndex]) {
            this._columnStyleTable[sheetIndex] = {};
        }
        if (!this._autoRowHeight[sheetIndex]) {
            this._autoRowHeight[sheetIndex] = {};
        }
    };
    WriterDataModel.prototype._updateFileList = function (types, xFile) {
        if (!types || !xFile) {
            return false;
        }
        var result = true;
        if (!common_1.StringEx._isNullOrEmpty(xFile.fileName)) {
            var type = this._convertRelationshipType2ContentType(xFile.fileType);
            if (!common_1.StringEx._isNullOrEmpty(type)) {
                var overrideType = new excel.OverrideContentType();
                overrideType.partName = xFile.fileName;
                overrideType.contentType = type;
                var isExist = false;
                for (var i = 0, len = types.length; i < len; i++) {
                    var item = types[i];
                    if (item instanceof excel.OverrideContentType && item.contentType === overrideType.contentType && item.partName === overrideType.partName) {
                        isExist = true;
                        break;
                    }
                }
                if (!isExist) {
                    types.push(overrideType);
                }
            }
        }
        if (xFile.relationFiles && xFile.relationFiles.count > 0) {
            for (var key in xFile.relationFiles) {
                if (xFile.relationFiles.hasOwnProperty(key) && key !== 'count') {
                    result = result && this._updateFileList(types, xFile.relationFiles[key]);
                }
            }
        }
        return result;
    };
    WriterDataModel.prototype._convertRelationshipType2ContentType = function (relationType) {
        if (common_1.StringEx._isNullOrEmpty(relationType)) {
            return '';
        }
        switch (relationType) {
            case excel_types_1.RelationshipConstants._relationshipSharedStringsType:
                return excel_types_1.XFileConstants._sharedStringType;
            case excel_types_1.RelationshipConstants._relationshipStylesType:
                return excel_types_1.XFileConstants._stylesType;
            case excel_types_1.RelationshipConstants._relationshipThemeType:
                return excel_types_1.XFileConstants._themeType;
            case excel_types_1.RelationshipConstants._relationshipWorkbookType:
                return excel_types_1.XFileConstants._workbookType;
            case excel_types_1.RelationshipConstants._relationshipWorksheetType:
                return excel_types_1.XFileConstants._worksheetType;
            case excel_types_1.RelationshipConstants._relationshipExternalLinkType:
                return excel_types_1.XFileConstants._externalLinkType;
            case excel_types_1.RelationshipConstants._relationshipTableType:
                return excel_types_1.XFileConstants._tableType;
            case excel_types_1.RelationshipConstants._relationshipCommentType:
                return excel_types_1.XFileConstants._commentsType;
            case excel_types_1.RelationshipConstants._relationshipDrawingType:
                return excel_types_1.XFileConstants._drawingType;
            case excel_types_1.RelationshipConstants._relationshipSlicerType:
                return excel_types_1.XFileConstants._slicerType;
            case excel_types_1.RelationshipConstants._relationshipSlicerCacheType:
                return excel_types_1.XFileConstants._slicerCacheType;
            case excel_types_1.RelationshipConstants._relationshipChartType:
                return excel_types_1.XFileConstants._chartType;
            case excel_types_1.RelationshipConstants._relationshipNewChartType:
                return excel_types_1.XFileConstants._chart2016Type;
            case excel_types_1.RelationshipConstants._realationshipChartColorStyle:
                return excel_types_1.XFileConstants._chart2016Colors;
            case excel_types_1.RelationshipConstants._realationshipChartStyle:
                return excel_types_1.XFileConstants._chart2016Style;
            case excel_types_1.RelationshipConstants._realationshipChartUserShapes:
                return excel_types_1.XFileConstants._chartShapes;
            case excel_types_1.RelationshipConstants._relationshipSheetMetadata:
                return excel_types_1.XFileConstants._sheetMetadata;
            case excel_types_1.RelationshipConstants._relationshipDocPropsCoreType:
                return excel_types_1.XFileConstants._docPropsCore;
            case excel_types_1.RelationshipConstants._relationshipDocPropsAppType:
                return excel_types_1.XFileConstants._docPropsApp;
            case excel_types_1.RelationshipConstants._relationshipDocPropsCustomType:
                return excel_types_1.XFileConstants._docPropsCustom;
            case excel_types_1.RelationshipConstants._relationshipPivotCacheDefinitionType:
                return excel_types_1.XFileConstants._pivotDefinitionType;
            case excel_types_1.RelationshipConstants._relationshipPivotCacheRecordsType:
                return excel_types_1.XFileConstants._pivotCacheRecordsType;
            case excel_types_1.RelationshipConstants._relationshipPivotTableType:
                return excel_types_1.XFileConstants._pivotTableType;
            default:
                return '';
        }
    };
    WriterDataModel.prototype._preProcessWorkbook = function () {
        var self = this, spread = self._spread;
        self._initStyle();
        self._preProcessNamedStyle();
        for (var sheetName in spread.sheets) {
            if (spread.sheets.hasOwnProperty(sheetName)) {
                var sheet = spread.sheets[sheetName];
                if (!sheet) {
                    continue;
                }
                self._setDefaultValue(sheet);
                self._initCacheCollections(sheet);
                self._preProcessCells(sheet);
                self._preprocessRowsVisibleInfo(sheet);
                self._preprocessColumnVisibleInfo(sheet);
                self._preProcessColumnStyles(sheet);
                self._preProcessDifferentConditionalFormats(sheet);
            }
        }
        setSheetDefaults(self._spread);
    };
    WriterDataModel.prototype._triggerOnCompleted = function () {
        var _this = this;
        if (_this.onCompleted) {
            _this.onCompleted();
        }
    };
    WriterDataModel.prototype._preProcessDifferentConditionalFormats = function (sheet) {
        var rules = sheet.conditionalFormats && sheet.conditionalFormats.rules;
        if (rules) {
            for (var i = 0; i < rules.length; i++) {
                var rule = rules[i];
                if (rule.style) {
                    rule.style.isPartFontStyle = true;
                    rule.style.isFormatStyle = true;
                    rule.dxfId = this._addDifferentConditionalFormat(rule.style);
                }
            }
        }
        sheet._colorFilterColumns = this._getColorFilter(sheet);
        this._preProcessTableStyle(sheet);
        this._preProcessPivotTableStyle(sheet);
        this._preProcessSortInfo(sheet);
        this._preProcessSlicerStyle(sheet);
    };
    WriterDataModel.prototype._addDifferentConditionalFormat = function (style) {
        var self = this;
        var index = self._dxfRecords.indexOf(style);
        if (index === -1) {
            index = self._dxfRecords.length;
            self._dxfRecords.push(style);
        }
        return index;
    };
    WriterDataModel.prototype._addDifferentConditionalFormatSlicer = function (style) {
        var self = this;
        var index = self._dxfSlicerRecords.indexOf(style);
        if (index === -1) {
            index = self._dxfSlicerRecords.length;
            self._dxfSlicerRecords.push(style);
        }
        return index;
    };
    WriterDataModel.prototype._preProcessSlicerStyle = function (sheet) {
        var self = this;
        var slicers = sheet.slicers;
        var tables = self._getTables();
        if (slicers && slicers.length > 0) {
            slicers.forEach(function (slicer) {
                var slicerTheme = slicer && slicer.style;
                if (!common_1._isNullOrUndefined(slicerTheme.name)) {
                    var customerTableStyle = {};
                    if (!hasThemeExist(self._customerTableStylesCache, slicerTheme)) {
                        customerTableStyle = {
                            styleElements: [],
                            name: getDifferentStyleName(self._customerTableStylesCache, slicerTheme.name)
                        };
                        slicerTheme.name = customerTableStyle.name;
                        for (var styleType in slicerTheme) {
                            if (slicerTheme.hasOwnProperty(styleType) && styleType !== 'name' && !common_1._isNullOrUndefined(slicerTheme[styleType])) {
                                switch (styleType) {
                                    case 'headerStyle':
                                    case 'wholeSlicerStyle':
                                        var styleElement = {};
                                        styleElement.type = styleType;
                                        styleElement.dxfId = self._addDifferentConditionalFormat(getExcelSlicerStyle(slicerTheme[styleType], styleType === 'headerStyle'));
                                        styleElement.tableId = getTableId(slicer.tableName, tables);
                                        customerTableStyle.styleElements.push(styleElement);
                                }
                            }
                        }
                        self._customerTableStyles.push(customerTableStyle);
                    }
                    if (!hasThemeExist(self._customerSlicerStylesCache, slicerTheme)) {
                        var customerSlicerStyle = {
                            styleElements: [],
                            name: getDifferentStyleName(self._customerTableStylesCache, slicerTheme.name)
                        };
                        slicerTheme.name = customerTableStyle.name;
                        for (var type in slicerTheme) {
                            if (slicerTheme.hasOwnProperty(type) && type !== 'name' && !common_1._isNullOrUndefined(slicerTheme[type])) {
                                switch (type) {
                                    case 'selectedItemWithDataStyle':
                                    case 'selectedItemWithNoDataStyle':
                                    case 'unSelectedItemWithDataStyle':
                                    case 'unSelectedItemWithNoDataStyle':
                                    case 'hoveredSelectedItemWithDataStyle':
                                    case 'hoveredSelectedItemWithNoDataStyle':
                                    case 'hoveredUnSelectedItemWithDataStyle':
                                    case 'hoveredUnSelectedItemWithNoDataStyle':
                                        customerSlicerStyle.styleElements.push({
                                            type: type,
                                            dxfId: self._addDifferentConditionalFormatSlicer(getExcelSlicerStyle(slicerTheme[type]))
                                        });
                                        break;
                                }
                            }
                        }
                        self._customerSlicerStyles.push(customerSlicerStyle);
                        self._customerSlicerStylesCache[customerSlicerStyle.name] = slicerTheme;
                    }
                }
            });
        }
    };
    WriterDataModel.prototype._preProcessTableStyle = function (sheet) {
        var self = this;
        function setCustomTableStyles(sheetTable, isPivot) {
            var tableTheme = sheetTable && sheetTable.style;
            if (!common_1._isNullOrUndefined(tableTheme && tableTheme.name)) {
                if (hasThemeExist(self._customerTableStylesCache, tableTheme)) {
                    return;
                }
                var customerTableStyle = { styleElements: [] };
                customerTableStyle.name = getDifferentStyleName(self._customerTableStylesCache, tableTheme.name);
                tableTheme.name = customerTableStyle.name;
                var firstRowStripSize = void 0, secondRowStripSize = void 0, firstColumnStripSize = void 0, secondColumnStripSize = void 0;
                for (var styleType in tableTheme) {
                    if (tableTheme.hasOwnProperty(styleType) && styleType !== 'name' && tableTheme[styleType] !== undefined) {
                        switch (styleType) {
                            case 'firstRowStripSize':
                                firstRowStripSize = tableTheme[styleType];
                                break;
                            case 'secondRowStripSize':
                                secondRowStripSize = tableTheme[styleType];
                                break;
                            case 'firstColumnStripSize':
                                firstColumnStripSize = tableTheme[styleType];
                                break;
                            case 'secondColumnStripSize':
                                secondColumnStripSize = tableTheme[styleType];
                                break;
                            default:
                                var styleElement = {};
                                styleElement.type = styleType;
                                tableTheme[styleType].isPartFontStyle = true;
                                styleElement.dxfId = self._addDifferentConditionalFormat(tableTheme[styleType]);
                                customerTableStyle.styleElements.push(styleElement);
                        }
                    }
                }
                setStripSizeByName(customerTableStyle, 'firstRowStripStyle', firstRowStripSize || 1);
                setStripSizeByName(customerTableStyle, 'secondRowStripStyle', secondRowStripSize || 1);
                setStripSizeByName(customerTableStyle, 'firstColumnStripStyle', firstColumnStripSize || 1);
                setStripSizeByName(customerTableStyle, 'secondColumnStripStyle', secondColumnStripSize || 1);
                setStripSizeByName(customerTableStyle, 'firstRowStripeStyle', firstRowStripSize || 1);
                setStripSizeByName(customerTableStyle, 'secondRowStripeStyle', secondRowStripSize || 1);
                setStripSizeByName(customerTableStyle, 'firstColumnStripeStyle', firstColumnStripSize || 1);
                setStripSizeByName(customerTableStyle, 'secondColumnStripeStyle', secondColumnStripSize || 1);
                customerTableStyle.isPivot = isPivot;
                self._customerTableStyles.push(customerTableStyle);
                self._customerTableStylesCache[customerTableStyle.name] = tableTheme;
            }
        }
        var pivotTables = sheet.pivotTables;
        if (pivotTables && pivotTables.length > 0) {
            pivotTables.forEach(function (sheetTable) { return setCustomTableStyles(sheetTable, true); });
        }
        var tables = sheet.tables;
        if (tables && tables.length > 0) {
            tables.forEach(function (sheetTable) { return setCustomTableStyles(sheetTable, false); });
        }
    };
    WriterDataModel.prototype._preProcessPivotTableStyle = function (sheet) {
        var self = this;
        var pivotTables = sheet.pivotTables;
        if (pivotTables && pivotTables.length > 0) {
            pivotTables.forEach(function (pivotTable) {
                if (!common_1._isNullOrUndefined(pivotTable.formats) && pivotTable.formats.length > 0) {
                    pivotTable.formats.forEach(function (format) {
                        if (!common_1._isNullOrUndefined(format.style)) {
                            format.dxfId = self._addDifferentConditionalFormat(format.style);
                            if (format.style && !common_1._isNullOrUndefined(format.style.formatter)) {
                                var formatString = format.style.formatter, result = {};
                                var ret = excel_style_1.ExtendedNumberFormatHelper.getFormatId(formatString);
                                var id = ret.id, isBuiltIn = ret.isBuiltIn;
                                if (isBuiltIn) {
                                    result.numberFormatIndex = id;
                                    format.style.numberFormatId = id;
                                }
                                else {
                                    result.numberFormat = new excel_style_1.ExcelNumerFormat(id, formatString);
                                    format.style.numberFormatId = result.numberFormat.numberFormatId;
                                }
                                self._pivotNumberFormats.push(result);
                            }
                        }
                    });
                }
                if (!common_1._isNullOrUndefined(pivotTable.fields) && pivotTable.fields.length > 0) {
                    pivotTable.fields.forEach(function (field) {
                        if (!common_1._isNullOrUndefined(field.numberFormat)) {
                            var formatString = field.numberFormat, result = {};
                            var ret = excel_style_1.ExtendedNumberFormatHelper.getFormatId(formatString);
                            var id = ret.id, isBuiltIn = ret.isBuiltIn;
                            if (isBuiltIn) {
                                result.numberFormatIndex = id;
                                field.numberFormatId = id;
                            }
                            else {
                                result.numberFormat = new excel_style_1.ExcelNumerFormat(id, formatString);
                                field.numberFormatId = result.numberFormat.numberFormatId;
                            }
                            self._pivotNumberFormats.push(result);
                        }
                    });
                }
                if (!common_1._isNullOrUndefined(pivotTable.dataFields) && pivotTable.dataFields.length > 0) {
                    pivotTable.dataFields.forEach(function (field) {
                        if (!common_1._isNullOrUndefined(field.numberFormat)) {
                            var formatString = field.numberFormat, result = {};
                            var ret = excel_style_1.ExtendedNumberFormatHelper.getFormatId(formatString);
                            var id = ret.id, isBuiltIn = ret.isBuiltIn;
                            if (isBuiltIn) {
                                result.numberFormatIndex = id;
                                field.numberFormatId = id;
                            }
                            else {
                                result.numberFormat = new excel_style_1.ExcelNumerFormat(id, formatString);
                                field.numberFormatId = result.numberFormat.numberFormatId;
                            }
                            self._pivotNumberFormats.push(result);
                        }
                    });
                }
            });
        }
    };
    WriterDataModel.prototype._preProcessSortInfo = function (sheet) {
        var tables = sheet.tables, len = tables ? tables.length : 0, tableSortInfo = {};
        for (var i = 0; i < len; i++) {
            tables[i].tableSortInfo = this._getSortInfo(tables[i].rowFilter);
        }
        sheet._tableSortInfo = tableSortInfo;
        if (sheet.rowFilter) {
            sheet.rowFilter.autoFilterSortInfo = this._getSortInfo(sheet.rowFilter);
        }
    };
    WriterDataModel.prototype._preprocessRowsVisibleInfo = function (sheet) {
        var self = this, rows = sheet.rows, defaultRowHeight = getSheetDefaultRowHeight(sheet);
        sheet.rowsVisibleInfo = {};
        for (var row = 0; row < sheet.rowCount; row++) {
            sheet.rowsVisibleInfo[row] = {};
            sheet.rowsVisibleInfo[row].size = rows && rows[row] && rows[row].size || defaultRowHeight;
            sheet.rowsVisibleInfo[row].visible = self._getRowVisibleInfo(sheet, row);
        }
    };
    WriterDataModel.prototype._preprocessColumnVisibleInfo = function (sheet) {
        var columns = sheet.columns, defaultColumnWidth = getSheetDefaultColumnWidth(sheet), colRangeGroup = sheet.columnOutlines;
        sheet.columnVisibleInfo = {};
        for (var col = 0; col < sheet.columnCount; col++) {
            sheet.columnVisibleInfo[col] = {};
            var column = columns && columns[col];
            sheet.columnVisibleInfo[col].size = column && column.size || defaultColumnWidth;
            if (column && column.visible === false) {
                sheet.columnVisibleInfo[col].visible = false;
            }
            if (excel_helper_1.isCollapsed(col, colRangeGroup)) {
                sheet.columnVisibleInfo[col].visible = false;
            }
        }
    };
    WriterDataModel.prototype._setDefaultValue = function (sheet) {
        if (sheet.rowCount === keyword_undefined) {
            sheet.rowCount = 200;
        }
        if (sheet.columnCount === keyword_undefined) {
            sheet.columnCount = 20;
        }
        if (sheet.activeRow === keyword_undefined) {
            sheet.activeRow = 0;
        }
        if (sheet.activeCol === keyword_undefined) {
            sheet.activeCol = 0;
        }
        if (sheet.visible === keyword_undefined) {
            sheet.visible = true;
        }
    };
    WriterDataModel.prototype._preProcessColumnStyles = function (sheet) {
        var sheetIndex = sheet.index, columnStyleTable = this._columnStyleTable[sheetIndex], columnCount = sheet.columnCount;
        var currentSheetStyle = sheet.data && sheet.data.defaultDataNode && sheet.data.defaultDataNode.style;
        for (var col = 0; col < columnCount; col++) {
            var styleObject = this._getStyleObject(sheet, -1, col);
            this._processRowOrColumnStyle(sheet, columnStyleTable, col, styleObject, currentSheetStyle);
        }
    };
    WriterDataModel.prototype._preProcessCells = function (sheet) {
        var self = this, sheetIndex = sheet.index, dataTable = sheet.data && sheet.data.dataTable, rowDataArray = sheet.data && sheet.data.rowDataArray;
        var dynamicArrayLevel = self._dynamicArrayLevel;
        var hyperlinks = self._hyperlinks;
        if (sheet.rowCount === 0) {
            return;
        }
        var columnCount = self._getLastNonNullColumn(dataTable, sheet) + 1;
        var cellStyleTable = self._cellStyleTable[sheetIndex], rowStyleTable = self._rowStyleTable[sheetIndex];
        var columnStyles = self._getColumnStyle(sheet, columnCount), sheetRowAutoHeightCollection = self._autoRowHeight[sheetIndex];
        var defaultRowHeight = 57, maxRow = self._getCurrentSheetMaxUsedRowIndex(sheet);
        var existTableRowsArray = [];
        var tables = sheet.tables;
        if (!common_1._isNullOrUndefined(tables) && Array.isArray(tables)) {
            for (var tableIndex = 0; tableIndex < tables.length; tableIndex++) {
                var currentTable = tables[tableIndex];
                var startRow = currentTable.row, endRow = startRow + currentTable.rowCount - 1;
                for (var rowIndex = startRow; rowIndex <= endRow; rowIndex++) {
                    if (!existTableRowsArray[rowIndex]) {
                        existTableRowsArray[rowIndex] = true;
                    }
                }
            }
        }
        var currentSheetStyle = sheet.data && sheet.data.defaultDataNode && sheet.data.defaultDataNode.style;
        for (var row = 0; row <= maxRow && row >= 0; row++) {
            if (dataTable && dataTable.hasOwnProperty(row + '') || (rowDataArray && rowDataArray[row]) || existTableRowsArray[row]) {
                var currentRowStyle = self._processRowOrColumnStyle(sheet, rowStyleTable, row, self._getStyleObject(sheet, row, -1), currentSheetStyle), maxRowHeight = defaultRowHeight;
                var rowData = dataTable && dataTable[row];
                for (var column = 0; column < columnCount && column >= 0; column++) {
                    var table = findTable(sheet, row, column);
                    if (rowData && rowData.hasOwnProperty(column + '') || table) {
                        var styleKey = row * columnCount + column;
                        var styleInfo = void 0, styleName = void 0, value = keyword_null, formula = keyword_null, prefix = keyword_null, arrayInfo = keyword_null, cellData = dataTable && dataTable[row] && dataTable[row][column];
                        var richText = keyword_undefined;
                        var isSpillError = false;
                        if (cellData) {
                            formula = cellData.formula;
                            prefix = cellData.prefix;
                            arrayInfo = cellData.arrayInfo;
                            var isDynamicArray = arrayInfo && arrayInfo.isDynamicArray;
                            var jsonValue = cellData.value;
                            if (!common_1._isNullOrUndefined(jsonValue)) {
                                if (!isObject(jsonValue)) {
                                    value = jsonValue;
                                    if (isDynamicArray && dynamicArrayLevel < 1) {
                                        dynamicArrayLevel = 1;
                                    }
                                }
                                else if (Array.isArray(jsonValue)) {
                                    value = jsonValue.join(',');
                                }
                                else {
                                    richText = jsonValue.richText;
                                    if (richText) {
                                        value = getPlainTextFromRichText(richText);
                                    }
                                    isSpillError = jsonValue._code >= 99;
                                    if (isSpillError && dynamicArrayLevel < 3) {
                                        dynamicArrayLevel = isDynamicArray ? 2 : 3;
                                    }
                                }
                            }
                        }
                        var isInTable = false;
                        if (table) {
                            isInTable = true;
                            var span = findSpan(sheet, row, column);
                            if (span) {
                                removeSpan(sheet, span);
                            }
                        }
                        var ret = self._getCellStyle(sheet, row, column, cellStyleTable, columnStyles[column], currentRowStyle, currentSheetStyle, styleKey, value);
                        styleName = ret.styleName;
                        styleInfo = ret.styleInfo;
                        if (isInTable) {
                            if (table.showHeader !== false && row === table.row) {
                                value = table.columns[column - table.col] && table.columns[column - table.col].name;
                                if (value && value.indexOf('\n') !== -1 && richText) {
                                    for (var i = 0; i < richText.length; i++) {
                                        richText[i].text = common_1.Util._replaceAll(richText[i].text, '\r', '');
                                    }
                                }
                            }
                            if (table.showFooter && row === table.row + table.rowCount - 1) {
                                var tableColumn = table.columns[column - table.col];
                                value = tableColumn && tableColumn.footerValue;
                                if (!common_1._isNullOrUndefined(value)) {
                                    value = value.toString();
                                }
                            }
                        }
                        var ret1 = self._getRealCellValueForExcel(value, !common_1._isNullOrUndefined(richText));
                        var cellValue = ret1.value;
                        cellValue = convertToExcelOADate(cellValue);
                        var cellType = ret1.cellType;
                        if (styleInfo || formula || cellValue !== keyword_null || !common_1.StringEx._isNullOrEmpty(styleName)) {
                            var cell = new excel.ExcelCell(row, column);
                            cell.cellType = cellType;
                            cell.value = cellValue;
                            cell.richText = richText;
                            cell.isSpillError = isSpillError;
                            self._setCellStyle(cellStyleTable, styleKey, styleInfo, styleName, cell);
                            self._setCellFormula(formula, arrayInfo, cell);
                            self._addCellToCache(sheetIndex, row, cell);
                            self._setCellHyperlink(cell, sheet, row, column, hyperlinks);
                            if (prefix) {
                                cell.prefix = prefix;
                            }
                        }
                    }
                }
                sheetRowAutoHeightCollection[row] = maxRowHeight;
            }
        }
        self._dynamicArrayLevel = dynamicArrayLevel;
        self._composeStylesCache = {};
    };
    WriterDataModel.prototype._getCurrentSheetMaxUsedRowIndex = function (sheet) {
        var notEmptyRows = this._getNotEmptyRows(sheet);
        return Math.min(sheet.rowCount - 1, notEmptyRows.length > 0 ? notEmptyRows.length : 0);
    };
    WriterDataModel.prototype._processRowOrColumnStyle = function (sheet, styleTable, index, styleObject, currentSheetStyle) {
        var self = this;
        var styleInfo;
        if (styleObject) {
            styleInfo = self._convertStyle(sheet, styleObject);
        }
        if (!styleInfo) {
            return keyword_null;
        }
        if (styleInfo.parentName) {
            styleInfo.parentName = self._getRenamedStyleName(sheet, styleInfo.parentName);
            var parentStyle = self._styles[self._namedStyleTable[styleInfo.parentName]];
            common_1._StyleHelper._composeStyle(styleInfo, parentStyle);
        }
        self._composeCellStyle(sheet, styleInfo, currentSheetStyle);
        if (!common_1._StyleHelper._isEmptyStyleInfo(styleInfo)) {
            styleTable[index] = self._getStyleIndex(styleInfo);
            if (!styleInfo.parentName || !self.isSameStyleInfo(self._styles[self._namedStyleTable[styleInfo.parentName]], styleInfo, true)) {
                styleInfo.parentName = keyword_null;
            }
        }
        return styleObject;
    };
    WriterDataModel.prototype._moveSheetNamedStyle = function () {
        var self = this, spread = self._spread, sheets = spread.sheets;
        var spreadNamedStyleTable;
        for (var sheetName in sheets) {
            if (sheets.hasOwnProperty(sheetName)) {
                var sheet = sheets[sheetName], styles = sheet.namedStyles;
                if (styles && styles.length > 0) {
                    if (!spreadNamedStyleTable) {
                        spreadNamedStyleTable = {};
                        if (spread.namedStyles) {
                            var spreadStyles = spread.namedStyles;
                            for (var i = 0; i < spreadStyles.length; i++) {
                                spreadNamedStyleTable[spreadStyles[i].name] = 1;
                            }
                        }
                        else {
                            spread.namedStyles = [];
                        }
                    }
                    for (var i = 0; i < styles.length; i++) {
                        var style = styles[i];
                        var name_3 = style.name;
                        if (!isBuiltInValidatorStyle(name_3) && !isBuiltInTableStyle(name_3) && common_1._isNullOrUndefined(WriterDataModel._builtInStyle[name_3])) {
                            var tmpName = style.name;
                            while (spreadNamedStyleTable[tmpName] || tmpName.length > 255) {
                                tmpName = generateStyleName(tmpName, sheet.name);
                            }
                            style.name = tmpName;
                            spread.namedStyles.push(style);
                            spreadNamedStyleTable[tmpName] = 1;
                            if (name_3 !== tmpName) {
                                sheet.renamedStyles = sheet.renamedStyles || {};
                                sheet.renamedStyles[name_3] = tmpName;
                            }
                        }
                    }
                }
            }
        }
    };
    WriterDataModel.prototype._preProcessNamedStyle = function () {
        var self = this, spread = self._spread, processedNamesStyle = {}, fakeNamedStyles = [];
        processedNamesStyle.Normal = {};
        self._moveSheetNamedStyle();
        self._preProcessNamedStyles(spread.namedStyles, processedNamesStyle, fakeNamedStyles);
        var builtInStyles = excel_style_1.BuiltInExcelStyles.getBuiltInStyles();
        var builtInStyleCollection = [];
        for (var i = 0, len = builtInStyles.length; i < len; i++) {
            var item = builtInStyles[i];
            var styleInfo = excel_style_1.ConverterHelper.toCellStyle(item.format());
            styleInfo.name = item.name;
            builtInStyleCollection.push(styleInfo);
        }
        this._preProcessNamedStyles(builtInStyleCollection, processedNamesStyle, fakeNamedStyles);
        var style;
        for (var i = 0, len = self._namedStyles.length; i < len; i++) {
            style = self._namedStyles[i];
            if (style && style.parentName) {
                common_1._StyleHelper._setActualStyle(self._namedStyles, style);
            }
        }
        for (var i = 0, len = self._styles.length; i < len; i++) {
            style = self._styles[i];
            var newStyle = excel_style_1.ConverterHelper.cloneSpreadJSStyle(style);
            newStyle.parentName = style.name;
            newStyle.name = keyword_undefined;
            self._namedStyleTable[style.name] = self._styles.length;
            self._styles.push(newStyle);
            var foundStyle = self.getEqualStyle(style, fakeNamedStyles);
            if (foundStyle) {
                self._namedStyleTable[foundStyle.name] = self._namedStyleTable[style.name];
                foundStyle.added = true;
            }
        }
        var normalStyle = common_1._StyleHelper._getByName(spread.namedStyles, 'Normal');
        for (var i = 0, len = fakeNamedStyles.length; i < len; i++) {
            var fakeStyle = fakeNamedStyles[i];
            if (!fakeStyle.added) {
                if (self.isSameStyleInfo(fakeStyle, normalStyle)) {
                    self._namedStyleTable[fakeStyle.name] = 0;
                }
                else {
                    self._namedStyleTable[fakeStyle.name] = self._styles.length;
                    self._styles.push(fakeStyle);
                }
            }
        }
    };
    WriterDataModel.prototype.isSameStyleInfo = function (style, comparedStyle, ignoreParent) {
        if (!style && !comparedStyle) {
            return true;
        }
        if (!style || !comparedStyle) {
            return false;
        }
        var styleFormat, comparedStyleFormat;
        if (!style._cache) {
            style._cache = { _styleFormat: excel_style_1.ConverterHelper.toExtendedFormat(style, this) };
        }
        styleFormat = style._cache._styleFormat;
        if (!comparedStyle._cache) {
            comparedStyle._cache = { _styleFormat: excel_style_1.ConverterHelper.toExtendedFormat(comparedStyle, this) };
        }
        comparedStyleFormat = comparedStyle._cache._styleFormat;
        return styleFormat.equals(comparedStyleFormat, ignoreParent);
    };
    WriterDataModel.prototype.getEqualStyle = function (style, styleArray) {
        for (var i = 0; i < styleArray.length; i++) {
            var styleItem = styleArray[i];
            if (this.isSameStyleInfo(style, styleItem, true)) {
                return styleItem;
            }
        }
        return keyword_null;
    };
    WriterDataModel.prototype._preProcessNamedStyles = function (namedStyles, processedNamesStyle, fakeNamedStyles) {
        function getStyleString(a) {
            var str = '';
            var aProps = Object.getOwnPropertyNames(a);
            for (var j = 0; j < aProps.length; j++) {
                var propName = aProps[j];
                if (isObject(a[propName])) {
                    str += propName + ':' + JSON.stringify(a[propName]) + '_';
                }
                else if (propName !== 'name') {
                    str += propName + ':' + a[propName] + '_';
                }
            }
            return str;
        }
        if (!namedStyles) {
            return;
        }
        var cache = {};
        for (var i = 0, len = namedStyles.length; i < len; i++) {
            var namedStyle = namedStyles[i], styleName = namedStyle.name;
            if (!processedNamesStyle[styleName]) {
                processedNamesStyle[styleName] = {};
                if (!isBuiltInValidatorStyle(styleName) && !isBuiltInTableStyle(styleName)) {
                    if (styleName.indexOf(const_builtInStyle) >= 0) {
                        fakeNamedStyles.push(namedStyle);
                    }
                    else {
                        var styleStr = getStyleString(namedStyle);
                        if (cache.hasOwnProperty(styleStr)) {
                            this._stylesForXfidCache[namedStyle.name] = cache[styleStr];
                        }
                        else {
                            this._styles.push(namedStyle);
                            this._namedStyles.push(namedStyle);
                            this._stylesForXfidCache[namedStyle.name] = this._styles.length - 1;
                            if (!WriterDataModel._builtInStyle[namedStyle.name]) {
                                cache[styleStr] = this._styles.length - 1;
                            }
                        }
                    }
                }
            }
        }
    };
    WriterDataModel.prototype._getStyleObject = function (sheet, row, col) {
        var data = sheet.data, style = keyword_null;
        if (!data) {
            return keyword_null;
        }
        if (row < 0 && col >= 0) {
            style = (data.columnDataArray && data.columnDataArray[col]) ? data.columnDataArray[col].style : keyword_null;
        }
        else if (row >= 0 && col < 0) {
            style = (data.rowDataArray && data.rowDataArray[row]) ? data.rowDataArray[row].style : keyword_null;
        }
        else if (row >= 0 && col >= 0) {
            style = (data.dataTable && data.dataTable[row] && data.dataTable[row][col]) ? sheet.data.dataTable[row][col].style : keyword_null;
        }
        return style;
    };
    WriterDataModel.prototype._getTheme = function () {
        var spread = this._spread, theme = keyword_null;
        for (var sheetName in spread.sheets) {
            if (spread.sheets.hasOwnProperty(sheetName)) {
                var sheet = spread.sheets[sheetName];
                if (sheet && sheet.theme) {
                    theme = sheet.theme;
                    break;
                }
            }
        }
        if (!theme) {
            return keyword_null;
        }
        if (isString(theme)) {
            return theme;
        }
        var themeName = theme.name;
        if (common_1.StringEx._isNullOrWhiteSpace(themeName)) {
            return keyword_null;
        }
        if (themeName.toUpperCase() === 'OFFICE') {
            themeName = 'Office Theme';
        }
        return new excel.ExcelTheme(themeName, this._getThemeColorScheme(theme), this._getFontScheme(theme));
    };
    WriterDataModel.prototype._getThemeColorScheme = function (theme) {
        var colors = [];
        colors.push(fromColorToExcelColor(theme.themeColor.background1));
        colors.push(fromColorToExcelColor(theme.themeColor.text1));
        colors.push(fromColorToExcelColor(theme.themeColor.background2));
        colors.push(fromColorToExcelColor(theme.themeColor.text2));
        colors.push(fromColorToExcelColor(theme.themeColor.accent1));
        colors.push(fromColorToExcelColor(theme.themeColor.accent2));
        colors.push(fromColorToExcelColor(theme.themeColor.accent3));
        colors.push(fromColorToExcelColor(theme.themeColor.accent4));
        colors.push(fromColorToExcelColor(theme.themeColor.accent5));
        colors.push(fromColorToExcelColor(theme.themeColor.accent6));
        colors.push(fromColorToExcelColor(theme.themeColor.hyperlink));
        colors.push(fromColorToExcelColor(theme.themeColor.followedHyperlink));
        return new excel.ColorScheme(theme.themeColor.name, colors);
    };
    WriterDataModel.prototype._getFontScheme = function (theme) {
        var majorFonts = new excel.ThemeFonts([new excel.RunFormatting(0, theme.headingFont)], []);
        var minorFonts = new excel.ThemeFonts([new excel.RunFormatting(0, theme.bodyFont)], []);
        return new excel.FontScheme(theme.name, majorFonts, minorFonts);
    };
    WriterDataModel.prototype._getColumnIndexInA1LetterForm = function (column) {
        column = Math.min(column, excel_types_1.ExcelConstants._openXmlMaxColumn - 1);
        return common_1.IndexHelper._getColumnIndexInA1Letter(column);
    };
    WriterDataModel.prototype._getContentTypes = function (rootVirtualFile, withVmlDrawingFiles) {
        var types = [];
        var defaultType = new excel_types_1.DefaultContentType();
        defaultType.extension = excel_types_1.XFileConstants._binExtension;
        defaultType.contentType = excel_types_1.XFileConstants._binType;
        types.push(defaultType);
        defaultType = new excel_types_1.DefaultContentType();
        defaultType.extension = excel_types_1.XFileConstants._relsExtension;
        defaultType.contentType = excel_types_1.XFileConstants._relsType;
        types.push(defaultType);
        defaultType = new excel_types_1.DefaultContentType();
        defaultType.extension = excel_types_1.XFileConstants._xmlExtension;
        defaultType.contentType = excel_types_1.XFileConstants._xmlType;
        types.push(defaultType);
        if (withVmlDrawingFiles) {
            defaultType = new excel_types_1.DefaultContentType();
            defaultType.extension = excel_types_1.XFileConstants._vmlExtension;
            defaultType.contentType = excel_types_1.XFileConstants._vmlDrawingsType;
            types.push(defaultType);
        }
        defaultType = new excel_types_1.DefaultContentType();
        defaultType.extension = excel_types_1.XFileConstants._jpgExtension;
        defaultType.contentType = excel_types_1.XFileConstants._jpgType;
        types.push(defaultType);
        defaultType = new excel_types_1.DefaultContentType();
        defaultType.extension = excel_types_1.XFileConstants._tiffExtension;
        defaultType.contentType = excel_types_1.XFileConstants._tiffType;
        types.push(defaultType);
        defaultType = new excel_types_1.DefaultContentType();
        defaultType.extension = excel_types_1.XFileConstants._jpegExtension;
        defaultType.contentType = excel_types_1.XFileConstants._jpegType;
        types.push(defaultType);
        defaultType = new excel_types_1.DefaultContentType();
        defaultType.extension = excel_types_1.XFileConstants._pngExtension;
        defaultType.contentType = excel_types_1.XFileConstants._pngType;
        types.push(defaultType);
        defaultType = new excel_types_1.DefaultContentType();
        defaultType.extension = excel_types_1.XFileConstants._bmpExtension;
        defaultType.contentType = excel_types_1.XFileConstants._bmpType;
        types.push(defaultType);
        defaultType = new excel_types_1.DefaultContentType();
        defaultType.extension = excel_types_1.XFileConstants._gifExtension;
        defaultType.contentType = excel_types_1.XFileConstants._gifType;
        types.push(defaultType);
        defaultType = new excel_types_1.DefaultContentType();
        defaultType.extension = excel_types_1.XFileConstants._svgExtension;
        defaultType.contentType = excel_types_1.XFileConstants._svgType;
        types.push(defaultType);
        defaultType = new excel_types_1.DefaultContentType();
        defaultType.extension = excel_types_1.XFileConstants._emfExtension;
        defaultType.contentType = excel_types_1.XFileConstants._emfType;
        types.push(defaultType);
        defaultType = new excel_types_1.DefaultContentType();
        defaultType.extension = excel_types_1.XFileConstants._wmfExtension;
        defaultType.contentType = excel_types_1.XFileConstants._wmfType;
        types.push(defaultType);
        var result = this._updateFileList(types, rootVirtualFile);
        if (!result) {
            return keyword_null;
        }
        return types;
    };
    WriterDataModel.prototype._getCells = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        return this._workbookCells[sheet.index];
    };
    WriterDataModel.prototype._getNonEmptyRows = function (sheetName) {
        var self = this, result = [], spread = self._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var notEmptyRows = self._getNotEmptyRows(sheet), maxRow = Math.min(sheet.rowCount - 1, notEmptyRows.length);
        var maxRowRangeLevel = self._getMaxLevel(sheet.rowOutlines);
        for (var row = 0; row <= maxRow; row++) {
            if (notEmptyRows[row]) {
                var excelRow = self._getRow(sheet, row, maxRowRangeLevel);
                if (excelRow || excelRow.collapsed ||
                    (!common_1._isNullOrUndefined(excelRow.outLineLevel) && excelRow.outLineLevel !== 0) ||
                    excelRow.visible === false || excelRow.formatId >= 0) {
                    excelRow.customHeight = !isNaN(excelRow.height);
                    result.push(excelRow);
                }
            }
            else if (sheet.rowFilter && self._isRowFilteredOut(sheet.rowFilter, row)) {
                var excelRow = new excel.ExcelRow(row);
                excelRow.visible = false;
                result.push(excelRow);
            }
        }
        return result;
    };
    WriterDataModel.prototype._isRowFilteredOut = function (rowFilter, row) {
        var result = false;
        if (rowFilter) {
            var filteredOutRows = rowFilter.filteredOutRows;
            if (filteredOutRows) {
                for (var i = 0; i < filteredOutRows.length; i++) {
                    var rowItem = filteredOutRows[i];
                    if (row === rowItem) {
                        result = true;
                        break;
                    }
                }
            }
        }
        return result;
    };
    WriterDataModel.prototype._getRowVisibleInfo = function (sheet, row) {
        var self = this, rows = sheet.rows, rowRangeGroup = sheet.rowOutlines;
        if (rows && rows[row] && rows[row].visible === false) {
            return false;
        }
        if (excel_helper_1.isCollapsed(row, rowRangeGroup)) {
            return false;
        }
        var rowFilter = sheet.rowFilter;
        if (rowFilter && row > 0 && self._isRowFilteredOut(rowFilter, row)) {
            return false;
        }
        var tables = sheet.tables;
        if (tables) {
            for (var i = 0; i < tables.length; i++) {
                var table = tables[i];
                if (self._isRowFilteredOut(table.rowFilter, row)) {
                    return false;
                }
            }
        }
        return true;
    };
    WriterDataModel.prototype._getRow = function (sheet, row, rowRangeGroupMaxLevel) {
        var self = this;
        var result = new excel.ExcelRow(row), rowRangeGroup = sheet.rowOutlines, sheetRow = sheet.rows && sheet.rows[row];
        result.height = excel_style_1.UnitHelper.pixelToPoint(sheetRow && sheetRow.size !== undefined ? sheetRow.size : getSheetDefaultRowHeight(sheet));
        if (rowRangeGroupMaxLevel >= 0) {
            result.collapsed = this._getCollapsed(row, rowRangeGroup);
            var outLineLevel = this._getLevelInternal(row, rowRangeGroup);
            result.outLineLevel = outLineLevel === -1 ? 0 : outLineLevel;
        }
        if (row < sheet.rowCount) {
            result.visible = self._getRowVisibleInfo(sheet, row);
        }
        if (!common_1._isNullOrUndefined(this._rowStyleTable[sheet.index])) {
            var formatId = this._rowStyleTable[sheet.index][row];
            result.formatId = common_1._isNullOrUndefined(formatId) ? -1 : formatId;
        }
        return result;
    };
    WriterDataModel.prototype._getNotEmptyRows = function (sheet) {
        var result = this._notEmptyRows[sheet.index];
        if (result !== undefined) {
            return result;
        }
        result = [];
        var rows = sheet.rows, rowDataArray = sheet.data && sheet.data.rowDataArray, dataTable = sheet.data && sheet.data.dataTable;
        if (rows) {
            for (var i = 0, len = rows.length; i < len; i++) {
                if (rows[i]) {
                    result[i] = true;
                }
            }
        }
        if (rowDataArray) {
            for (var i = 0, len = rowDataArray.length; i < len; i++) {
                if (rowDataArray[i]) {
                    result[i] = true;
                }
            }
        }
        if (dataTable) {
            for (var row in dataTable) {
                if (dataTable[row] && dataTable.hasOwnProperty(row)) {
                    result[row] = true;
                }
            }
        }
        var tables = sheet.tables;
        if (tables) {
            tables.forEach(function (sheetTable) {
                var start = sheetTable.row;
                var end = sheetTable.row + sheetTable.rowCount;
                for (var i = start; i < end; i++) {
                    result[i] = true;
                }
            });
        }
        var spans = sheet.spans;
        if (spans) {
            var len = spans.length;
            for (var index = 0; index < len; index++) {
                var span = spans[index];
                for (var rowIndex = span.row; rowIndex < span.row + span.rowCount; rowIndex++) {
                    result[rowIndex] = true;
                }
            }
        }
        var itemsData = sheet.rowOutlines && sheet.rowOutlines.itemsData;
        if (itemsData) {
            for (var i = 0, len = itemsData.length; i < len; i++) {
                var item = itemsData[i];
                for (var row = item.index; row < item.index + item.count; row++) {
                    result[row] = true;
                }
            }
        }
        this._notEmptyRows[sheet.index] = result;
        return result;
    };
    WriterDataModel.prototype._getNonEmptyColumns = function (sheetName) {
        var result = [], spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var maxLevel = this._getMaxLevel(sheet.columnOutlines), columnCount = sheet.columnCount;
        for (var column = 0; column < columnCount; column++) {
            var excelColumn = this._getColumn(sheet, column, maxLevel);
            if (excelColumn &&
                (Math.abs(excelColumn.width - this._getDefaultColumnWidth(sheetName)) > 0.0001 ||
                    excelColumn.collapsed ||
                    (excelColumn.outLineLevel !== undefined && excelColumn.outLineLevel !== keyword_null && excelColumn.outLineLevel !== 0) ||
                    excelColumn.visible === false || excelColumn.formatId >= 0)) {
                result.push(excelColumn);
            }
        }
        return result;
    };
    WriterDataModel.prototype._getLevelInternal = function (index, group) {
        if (!group || !group.itemsData) {
            return 0;
        }
        var itemsData = group.itemsData;
        for (var i = 0, len = itemsData.length; i < len; i++) {
            var itemData = itemsData[i];
            if (index >= itemData.index && index < itemData.index + itemData.count) {
                return itemData.info ? itemData.info.level + 1 : 1;
            }
        }
        return 0;
    };
    WriterDataModel.prototype._getCollapsed = function (index, group) {
        if (!group || !group.itemsData) {
            return false;
        }
        var itemsData = group.itemsData;
        for (var i = 0, len = itemsData.length; i < len; i++) {
            var itemData = itemsData[i];
            if (index >= itemData.index && index < itemData.index + itemData.count) {
                return itemData.info ? !!itemData.info.collapsed : false;
            }
        }
        return false;
    };
    WriterDataModel.prototype._getColumn = function (sheet, column, columnRangeGroupMaxLevel) {
        var result = new excel.ExcelColumn(column), colRangeGroup = sheet.columnOutlines, sheetColumn = sheet.columns && sheet.columns[column];
        result.width = this.calcColumnWidth(sheetColumn && sheetColumn.size !== undefined ? sheetColumn.size : getSheetDefaultColumnWidth(sheet));
        if (columnRangeGroupMaxLevel >= 0 && column < sheet.columnCount) {
            result.collapsed = this._getCollapsed(column, colRangeGroup);
            var outLineLevel = this._getLevelInternal(column, colRangeGroup);
            result.outLineLevel = outLineLevel === -1 ? 0 : outLineLevel;
        }
        if (column < sheet.columnCount) {
            if (sheetColumn && sheetColumn.visible === false) {
                result.visible = false;
            }
            if (excel_helper_1.isCollapsed(column, colRangeGroup)) {
                result.visible = false;
            }
        }
        if (!common_1._isNullOrUndefined(this._columnStyleTable[sheet.index])) {
            var formatId = this._columnStyleTable[sheet.index][column];
            result.formatId = common_1._isNullOrUndefined(formatId) ? -1 : formatId;
        }
        return result;
    };
    WriterDataModel.prototype._getMaxLevel = function (group) {
        if (!group || !group.itemsData) {
            return -1;
        }
        var maxRowLevel = -1;
        for (var i = 0, len = group.itemsData.length; i < len; i++) {
            var itemsData = group.itemsData[i];
            if (itemsData.info && itemsData.info.level > maxRowLevel) {
                maxRowLevel = itemsData.info.level;
            }
        }
        return maxRowLevel;
    };
    WriterDataModel.prototype._getGutters = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var rowMaxOutLineLevel = 0, columnMaxOutLineLevel = 0;
        var maxRowLevel = -1, rowRangeGroup = sheet.rowOutlines;
        if (rowRangeGroup) {
            maxRowLevel = this._getMaxLevel(rowRangeGroup);
        }
        if (maxRowLevel !== -1) {
            rowMaxOutLineLevel = maxRowLevel + 2;
        }
        var maxColumnLevel = -1, colRangeGroup = sheet.columnOutlines;
        if (colRangeGroup) {
            maxColumnLevel = this._getMaxLevel(colRangeGroup);
        }
        if (maxColumnLevel !== -1) {
            columnMaxOutLineLevel = maxColumnLevel + 2;
        }
        return {
            outlineLevelRow: rowMaxOutLineLevel,
            outlineLevelColumn: columnMaxOutLineLevel
        };
    };
    WriterDataModel.prototype._getDefaultRowHeight = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var height = excel_style_1.UnitHelper.pixelToPoint(sheet.defaults ? sheet.defaults.rowHeight : getSheetDefaultRowHeight(sheet));
        var customHeight = false;
        var calculatedHeight = 57;
        customHeight = Math.abs(calculatedHeight - height) >= 2;
        return {
            height: height,
            customHeight: customHeight
        };
    };
    WriterDataModel.prototype._getDefaultColumnWidth = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        return this.calcColumnWidth(sheet.defaults ? sheet.defaults.colWidth : getSheetDefaultColumnWidth(sheet));
    };
    WriterDataModel.prototype._getDefaultColumnWidthValue = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (sheet.defaults && sheet.defaults.colWidth && sheet.defaults._isExcelDefaultColumnWidth !== true) {
            var columnWidth = sheet.defaults ? sheet.defaults.colWidth : getSheetDefaultColumnWidth(sheet);
            return this.calcColumnWidth(columnWidth);
        }
    };
    WriterDataModel.prototype.calcColumnWidth = function (actualWidth) {
        if (actualWidth === 0) {
            return 0;
        }
        var defaultStyle = WriterDataModel._getDefaultStyle(this._spread);
        var maxDigitWidth = Math.round(this._getMaxiumDigitWidth(defaultStyle.fontForColumnWidth ? defaultStyle.fontForColumnWidth : defaultStyle.font));
        var characters = Math.floor((actualWidth - 5) / maxDigitWidth * 100 + 0.5) / 100;
        return Math.floor((characters * maxDigitWidth + 5) / maxDigitWidth * 256) / 256;
    };
    WriterDataModel.prototype._getMaxiumDigitWidth = function (font) {
        if (this._maxiumDigitWidth === keyword_undefined) {
            this._maxiumDigitWidth = excel_style_1.UnitHelper.getMaxiumDigitWidth(font);
        }
        return this._maxiumDigitWidth;
    };
    WriterDataModel.prototype._getSelectionList = function (sheetName, selectionList, activeCell, panelIndex) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (!sheet) {
            return false;
        }
        var frozenRowCount = sheet.frozenRowCount, frozenColumnCount = sheet.frozenColCount;
        activeCell.col = sheet.activeCol >= 0 ? sheet.activeCol : 0;
        activeCell.row = sheet.activeRow >= 0 ? sheet.activeRow : 0;
        var hasFrozenRow = frozenRowCount > 0, hasFrozenColumn = frozenColumnCount > 0;
        if (panelIndex === 0) {
            if (!hasFrozenRow || !hasFrozenColumn) {
                return false;
            }
        }
        else if (panelIndex === 1) {
            if (!hasFrozenColumn) {
                return false;
            }
            if (hasFrozenRow) {
                activeCell.col = frozenColumnCount;
                activeCell.row = 0;
            }
        }
        else if (panelIndex === 2) {
            if (!hasFrozenRow) {
                return false;
            }
            if (hasFrozenColumn) {
                activeCell.col = 0;
                activeCell.row = frozenRowCount;
            }
        }
        activeCell.col = Math.min(excel_types_1.ExcelConstants._openXmlMaxColumn, activeCell.col);
        activeCell.row = Math.min(excel_types_1.ExcelConstants._openXmlMaxRow, activeCell.row);
        if (selectionList) {
            var rect = void 0;
            if (sheet.selections) {
                for (var i = 0; i < sheet.selections.length; i++) {
                    var range = sheet.selections[i];
                    if (isObject(range)) {
                        rect = new common_1.Range(range.row > 0 ? range.row : 0, range.col > 0 ? range.col : 0, range.rowCount > 0 ? range.rowCount : excel_types_1.ExcelConstants._openXmlMaxRow, range.colCount > 0 ? range.colCount : excel_types_1.ExcelConstants._openXmlMaxColumn);
                        selectionList.push(rect);
                    }
                }
            }
            else {
                selectionList.push(new common_1.Range(activeCell.row, activeCell.col, 1, 1));
            }
        }
        return true;
    };
    WriterDataModel.prototype._addCellToCache = function (sheetIndex, row, cell) {
        if (common_1._isNullOrUndefined(this._workbookCells[sheetIndex][row])) {
            this._workbookCells[sheetIndex][row] = [];
        }
        this._workbookCells[sheetIndex][row].push(cell);
    };
    WriterDataModel.prototype._addDataTimeFormatterIfValueIsDate = function (value, styleInfo) {
        if (isString(value) && value.substring(0, 7) === '/OADate' && styleInfo && !styleInfo.formatter) {
            if (styleInfo.autoFormatter) {
                styleInfo.formatter = styleInfo.autoFormatter.formatCached;
                return;
            }
            var startIndex = value.indexOf('('), endIndex = value.indexOf(')');
            if (startIndex !== -1 && endIndex !== -1) {
                var dataNumber = parseInt(value.substring(startIndex + 1, endIndex), 10);
                if (dataNumber < 1) {
                    styleInfo.formatter = 'h:mm:ss';
                }
                else if (dataNumber > 1) {
                    styleInfo.formatter = 'M/d/yyyy';
                }
            }
        }
    };
    WriterDataModel.prototype._setCellStyle = function (cellStyleTable, styleKey, styleInfo, styleName, cell) {
        var id;
        if (!common_1.StringEx._isNullOrEmpty(styleName)) {
            if ((id = this._namedStyleTable[styleName]) !== undefined) {
                cell.formatId = id;
            }
            else {
                cell.formatId = -1;
            }
        }
        else if (styleInfo) {
            if ((id = cellStyleTable[styleKey]) !== undefined) {
                cell.formatId = id;
            }
            else {
                cell.formatId = -1;
            }
        }
        else {
            cell.formatId = -1;
        }
    };
    WriterDataModel.prototype._setCellFormula = function (formula, arrayInfo, cell) {
        if (!common_1.StringEx._isNullOrWhiteSpace(formula)) {
            cell.formula = formula;
            if (arrayInfo) {
                cell.isArrayFormula = true;
                cell.cellType = 8;
                cell.arrayFormulaRange = arrayInfo;
                if (arrayInfo.isDynamicArray) {
                    cell.isDynamicArray = true;
                }
            }
            else {
                cell.cellType = 3;
            }
        }
    };
    WriterDataModel.prototype._setCellHyperlink = function (cell, sheet, row, column, hyperlinks) {
        if (!sheet.data || !sheet.data.dataTable || !sheet.data.dataTable[row]) {
            return;
        }
        var hyperlinkInfo = sheet.data.dataTable[row][column] && sheet.data.dataTable[row][column].hyperlink;
        if (hyperlinkInfo) {
            var hyperlink = {};
            var spans = this._getMergedCells(sheet.name);
            var isMergedCell = false;
            if (spans) {
                for (var i = 0; i < spans.length; i++) {
                    var span = spans[i];
                    if (span.row === row && span.col === column) {
                        hyperlink.ref = common_1.IndexHelper._getColumnIndexInA1Letter(span.col) + (span.row + 1) + ':' +
                            common_1.IndexHelper._getColumnIndexInA1Letter(span.col + span.colCount - 1) + (span.row + span.rowCount);
                        isMergedCell = true;
                        break;
                    }
                }
            }
            if (!isMergedCell) {
                hyperlink.ref = common_1.IndexHelper._getColumnIndexInA1Letter(column) + (row + 1);
            }
            var locationPrefix = 'sjs://';
            if (hyperlinkInfo.url) {
                if (hyperlinkInfo.url.substring(0, locationPrefix.length) === locationPrefix) {
                    hyperlink.location = common_1.Util._xmlEncode(hyperlinkInfo.url.replace(locationPrefix, ''));
                    var value = sheet.data.dataTable[row][column].value;
                    if (typeof value === 'string') {
                        hyperlink.display = common_1.Util._xmlEncode(value);
                    }
                }
                else {
                    hyperlink.url = common_1.Util._xmlEncode(hyperlinkInfo.url);
                }
            }
            if (hyperlinkInfo.tooltip) {
                hyperlink.tooltip = common_1.Util._xmlEncode(hyperlinkInfo.tooltip);
            }
            hyperlink['xr:uid'] = common_1._getRandomID();
            if (!hyperlinks[sheet.name]) {
                hyperlinks[sheet.name] = [];
            }
            hyperlinks[sheet.name].push(hyperlink);
        }
    };
    WriterDataModel.prototype._getRealCellValueForExcel = function (value, isRichText) {
        var cellType = 0;
        if (common_1._isNullOrUndefined(value)) {
            value = keyword_null;
        }
        else if (value._error) {
            cellType = 7;
            return {
                value: value._error,
                cellType: cellType
            };
        }
        else if (typeof value === 'number') {
            cellType = 1;
            if (isNaN(value)) {
                value = 0;
            }
        }
        else if (typeof value === 'boolean') {
            cellType = 5;
        }
        else if (isString(value) && value.substring(0, 7) === '/OADate') {
            cellType = 6;
        }
        else if (isRichText) {
            cellType = 9;
        }
        else if (isString(value)) {
            cellType = 2;
        }
        else {
            cellType = 2;
            value = value.toString();
        }
        return {
            value: value,
            cellType: cellType
        };
    };
    WriterDataModel.prototype._convertStyle = function (sheet, style) {
        var self = this;
        if (isObject(style)) {
            return excel_style_1.ConverterHelper.cloneSpreadJSStyle(style);
        }
        else if (isString(style)) {
            if (builtInStyleRegex.test(style)) {
                var pos = style.indexOf(const_builtInStyle);
                var styleName = self._getRenamedStyleName(sheet, style.substring(pos));
                return excel_style_1.ConverterHelper.cloneSpreadJSStyle(self._styles[self._namedStyleTable[styleName]]);
            }
            else {
                return { parentName: style };
            }
        }
    };
    WriterDataModel.prototype._getStyleByName = function (name) {
        var self = this;
        return name && self._styles[self._namedStyleTable[name]];
    };
    WriterDataModel.prototype._composeCellStyle = function (sheet, styleInfo, rowColumnStyle) {
        var self = this;
        if (rowColumnStyle) {
            rowColumnStyle = self._convertStyle(sheet, rowColumnStyle);
            common_1._StyleHelper._composeStyle(styleInfo, rowColumnStyle, true);
            if (rowColumnStyle && rowColumnStyle.parentName) {
                rowColumnStyle.parentName = self._getRenamedStyleName(sheet, rowColumnStyle.parentName);
                var parentStyle = self._styles[self._namedStyleTable[rowColumnStyle.parentName]];
                common_1._StyleHelper._composeStyle(styleInfo, parentStyle);
            }
        }
    };
    WriterDataModel.prototype._composeHyperlinkStyle = function (style, hyperlink) {
        if (!common_1._isNullOrUndefined(hyperlink.linkColor)) {
            style.foreColor = hyperlink.linkColor;
        }
        else if (hyperlink.linkColor === keyword_undefined && style.foreColor) {
        }
        else {
            style.foreColor = 'hyperlink';
        }
        if (common_1._isNullOrUndefined(style.textDecoration)) {
            style.textDecoration = 1;
        }
        else if ((style.textDecoration & 1) !== 1) {
            style.textDecoration += 1;
        }
    };
    WriterDataModel.prototype._getRenamedStyleName = function (sheet, name) {
        if (sheet.renamedStyles && sheet.renamedStyles[name]) {
            name = sheet.renamedStyles[name];
        }
        return name;
    };
    WriterDataModel.prototype._getCellStyle = function (sheet, row, column, cellStyleTable, currentColumnStyle, currentRowStyle, currentSheetStyle, styleKey, value) {
        var self = this, data = sheet.data;
        var styleObject = self._getStyleObject(sheet, row, column);
        var styleInfo = keyword_null;
        var styleName = keyword_null;
        var hyperlink = data && data.dataTable && data.dataTable[row] && data.dataTable[row][column] && data.dataTable[row][column].hyperlink;
        var specialStyle = hyperlink || (isString(value) && value.substring(0, 7) === '/OADate')
            || (value !== keyword_null && value !== undefined && (currentColumnStyle || currentRowStyle));
        var k = keyword_undefined;
        if (isStringOrNull(styleObject) && isStringOrNull(currentRowStyle) && isStringOrNull(currentColumnStyle) && !specialStyle) {
            k = '' + styleObject + '|' + currentColumnStyle + '|' + currentRowStyle;
        }
        if (k && self._composeStylesCache[k]) {
            cellStyleTable[styleKey] = self._composeStylesCache[k].styleIndex;
            return self._composeStylesCache[k];
        }
        if (styleObject) {
            styleInfo = self._convertStyle(sheet, styleObject);
        }
        else if (specialStyle) {
            styleInfo = {};
        }
        if (styleInfo) {
            if (styleInfo.parentName) {
                styleInfo.parentName = self._getRenamedStyleName(sheet, styleInfo.parentName);
                var parentStyle = self._styles[self._namedStyleTable[styleInfo.parentName]] || self._styles[self._stylesForXfidCache[styleInfo.parentName]];
                common_1._StyleHelper._composeStyle(styleInfo, parentStyle);
            }
            self._composeCellStyle(sheet, styleInfo, currentRowStyle);
            self._composeCellStyle(sheet, styleInfo, currentColumnStyle);
            self._composeCellStyle(sheet, styleInfo, currentSheetStyle);
            if (hyperlink) {
                self._composeHyperlinkStyle(styleInfo, hyperlink);
            }
            self._addDataTimeFormatterIfValueIsDate(value, styleInfo);
            if (common_1._StyleHelper._isEmptyStyleInfo(styleInfo)) {
                styleInfo = keyword_null;
            }
            else {
                var index = cellStyleTable[styleKey] = self._getStyleIndex(styleInfo);
                if (styleInfo.parentName && self.isSameStyleInfo(self._styles[self._namedStyleTable[styleInfo.parentName]], styleInfo, true)) {
                    styleName = styleInfo.parentName;
                }
                if (styleInfo.name && self.isSameStyleInfo(self._styles[self._namedStyleTable[styleInfo.name]], styleInfo, true)) {
                    styleName = styleInfo.name;
                }
                if (k) {
                    self._composeStylesCache[k] = {
                        styleIndex: index,
                        styleName: styleName,
                        styleInfo: styleInfo
                    };
                }
            }
        }
        return {
            styleName: styleName,
            styleInfo: styleInfo
        };
    };
    WriterDataModel.prototype._getStyleIndex = function (style) {
        var styles = this._styles;
        if (!style) {
            return 0;
        }
        for (var i = styles.length - 1; i >= 0; i--) {
            if ((!styles[i].name || styles[i].name.indexOf(const_builtInStyle) >= 0) && common_1._StyleHelper._isEqualStyleJSONObject(styles[i], style)) {
                return i;
            }
        }
        style.name = keyword_undefined;
        styles.push(style);
        return styles.length - 1;
    };
    WriterDataModel.prototype._getLastNonNullRow = function (dataTable) {
        if (!dataTable) {
            return 0;
        }
        var maxRow = 0;
        for (var row in dataTable) {
            if (dataTable.hasOwnProperty(row) && parseInt(row, 10) > maxRow) {
                maxRow = parseInt(row, 10);
            }
        }
        return maxRow;
    };
    WriterDataModel.prototype._getLastNonNullColumn = function (dataTable, sheet) {
        var maxColumn = 0;
        if (dataTable) {
            for (var row in dataTable) {
                if (dataTable.hasOwnProperty(row)) {
                    for (var col in dataTable[row]) {
                        if (parseInt(col, 10) > maxColumn) {
                            maxColumn = parseInt(col, 10);
                        }
                    }
                }
            }
        }
        var tables = sheet.tables;
        if (tables) {
            tables.forEach(function (sheetTable) {
                if (sheetTable.col + sheetTable.colCount > maxColumn) {
                    maxColumn = sheetTable.col + sheetTable.colCount;
                }
            });
        }
        return maxColumn;
    };
    WriterDataModel.prototype._nextNonNullRow = function (dataTable, rowCount, row) {
        row++;
        while (row >= 0 && row < rowCount) {
            if (dataTable[row]) {
                break;
            }
            row++;
        }
        if (row < rowCount) {
            return row;
        }
        return -1;
    };
    WriterDataModel.prototype._nextNonNullColumn = function (dataTable, rowCount, colCount, row, col) {
        var dr = keyword_null;
        if (row >= 0 && row < rowCount) {
            dr = dataTable[row];
        }
        if (!dr) {
            return -1;
        }
        col++;
        while (col >= 0 && col < colCount) {
            if (dr[col]) {
                break;
            }
            col++;
        }
        if (col < colCount) {
            return col;
        }
        return -1;
    };
    WriterDataModel.prototype._getColumnStyle = function (sheet, columnCount) {
        var columnStyles = [], sheetColumnCount = sheet.columnCount;
        if (!sheet.data || !sheet.data.columnDataArray) {
            return columnStyles;
        }
        for (var column = 0; column < columnCount; column++) {
            if (column < sheetColumnCount) {
                var columnStyle = this._getStyleObject(sheet, -1, column);
                columnStyles.push(columnStyle);
            }
            else {
                columnStyles.push(keyword_null);
            }
        }
        return columnStyles;
    };
    WriterDataModel.prototype._getExcelCellFormats = function () {
        var self = this, results = [], styleParentIndexMapping = { count: 0 };
        for (var i = 0, len = self._styles.length; i < len; i++) {
            var style = self._styles[i];
            var format = excel_style_1.ConverterHelper.toExtendedFormat(style, self);
            if (style.name && style.name.indexOf(const_builtInStyle) < 0) {
                if (!styleParentIndexMapping[style.name]) {
                    styleParentIndexMapping[style.name] = styleParentIndexMapping.count;
                    styleParentIndexMapping.count++;
                }
                format.isStyleFormat = true;
            }
            else {
                var parentID = 0;
                if (styleParentIndexMapping[style.parentName] !== void 0 && styleParentIndexMapping[style.parentName] !== keyword_null) {
                    parentID = styleParentIndexMapping[style.parentName];
                    var parentFormatObj = results[parentID];
                    if (!format.applyNumberFormat && parentFormatObj) {
                        if (parentFormatObj.numberFormat) {
                            format.numberFormat = parentFormatObj.numberFormat;
                        }
                        else if (parentFormatObj.numberFormatIndex !== void 0) {
                            format.numberFormatIndex = parentFormatObj.numberFormatIndex;
                        }
                    }
                }
                format.parentFormatID = parentID;
            }
            results.push(format);
        }
        return results;
    };
    WriterDataModel.prototype._getExcelDefaultFormat = function () {
        var defaultStyle = excel_style_1.ConverterHelper.cloneSpreadJSStyle(WriterDataModel._getDefaultStyle(this._spread));
        var result = excel_style_1.ConverterHelper.toExtendedFormat(defaultStyle, this);
        result.parentFormatID = 0;
        return result;
    };
    WriterDataModel.prototype._getExcelStyles = function () {
        var self = this, result = [], normalStyle = keyword_null;
        for (var i = 0, len = self._namedStyles.length; i < len; i++) {
            var nameStyle = self._namedStyles[i];
            if (nameStyle.name === 'Normal') {
                var style = new excel_style_1.ExcelStyle();
                style.name = 'Normal';
                style.format(excel_style_1.ConverterHelper.toExtendedFormat(nameStyle, self));
                style.format().isStyleFormat = true;
                style.builtInStyle = 0;
                normalStyle = style;
                self._normalStyleInfo = nameStyle;
                break;
            }
        }
        if (!normalStyle) {
            var normal = new excel_style_1.ExcelStyle();
            normal.name = 'Normal';
            normal.format(excel_style_1.ConverterHelper.toExtendedFormat(WriterDataModel._getDefaultStyle(this._spread), self));
            normal.format().font.fontSize = 14.67;
            normal.format().isStyleFormat = true;
            normal.builtInStyle = 0;
            result.push(normal);
        }
        for (var i = 0, len = self._namedStyles.length; i < len; i++) {
            var item = self._namedStyles[i];
            if (item.name) {
                if (WriterDataModel._builtInStyle[item.name] !== undefined) {
                    var style = new excel_style_1.ExcelStyle();
                    style.name = item.name;
                    style.format(excel_style_1.ConverterHelper.toExtendedFormat(item, self));
                    style.format().isStyleFormat = true;
                    style.builtInStyle = WriterDataModel._builtInStyle[item.name];
                    if ((item.name.substring(0, 'RowLevel_'.length) === 'RowLevel_' || item.name.substring(0, 'ColLevel_'.length) === 'ColLevel_') && item.name.length > 9) {
                        style.outLineLevel = parseInt(item.name.substring(9), 10) - 1;
                    }
                    result.push(style);
                }
                else {
                    var style1 = new excel_style_1.CustomExcelStyle();
                    style1.name = item.name;
                    style1.format(excel_style_1.ConverterHelper.toExtendedFormat(item, self));
                    style1.format().isStyleFormat = true;
                    result.push(style1);
                }
            }
        }
        return result;
    };
    WriterDataModel.prototype._getSheetsName = function () {
        var ret = [], sheets = this._spread.sheets;
        for (var sheetName in sheets) {
            if (sheets.hasOwnProperty(sheetName)) {
                var sheet = sheets[sheetName];
                ret[sheet.index] = sheetName;
            }
        }
        return ret;
    };
    WriterDataModel.prototype._getSheetByName = function (name) {
        return this._spread.sheets[name];
    };
    WriterDataModel.prototype._getOutlineDirection = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (!sheet) {
            return {};
        }
        return {
            colsSumRight: !(sheet.columnOutlines && sheet.columnOutlines.direction === 0),
            rowsSumBelow: !(sheet.rowOutlines && sheet.rowOutlines.direction === 0)
        };
    };
    WriterDataModel.prototype._getSheetTabColor = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (!sheet) {
            return keyword_null;
        }
        return toExcelColor(sheet.sheetTabColor);
    };
    WriterDataModel.prototype._getDimensions = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (!sheet) {
            return {};
        }
        return {
            rowCount: sheet.rowCount,
            columnCount: sheet.columnCount
        };
    };
    WriterDataModel.prototype._getDisplayElements = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var ret = {
            showGridLine: true,
            showRowColHeaders: true,
            gridlineColor: keyword_null,
            zoom: 1
        };
        if (!sheet) {
            return ret;
        }
        if (sheet.gridline && (sheet.gridline.showVerticalGridline === false || sheet.gridline.showHorizontalGridline === false)) {
            ret.showGridLine = false;
        }
        if (sheet.rowHeaderVisible === false && sheet.colHeaderVisible === false) {
            ret.showRowColHeaders = false;
        }
        if (sheet.gridline && sheet.gridline.color) {
            ret.gridlineColor = excel_style_1.ColorHelper.toExcelIndexedColor(toExcelColor(sheet.gridline.color, 0xffd0d7e5));
        }
        if (sheet.topCellIndex !== undefined && sheet.leftCellIndex !== undefined) {
            var topLeftCell = {
                row: sheet.topCellIndex,
                col: sheet.leftCellIndex
            };
            ret.topLeftCell = topLeftCell;
        }
        ret.zoom = sheet.zoomFactor;
        return ret;
    };
    WriterDataModel.prototype._getFrozen = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var ret = {
            frozenRowCount: 0,
            frozenColCount: 0
        };
        if (!sheet) {
            return ret;
        }
        ret.frozenRowCount = sheet.frozenRowCount || 0;
        ret.frozenColCount = sheet.frozenColCount || 0;
        return ret;
    };
    WriterDataModel.prototype._getProtect = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        return sheet ? sheet.isProtected : false;
    };
    WriterDataModel.prototype._getProtectionOptions = function (sheetName, isSheetProtect) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var protectionOptions = sheet.protectionOptions;
        var result = {}, value;
        for (var key in protectionOptions) {
            if (protectionOptions.hasOwnProperty(key)) {
                value = protectionOptions[key];
                if (!((value && key === 'allowSelectLockedCells') ||
                    (value && key === 'allowSelectUnlockedCells') ||
                    (value && key === 'allowEditObjects'))) {
                    result[excel_helper_1.fromProtectionOptions[key] ? excel_helper_1.fromProtectionOptions[key] : key] = protectionOptions[key];
                }
            }
        }
        if (isSheetProtect && !protectionOptions) {
            result.objects = false;
        }
        return result;
    };
    WriterDataModel.prototype._getMergedCells = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        return sheet ? sheet.spans : [];
    };
    WriterDataModel.prototype._getTabsAndScroll = function () {
        var spread = this._spread;
        return {
            showHorizontalScrollbar: spread.showHorizontalScrollbar,
            showVerticalScrollbar: spread.showVerticalScrollbar,
            tabStripVisible: spread.tabStripVisible,
            tabStripRatio: spread.tabStripRatio,
            startSheetIndex: spread.startSheetIndex,
            activeSheetIndex: spread.activeSheetIndex
        };
    };
    WriterDataModel.prototype._isSheetHidden = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        return sheet ? sheet.visible === false : true;
    };
    WriterDataModel.prototype._getDefinedNames = function () {
        var definedNames = [], definedName;
        if (this._spread.names) {
            for (var i = 0; i < this._spread.names.length; i++) {
                definedName = this._spread.names[i];
                definedNames.push({
                    name: definedName.name,
                    localSheetId: -1,
                    formula: definedName.formula,
                    comment: definedName.comment
                });
            }
        }
        var sheets = this._spread.sheets;
        for (var sheetName in sheets) {
            if (sheets.hasOwnProperty(sheetName)) {
                var sheet = sheets[sheetName];
                if (sheet.names) {
                    for (var i = 0; i < sheet.names.length; i++) {
                        definedName = sheet.names[i];
                        definedNames.push({
                            name: definedName.name,
                            localSheetId: sheet.index,
                            formula: definedName.formula,
                            comment: definedName.comment
                        });
                    }
                }
            }
        }
        return definedNames;
    };
    WriterDataModel.prototype._getConditionalFormatting = function (sheetName) {
        var self = this, sheet = self._spread.sheets && self._spread.sheets[sheetName];
        return sheet.conditionalFormats;
    };
    WriterDataModel._getDefaultStyle = function (workbook) {
        var defaultStyle = {
            foreColor: 'black',
            font: 'normal normal normal 11pt/normal Calibri',
            locked: true,
            name: 'Normal',
            textDecoration: 0,
            hAlign: 3,
            vAlign: 0,
        };
        for (var sheetName in workbook.sheets) {
            if (workbook.sheets.hasOwnProperty(sheetName)) {
                var sheet = workbook.sheets[sheetName];
                if (sheet.data && sheet.data.defaultDataNode && sheet.data.defaultDataNode.style) {
                    var sheetDefaultStyle = sheet.data.defaultDataNode.style;
                    var styleInfo = this.prototype._convertStyle(sheet, sheetDefaultStyle);
                    var parentName = styleInfo.parentName;
                    while (parentName) {
                        var temp = getStyleByName(parentName, workbook, sheet);
                        if (!temp) {
                            break;
                        }
                        common_1._StyleHelper._composeStyle(styleInfo, temp);
                        parentName = temp.parentName;
                    }
                    common_1._StyleHelper._composeStyle(styleInfo, defaultStyle);
                    return styleInfo;
                }
            }
        }
        return defaultStyle;
    };
    WriterDataModel.prototype._getComments = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        return sheet.comments && sheet.comments.map(function (comment) {
            return excel_helper_1.convertToExcelComment(sheet, comment);
        });
    };
    WriterDataModel.prototype._getPivotTables = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        return sheet.pivotTables;
    };
    WriterDataModel.prototype._getPictures = function (sheet) {
        return sheet.floatingObjects && sheet.floatingObjects.filter(function (item) {
            return item.typeName === '1' &&
                item.src && item.src.indexOf(';base64,') !== -1;
        }).map(function (picture) {
            return excel_helper_1.convertToExcelPicture(sheet, picture);
        });
    };
    WriterDataModel.prototype._getSparklineGroups = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        return sheet.sparklineGroups;
    };
    WriterDataModel.prototype._getColorFilter = function (sheet) {
        var rowFilter = sheet.rowFilter, self = this;
        if (rowFilter) {
            var colorFilterColumns_1 = [];
            var filteredColumns_1 = rowFilter.filteredColumns, filterItemMap = rowFilter.filterItemMap;
            if (filterItemMap && filteredColumns_1 && filteredColumns_1.length > 0) {
                filterItemMap.forEach(function (filterItem) {
                    if (filteredColumns_1.indexOf(filterItem.index) < 0) {
                        return;
                    }
                    var condition = filterItem.conditions[0];
                    if (condition.conType === 3) {
                        var isBackgroundColor = condition.compareType === 0;
                        colorFilterColumns_1.push({
                            autoFilterColumnId: filterItem.index - getFilterRange(sheet, rowFilter.range).col,
                            colorFilter: {
                                cellColor: isBackgroundColor,
                                dxfId: self._addDifferentConditionalFormat({
                                    isColorFilter: true,
                                    fill: excel_style_1.ColorHelper.toExcelBackColor(condition.expected, isBackgroundColor)
                                })
                            }
                        });
                    }
                });
            }
            return colorFilterColumns_1;
        }
    };
    WriterDataModel.prototype._getSortInfo = function (rowFilter) {
        var sortInfo, autoFilterSortInfo = keyword_null;
        if (rowFilter) {
            sortInfo = rowFilter.sortInfo;
            if (sortInfo && !common_1._isNullOrUndefined(sortInfo.ascending) && !common_1._isNullOrUndefined(sortInfo.index)) {
                autoFilterSortInfo = {
                    range: new common_1.Range(rowFilter.range.row, sortInfo.index, rowFilter.range.rowCount, 1),
                    descending: !sortInfo.ascending
                };
                if (sortInfo.color !== keyword_undefined) {
                    var isBackColor = sortInfo.isBackColor;
                    autoFilterSortInfo.isBackColor = isBackColor;
                    if (sortInfo.color[0] === '{') {
                        sortInfo.color = JSON.parse(sortInfo.color);
                    }
                    autoFilterSortInfo.dxfid = this._addDifferentConditionalFormat({
                        isColorFilter: true,
                        fill: excel_style_1.ColorHelper.toExcelBackColor(sortInfo.color, isBackColor)
                    });
                }
            }
        }
        return autoFilterSortInfo;
    };
    WriterDataModel.prototype._convertPivotAutoFilterFromJSON = function (pivotFilter, type) {
        var autoFilter = pivotFilter.autoFilter;
        var autoFilters = {
            range: 'A1',
            filterColumns: []
        };
        var filterItemMap = autoFilter.filterItemMap;
        if (filterItemMap) {
            filterItemMap.forEach(function (filterItem) {
                if (filterItem) {
                    var conditionArray = filterItem.conditions, condition = conditionArray[0];
                    var filterColumn = { autoFilterColumnId: 0 };
                    var filterCondition = toExcelPivotFilter(condition, type);
                    if (!common_1._isNullOrUndefined(filterCondition)) {
                        var filterType = filterCondition.filterType;
                        if (filterType === 1) {
                            filterColumn.top10 = filterCondition;
                        }
                        else if (filterType === 2) {
                            filterColumn.dynamicFilter = filterCondition;
                        }
                        else if (filterType === 4) {
                            filterColumn.customFilters = filterCondition;
                        }
                        else if (filterType === 3) {
                            filterColumn.filters = filterCondition;
                        }
                        autoFilters.filterColumns.push(filterColumn);
                    }
                }
            });
        }
        return autoFilters;
    };
    WriterDataModel.prototype._convertAutoFilterFromJSON = function (sheetName, rowFilter, sortInfo) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (common_1._isNullOrUndefined(rowFilter) || common_1._isNullOrUndefined(rowFilter.range)) {
            return keyword_null;
        }
        var rowFilterRange = rowFilter.range;
        var frozenRowCountForAdjust = rowFilter.adjustRangeForFrozen ? sheet.frozenRowCount : 0;
        var autoFilter = {
            range: getFilterRange(sheet, rowFilterRange, frozenRowCountForAdjust),
            filterColumns: []
        };
        if (sheet._colorFilterColumns && sheet._colorFilterColumns.length > 0) {
            autoFilter.filterColumns = sheet._colorFilterColumns;
        }
        var filteredColumns = rowFilter.filteredColumns, filterItemMap = rowFilter.filterItemMap;
        if (filterItemMap && filteredColumns && filteredColumns.length > 0) {
            filterItemMap.forEach(function (filterItem) {
                if (filterItem.index < rowFilterRange.col || filterItem.index >= rowFilterRange.col + rowFilterRange.colCount ||
                    filteredColumns.indexOf(filterItem.index) < 0) {
                    return;
                }
                var conditionArray = filterItem.conditions, condition;
                condition = conditionArray[0];
                for (var i = 1; i < conditionArray.length; i++) {
                    condition = {
                        conType: 0,
                        compareType: 0,
                        item1: condition,
                        item2: conditionArray[i]
                    };
                }
                if (condition) {
                    var filterColumn = { autoFilterColumnId: filterItem.index - autoFilter.range.col };
                    var filterCondition = toExcelFilter(sheet, condition, new common_1.Range(autoFilter.range.row + 1, autoFilter.range.col, autoFilter.range.rowCount - 1, 1));
                    if (!common_1._isNullOrUndefined(filterCondition)) {
                        var filterType = filterCondition.filterType;
                        if (filterType === 1) {
                            filterColumn.top10 = filterCondition;
                        }
                        else if (filterType === 2) {
                            filterColumn.dynamicFilter = filterCondition;
                        }
                        else if (filterType === 3) {
                            filterColumn.filters = filterCondition;
                        }
                        else if (filterType === 4) {
                            filterColumn.customFilters = filterCondition;
                        }
                        autoFilter.filterColumns.push(filterColumn);
                    }
                }
            });
        }
        autoFilter.sortInfo = sortInfo;
        return autoFilter;
    };
    WriterDataModel.prototype._getAutoFilter = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName], sortInfo = keyword_null;
        if (sheet.rowFilter) {
            sortInfo = sheet.rowFilter.autoFilterSortInfo;
        }
        return this._convertAutoFilterFromJSON(sheetName, sheet.rowFilter, sortInfo);
    };
    WriterDataModel.prototype._getTables = function (sheetName) {
        var tables = [], spread = this._spread;
        if (sheetName) {
            return spread.sheets[sheetName].tables;
        }
        for (var name_4 in spread.sheets) {
            if (spread.sheets[name_4].tables) {
                tables = tables.concat(spread.sheets[name_4].tables);
            }
        }
        return tables;
    };
    WriterDataModel.prototype._getSlicers = function (sheetName) {
        var sheet = this._spread.sheets[sheetName];
        return sheet.slicers && sheet.slicers.map(function (slicer) {
            return excel_helper_1.convertToExcelSlicer(sheet, slicer);
        });
    };
    WriterDataModel.prototype._getCharts = function (sheet) {
        return sheet.charts && sheet.charts.map(function (chart) {
            return excel_helper_1.convertToExcelChart(sheet, chart);
        });
    };
    WriterDataModel.prototype._getShapes = function (sheet) {
        return sheet.shapes && sheet.shapes.map(function (shape) {
            return excel_helper_1.convertToExcelShape(sheet, shape);
        });
    };
    WriterDataModel.prototype._getDrawingObjects = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var slicers = this._getSlicers(sheetName);
        var pictures = this._getPictures(sheet);
        var charts = this._getCharts(sheet);
        var shapes = this._getShapes(sheet);
        var count = 0;
        [slicers, pictures, charts, shapes].forEach(function (item) {
            if (item) {
                count += item.length;
            }
        });
        return {
            slicers: slicers,
            pictures: pictures,
            charts: charts,
            shapes: shapes,
            withDrawingObjects: count > 0
        };
    };
    WriterDataModel.prototype._getValidationData = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var result = [];
        var validations = sheet.validations;
        if (validations) {
            var sheetNames = this._getSheetsName();
            processDataValidator(validations, result, sheetName, sheetNames);
        }
        return result;
    };
    WriterDataModel.prototype._getPrintPageMargin = function (sheetName) {
        var defaultMargin = { top: 75, bottom: 75, left: 70, right: 70, header: 30, footer: 30 };
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var printInfo = sheet.printInfo, margin = printInfo && printInfo.margin;
        return margin ? {
            bottom: getPageMarginInExcel(margin.bottom, defaultMargin.bottom),
            top: getPageMarginInExcel(margin.top, defaultMargin.bottom),
            left: getPageMarginInExcel(margin.left, defaultMargin.bottom),
            right: getPageMarginInExcel(margin.right, defaultMargin.bottom),
            header: getPageMarginInExcel(margin.header, defaultMargin.bottom),
            footer: getPageMarginInExcel(margin.footer, defaultMargin.bottom)
        } : keyword_null;
    };
    WriterDataModel.prototype._getPrintOptions = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var printInfo = sheet.printInfo;
        if (printInfo) {
            var centering = printInfo.centering;
            return {
                horizontalCentered: centering === 1 || centering === 3,
                verticalCentered: centering === 2 || centering === 3,
                printGridLine: printInfo.showGridLine,
                printRowColumnsHeaders: printInfo.showRowHeader === 2 && printInfo.showColumnHeader === 2
            };
        }
    };
    WriterDataModel.prototype._getPrintPageSetting = function (sheetName, isUseSmartPrint) {
        function buildExcelPrintHeader(left, center, right) {
            left = left || '';
            center = center || '';
            right = right || '';
            return '&L' + left + '&C' + center + '&R' + right;
        }
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var printInfo = sheet.printInfo;
        if (!printInfo) {
            return keyword_null;
        }
        var excelSettings = {};
        var fitPagesTall = printInfo.fitPagesTall, fitPagesWide = printInfo.fitPagesWide;
        if (!common_1._isNullOrUndefined(fitPagesTall) && fitPagesTall !== -1) {
            excelSettings.useSmartPrint = true;
            excelSettings.smartPrintPagesHeight = Math.max(0, fitPagesTall);
        }
        if (!common_1._isNullOrUndefined(fitPagesWide) && fitPagesWide !== -1) {
            excelSettings.useSmartPrint = true;
            excelSettings.smartPrintPagesWidth = Math.max(0, fitPagesWide);
        }
        if (!isUseSmartPrint) {
            if (printInfo.paperSize) {
                var paperKind = printInfo.paperSize.kind;
                if (paperKind !== 0) {
                    excelSettings.paperSizeIndex = paperKind;
                }
            }
            excelSettings.copies = 1;
            if (!common_1._isNullOrUndefined(printInfo.firstPageNumber)) {
                excelSettings.useCustomStartingPage = true;
                excelSettings.firstPageNumber = printInfo.firstPageNumber;
            }
            excelSettings.orientation = printInfo.orientation === 2 ? 2 : 1;
            excelSettings.pageOrder = printInfo.pageOrder === 1 ? 1 : 2;
            excelSettings.zoomFactor = parseFloat(printInfo.zoomFactor);
            excelSettings.showColor = !printInfo.blackAndWhite;
            var headerString = buildExcelPrintHeader(printInfo.headerLeft, printInfo.headerCenter, printInfo.headerRight);
            var footerString = buildExcelPrintHeader(printInfo.footerLeft, printInfo.footerCenter, printInfo.footerRight);
            excelSettings.advancedHeadFooterSetting = {
                headerEvenPage: headerString,
                headerOddPage: headerString,
                footerOddPage: footerString,
                footerEvenPage: footerString
            };
            var rows = sheet.rows, rowBreakLines_1 = [];
            if (rows && rows.length > 0) {
                rows.forEach(function (rowInfo, rowIndex) {
                    if (rowInfo && rowInfo.pageBreak) {
                        rowBreakLines_1.push(rowIndex);
                    }
                });
            }
            var columns = sheet.columns, columnBreakLines_1 = [];
            if (columns && columns.length > 0) {
                columns.forEach(function (columnInfo, columnIndex) {
                    if (columnInfo && columnInfo.pageBreak) {
                        columnBreakLines_1.push(columnIndex);
                    }
                });
            }
            if (rowBreakLines_1.length > 0) {
                excelSettings.rowBreakLines = rowBreakLines_1;
            }
            if (columnBreakLines_1.length > 0) {
                excelSettings.columnBreakLines = columnBreakLines_1;
            }
        }
        return excelSettings;
    };
    WriterDataModel.prototype._getPrintInfo = function (sheetName) {
        return this._spread.sheets && this._spread.sheets[sheetName].printInfo;
    };
    WriterDataModel.prototype._getFilterInfo = function (sheetName) {
        return this._spread.sheets && this._spread.sheets[sheetName].rowFilter;
    };
    WriterDataModel.prototype._getCameraToolImages = function (sheetName) {
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var shapes = sheet.shapes, cameraToolImages = [];
        if (shapes && shapes.length > 0) {
            this._findCameraTools(shapes, cameraToolImages);
        }
        return cameraToolImages;
    };
    WriterDataModel.prototype._findCameraTools = function (shapes, cameraToolImages) {
        var _this_1 = this;
        function getImageInfo(name, imageString) {
            var retValue = { name: name };
            excel_helper_1.getPictureInfo(imageString, retValue);
            return retValue;
        }
        shapes.forEach(function (shape, index) {
            if (shape.shapeType === 1) {
                var pic = void 0;
                if (shape.shapeData && shape.shapeData.pic) {
                    pic = shape.shapeData.pic;
                }
                else if (shape.cameraTool === true) {
                    pic = shape;
                }
                if (pic) {
                    var indexStr = index + 1;
                    var retValue = getImageInfo('Picture_x0020_' + indexStr, pic.src);
                    retValue.style = pic.vmlStyle;
                    retValue.anchor = pic.anchor;
                    retValue.cellRange = pic.cellRange;
                    retValue.spid = '_x0000_s10' + pic.spid;
                    cameraToolImages.push(retValue);
                }
            }
            else if (shape.shapeType === 3) {
                var groupShape = (shape.shapeData && shape.shapeData.grpSp && shape.shapeData.grpSp.sp) || shape.sp;
                if (groupShape) {
                    _this_1._findCameraTools(groupShape, cameraToolImages);
                }
            }
        });
    };
    WriterDataModel.prototype._getPrintHeaderFooterImage = function (sheetName) {
        function getPrintImage(name, imageString) {
            var retValue = { name: name };
            excel_helper_1.getPictureInfo(imageString, retValue);
            return retValue;
        }
        var spread = this._spread, sheet = spread.sheets && spread.sheets[sheetName];
        var printInfo = sheet.printInfo, headerFooterImages = [];
        if (printInfo) {
            if (printInfo.headerLeftImage) {
                headerFooterImages.push(getPrintImage('LH', printInfo.headerLeftImage));
            }
            if (printInfo.headerCenterImage) {
                headerFooterImages.push(getPrintImage('CH', printInfo.headerCenterImage));
            }
            if (printInfo.headerRightImage) {
                headerFooterImages.push(getPrintImage('RH', printInfo.headerRightImage));
            }
            if (printInfo.footerLeftImage) {
                headerFooterImages.push(getPrintImage('LF', printInfo.footerLeftImage));
            }
            if (printInfo.footerCenterImage) {
                headerFooterImages.push(getPrintImage('CF', printInfo.footerCenterImage));
            }
            if (printInfo.footerRightImage) {
                headerFooterImages.push(getPrintImage('RF', printInfo.footerRightImage));
            }
        }
        return headerFooterImages;
    };
    WriterDataModel.prototype._getExcelCellXfsStyles = function () {
        return this._stylesForXfidCache;
    };
    WriterDataModel._builtInStyle = {
        '20% - Accent1': 30,
        '20% - Accent2': 34,
        '20% - Accent3': 38,
        '20% - Accent4': 42,
        '20% - Accent5': 46,
        '20% - Accent6': 50,
        '40% - Accent1': 31,
        '40% - Accent2': 35,
        '40% - Accent3': 39,
        '40% - Accent4': 43,
        '40% - Accent5': 47,
        '40% - Accent6': 51,
        '60% - Accent1': 32,
        '60% - Accent2': 36,
        '60% - Accent3': 40,
        '60% - Accent4': 44,
        '60% - Accent5': 48,
        '60% - Accent6': 52,
        'Accent1': 29,
        'Accent2': 33,
        'Accent3': 37,
        'Accent4': 41,
        'Accent5': 45,
        'Accent6': 49,
        'Bad': 27,
        'Calculation': 22,
        'Check Cell': 23,
        'Comma': 3,
        'Comma [0]': 6,
        'Currency': 4,
        'Currency [0]': 7,
        'Explanatory Text': 53,
        'Good': 26,
        'Heading 1': 16,
        'Heading 2': 17,
        'Heading 3': 18,
        'Heading 4': 19,
        'Input': 20,
        'Linked Cell': 24,
        'Neutral': 28,
        'Normal': 0,
        'Note': 10,
        'Output': 21,
        'Percent': 5,
        'Title': 15,
        'Total': 25,
        'Warning Text': 11,
        'Hyperlink': 8,
        'FollowedHyperLink': 9,
        'RowLevel_1': 1,
        'RowLevel_2': 1,
        'RowLevel_3': 1,
        'RowLevel_4': 1,
        'RowLevel_5': 1,
        'RowLevel_6': 1,
        'RowLevel_7': 1,
        'ColLevel_1': 2,
        'ColLevel_2': 2,
        'ColLevel_3': 2,
        'ColLevel_4': 2,
        'ColLevel_5': 2,
        'ColLevel_6': 2,
        'ColLevel_7': 2
    };
    return WriterDataModel;
}());
exports.WriterDataModel = WriterDataModel;
/***/ }),

/***/ './src/datamodel/datetime-helper.ts':
/*!******************************************!*\
  !*** ./src/datamodel/datetime-helper.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });
var common_1 = __webpack_require__(/*! ./../common/common */ './src/common/common.ts');
var keyword_null = null, keyword_undefined = void 0;
function _getTimezoneOffset(date) {
    var offset = date.getTimezoneOffset();
    if (offset === -485) {
        offset = -485 - 43 / 60;
    }
    return offset;
}
var DateTimeHelper = /** @class */ (function () {
    function DateTimeHelper() {
    }
    DateTimeHelper._addOADateString = function (date) {
        return '/OADate(' + date + ')/';
    };
    DateTimeHelper._removeOADateString = function (date) {
        if (typeof date === 'string' && date.substr(0, 8) === '/OADate(') {
            return parseInt(date.substr(8, date.length - 8 - 1 - 1), 10);
        }
        return date;
    };
    DateTimeHelper._toOADate = function (date) {
        if (date === keyword_undefined || date === keyword_null) {
            return 0;
        }
        if (typeof date === 'number' || typeof date === 'string') {
            date = new Date(date);
        }
        if (date instanceof Date) {
            return (date.getTime() * 1440 + 25569 * 86400000 * 1440 - _getTimezoneOffset(date) * 86400000) / (86400000 * 1440);
        }
        return 0;
    };
    DateTimeHelper._fromOADate = function (oadate) {
        var offsetDay = oadate - 25569;
        var date = new Date(offsetDay * 86400000);
        var adjustValue = offsetDay >= 0 ? 1 : -1;
        var oldDateTimezoneOffset = _getTimezoneOffset(date);
        var ms = (oadate * 86400000 * 1440 + adjustValue - 25569 * 86400000 * 1440 + oldDateTimezoneOffset * 86400000) / 1440;
        var firstResult = new Date(ms);
        var fixHourSign = oldDateTimezoneOffset >= 0 ? 1 : -1;
        var nextHour = new Date(ms + fixHourSign * 3600000);
        var nextHourTimezoneOffset = _getTimezoneOffset(nextHour);
        if (oldDateTimezoneOffset !== nextHourTimezoneOffset) {
            var newResult = new Date(ms + (nextHourTimezoneOffset - oldDateTimezoneOffset) * 60 * 1000);
            if (oldDateTimezoneOffset > nextHourTimezoneOffset) {
                if (fixHourSign === -1 || nextHourTimezoneOffset === _getTimezoneOffset(firstResult)) {
                    newResult = newResult.getMilliseconds() === 999 ? new Date(newResult.valueOf() + 1) : newResult;
                    return newResult;
                }
            }
            else if (oldDateTimezoneOffset < nextHourTimezoneOffset) {
                if (fixHourSign === 1 || nextHourTimezoneOffset === _getTimezoneOffset(firstResult)) {
                    newResult = newResult.getMilliseconds() === 999 ? new Date(newResult.valueOf() + 1) : newResult;
                    return newResult;
                }
            }
        }
        firstResult = firstResult.getMilliseconds() === 999 ? new Date(firstResult.valueOf() + 1) : firstResult;
        return firstResult;
    };
    DateTimeHelper._isDatesOrTimesNumberFormat = function (formatCode) {
        if (!formatCode || formatCode === ' ') {
            return false;
        }
        if (formatCode.length === 0) {
            return false;
        }
        formatCode = formatCode.toUpperCase();
        formatCode = formatCode.replace(/(\[.*\])+/g, ' ');
        formatCode = formatCode.replace(/"[^"]*"/g, ' ');
        formatCode = formatCode.replace(/(\*.|_.|\\.)+/g, ' ');
        if (formatCode.indexOf('GENERAL') !== -1) {
            return false;
        }
        var start = -1;
        var length = 0;
        var inFormatPattern = false;
        var isValidDateOrTimePattern = null;
        var i = 0;
        for (; i < formatCode.length; i++) {
            var code = formatCode[i];
            if (code === '[') {
                do {
                    code = formatCode[i];
                    i++;
                } while (i < formatCode.length && code !== ']');
            }
            if (code === 'Y' || code === 'D' || code === 'M' || code === 'H' || code === 'S' || code === 'A') {
                if (!inFormatPattern) {
                    if (i === 0 || (formatCode.length > 0 && formatCode[i - 1] !== '\\')) {
                        inFormatPattern = true;
                        start = i;
                        length = 1;
                    }
                }
                else {
                    length++;
                }
            }
            else {
                inFormatPattern = false;
                if (code === ' ' && isValidDateOrTimePattern) {
                    return true;
                }
                if (length !== 0) {
                    var subFormatPattern = formatCode.substring(start, start + length);
                    start = i;
                    length = 0;
                    if (isValidDateOrTimePattern === keyword_null) {
                        isValidDateOrTimePattern = DateTimeHelper._isValidDateOrTimeFormatPattern(subFormatPattern);
                    }
                    else {
                        isValidDateOrTimePattern = isValidDateOrTimePattern && DateTimeHelper._isValidDateOrTimeFormatPattern(subFormatPattern);
                    }
                }
            }
        }
        if (length !== 0 && i === formatCode.length) {
            var subFormatPattern = formatCode.substring(start, start + length);
            if (isValidDateOrTimePattern === keyword_null) {
                isValidDateOrTimePattern = DateTimeHelper._isValidDateOrTimeFormatPattern(subFormatPattern);
            }
            else {
                isValidDateOrTimePattern = isValidDateOrTimePattern && DateTimeHelper._isValidDateOrTimeFormatPattern(subFormatPattern);
            }
        }
        return !!isValidDateOrTimePattern;
    };
    DateTimeHelper._isValidDateOrTimeFormatPattern = function (pattern) {
        if (common_1.StringEx._isNullOrWhiteSpace(pattern)) {
            return false;
        }
        var itemGroups = [], searchedChars = '';
        for (var i = 0, len = pattern.length; i < len; i++) {
            var c = pattern[i];
            if (searchedChars.indexOf(c) === -1) {
                itemGroups.push({ key: c, count: pattern.match(new RegExp(c, 'g')).length });
                searchedChars += c;
            }
        }
        var DateAndTimeFormatElementDict = { Y: 4, D: 4, M: 5, H: 2, S: 2, A: 4 };
        for (var i = 0, len1 = itemGroups.length; i < len1; i++) {
            var item = itemGroups[i];
            var maxCount = DateAndTimeFormatElementDict[item.key];
            if (maxCount === keyword_undefined) {
                return false;
            }
            if (item.count > maxCount) {
                return false;
            }
        }
        return true;
    };
    return DateTimeHelper;
}());
exports.DateTimeHelper = DateTimeHelper;
/***/ }),

/***/ './src/datamodel/excel-helper.ts':
/*!***************************************!*\
  !*** ./src/datamodel/excel-helper.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });
var common_1 = __webpack_require__(/*! ./../common/common */ './src/common/common.ts');
var excel_style_1 = __webpack_require__(/*! ./excel-style */ './src/datamodel/excel-style.ts');
var chart_model_1 = __webpack_require__(/*! ./chart-model */ './src/datamodel/chart-model.ts');
var keyword_null = null;
function getActualColumnWidth(sheet, beginColumn, endColumn) {
    var defaultColumnWidth = sheet.defaults.colWidth;
    var columns = sheet.columns, width = 0;
    var defaultWidth = !columns ? defaultColumnWidth : keyword_null;
    for (var c = beginColumn; c < endColumn; c++) {
        width += defaultWidth || getColumnWidth(columns, c, defaultColumnWidth, sheet.columnOutlines);
    }
    return width;
}
function getColumnWidth(columns, index, defaultColumnWidth, outlines) {
    var item = columns[index];
    if (item) {
        if (outlines && isCollapsed(index, outlines)) {
            return 0;
        }
        return item.visible === false ? 0 : item.size;
    }
    return defaultColumnWidth;
}
function getActualRowHeight(sheet, beginRow, endRow) {
    var defaultRowHeight = sheet.defaults.rowHeight;
    var rows = sheet.rows, height = 0;
    var defaultHeight = !rows ? defaultRowHeight : keyword_null;
    for (var r = beginRow; r < endRow; r++) {
        height += defaultHeight || getRowHeight(rows, r, defaultRowHeight, sheet.rowOutlines);
    }
    return height;
}
function getRowHeight(rows, index, defaultRowHeight, outlines) {
    var item = rows[index];
    if (item) {
        if (outlines && isCollapsed(index, outlines)) {
            return 0;
        }
        return item.visible === false ? 0 : item.size;
    }
    return defaultRowHeight;
}
function getColumnAnchor(sheet, width) {
    var defaultColumnWidth = sheet.defaults.colWidth;
    var columns = sheet.columns, totalWidth = 0, c = 0, last;
    var defaultWidth = !columns ? defaultColumnWidth : keyword_null;
    while (totalWidth < width) {
        last = defaultWidth || getColumnWidth(columns, c, defaultColumnWidth);
        totalWidth += last;
        c++;
    }
    var offset = totalWidth - width;
    if (offset > 0) {
        c--;
        offset = last - offset;
    }
    return { col: c, colOffset: offset };
}
function getRowAnchor(sheet, height) {
    var defaultRowHeight = sheet.defaults.rowHeight;
    var rows = sheet.rowsVisibleInfo || sheet.rows, totalHeight = 0, r = 0, last;
    var defaultHeight = !rows ? defaultRowHeight : keyword_null;
    while (totalHeight < height) {
        last = defaultHeight || getRowHeight(rows, r, defaultRowHeight);
        totalHeight += last;
        r++;
    }
    var offset = totalHeight - height;
    if (offset > 0) {
        r--;
        offset = last - offset;
    }
    return { row: r, rowOffset: offset };
}
function getAnchor(sheet, rect) {
    var x = rect.x, y = rect.y;
    var startPoint = {}, endPoint = {}, anchor;
    anchor = getRowAnchor(sheet, y);
    copyProperties(anchor, startPoint, ['row', 'rowOffset']);
    anchor = getColumnAnchor(sheet, x);
    copyProperties(anchor, startPoint, ['col', 'colOffset']);
    anchor = getRowAnchor(sheet, y + rect.height);
    copyProperties(anchor, endPoint, ['row', 'rowOffset']);
    anchor = getColumnAnchor(sheet, x + rect.width);
    copyProperties(anchor, endPoint, ['col', 'colOffset']);
    return { startPoint: startPoint, endPoint: endPoint };
}
function isCollapsed(index, group) {
    if (!group) {
        return false;
    }
    if (group.items) {
        return group.items[index] && group.items[index].viewCollapsed;
    }
    if (!group.itemsData) {
        return false;
    }
    if (!group.collapseIndexMap) {
        createCollapsedIndexMap(group);
    }
    var collapseIndexMap = group.collapseIndexMap;
    return !!collapseIndexMap[index];
}
exports.isCollapsed = isCollapsed;
function createCollapsedIndexMap(group) {
    var itemsData = group.itemsData, collapseIndexMap = group.collapseIndexMap = {};
    var i, len, itemData, endIndex, j, itemData1, isCollapse = false;
    if (group.direction === 0) {
        for (i = itemsData.length - 1; i >= 0; i--) {
            itemData = itemsData[i];
            if (itemData && itemData.count === 1 && itemData.info && itemData.info.collapsed) {
                endIndex = itemData.index + itemData.count;
                for (j = i + 1; j < itemsData.length; j++) {
                    itemData1 = itemsData[j];
                    if (itemData1 && itemData1.info && itemData1.info.level > itemData.info.level && itemData1.index === endIndex) {
                        endIndex = itemData1.index + itemData1.count;
                    }
                }
                for (var k = itemData.index + 1; k < endIndex; k++) {
                    collapseIndexMap[k] = true;
                }
            }
        }
    }
    else {
        for (i = 0, len = itemsData.length; i < len; i++) {
            itemData = itemsData[i];
            if (itemData && itemData.count === 1 && itemData.info && itemData.info.collapsed) {
                endIndex = itemData.index - 1;
                if (endIndex < 0 && itemData.info.level === -1) {
                    break;
                }
                for (j = i - 1; j >= 0; j--) {
                    itemData1 = itemsData[j];
                    if (itemData1 && itemData1.info && itemData1.info.level > itemData.info.level && itemData1.index + itemData1.count - 1 === endIndex) {
                        endIndex = itemData1.index - 1;
                    }
                }
                for (var k = endIndex + 1; k < itemData.index; k++) {
                    collapseIndexMap[k] = true;
                }
            }
        }
    }
}
var commentHostMargin = 7;
function copyProperties(src, dest, props) {
    props.forEach(function (prop) {
        if (src[prop] !== undefined) {
            dest[prop] = src[prop];
        }
    });
}
function convertFromExcelComment(sheet, excelComment) {
    var comment = {};
    copyProperties(excelComment, comment, [
        'fontSize', 'fontStyle', 'fontFamily', 'fontWeight', 'textDecoration', 'text',
        'autoSize', 'dynamicMove', 'dynamicSize', 'locked', 'lockText', 'displayMode'
    ]);
    var beginRow = sheet.forzenRowCount || 0, beginColumn = sheet.forzenColumnCount || 0, row = excelComment.row, col = excelComment.col, anchor = excelComment.anchor;
    var topRightX = getActualColumnWidth(sheet, beginColumn, col + 1), topRightY = getActualRowHeight(sheet, beginRow, row);
    comment.rowIndex = row - beginRow;
    comment.colIndex = col - beginColumn;
    if (anchor) {
        var startX = getActualColumnWidth(sheet, beginColumn, anchor[0]) + anchor[1] - commentHostMargin, startY = getActualRowHeight(sheet, beginRow, anchor[2]) + anchor[3] - commentHostMargin, endX = getActualColumnWidth(sheet, beginColumn, anchor[4]) + anchor[5] + commentHostMargin, endY = getActualRowHeight(sheet, beginRow, anchor[6]) + anchor[7] + commentHostMargin;
        comment.location = {
            x: startX - topRightX,
            y: startY - topRightY
        };
        comment.width = endX - startX;
        comment.height = endY - startY;
        inflateWorksheetByComment(sheet, anchor);
    }
    else {
        comment.location = {
            x: excel_style_1.UnitHelper.pointToPixel(excelComment.marginLeft) - topRightX - commentHostMargin,
            y: excel_style_1.UnitHelper.pointToPixel(excelComment.marginTop) - topRightY - commentHostMargin
        };
        comment.width = pointToPixel(excelComment.width) + 2 * commentHostMargin;
        comment.height = pointToPixel(excelComment.height) + 2 * commentHostMargin;
        inflateWorksheetByComment(sheet, keyword_null, {
            x: comment.location.x + topRightX,
            y: comment.location.y + topRightY,
            width: comment.width,
            height: comment.height
        });
    }
    var color = excelComment.foreColor;
    if (color && color !== excel_style_1.ExcelColor.EmptyColor) {
        comment.foreColor = excel_style_1.ColorHelper.toRGBColor(color);
    }
    color = excelComment.backColor;
    if (color) {
        comment.backColor = color.split(' ')[0];
    }
    color = excelComment.borderColor;
    if (color) {
        comment.borderColor = color.split(' ')[0];
    }
    var borderWidth = excelComment.borderWidth;
    if (borderWidth) {
        comment.borderWidth = pointToPixel(borderWidth);
    }
    comment.borderStyle = excelBorderStyleToWebBorderStyle(excelComment.dashStyle, excelComment.lineStyle);
    var value = excelComment.zIndex;
    if (!common_1._isNullOrUndefined(value)) {
        comment.zIndex = value;
    }
    value = excelComment.opacity;
    if (!common_1._isNullOrUndefined(value)) {
        comment.opacity = value;
    }
    if (excelComment.autoSize) {
        comment.autoSize = true;
    }
    comment.locked = excelComment.locked !== false;
    comment.lockText = excelComment.lockText !== false;
    comment.dynamicSize = excelComment.dynamicSize !== false;
    comment.dynamicMove = excelComment.dynamicMove !== false;
    value = excelComment.inset;
    if (value) {
        var padding_1 = [0, 0, 0, 0];
        value.trim().split(',').forEach(function (item, index) {
            var paddingValue = item || ['0.1in', '0.05in'][index % 2];
            padding_1[index] = convertToPixel(paddingValue);
        });
        comment.padding = {
            left: padding_1[0],
            top: padding_1[1],
            right: padding_1[2],
            bottom: padding_1[3]
        };
    }
    var hAlign = ['left', 'center', 'right'].indexOf(excelComment.hAlign);
    if (hAlign !== -1) {
        comment.horizontalAlign = hAlign;
    }
    return comment;
}
exports.convertFromExcelComment = convertFromExcelComment;
function convertToExcelComment(sheet, comment) {
    var row = comment.rowIndex, col = comment.colIndex, location = comment.location || { x: 9, y: -18 }, excelComment = { row: row, col: col };
    if (common_1._isNullOrUndefined(comment.width)) {
        comment.width = 160;
    }
    if (common_1._isNullOrUndefined(comment.height)) {
        comment.height = 100;
    }
    comment.fontFamily = comment.fontFamily || 'Arial';
    comment.borderColor = comment.borderColor || 'black';
    comment.backColor = comment.backColor || '#FFFFE1';
    copyProperties(comment, excelComment, [
        'zIndex', 'opacity', 'fontStyle', 'fontFamily', 'fontWeight', 'textDecoration', 'text',
        'autoSize', 'dynamicMove', 'dynamicSize', 'locked', 'lockText', 'displayMode', 'backColor', 'borderColor'
    ]);
    var topRightX = getActualColumnWidth(sheet, 0, col + 1);
    var topRightY = getActualRowHeight(sheet, 0, row);
    excelComment.marginLeft = excel_style_1.UnitHelper.pixelToPoint(topRightX + location.x + commentHostMargin);
    excelComment.marginTop = excel_style_1.UnitHelper.pixelToPoint(topRightY + location.y + commentHostMargin);
    excelComment.width = excel_style_1.UnitHelper.pixelToPoint(comment.width - 2 * commentHostMargin) + 'pt';
    excelComment.height = excel_style_1.UnitHelper.pixelToPoint(comment.height - 2 * commentHostMargin) + 'pt';
    var fontSize = comment.fontSize || '9pt';
    if (fontSize.indexOf('px') !== -1) {
        excelComment.fontSize = excel_style_1.UnitHelper.pixelToPoint(parseFloat(fontSize));
    }
    else {
        excelComment.fontSize = fontSize.replace('pt', '');
    }
    var foreColor = comment.foreColor;
    excelComment.foreColor = foreColor && excel_style_1.ColorHelper.toExcelColor(foreColor);
    excelComment.borderWidth = excel_style_1.UnitHelper.pixelToPoint(comment.borderWidth || 1) + 'pt';
    var borderStyle = webBorderStyleToExcelBorderStyle(comment.borderStyle);
    excelComment.dashStyle = borderStyle.dashStyle;
    excelComment.lineStyle = borderStyle.lineStyle;
    var padding = comment.padding;
    if (padding) {
        excelComment.inset = [
            excel_style_1.UnitHelper.pixelToPoint(padding.left) + 'pt',
            excel_style_1.UnitHelper.pixelToPoint(padding.top) + 'pt',
            excel_style_1.UnitHelper.pixelToPoint(padding.right) + 'pt',
            excel_style_1.UnitHelper.pixelToPoint(padding.bottom) + 'pt'
        ].join(',');
    }
    excelComment.hAlign = ['Left', 'Center', 'Right'][comment.horizontalAlign || 0] || 'Left';
    excelComment.visibility = comment.displayMode === 1 ? 'visible' : 'hidden';
    return excelComment;
}
exports.convertToExcelComment = convertToExcelComment;
function pointToPixel(value) {
    if (value) {
        return excel_style_1.UnitHelper.pointToPixel(parseFloat(value.replace('pt', '')));
    }
    return 0;
}
function convertToPixel(value) {
    var point = 0;
    if (value.indexOf('in') !== -1) {
        point = parseFloat(value.replace('in', '').trim()) * 72;
    }
    else if (value.indexOf('cm') !== -1) {
        point = parseFloat(value.replace('cm', '').trim()) * 72 / 2.54;
    }
    else if (value.indexOf('mm') !== -1) {
        point = parseFloat(value.replace('mm', '').trim()) * 72 / 25.4;
    }
    else if (value.indexOf('pt') !== -1) {
        point = parseFloat(value.replace('pt', '').trim());
    }
    return excel_style_1.UnitHelper.pointToPixel(point);
}
function excelBorderStyleToWebBorderStyle(dashStyle, lineStyle) {
    if (!common_1.StringEx._isNullOrEmpty(lineStyle)) {
        return 'double';
    }
    if (dashStyle) {
        switch (dashStyle.toLowerCase()) {
            case 'solid':
                return 'solid';
            case '1 1':
                return 'dotted';
            case 'dash':
            case 'dashdot':
            case 'longdash':
            case 'longdashdot':
            case 'longdashdotdot':
                return 'dashed';
        }
    }
    return 'solid';
}
function webBorderStyleToExcelBorderStyle(borderStyle) {
    var dashStyle, lineStyle;
    if (borderStyle) {
        switch (borderStyle.toLowerCase()) {
            case 'solid':
                dashStyle = 'solid';
                break;
            case 'dotted':
                dashStyle = '1 1';
                break;
            case 'dashed':
                dashStyle = 'dash';
                break;
            case 'double':
                lineStyle = 'thinThin';
                break;
        }
    }
    return { dashStyle: dashStyle, lineStyle: lineStyle };
}
function convertFloatingObjectAnchor(twoCellAnchor, floatingObject) {
    if (twoCellAnchor) {
        var startPoint = twoCellAnchor.startPoint, endPoint = twoCellAnchor.endPoint;
        floatingObject.startRow = startPoint.row;
        floatingObject.startRowOffset = startPoint.rowOffset;
        floatingObject.startColumn = startPoint.col;
        floatingObject.startColumnOffset = startPoint.colOffset;
        floatingObject.endRow = endPoint.row;
        floatingObject.endRowOffset = endPoint.rowOffset;
        floatingObject.endColumn = endPoint.col;
        floatingObject.endColumnOffset = endPoint.colOffset;
    }
}
var percentageFactor = 100000;
function convertFromSourceRectangle(srcRect) {
    return {
        l: srcRect.l / percentageFactor,
        t: srcRect.t / percentageFactor,
        r: srcRect.r / percentageFactor,
        b: srcRect.b / percentageFactor
    };
}
function convertToSourceRectangle(srcRect) {
    return {
        l: parseInt((srcRect.l || 0) * percentageFactor, 10),
        t: parseInt((srcRect.t || 0) * percentageFactor, 10),
        r: parseInt((srcRect.r || 0) * percentageFactor, 10),
        b: parseInt((srcRect.b || 0) * percentageFactor, 10)
    };
}
function convertFromExcelPicture(sheet, excelPicture, floatingObjects) {
    var pictureName = getUniqueName(floatingObjects, excelPicture.name, 'picture'), picture = { name: pictureName, alt: excelPicture.descr };
    copyProperties(excelPicture, picture, ['src', 'isVisible', 'locked', 'rot']);
    convertFromExcelAnchor(excelPicture.anchor, sheet, picture, excelPicture.xfrm);
    convertPictureStyle(excelPicture.pictureFormat, picture);
    var srcRect = excelPicture.srcRect;
    if (srcRect) {
        picture.srcRect = convertFromSourceRectangle(srcRect);
    }
    return picture;
}
exports.convertFromExcelPicture = convertFromExcelPicture;
function convertToExcelSlicer(sheet, slicer) {
    slicer.twoCellAnchor = getFloatingObjectAnchor(sheet, slicer);
    return slicer;
}
exports.convertToExcelSlicer = convertToExcelSlicer;
function excelLineTypeToPictureBorderStyle(lineDashType, compoundLineType) {
    switch (lineDashType) {
        case 'solid':
            return compoundLineType === 'dbl' ? 'double' : 'solid';
        case 'dot':
        case 'sysDot':
            return 'dotted';
    }
    return 'dashed';
}
function isNoneBorderStyle(borderStyle) {
    return !borderStyle || borderStyle === 'hidden';
}
function pictureBorderStyleToExcelLineType(borderStyle) {
    switch (borderStyle) {
        case 'dotted':
            return 'dot';
        case 'dashed':
            return 'dash';
        case 'double':
            return 'dbl';
    }
    return 'solid';
}
function convertToExcelPicture(sheet, picture) {
    var excelPicture = {};
    var src = picture.src;
    getPictureInfo(src, excelPicture);
    copyProperties(picture, excelPicture, ['name', 'locked', 'rot']);
    excelPicture.descr = picture.alt;
    excelPicture.twoCellAnchor = getFloatingObjectAnchor(sheet, picture, true);
    excelPicture.hidden = picture.isVisible === false;
    excelPicture.fillColor = excel_style_1.ColorHelper.toExcelColor(picture.backColor);
    excelPicture.lineBorder = {
        width: isNoneBorderStyle(picture.borderStyle) ? 0 : picture.borderWidth,
        color: excel_style_1.ColorHelper.toExcelColor(picture.borderColor),
        style: pictureBorderStyleToExcelLineType(picture.borderStyle),
        noFill: picture.noFill
    };
    var srcRect = picture.srcRect;
    if (srcRect) {
        excelPicture.srcRect = convertToSourceRectangle(srcRect);
    }
    return excelPicture;
}
exports.convertToExcelPicture = convertToExcelPicture;
var imageBase64Flag = ';base64,';
function getPictureInfo(src, excelPicture) {
    var index = src.indexOf(imageBase64Flag);
    if (index > 0) {
        excelPicture.base64Image = src.substr(index + imageBase64Flag.length);
        var imageType = src.substr(0, index).split('/').pop();
        if (imageType === 'x-icon') {
            imageType = 'png';
        }
        excelPicture.imageType = imageType;
    }
}
exports.getPictureInfo = getPictureInfo;
function isSVGPicture(base64Str) {
    if (!base64Str) {
        return false;
    }
    var imageInfo = {};
    getPictureInfo(base64Str, imageInfo);
    return imageInfo.imageType === 'svg+xml';
}
exports.isSVGPicture = isSVGPicture;
function getUniqueName(floatingObjects, name, defaultName) {
    function isMatch(obj) {
        return obj.name === this.name;
    }
    function isDuplicated(floatingObjectName) {
        var callback = isMatch.bind({ name: floatingObjectName });
        return floatingObjects.filter(callback)[0] !== undefined;
    }
    name = name || defaultName;
    var newName = name, i = 1;
    while (isDuplicated(newName)) {
        newName = name + '_' + i++;
    }
    return newName;
}
function convertPictureStyle(pictureFormat, picture) {
    if (!pictureFormat) {
        return null;
    }
    var fillFormat = pictureFormat.fillFormat;
    if (fillFormat && fillFormat.fillFormatType === 1) {
        picture.backColor = excel_style_1.ColorHelper.toRGBColor(fillFormat.color);
    }
    var lineFormat = pictureFormat.lineFormat;
    if (lineFormat) {
        picture.borderWidth = lineFormat.width;
        var lineFillFormat = lineFormat.fillFormat;
        if (lineFillFormat && lineFillFormat.fillFormatType === 1) {
            picture.borderColor = excel_style_1.ColorHelper.toRGBColor(lineFillFormat.color);
        }
        else if (lineFillFormat && lineFillFormat.fillFormatType === 0) {
            picture.noFill = true;
        }
        var lineDashType = lineFormat.lineDashType;
        if (lineDashType) {
            var compoundLineType = lineFormat.compoundLineType;
            picture.borderStyle = excelLineTypeToPictureBorderStyle(lineDashType, compoundLineType);
        }
    }
}
var _INFLATE_OFFSET = 2;
function inflateWorksheet(sheet, rowCount, columnCount) {
    if (sheet.rowCount < rowCount) {
        sheet.rowCount = rowCount;
    }
    if (sheet.columnCount < columnCount) {
        sheet.columnCount = columnCount;
    }
}
function inflateWorksheetByAnchor(sheet, twoCellAnchor) {
    var rowCount = 0, columnCount = 0;
    var point = twoCellAnchor.endPoint;
    if (point) {
        rowCount = point.row;
        columnCount = point.col;
    }
    rowCount += _INFLATE_OFFSET;
    columnCount += _INFLATE_OFFSET;
    inflateWorksheet(sheet, rowCount, columnCount);
}
exports.inflateWorksheetByAnchor = inflateWorksheetByAnchor;
function inflateWorksheetByComment(sheet, anchor, rect) {
    var rowCount, columnCount;
    if (anchor) {
        rowCount = anchor[6];
        columnCount = anchor[4];
    }
    else {
        var twoPointsAnchor = getAnchor(sheet, rect);
        rowCount = twoPointsAnchor.endPoint.row;
        columnCount = twoPointsAnchor.endPoint.col;
    }
    rowCount += _INFLATE_OFFSET;
    columnCount += _INFLATE_OFFSET;
    inflateWorksheet(sheet, rowCount, columnCount);
}
function getBounds(sheet, startPoint, endPoint) {
    var x, y, x1, y1;
    x = getActualColumnWidth(sheet, 0, startPoint.col) + startPoint.colOffset;
    y = getActualRowHeight(sheet, 0, startPoint.row) + startPoint.rowOffset;
    x1 = getActualColumnWidth(sheet, 0, endPoint.col) + endPoint.colOffset;
    y1 = getActualRowHeight(sheet, 0, endPoint.row) + endPoint.rowOffset;
    return { x: x, y: y, width: x1 - x, height: y1 - y };
}
exports.getBounds = getBounds;
function getBoundsByTwoCellAnchor(sheet, twoCellAnchor) {
    return getBounds(sheet, twoCellAnchor.startPoint, twoCellAnchor.endPoint);
}
function getBoundsByOneCellAnchor(sheet, oneCellAnchor) {
    var startPoint = oneCellAnchor.startPoint;
    var x = getActualColumnWidth(sheet, 0, startPoint.col) + startPoint.colOffset;
    var y = getActualRowHeight(sheet, 0, startPoint.row) + startPoint.rowOffset;
    return { x: x, y: y, width: oneCellAnchor.width, height: oneCellAnchor.height };
}
function getBoundsByAbsoluteAnchor(absoluteAnchor) {
    return { x: absoluteAnchor.x, y: absoluteAnchor.y, width: absoluteAnchor.width, height: absoluteAnchor.height };
}
function getBoundsByRelativeSizeAnchor(relSizeAnchor, containerWidth, containerHeight) {
    var startPoint = relSizeAnchor.startPoint, endPoint = relSizeAnchor.endPoint;
    var x = startPoint.x * containerWidth;
    var y = startPoint.y * containerHeight;
    var x1 = endPoint.x * containerWidth;
    var y1 = endPoint.y * containerHeight;
    return { x: x, y: y, width: x1 - x, height: y1 - y };
}
function getBoundsByAbsoluteSizeAnchor(absSizeAnchor, containerWidth, containerHeight) {
    var startPoint = absSizeAnchor.startPoint;
    return { x: startPoint.x * containerWidth, y: startPoint.y * containerHeight, width: absSizeAnchor.width, height: absSizeAnchor.height };
}
function getFloatingObjectAnchor(sheet, floatingObject, isPicture) {
    if (!common_1._isNullOrUndefined(floatingObject.startRow)) {
        if (isPicture) {
            floatingObject = getPictureAnchor(sheet, floatingObject);
        }
        var startPoint = {
            row: floatingObject.startRow,
            rowOffset: floatingObject.startRowOffset || 0,
            col: floatingObject.startColumn,
            colOffset: floatingObject.startColumnOffset || 0
        }, endPoint = {
            row: floatingObject.endRow,
            rowOffset: floatingObject.endRowOffset || 0,
            col: floatingObject.endColumn,
            colOffset: floatingObject.endColumnOffset || 0
        };
        var editAsValue = getEditAsValueFromMoveSize(floatingObject.dynamicMove, floatingObject.dynamicSize);
        return { startPoint: startPoint, endPoint: endPoint, editAs: editAsValue };
    }
    return getAnchor(sheet, {
        x: floatingObject.x || 0,
        y: floatingObject.y || 0,
        width: floatingObject.width || 0,
        height: floatingObject.height || 0
    });
}
function getPictureAnchor(sheet, floatingObject) {
    var pictureStretch = floatingObject.pictureStretch;
    if (pictureStretch === 0) {
        return floatingObject;
    }
    else if (pictureStretch === 1) {
        return recalcPictureLayoutForCenter(sheet, floatingObject);
    }
    else if (pictureStretch === 2) {
        return recalcPictureLayoutForZoom(sheet, floatingObject);
    }
    else if (pictureStretch === 3) {
        return recalcPictureLayoutForNone(sheet, floatingObject);
    }
    return floatingObject;
}
function recalcPictureLayoutForCenter(sheet, floatingObject) {
    var rowCount = sheet.rowCount, columnCount = sheet.columnCount;
    var width = floatingObject.width, height = floatingObject.height, startRow = floatingObject.startRow, startRowOffset = floatingObject.startRowOffset || 0, startColumn = floatingObject.startColumn, startColumnOffset = floatingObject.startColumnOffset || 0, endRow = floatingObject.endRow, endRowOffset = floatingObject.endRowOffset || 0, endColumn = floatingObject.endColumn, endColumnOffset = floatingObject.endColumnOffset || 0, originalWidth = floatingObject.originalWidth, originalHeight = floatingObject.originalHeight;
    var newWidth = Math.min(width, originalWidth), newHeight = Math.min(height, originalHeight);
    var newStartRowOffset = originalHeight > height ? startRowOffset : startRowOffset + (height - originalHeight) / 2, newStartColumnOffset = originalWidth > width ? startColumnOffset : startColumnOffset + (width - originalWidth) / 2;
    width = newWidth;
    height = newHeight;
    var totalHeight = 0, r = startRow, nsro = newStartRowOffset, isStartRowUpdated = false;
    while (r < rowCount) {
        var rh = getActualRowHeight(sheet, r, ++r);
        totalHeight += rh;
        !isStartRowUpdated && (nsro -= rh);
        if (nsro < 0 && !isStartRowUpdated) {
            startRow = r - 1 < 0 ? 0 : r - 1;
            startRowOffset = rh + nsro;
            isStartRowUpdated = true;
        }
        if (totalHeight > height + newStartRowOffset) {
            endRow = r - 1 < 0 ? 0 : r - 1;
            endRowOffset = rh - (totalHeight - height - newStartRowOffset);
            break;
        }
    }
    var totalWidth = 0, c = startColumn, nsco = newStartColumnOffset, isStartColumnUpdated = false;
    while (c < columnCount) {
        var cw = getActualColumnWidth(sheet, c, ++c);
        totalWidth += cw;
        !isStartColumnUpdated && (nsco -= cw);
        if (nsco < 0 && !isStartColumnUpdated) {
            startColumn = c - 1 < 0 ? 0 : c - 1;
            startColumnOffset = cw + nsco;
            isStartColumnUpdated = true;
        }
        if (totalWidth > width + newStartColumnOffset) {
            endColumn = c - 1 < 0 ? 0 : c - 1;
            endColumnOffset = cw - (totalWidth - width - newStartColumnOffset);
            break;
        }
    }
    floatingObject.width = width;
    floatingObject.height = height;
    floatingObject.startRow = startRow;
    floatingObject.startRowOffset = startRowOffset;
    floatingObject.endRow = endRow;
    floatingObject.endRowOffset = endRowOffset;
    floatingObject.startColumn = startColumn;
    floatingObject.startColumnOffset = startColumnOffset;
    floatingObject.endColumn = endColumn;
    floatingObject.endColumnOffset = endColumnOffset;
    return floatingObject;
}
function recalcPictureLayoutForZoom(sheet, floatingObject) {
    var rowCount = sheet.rowCount, columnCount = sheet.columnCount;
    var width = floatingObject.width, height = floatingObject.height, startRow = floatingObject.startRow, startRowOffset = floatingObject.startRowOffset || 0, startColumn = floatingObject.startColumn, startColumnOffset = floatingObject.startColumnOffset || 0, endRow = floatingObject.endRow, endRowOffset = floatingObject.endRowOffset || 0, endColumn = floatingObject.endColumn, endColumnOffset = floatingObject.endColumnOffset || 0, originalWidth = floatingObject.originalWidth, originalHeight = floatingObject.originalHeight, ratio = width / height, originalRatio = originalWidth / originalHeight;
    var newStartColumnOffset = 0, newStartRowOffset = 0, newWidth = width, newHeight = height;
    if (height > 0 && originalHeight > 0 && ratio > originalRatio) {
        newWidth = originalRatio * height;
        newStartColumnOffset = startColumnOffset + width / 2 - newWidth / 2;
        width = newWidth;
        height = 1 / originalRatio * width;
    }
    else if (width > 0 && originalWidth > 0 && 1 / ratio > 1 / originalRatio) {
        newHeight = 1 / originalRatio * width;
        newStartRowOffset = startRowOffset + height / 2 - newHeight / 2;
        height = newHeight;
        width = originalRatio * height;
    }
    else {
        return floatingObject;
    }
    if (newStartColumnOffset > 0) {
        var currentWidth = getActualColumnWidth(sheet, startColumn, ++startColumn);
        while (startColumn < columnCount) {
            newStartColumnOffset -= currentWidth;
            if (newStartColumnOffset < 0) {
                startColumn--;
                startColumnOffset = newStartColumnOffset + currentWidth;
                break;
            }
            currentWidth = getActualColumnWidth(sheet, startColumn, ++startColumn);
        }
        var totalWidth = 0, c = startColumn;
        while (c < columnCount) {
            var cw = getActualColumnWidth(sheet, c, ++c);
            totalWidth += cw;
            if (totalWidth > newWidth + startColumnOffset) {
                endColumnOffset = cw - (totalWidth - newWidth - startColumnOffset);
                endColumn = c - 1 < 0 ? 0 : c - 1;
                break;
            }
        }
    }
    else if (newStartRowOffset > 0) {
        var currentHeight = getActualRowHeight(sheet, startRow, ++startRow);
        while (startRow < rowCount) {
            newStartRowOffset -= currentHeight;
            if (newStartRowOffset < 0) {
                startRow--;
                startRowOffset = newStartRowOffset + currentHeight;
                break;
            }
            currentHeight = getActualRowHeight(sheet, startRow, ++startRow);
        }
        var totalHeight = 0, r = startRow;
        while (r < rowCount) {
            var cr = getActualRowHeight(sheet, r, ++r);
            totalHeight += cr;
            if (totalHeight > newHeight + startRowOffset) {
                endRowOffset = cr - (totalHeight - newHeight - startRowOffset);
                endRow = r - 1 < 0 ? 0 : r - 1;
                break;
            }
        }
    }
    floatingObject.width = width;
    floatingObject.height = height;
    floatingObject.startRow = startRow;
    floatingObject.startRowOffset = startRowOffset;
    floatingObject.endRow = endRow;
    floatingObject.endRowOffset = endRowOffset;
    floatingObject.startColumn = startColumn;
    floatingObject.startColumnOffset = startColumnOffset;
    floatingObject.endColumn = endColumn;
    floatingObject.endColumnOffset = endColumnOffset;
    return floatingObject;
}
function recalcPictureLayoutForNone(sheet, floatingObject) {
    var rowCount = sheet.rowCount, columnCount = sheet.columnCount;
    var width = floatingObject.width, height = floatingObject.height, startRow = floatingObject.startRow, startRowOffset = floatingObject.startRowOffset || 0, startColumn = floatingObject.startColumn, startColumnOffset = floatingObject.startColumnOffset || 0, endRow = floatingObject.endRow, endRowOffset = floatingObject.endRowOffset || 0, endColumn = floatingObject.endColumn, endColumnOffset = floatingObject.endColumnOffset || 0, originalWidth = floatingObject.originalWidth, originalHeight = floatingObject.originalHeight;
    width = Math.min(width, originalWidth);
    height = Math.min(height, originalHeight);
    var totalHeight = 0, r = startRow;
    while (r < rowCount) {
        var rh = getActualRowHeight(sheet, r, ++r);
        totalHeight += rh;
        if (totalHeight > height + startRowOffset) {
            endRow = r - 1 < 0 ? 0 : r - 1;
            endRowOffset = rh - (totalHeight - height - startRowOffset);
            break;
        }
    }
    var totalWidth = 0, c = startColumn;
    while (c < columnCount) {
        var cw = getActualColumnWidth(sheet, c, ++c);
        totalWidth += cw;
        if (totalWidth > width + startColumnOffset) {
            endColumn = c - 1 < 0 ? 0 : c - 1;
            endColumnOffset = cw - (totalWidth - width - startColumnOffset);
            break;
        }
    }
    floatingObject.width = width;
    floatingObject.height = height;
    floatingObject.startRow = startRow;
    floatingObject.startRowOffset = startRowOffset;
    floatingObject.endRow = endRow;
    floatingObject.endRowOffset = endRowOffset;
    floatingObject.startColumn = startColumn;
    floatingObject.startColumnOffset = startColumnOffset;
    floatingObject.endColumn = endColumn;
    floatingObject.endColumnOffset = endColumnOffset;
    return floatingObject;
}
function getDrawingBounds(sheet, anchor, containerWidth, containerHeight) {
    var anchorType = anchor.anchorType;
    if (anchorType === 0) {
        return getBoundsByTwoCellAnchor(sheet, anchor);
    }
    else if (anchorType === 1) {
        return getBoundsByOneCellAnchor(sheet, anchor);
    }
    else if (anchorType === 2) {
        return getBoundsByAbsoluteAnchor(anchor);
    }
    else if (anchorType === 3) {
        return getBoundsByRelativeSizeAnchor(anchor, containerWidth, containerHeight);
    }
    else if (anchorType === 4) {
        return getBoundsByAbsoluteSizeAnchor(anchor, containerWidth, containerHeight);
    }
    return null;
}
function getMoveSizeValueFromAnchor(anchor) {
    var editAs = anchor.anchorType || anchor.editAs || 0;
    var dynamicMove = true, dynamicSize = true;
    if (editAs === 2) {
        dynamicMove = false;
        dynamicSize = false;
    }
    else if (editAs === 1) {
        dynamicSize = false;
    }
    return {
        dynamicMove: dynamicMove,
        dynamicSize: dynamicSize
    };
}
function getEditAsValueFromMoveSize(dynamicMove, dynamicSize) {
    var editAsValue;
    if (dynamicMove === false && dynamicSize === false) {
        editAsValue = 2;
    }
    else if (dynamicSize === false) {
        editAsValue = 1;
    }
    return editAsValue;
}
function getUserShapesDrawingAnchor(shapeItem, containerWidth, containerHeight) {
    var anchorInfo = {
        x: shapeItem.x || 0,
        y: shapeItem.y || 0,
        width: shapeItem.width || 0,
        height: shapeItem.height || 0
    };
    return {
        startPoint: {
            x: (anchorInfo.x / containerWidth).toFixed(5),
            y: (anchorInfo.y / containerHeight).toFixed(5)
        },
        endPoint: {
            x: ((anchorInfo.x + anchorInfo.width) / containerWidth).toFixed(5),
            y: ((anchorInfo.y + anchorInfo.height) / containerHeight).toFixed(5)
        }
    };
}
function getExcelColor(color) {
    if (!color) {
        return null;
    }
    var excelColor = excel_style_1.ColorHelper.toExcelColor(color), colorType = excelColor.colorType();
    if (colorType === 2) {
        var tempColor = excel_style_1.ColorHelper.getRGBAColorData(excelColor);
        return {
            srgbClr: {
                val: tempColor.rgb
            }
        };
    }
    else if (colorType === 3) {
        return {
            schemeClr: {
                val: excelColor.value()
            }
        };
    }
    return null;
}
function rotateVector(vector, sin, cos) {
    return {
        x: vector.x * cos - vector.y * sin,
        y: vector.x * sin + vector.y * cos
    };
}
var fromExcelAngleRatio = Math.PI / 180 / 60000;
function getDrawingBoundsFromXfrm(xfrm) {
    if (xfrm && xfrm.rot) {
        var rot = xfrm.rot, off = xfrm.off, ext = xfrm.ext, x = off.x, y = off.y, cx = ext.cx, cy = ext.cy;
        var halfWidth = cx / 2, halfHeight = cy / 2;
        var radians = rot * fromExcelAngleRatio, sin_1 = Math.sin(radians), cos_1 = Math.cos(radians);
        var centerX_1 = x + halfWidth, centerY_1 = y + halfHeight;
        var pointXs_1 = [], pointYs_1 = [];
        [
            { x: -halfWidth, y: -halfHeight },
            { x: halfWidth, y: -halfHeight },
            { x: -halfWidth, y: halfHeight },
            { x: halfWidth, y: halfHeight }
        ].forEach(function (item) {
            var point = rotateVector(item, sin_1, cos_1);
            pointXs_1.push(point.x + centerX_1);
            pointYs_1.push(point.y + centerY_1);
        });
        var left = Math.min.apply(null, pointXs_1);
        var right = Math.max.apply(null, pointXs_1);
        var top_1 = Math.min.apply(null, pointYs_1);
        var bottom = Math.max.apply(null, pointYs_1);
        return {
            x: left,
            y: top_1,
            width: right - left,
            height: bottom - top_1
        };
    }
}
function convertFromExcelAnchor(anchor, sheet, jsonData, xfrm) {
    var bounds = getDrawingBoundsFromXfrm(xfrm) || getDrawingBounds(sheet, anchor);
    var moveSizeValue = getMoveSizeValueFromAnchor(anchor);
    jsonData.dynamicMove = moveSizeValue.dynamicMove;
    jsonData.dynamicSize = moveSizeValue.dynamicSize;
    copyProperties(bounds, jsonData, ['x', 'y', 'width', 'height']);
    var twoCellAnchor;
    if (anchor.anchorType === 0) {
        if (xfrm) {
            twoCellAnchor = getAnchor(sheet, bounds);
        }
        else {
            twoCellAnchor = anchor;
        }
        convertFloatingObjectAnchor(twoCellAnchor, jsonData);
    }
    else {
        twoCellAnchor = getAnchor(sheet, bounds);
    }
    inflateWorksheetByAnchor(sheet, twoCellAnchor);
    var clientData = anchor.clientData;
    if (clientData) {
        jsonData.isLocked = clientData.fLocksWithSheet;
        jsonData.canPrint = clientData.fPrintsWithSheet;
    }
}
function convertFromExcelChart(sheet, excelChart) {
    inflateWorksheetByAnchor(sheet, excelChart);
    var GraphicalObjectFrame, cNvPrValue;
    var seriesItemTemp = common_1.Util._get2016ChartSeries(excelChart);
    var layoutId = seriesItemTemp && seriesItemTemp.layoutId;
    var is2016Chart = common_1.Util._is2016ChartByLayoutId(layoutId);
    if (is2016Chart) {
        GraphicalObjectFrame = excelChart.AlternateContent && excelChart.AlternateContent.Choice
            && excelChart.AlternateContent.Choice.GraphicalObjectFrame && excelChart.AlternateContent.Choice.GraphicalObjectFrame.nvGraphicFramePr;
    }
    else {
        GraphicalObjectFrame = excelChart.graphicFrame && excelChart.graphicFrame.nvGraphicFramePr;
    }
    cNvPrValue = GraphicalObjectFrame && GraphicalObjectFrame.cNvPr;
    var chartName = getUniqueName(sheet.charts, cNvPrValue.name, 'chart');
    var chartSpace = excelChart.chartSpace;
    var chartJsonData = {
        name: chartName,
        chartSpace: chartSpace,
        isVisible: !cNvPrValue.hidden,
        alt: cNvPrValue.descr,
        AlternateContent: excelChart.AlternateContent
    };
    convertFromExcelAnchor(excelChart, sheet, chartJsonData);
    var width = chartJsonData.width, height = chartJsonData.height;
    var userShapes = chartSpace.userShapes;
    if (userShapes) {
        chartSpace.userShapes = userShapes.map(function (shapeItem) {
            if (shapeItem.pic) {
                return convertFromExcelPictureInChart(sheet, shapeItem, width, height);
            }
            else if (shapeItem.graphicFrame) {
                return convertFromExcelChartInChart(sheet, shapeItem, width, height);
            }
        });
    }
    return chartJsonData;
}
exports.convertFromExcelChart = convertFromExcelChart;
function convertToExcelShape(sheet, shape) {
    var excelShapeData = shape.shapeData;
    excelShapeData.editAs = getEditAsValueFromMoveSize(shape.dynamicMove, shape.dynamicSize);
    excelShapeData.clientData = {
        fLocksWithSheet: shape.isLocked,
        fPrintsWithSheet: shape.canPrint
    };
    var alt = shape.alt;
    if (alt) {
        if (excelShapeData.sp) {
            excelShapeData.sp.nvSpPr.cNvPr.descr = alt;
        }
        else if (excelShapeData.cxnSp) {
            excelShapeData.cxnSp.nvCxnSpPr.cNvPr.descr = alt;
        }
        else if (excelShapeData.grpSp) {
            excelShapeData.grpSp.nvGrpSpPr.cNvPr.descr = alt;
        }
        else if (excelShapeData.pic) {
            excelShapeData.pic.nvPicPr.cNvPr.descr = alt;
        }
    }
    return excelShapeData;
}
exports.convertToExcelShape = convertToExcelShape;
function convertToExcelChart(sheet, chart) {
    var anchorInfo = getFloatingObjectAnchor(sheet, chart);
    var isVisible = chart.isVisible;
    var chartSpace = chart.chartSpace;
    var excelChartData = {
        anchorType: 0,
        startPoint: anchorInfo.startPoint,
        endPoint: anchorInfo.endPoint,
        editAs: anchorInfo.editAs,
        graphicFrame: {
            nvGraphicFramePr: {
                cNvPr: {
                    name: chart.name,
                    descr: chart.alt || '',
                    hidden: common_1._isNullOrUndefined(isVisible) ? false : !isVisible
                }
            }
        },
        clientData: {
            fLocksWithSheet: chart.isLocked,
            fPrintsWithSheet: chart.canPrint
        },
        chartSpace: chartSpace,
        AlternateContent: chart.AlternateContent
    };
    var currentId = 1, relSizeAnchor;
    var userShapes = chartSpace.userShapes;
    if (userShapes && userShapes.length > 0) {
        relSizeAnchor = userShapes.map(function (shapeItem) {
            if (shapeItem.typeName === '1') {
                return convertToExcelPictureInChart(shapeItem, currentId++, chart.width, chart.height);
            }
            else if (shapeItem.typeName === '2') {
                return convertToExcelChartInChart(shapeItem, currentId++, chart.width, chart.height);
            }
        });
        chartSpace.userShapes = {
            relSizeAnchor: relSizeAnchor
        };
    }
    return excelChartData;
}
exports.convertToExcelChart = convertToExcelChart;
function convertFromExcelChartInChart(sheet, excelChartInChart, containerWidth, containerHeight) {
    var cNvPrValue = excelChartInChart.graphicFrame && excelChartInChart.graphicFrame.nvGraphicFramePr &&
        excelChartInChart.graphicFrame.nvGraphicFramePr.cNvPr && excelChartInChart.graphicFrame.nvGraphicFramePr.cNvPr;
    var chartName = getUniqueName(sheet.charts, cNvPrValue.name, 'chart');
    var bounds = getDrawingBounds(sheet, excelChartInChart, containerWidth, containerHeight);
    var chartJsonData = {
        name: chartName,
        chartSpace: excelChartInChart.chartSpace,
        isVisible: !cNvPrValue.hidden,
        alt: cNvPrValue.descr
    };
    copyProperties(bounds, chartJsonData, ['x', 'y', 'width', 'height']);
    return chartJsonData;
}
function convertToExcelChartInChart(chart, id, containerWidth, containerHeight) {
    var anchorInfo = getUserShapesDrawingAnchor(chart, containerWidth, containerHeight);
    var isVisible = chart.isVisible;
    return {
        typeName: chart.typeName,
        anchorType: 3,
        startPoint: anchorInfo.startPoint,
        endPoint: anchorInfo.endPoint,
        graphicFrame: {
            nvGraphicFramePr: {
                cNvPr: {
                    name: chart.name,
                    descr: chart.alt || '',
                    hidden: common_1._isNullOrUndefined(isVisible) ? false : !isVisible
                }
            }
        },
        chartSpace: chart.chartSpace
    };
}
function convertFromExcelPictureInChart(sheet, excelPictureInChart, containerWidth, containerHeight) {
    var cNvPrValue = excelPictureInChart.pic && excelPictureInChart.pic.nvPicPr &&
        excelPictureInChart.pic.nvPicPr.cNvPr;
    var pictureName = cNvPrValue.name;
    var floatingObjects = sheet.floatingObjects;
    if (floatingObjects) {
        pictureName = getUniqueName(floatingObjects, pictureName, 'picture');
    }
    var blipFill = excelPictureInChart.pic && excelPictureInChart.pic.blipFill;
    var blipBlob = blipFill && blipFill.blip && blipFill.blip.blipBlob;
    var src = blipBlob && blipBlob.blob;
    var picture = {
        name: pictureName,
        alt: cNvPrValue.descr,
        src: src,
        isVisible: !cNvPrValue.hidden
    };
    var bounds = getDrawingBounds(sheet, excelPictureInChart, containerWidth, containerHeight);
    copyProperties(bounds, picture, ['x', 'y', 'width', 'height']);
    convertPictureStyle(excelPictureInChart.pictureFormat, picture);
    return picture;
}
function convertToExcelPictureInChart(picture, id, containerWidth, containerHeight) {
    var anchorInfo = getUserShapesDrawingAnchor(picture, containerWidth, containerHeight);
    var excelPicture = {
        typeName: picture.typeName,
        anchorType: 3,
        startPoint: anchorInfo.startPoint,
        endPoint: anchorInfo.endPoint,
        pic: {
            nvPicPr: {
                cNvPr: {
                    name: picture.name,
                    descr: picture.alt || ''
                },
                cNvPicPr: {
                    picLocks: {}
                }
            },
            spPr: {
                ln: {
                    w: isNoneBorderStyle(picture.borderStyle) ? 0 : picture.borderWidth
                },
                prstGeom: {
                    prst: 1,
                    avLst: {}
                }
            }
        },
        src: picture.src
    };
    var spPr = excelPicture.pic.spPr, ln = spPr.ln;
    var backColor = getExcelColor(picture.backColor);
    if (backColor) {
        spPr.solidFill = backColor;
    }
    var borderColor = getExcelColor(picture.borderColor);
    if (borderColor) {
        ln.solidFill = borderColor;
    }
    var borderStyle = pictureBorderStyleToExcelLineType(picture.borderStyle);
    if (borderStyle === 'dbl') {
        ln.cmpd = chart_model_1.Charts.ST_CompoundLine[borderStyle];
    }
    else {
        ln.prstDash = chart_model_1.Charts.ST_PresetLineDashVal[borderStyle];
    }
    return excelPicture;
}
function isBorderEqual(border1, border2) {
    if (border1 && border2 && border1.color === border2.color && border1.type === border2.type) {
        return true;
    }
    return (!border1 && !border2);
}
exports.isBorderEqual = isBorderEqual;
var needResetStyleName = {
    backColor: 0,
    foreColor: 0,
    borderBottom: 1,
    borderLeft: 1,
    borderRight: 1,
    borderTop: 1,
    font: 0,
    textDecoration: 0
};
function processTableCellStyle(style, defaultStyle) {
    var newStyle = {};
    for (var item in style) {
        if (!style.hasOwnProperty(item)) {
            continue;
        }
        if (needResetStyleName[item] === 0) {
            if (style[item] !== defaultStyle[item]) {
                newStyle[item] = style[item];
            }
        }
        else if (needResetStyleName[item] === 1) {
            if (!isBorderEqual(style[item], defaultStyle[item])) {
                newStyle[item] = style[item];
            }
        }
        else {
            newStyle[item] = style[item];
        }
    }
    return newStyle;
}
exports.processTableCellStyle = processTableCellStyle;
function getImageContent(fileName, getFileDataAndCleanData) {
    var extension = 'png';
    var pos = fileName.lastIndexOf('.');
    if (pos !== -1) {
        extension = fileName.substr(pos + 1);
    }
    if (extension === 'svg') {
        extension = 'svg+xml';
    }
    var imageContent = getFileDataAndCleanData(fileName, true);
    if (imageContent) {
        return 'data:image/' + extension + ';base64,' + imageContent;
    }
    return keyword_null;
}
exports.getImageContent = getImageContent;
function cloneObject(src) {
    return JSON.parse(JSON.stringify(src));
}
function getXFrm(drawingObject) {
    var t = drawingObject.sp || drawingObject.cxnSp || drawingObject.grpSp;
    return t && (t.spPr && t.spPr.xfrm || t.grpSpPr && t.grpSpPr.xfrm);
}
exports.getXFrm = getXFrm;
function convertFromExcelShape(sheet, excelShape) {
    var shape = {};
    convertFromExcelAnchor(excelShape, sheet, shape);
    if (excelShape.sp) {
        shape.shapeType = excelShape.sp.shapeType;
        shape.name = excelShape.sp.nvSpPr.cNvPr.name;
        shape.alt = excelShape.sp.nvSpPr.cNvPr.descr;
        shape.shapeData = cloneObject(excelShape);
    }
    else if (excelShape.cxnSp) {
        shape.shapeType = excelShape.cxnSp.shapeType;
        shape.name = excelShape.cxnSp.nvCxnSpPr.cNvPr.name;
        shape.alt = excelShape.cxnSp.nvCxnSpPr.cNvPr.descr;
        shape.shapeData = cloneObject(excelShape);
    }
    else if (excelShape.grpSp) {
        shape.shapeType = excelShape.grpSp.shapeType;
        shape.name = excelShape.grpSp.nvGrpSpPr.cNvPr.name;
        shape.alt = excelShape.grpSp.nvGrpSpPr.cNvPr.descr;
        shape.shapeData = cloneObject(excelShape);
    }
    else if (excelShape.pic) {
        var pic = excelShape.pic;
        shape.shapeType = pic.shapeType;
        shape.name = pic.nvPicPr.cNvPr.name;
        shape.alt = pic.nvPicPr.cNvPr.descr;
        shape.shapeData = cloneObject(excelShape);
    }
    var shapeData = shape.shapeData;
    if (shapeData && shapeData.hidden) {
        shapeData.isVisible = false;
        shape.isVisible = false;
        delete shapeData.hidden;
    }
    return shape;
}
exports.convertFromExcelShape = convertFromExcelShape;
exports.toProtectionOptions = {
    selectLockedCells: 'allowSelectLockedCells',
    selectUnlockedCells: 'allowSelectUnlockedCells',
    autoFilter: 'allowFilter',
    sort: 'allowSort',
    insertColumns: 'allowInsertColumns',
    insertRows: 'allowInsertRows',
    deleteColumns: 'allowDeleteColumns',
    deleteRows: 'allowDeleteRows',
    objects: 'allowEditObjects'
};
exports.fromProtectionOptions = {
    allowSelectLockedCells: 'selectLockedCells',
    allowSelectUnlockedCells: 'selectUnlockedCells',
    allowFilter: 'autoFilter',
    allowSort: 'sort',
    allowInsertColumns: 'insertColumns',
    allowInsertRows: 'insertRows',
    allowDeleteColumns: 'deleteColumns',
    allowDeleteRows: 'deleteRows',
    allowEditObjects: 'objects'
};
exports.excelSupportProtectionOptions = {
    formatCells: true,
    formatColumns: true,
    formatRows: true,
    insertColumns: true,
    insertRows: true,
    insertHyperlinks: true,
    deleteColumns: true,
    deleteRows: true,
    sort: true,
    autoFilter: true,
    pivotTables: true
};
/***/ }),

/***/ './src/datamodel/excel-style.ts':
/*!**************************************!*\
  !*** ./src/datamodel/excel-style.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });
var common_1 = __webpack_require__(/*! ./../common/common */ './src/common/common.ts');
var builtIn_resource_1 = __webpack_require__(/*! ./../common/builtIn-resource */ './src/common/builtIn-resource.ts');
var excel_types_1 = __webpack_require__(/*! ./../common/excel-types */ './src/common/excel-types.ts');
var xml_reader_1 = __webpack_require__(/*! ./../xml-io/xml-reader */ './src/xml-io/xml-reader.ts');
var style_reader_1 = __webpack_require__(/*! ./../xlsx-io/reader/style-reader */ './src/xlsx-io/reader/style-reader.ts');
var keyword_null = null, keyword_undefined = void 0;
var THEME_HEADINGS = 'Headings';
var THEME_BODY = 'Body';
var DEFAULT_FONT_FAMILY = 'Calibri';
var BOLD = 'bold', ITALIC = 'italic';
var FontSchemeCategory;
(function (FontSchemeCategory) {
    FontSchemeCategory[FontSchemeCategory['none'] = 0] = 'none';
    FontSchemeCategory[FontSchemeCategory['major'] = 1] = 'major';
    FontSchemeCategory[FontSchemeCategory['minor'] = 2] = 'minor';
    FontSchemeCategory[FontSchemeCategory['ninched'] = 255] = 'ninched';
})(FontSchemeCategory = exports.FontSchemeCategory || (exports.FontSchemeCategory = {}));
var ExcelVerticalAlignment;
(function (ExcelVerticalAlignment) {
    ExcelVerticalAlignment[ExcelVerticalAlignment['top'] = 0] = 'top';
    ExcelVerticalAlignment[ExcelVerticalAlignment['center'] = 1] = 'center';
    ExcelVerticalAlignment[ExcelVerticalAlignment['bottom'] = 2] = 'bottom';
    ExcelVerticalAlignment[ExcelVerticalAlignment['justify'] = 3] = 'justify';
    ExcelVerticalAlignment[ExcelVerticalAlignment['distributed'] = 4] = 'distributed';
})(ExcelVerticalAlignment = exports.ExcelVerticalAlignment || (exports.ExcelVerticalAlignment = {}));
var ExcelHorizontalAlignment;
(function (ExcelHorizontalAlignment) {
    ExcelHorizontalAlignment[ExcelHorizontalAlignment['general'] = 0] = 'general';
    ExcelHorizontalAlignment[ExcelHorizontalAlignment['left'] = 1] = 'left';
    ExcelHorizontalAlignment[ExcelHorizontalAlignment['center'] = 2] = 'center';
    ExcelHorizontalAlignment[ExcelHorizontalAlignment['right'] = 3] = 'right';
    ExcelHorizontalAlignment[ExcelHorizontalAlignment['fill'] = 4] = 'fill';
    ExcelHorizontalAlignment[ExcelHorizontalAlignment['justify'] = 5] = 'justify';
    ExcelHorizontalAlignment[ExcelHorizontalAlignment['centerContinuous'] = 6] = 'centerContinuous';
    ExcelHorizontalAlignment[ExcelHorizontalAlignment['distributed'] = 7] = 'distributed';
})(ExcelHorizontalAlignment = exports.ExcelHorizontalAlignment || (exports.ExcelHorizontalAlignment = {}));
var TextDirection;
(function (TextDirection) {
    TextDirection[TextDirection['accordingToContext'] = 0] = 'accordingToContext';
    TextDirection[TextDirection['leftToRight'] = 1] = 'leftToRight';
    TextDirection[TextDirection['rightToLeft'] = 2] = 'rightToLeft';
})(TextDirection = exports.TextDirection || (exports.TextDirection = {}));
var UnderLineStyle;
(function (UnderLineStyle) {
    UnderLineStyle[UnderLineStyle['none'] = 0] = 'none';
    UnderLineStyle[UnderLineStyle['single'] = 1] = 'single';
    UnderLineStyle[UnderLineStyle['double'] = 2] = 'double';
    UnderLineStyle[UnderLineStyle['singleaccounting'] = 3] = 'singleaccounting';
    UnderLineStyle[UnderLineStyle['doubleaccounting'] = 4] = 'doubleaccounting';
})(UnderLineStyle = exports.UnderLineStyle || (exports.UnderLineStyle = {}));
var VertAlign;
(function (VertAlign) {
    VertAlign[VertAlign['baseLine'] = 0] = 'baseLine';
    VertAlign[VertAlign['superscript'] = 1] = 'superscript';
    VertAlign[VertAlign['subscript'] = 2] = 'subscript';
})(VertAlign = exports.VertAlign || (exports.VertAlign = {}));
var ExcelBorderStyle;
(function (ExcelBorderStyle) {
    ExcelBorderStyle[ExcelBorderStyle['none'] = 0] = 'none';
    ExcelBorderStyle[ExcelBorderStyle['thin'] = 1] = 'thin';
    ExcelBorderStyle[ExcelBorderStyle['medium'] = 2] = 'medium';
    ExcelBorderStyle[ExcelBorderStyle['dashed'] = 3] = 'dashed';
    ExcelBorderStyle[ExcelBorderStyle['dotted'] = 4] = 'dotted';
    ExcelBorderStyle[ExcelBorderStyle['thick'] = 5] = 'thick';
    ExcelBorderStyle[ExcelBorderStyle['double'] = 6] = 'double';
    ExcelBorderStyle[ExcelBorderStyle['hair'] = 7] = 'hair';
    ExcelBorderStyle[ExcelBorderStyle['mediumDashed'] = 8] = 'mediumDashed';
    ExcelBorderStyle[ExcelBorderStyle['dashDot'] = 9] = 'dashDot';
    ExcelBorderStyle[ExcelBorderStyle['mediumDashDot'] = 10] = 'mediumDashDot';
    ExcelBorderStyle[ExcelBorderStyle['dashDotDot'] = 11] = 'dashDotDot';
    ExcelBorderStyle[ExcelBorderStyle['mediumDashDotDot'] = 12] = 'mediumDashDotDot';
    ExcelBorderStyle[ExcelBorderStyle['slantDashDot'] = 13] = 'slantDashDot';
})(ExcelBorderStyle = exports.ExcelBorderStyle || (exports.ExcelBorderStyle = {}));
var FillPatternType;
(function (FillPatternType) {
    FillPatternType[FillPatternType['none'] = 0] = 'none';
    FillPatternType[FillPatternType['solid'] = 1] = 'solid';
    FillPatternType[FillPatternType['darkGray'] = 2] = 'darkGray';
    FillPatternType[FillPatternType['mediumGray'] = 3] = 'mediumGray';
    FillPatternType[FillPatternType['lightGray'] = 4] = 'lightGray';
    FillPatternType[FillPatternType['gray125'] = 5] = 'gray125';
    FillPatternType[FillPatternType['gray0625'] = 6] = 'gray0625';
    FillPatternType[FillPatternType['darkHorizontal'] = 7] = 'darkHorizontal';
    FillPatternType[FillPatternType['darkVertical'] = 8] = 'darkVertical';
    FillPatternType[FillPatternType['darkDown'] = 9] = 'darkDown';
    FillPatternType[FillPatternType['darkUp'] = 10] = 'darkUp';
    FillPatternType[FillPatternType['darkGrid'] = 11] = 'darkGrid';
    FillPatternType[FillPatternType['darkTrellis'] = 12] = 'darkTrellis';
    FillPatternType[FillPatternType['lightHorizontal'] = 13] = 'lightHorizontal';
    FillPatternType[FillPatternType['lightVertical'] = 14] = 'lightVertical';
    FillPatternType[FillPatternType['lightDown'] = 15] = 'lightDown';
    FillPatternType[FillPatternType['lightUp'] = 16] = 'lightUp';
    FillPatternType[FillPatternType['lightGrid'] = 17] = 'lightGrid';
    FillPatternType[FillPatternType['lightTrellis'] = 18] = 'lightTrellis';
})(FillPatternType = exports.FillPatternType || (exports.FillPatternType = {}));
var ExcelColor = /** @class */ (function () {
    function ExcelColor(colorType, color, tint) {
        var self = this;
        if (colorType === 3 && color > 11 && color !== 0xF1 && color !== 0xF2 && color !== 0xF3 && color !== 0xF4 && color !== 0xFF) {
            throw new Error('themeColorIndexError');
        }
        if (tint > 1.0 || tint < -1.0) {
            throw new Error('colorTintError');
        }
        if (colorType === 1 && color === 32767) {
            self._isAutoColor = true;
        }
        self._colorType = colorType || 2;
        self._color = color || 0;
        self._tint = tint || 0;
    }
    ExcelColor.prototype.colorType = function () {
        return this._colorType;
    };
    ExcelColor.prototype.value = function () {
        return this._color;
    };
    ExcelColor.prototype.tint = function () {
        return this._tint;
    };
    ExcelColor.prototype.isAutoColor = function (value) {
        var self = this;
        if (arguments.length === 0) {
            return self._isAutoColor;
        }
        if (typeof value === 'boolean' && value !== self._isAutoColor) {
            self._isAutoColor = value;
        }
    };
    ExcelColor.prototype.isIndexedColor = function () {
        return this._colorType === 1;
    };
    ExcelColor.prototype.isRGBColor = function () {
        return this._colorType === 2;
    };
    ExcelColor.prototype.isThemeColor = function () {
        return this._colorType === 3;
    };
    ExcelColor.prototype.equals = function (other) {
        if (this === other) {
            return true;
        }
        if (!other) {
            return false;
        }
        return this._colorType === other.colorType() &&
            this.value() === other.value() &&
            this.tint() === other.tint() &&
            this.isAutoColor() === other.isAutoColor();
    };
    ExcelColor.EmptyColor = new ExcelColor();
    return ExcelColor;
}());
exports.ExcelColor = ExcelColor;
var ExcelBorderSide = /** @class */ (function () {
    function ExcelBorderSide(color, lineStyle) {
        this.color = color || null;
        this.lineStyle = lineStyle || 0;
    }
    ExcelBorderSide.prototype.equals = function (other) {
        var self = this;
        if (self === other) {
            return true;
        }
        if (!other) {
            return false;
        }
        if (!self.color) {
            if (other.color) {
                return false;
            }
            return self.lineStyle === other.lineStyle;
        }
        return self.color.equals(other.color) && self.lineStyle === other.lineStyle;
    };
    ExcelBorderSide.prototype.isDefault = function () {
        return this.color === null && this.lineStyle === 0;
    };
    return ExcelBorderSide;
}());
exports.ExcelBorderSide = ExcelBorderSide;
var ExcelBorder = /** @class */ (function () {
    function ExcelBorder() {
        var self = this;
        self.left = new ExcelBorderSide();
        self.top = new ExcelBorderSide();
        self.right = new ExcelBorderSide();
        self.bottom = new ExcelBorderSide();
        self.diagonalUp = new ExcelBorderSide();
        self.diagonalDown = new ExcelBorderSide();
    }
    ExcelBorder.prototype.clone = function () {
        var self = this, border = new ExcelBorder();
        border.left = new ExcelBorderSide(self.left.color, self.left.lineStyle);
        border.right = new ExcelBorderSide(self.right.color, self.right.lineStyle);
        border.top = new ExcelBorderSide(self.top.color, self.top.lineStyle);
        border.bottom = new ExcelBorderSide(self.bottom.color, self.bottom.lineStyle);
        border.diagonalUp = new ExcelBorderSide(self.diagonalUp.color, self.diagonalUp.lineStyle);
        border.diagonalDown = new ExcelBorderSide(self.diagonalDown.color, self.diagonalDown.lineStyle);
        return border;
    };
    ExcelBorder.prototype.compose = function (border) {
        var self = this;
        if (self.left.isDefault()) {
            self.left = border.left;
        }
        if (self.right.isDefault()) {
            self.right = border.right;
        }
        if (self.top.isDefault()) {
            self.top = border.top;
        }
        if (self.bottom.isDefault()) {
            self.bottom = border.bottom;
        }
        if (self.diagonalUp.isDefault()) {
            self.diagonalUp = border.diagonalUp;
        }
        if (self.diagonalDown.isDefault()) {
            self.diagonalDown = border.diagonalDown;
        }
    };
    ExcelBorder.prototype.equals = function (other) {
        var self = this;
        if (self === other) {
            return true;
        }
        if (!other) {
            return false;
        }
        return self.left.equals(other.left) &&
            self.right.equals(other.right) &&
            self.top.equals(other.top) &&
            self.bottom.equals(other.bottom) &&
            self.diagonalUp.equals(other.diagonalUp) &&
            self.diagonalDown.equals(other.diagonalDown);
    };
    return ExcelBorder;
}());
exports.ExcelBorder = ExcelBorder;
var ExcelFill = /** @class */ (function () {
    function ExcelFill() {
    }
    ExcelFill.prototype.clone = function () {
        var self = this, obj = new ExcelFill();
        obj.bgColor = self.bgColor;
        obj.fgColor = self.fgColor;
        obj.patternType = self.patternType;
        obj.stops = self.stops;
        obj.type = self.type;
        obj.degree = self.degree;
        obj.left = self.left;
        obj.right = self.right;
        obj.top = self.top;
        obj.bottom = self.bottom;
        return obj;
    };
    ExcelFill.prototype.compose = function (fill) {
        var self = this;
        if (self.bgColor === keyword_undefined) {
            self.bgColor = fill.bgColor;
        }
        if (self.fgColor === keyword_undefined) {
            self.fgColor = fill.fgColor;
        }
        if (self.patternType === keyword_undefined) {
            self.patternType = fill.patternType;
        }
        if (self.stops === keyword_undefined) {
            self.stops = fill.stops;
        }
        if (self.type === keyword_undefined) {
            self.type = fill.type;
        }
        if (self.degree === keyword_undefined) {
            self.degree = fill.degree;
        }
        if (self.left === keyword_undefined) {
            self.left = fill.left;
        }
        if (self.right === keyword_undefined) {
            self.right = fill.right;
        }
        if (self.top === keyword_undefined) {
            self.top = fill.top;
        }
        if (self.bottom === keyword_undefined) {
            self.bottom = fill.bottom;
        }
    };
    ExcelFill.prototype.equals = function (other) {
        var self = this;
        if (self === other) {
            return true;
        }
        if (!other) {
            return false;
        }
        return JSON.stringify(self) === JSON.stringify(other);
    };
    ExcelFill.Default = function () {
        if (!ExcelFill._default) {
            ExcelFill._default = new ExcelFill();
            ExcelFill._default.bgColor = keyword_undefined;
            ExcelFill._default.fgColor = keyword_undefined;
            ExcelFill._default.patternType = 0;
        }
        return ExcelFill._default;
    };
    return ExcelFill;
}());
exports.ExcelFill = ExcelFill;
var ExcelFont = /** @class */ (function () {
    function ExcelFont(name, fontColor, fontFamily) {
        var self = this;
        if (typeof fontColor !== 'undefined') {
            self.fontColor = fontColor;
        }
        else {
            self.fontColor = null;
        }
        if (typeof name !== 'undefined') {
            self.fontName = name;
        }
        else {
            self.fontName = null;
        }
        if (typeof fontFamily !== 'undefined') {
            self.fontFamily = fontFamily;
        }
        else {
            self.fontFamily = 0;
        }
        self.isAutoColor = false;
        self.isBold = false;
        self.isItalic = false;
        self.isOutlineStyle = false;
        self.isShadowStyle = false;
        self.isStrikeOut = false;
        self.fontScheme = 0;
        self.fontSize = 11;
        self.charSetIndex = 0;
        self.underLineStyle = 0;
        self.vertAlign = 0;
        self._default = null;
    }
    ExcelFont.prototype.equals = function (right) {
        var self = this;
        if (self === right) {
            return true;
        }
        if (!right) {
            return false;
        }
        var result = self.isBold === right.isBold &&
            self.isItalic === right.isItalic &&
            this.isOutlineStyle === right.isOutlineStyle &&
            this.isShadowStyle === right.isShadowStyle &&
            this.isStrikeOut === right.isStrikeOut &&
            this.fontName === right.fontName &&
            this.fontFamily === right.fontFamily &&
            this.fontSize === right.fontSize &&
            this.charSetIndex === right.charSetIndex &&
            this.underLineStyle === right.underLineStyle &&
            this.vertAlign === right.vertAlign &&
            this.fontScheme === right.fontScheme;
        if (!result) {
            return false;
        }
        if (!self.fontColor && !right.fontColor) {
            return true;
        }
        else if (!self.fontColor && right.fontColor) {
            return false;
        }
        else if (self.fontColor && !right.fontColor) {
            return false;
        }
        return self.fontColor.equals(right.fontColor);
    };
    ExcelFont.prototype.clone = function () {
        var self = this;
        var font = new ExcelFont(self.fontName, self.fontColor, self.fontFamily);
        font.isAutoColor = self.isAutoColor;
        font.isBold = self.isBold;
        font.isItalic = self.isItalic;
        font.isOutlineStyle = self.isOutlineStyle;
        font.isShadowStyle = self.isShadowStyle;
        font.isStrikeOut = self.isStrikeOut;
        font.fontScheme = self.fontScheme;
        font.fontSize = self.fontSize;
        font.charSetIndex = self.charSetIndex;
        font.underLineStyle = self.underLineStyle;
        font.vertAlign = self.vertAlign;
        return font;
    };
    ExcelFont.prototype.Default = function () {
        var self = this;
        if (!self._default) {
            self._default = new ExcelFont();
            self._default.fontSize = 11;
            self._default.fontFamily = 2;
            self._default.fontColor = new ExcelColor(1, 0, 0);
            self._default.fontName = 'Calibri';
            self._default.charSetIndex = 0;
        }
        return self._default;
    };
    ExcelFont.prototype.compose = function (font) {
        var self = this;
        if (self.fontColor === null) {
            self.fontColor = font.fontColor;
        }
        if (self.fontName === null) {
            self.fontName = font.fontName;
        }
        if (self.fontFamily === 0) {
            self.fontFamily = font.fontFamily;
        }
        if (self.isAutoColor === false) {
            self.isAutoColor = font.isAutoColor;
        }
        if (self.isBold === false) {
            self.isBold = font.isBold;
        }
        if (self.isItalic === false) {
            self.isItalic = font.isItalic;
        }
        if (self.isOutlineStyle === false) {
            self.isOutlineStyle = font.isOutlineStyle;
        }
        if (self.isShadowStyle === false) {
            self.isShadowStyle = font.isShadowStyle;
        }
        if (self.isStrikeOut === false) {
            self.isStrikeOut = font.isStrikeOut;
        }
        if (self.fontScheme === 0) {
            self.fontScheme = font.fontScheme;
        }
        if (self.fontSize === 11) {
            self.fontSize = font.fontSize;
        }
        if (self.charSetIndex === 0) {
            self.charSetIndex = font.charSetIndex;
        }
        if (self.underLineStyle === 0) {
            self.underLineStyle = font.underLineStyle;
        }
        if (self.vertAlign === 0) {
            self.vertAlign = font.vertAlign;
        }
        if (self._default === null) {
            self._default = font._default;
        }
    };
    return ExcelFont;
}());
exports.ExcelFont = ExcelFont;
var ExcelNumerFormat = /** @class */ (function () {
    function ExcelNumerFormat(id, code) {
        this.numberFormatId = id;
        this.numberFormatCode = code;
    }
    ExcelNumerFormat.prototype.equals = function (other) {
        var self = this;
        if (self === other) {
            return true;
        }
        if (!other) {
            return false;
        }
        return self.numberFormatId === other.numberFormatId && self.numberFormatCode === other.numberFormatCode;
    };
    ExcelNumerFormat.prototype.compose = function (numberFormat) {
        var self = this;
        if (self.numberFormatId === keyword_undefined) {
            self.numberFormatId = numberFormat.numberFormatId;
        }
        if (self.numberFormatCode === keyword_undefined) {
            self.numberFormatCode = numberFormat.numberFormatCode;
        }
    };
    ExcelNumerFormat.prototype.clone = function () {
        var self = this;
        return new ExcelNumerFormat(self.numberFormatId, self.numberFormatCode);
    };
    return ExcelNumerFormat;
}());
exports.ExcelNumerFormat = ExcelNumerFormat;
var ExtendedFormat = /** @class */ (function () {
    function ExtendedFormat() {
        var self = this;
        self.font = (new ExcelFont()).Default();
        self.border = new ExcelBorder();
        self.applyAlignment = keyword_undefined;
        self.applyBorder = keyword_undefined;
        self.applyFill = keyword_undefined;
        self.applyFont = keyword_undefined;
        self.applyNumberFormat = keyword_undefined;
        self.applyProtection = keyword_undefined;
        self.quotePrefix = keyword_undefined;
        self.fill = ExcelFill.Default();
        self.numberFormatIndex = 0;
        self.numberFormat = keyword_undefined;
        self.isStyleFormat = false;
        self.parentFormatID = keyword_undefined;
        self.parentName = keyword_undefined;
        self.horizontalAlign = 0;
        self.verticalAlign = 0;
        self.isLocked = false;
        self.rotation = 0;
        self.isWordWrap = false;
        self.isJustfyLastLine = false;
        self.isShrinkToFit = false;
        self.isFirstSymbolApostrophe = false;
        self.readingOrder = 0;
        self.isHidden = false;
        self.indent = 0;
        self.isVerticalText = false;
    }
    ExtendedFormat.Default = function () {
        var extendedFormat = new ExtendedFormat();
        extendedFormat.numberFormatIndex = 0;
        extendedFormat.isLocked = true;
        extendedFormat.verticalAlign = 2;
        extendedFormat.horizontalAlign = 0;
        return extendedFormat;
    };
    ExtendedFormat.prototype.copyFrom = function (source) {
        var self = this;
        self.applyAlignment = source.applyAlignment;
        self.applyBorder = source.applyBorder;
        self.applyFill = source.applyFill;
        self.applyFont = source.applyFont;
        self.applyNumberFormat = source.applyNumberFormat;
        self.applyProtection = source.applyProtection;
        self.fill = source.fill !== null ? source.fill.clone() : null;
        self.border = source.border !== null ? source.border.clone() : null;
        self.font = source.font !== null ? source.font.clone() : null;
        self.numberFormatIndex = source.numberFormatIndex;
        self.numberFormat = source.numberFormat;
        self.isStyleFormat = source.isStyleFormat;
        self.parentFormatID = source.parentFormatID;
        self.horizontalAlign = source.horizontalAlign;
        self.verticalAlign = source.verticalAlign;
        self.isLocked = source.isLocked;
        self.rotation = source.rotation;
        self.isWordWrap = source.isWordWrap;
        self.isJustfyLastLine = source.isJustfyLastLine;
        self.isShrinkToFit = source.isShrinkToFit;
        self.isFirstSymbolApostrophe = source.isFirstSymbolApostrophe;
        self.readingOrder = source.readingOrder;
        self.isHidden = source.isHidden;
        self.indent = source.indent;
        self.quotePrefix = source.quotePrefix;
    };
    ExtendedFormat.prototype.clone = function () {
        var s = new ExtendedFormat();
        s.copyFrom(this);
        return s;
    };
    ExtendedFormat.prototype.equals = function (excelStyle, ignoreParent) {
        var self = this;
        if (self === excelStyle) {
            return true;
        }
        if (!excelStyle) {
            return false;
        }
        if (!self.numberFormat && excelStyle.numberFormat) {
            return false;
        }
        var result = self.numberFormatIndex === excelStyle.numberFormatIndex &&
            self.horizontalAlign === excelStyle.horizontalAlign &&
            self.verticalAlign === excelStyle.verticalAlign &&
            self.isLocked === excelStyle.isLocked &&
            self.rotation === excelStyle.rotation &&
            self.isWordWrap === excelStyle.isWordWrap &&
            self.isJustfyLastLine === excelStyle.isJustfyLastLine &&
            self.isShrinkToFit === excelStyle.isShrinkToFit &&
            self.isFirstSymbolApostrophe === excelStyle.isFirstSymbolApostrophe &&
            self.readingOrder === excelStyle.readingOrder &&
            self.isHidden === excelStyle.isHidden &&
            self.indent === excelStyle.indent &&
            self.applyAlignment === excelStyle.applyAlignment &&
            self.applyBorder === excelStyle.applyBorder &&
            self.applyFill === excelStyle.applyFill &&
            self.applyFont === excelStyle.applyFont &&
            self.applyNumberFormat === excelStyle.applyNumberFormat &&
            self.applyProtection === excelStyle.applyProtection &&
            self.parentFormatID === excelStyle.parentFormatID &&
            self.quotePrefix === excelStyle.quotePrefix &&
            self.border.equals(excelStyle.border);
        if (!ignoreParent) {
            result = (result && self.parentName === excelStyle.parentName);
        }
        if (!self.font) {
            if (excelStyle.font) {
                return false;
            }
        }
        else {
            result = (result && self.font.equals(excelStyle.font));
        }
        if (self.numberFormat) {
            result = (result && self.numberFormat.equals(excelStyle.numberFormat));
        }
        if (!self.fill) {
            if (excelStyle.fill) {
                return false;
            }
        }
        else {
            result = (result && self.fill.equals(excelStyle.fill));
        }
        return result;
    };
    return ExtendedFormat;
}());
exports.ExtendedFormat = ExtendedFormat;
var ExcelStyle = /** @class */ (function () {
    function ExcelStyle() {
        this._format = null;
        this.builtInStyle = 0;
        this.category = 0;
        this.isCustomBuiltin = false;
        this.name = null;
        this.outLineLevel = 0;
    }
    ExcelStyle.prototype.format = function (value) {
        var self = this;
        if (arguments.length === 0) {
            if (self._format === null) {
                self._format = new ExtendedFormat();
            }
            return self._format;
        }
        self._format = value;
    };
    ExcelStyle.prototype.copy = function () {
        var self = this, result = new ExcelStyle();
        result.builtInStyle = self.builtInStyle;
        result.outLineLevel = self.outLineLevel;
        result.isCustomBuiltin = self.isCustomBuiltin;
        result.category = self.category;
        result.name = self.name;
        result.format(self.format().clone());
        return result;
    };
    ExcelStyle.prototype.isBuiltInStyle = function () {
        return true;
    };
    ExcelStyle.prototype.getBuiltInStyleCategory = function () {
        var self = this;
        if (!self.isBuiltInStyle()) {
            return 0;
        }
        switch (self.builtInStyle) {
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 48:
            case 2:
            case 1:
                return 4;
            case 24:
                return 1;
            case 19:
                return 2;
            case 20:
                return 2;
            case 3:
            case 6:
            case 4:
            case 7:
                return 5;
            case 49:
                return 2;
            case 23:
                return 1;
            case 13:
            case 14:
            case 15:
            case 16:
                return 3;
            case 17:
                return 2;
            case 21:
                return 2;
            case 25:
                return 1;
            case 0:
                return 1;
            case 10:
            case 18:
                return 2;
            case 5:
                return 5;
            case 12:
            case 22:
                return 3;
            case 11:
                return 2;
            default:
                return 0;
        }
    };
    return ExcelStyle;
}());
exports.ExcelStyle = ExcelStyle;
var CustomExcelStyle = /** @class */ (function () {
    function CustomExcelStyle() {
        this._format = null;
        this.name = null;
    }
    CustomExcelStyle.prototype.format = function (value) {
        var self = this;
        if (arguments.length === 0) {
            if (self._format === null) {
                self._format = new ExtendedFormat();
            }
            return self._format;
        }
        self._format = value;
        return this;
    };
    CustomExcelStyle.prototype.copy = function () {
        var result = new CustomExcelStyle();
        result.name = this.name;
        result.format(this.format().clone());
        return result;
    };
    CustomExcelStyle.prototype.isBuiltInStyle = function () {
        return false;
    };
    return CustomExcelStyle;
}());
exports.CustomExcelStyle = CustomExcelStyle;
var BuiltInExcelStyles = /** @class */ (function () {
    function BuiltInExcelStyles() {
    }
    BuiltInExcelStyles.initBuiltInExcelStyleCollections = function () {
        BuiltInExcelStyles.builtInStyles.length = 0;
        var dataString = builtIn_resource_1.BuiltInStylesResource;
        if (dataString) {
            var reader = new xml_reader_1.XmlReader();
            reader.reset();
            reader.setXml(dataString);
            var fonts = [], fills = [], borders = [], styleXfs = [], numberFormats = {};
            while (reader.read()) {
                if (reader.depth !== 1 || reader.elementType === 2) {
                    continue;
                }
                switch (reader.name()) {
                    case 'numFmts':
                        style_reader_1.readNumberFormats(reader, numberFormats);
                        break;
                    case 'fonts':
                        style_reader_1.readFonts(reader, fonts);
                        break;
                    case 'fills':
                        style_reader_1.readFills(reader, fills);
                        break;
                    case 'borders':
                        style_reader_1.readBorders(reader, borders);
                        break;
                    case 'cellStyleXfs':
                        style_reader_1.readXFs(reader, styleXfs, fonts, borders, numberFormats, fills, true);
                        break;
                    case 'cellStyles':
                        var depth = reader.depth;
                        while (reader.read()) {
                            if (reader.depth <= depth) {
                                return;
                            }
                            if (reader.nodeType() === 1 && reader.name() === 'cellStyle') {
                                var name_1 = keyword_undefined, xfId = 0, builtinId = 0;
                                while (reader.moveToNextAttribute()) {
                                    switch (reader.readAttributeNameAsString()) {
                                        case 'name':
                                            name_1 = reader.readContentAsString();
                                            break;
                                        case 'xfId':
                                            xfId = reader.readContentAsInt(0);
                                            break;
                                        case 'builtinId':
                                            builtinId = reader.readContentAsInt(0);
                                            break;
                                        default:
                                            break;
                                    }
                                }
                                var cellFormat = styleXfs[xfId];
                                cellFormat.isStyleFormat = true;
                                var style = new ExcelStyle();
                                style.name = name_1;
                                style.format(cellFormat.clone());
                                if (!style.format().numberFormat && numberFormats[style.format().numberFormatIndex]) {
                                    style.format().numberFormat = numberFormats[style.format().numberFormatIndex];
                                    style.format().numberFormatIndex = 0;
                                }
                                style.isCustomBuiltin = false;
                                style.builtInStyle = builtinId;
                                style.category = style.getBuiltInStyleCategory();
                                BuiltInExcelStyles.builtInStyles.push(style);
                            }
                        }
                        break;
                    default:
                        break;
                }
            }
        }
    };
    BuiltInExcelStyles.getBuiltInStyles = function () {
        var builtLen = BuiltInExcelStyles.builtInStyles.length;
        if (builtLen !== 47) {
            BuiltInExcelStyles.initBuiltInExcelStyleCollections();
        }
        var result = [];
        builtLen = BuiltInExcelStyles.builtInStyles.length;
        for (var i = 0; i < builtLen; i++) {
            result.push(BuiltInExcelStyles.builtInStyles[i].copy());
        }
        return result;
    };
    BuiltInExcelStyles.getNormalStyle = function () {
        var format = new ExtendedFormat();
        format.font = new ExcelFont();
        format.font.fontColor = new ExcelColor(3, 1);
        format.font.fontSize = 11;
        format.font.fontName = 'Calibri';
        var ret = new ExcelStyle();
        ret.format(format);
        ret.name = 'Normal';
        ret.builtInStyle = 0;
        return ret;
    };
    BuiltInExcelStyles.builtInStyles = [];
    return BuiltInExcelStyles;
}());
exports.BuiltInExcelStyles = BuiltInExcelStyles;
var ExtendedNumberFormatHelper = /** @class */ (function () {
    function ExtendedNumberFormatHelper() {
    }
    ExtendedNumberFormatHelper.builtInNumberFomrat = function () {
        if (!ExtendedNumberFormatHelper._builtInNumberFomrat) {
            ExtendedNumberFormatHelper._builtInNumberFomrat = { count: 0 };
        }
        if (ExtendedNumberFormatHelper._builtInNumberFomrat.count === 0) {
            ExtendedNumberFormatHelper.initBuintNumberFormat();
        }
        return ExtendedNumberFormatHelper._builtInNumberFomrat;
    };
    ExtendedNumberFormatHelper.languageIndepedentNumberFormat = function () {
        if (!ExtendedNumberFormatHelper._languageIndepedentNumberFormat) {
            ExtendedNumberFormatHelper._languageIndepedentNumberFormat = { count: 0 };
        }
        if (ExtendedNumberFormatHelper._languageIndepedentNumberFormat.count === 0) {
            ExtendedNumberFormatHelper.initLanguageIndepedentNumberFormat();
        }
        return ExtendedNumberFormatHelper._languageIndepedentNumberFormat;
    };
    ExtendedNumberFormatHelper.formatCodeTable = function () {
        if (!ExtendedNumberFormatHelper._formatCodeTable) {
            ExtendedNumberFormatHelper._formatCodeTable = [];
        }
        return ExtendedNumberFormatHelper._formatCodeTable;
    };
    ExtendedNumberFormatHelper.customNumberFormat = function () {
        if (!ExtendedNumberFormatHelper._customNumberFormat) {
            ExtendedNumberFormatHelper._customNumberFormat = { count: 0 };
        }
        return ExtendedNumberFormatHelper._customNumberFormat;
    };
    ExtendedNumberFormatHelper.getCultureInfo = function () {
        var root = common_1._getRoot();
        var cultureInfo = root && root.GC && root.GC.Spread && root.GC.Spread.Common && common_1._getRoot().GC.Spread.Common.CultureManager.getCultureInfo();
        return cultureInfo || common_1._getCultureObj();
    };
    ExtendedNumberFormatHelper.initBuintNumberFormat = function () {
        var _builtInNumberFormat = ExtendedNumberFormatHelper._builtInNumberFomrat;
        _builtInNumberFormat[0] = 'General';
        _builtInNumberFormat[1] = '0';
        _builtInNumberFormat[2] = '0.00';
        _builtInNumberFormat[3] = '#,##0';
        _builtInNumberFormat[4] = '#,##0.00';
        _builtInNumberFormat[9] = '0%';
        _builtInNumberFormat[10] = '0.00%';
        _builtInNumberFormat[11] = '0.00E+00';
        _builtInNumberFormat[12] = '# ?/?';
        _builtInNumberFormat[13] = '# ??/??';
        _builtInNumberFormat[14] = 'm/d/yyyy';
        _builtInNumberFormat[15] = 'd-mmm-yy';
        _builtInNumberFormat[16] = 'd-mmm';
        _builtInNumberFormat[17] = 'mmm-yy';
        _builtInNumberFormat[18] = 'h:mm AM/PM';
        _builtInNumberFormat[19] = 'h:mm:ss AM/PM';
        _builtInNumberFormat[20] = 'h:mm';
        _builtInNumberFormat[21] = 'h:mm:ss';
        _builtInNumberFormat[22] = 'm/d/yyyy h:mm';
        _builtInNumberFormat[37] = '#,##0 ;(#,##0)';
        _builtInNumberFormat[38] = '#,##0 ;[Red](#,##0)';
        _builtInNumberFormat[39] = '#,##0.00;(#,##0.00)';
        _builtInNumberFormat[40] = '#,##0.00;[Red](#,##0.00)';
        _builtInNumberFormat[45] = 'mm:ss';
        _builtInNumberFormat[46] = '[h]:mm:ss';
        _builtInNumberFormat[47] = 'mm:ss.0';
        _builtInNumberFormat[48] = '##0.0E+0';
        _builtInNumberFormat[49] = '@';
        _builtInNumberFormat.count = 49;
        if (common_1._getCulture()) {
            var cultureStr = common_1._getCulture();
            if (cultureStr === 'zh-cn') {
                _builtInNumberFormat[14] = 'yyyy/m/d';
                _builtInNumberFormat[17] = 'mmm-yy';
                _builtInNumberFormat[22] = 'yyyy/m/d h:mm';
                _builtInNumberFormat[27] = 'yyyy\"\u5e74\"m\"\u6708\"';
                _builtInNumberFormat[28] = 'm\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat[29] = 'm\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat[30] = 'm-d-yy';
                _builtInNumberFormat[31] = 'yyyy\"\u5e74\"m\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat[32] = 'h\"\u65f6\"mm\"\u5206\"';
                _builtInNumberFormat[33] = 'h\"\u65f6\"mm\"\u5206\"ss\"\u79d2\"';
                _builtInNumberFormat[34] = '\u4e0a\u5348/\u4e0b\u5348h\"\u65f6\"mm\"\u5206\"';
                _builtInNumberFormat[35] = '\u4e0a\u5348/\u4e0b\u5348h\"\u65f6\"mm\"\u5206\"ss\"\u79d2\"';
                _builtInNumberFormat[36] = 'yyyy\"\u5e74\"m\"\u6708\"';
                _builtInNumberFormat[39] = '#,##0.00;-#,##0.00';
                _builtInNumberFormat[40] = '#,##0.00;[Red]-#,##0.00';
                _builtInNumberFormat[50] = 'yyyy\"\u5e74\"m\"\u6708\"';
                _builtInNumberFormat[51] = 'm\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat[52] = 'yyyy\"\u5e74\"m\"\u6708\"';
                _builtInNumberFormat[53] = 'm\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat[54] = 'm\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat[55] = '\u4e0a\u5348/\u4e0b\u5348h\"\u65f6\"mm\"\u5206\"';
                _builtInNumberFormat[56] = '\u4e0a\u5348/\u4e0b\u5348h\"\u65f6\"mm\"\u5206\"ss\"\u79d2\"';
                _builtInNumberFormat[57] = 'yyyy\"\u5e74\"m\"\u6708\"';
                _builtInNumberFormat[58] = 'm\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat.count = 58;
            }
            else if (cultureStr === 'ja-jp') {
                _builtInNumberFormat[14] = 'yyyy/m/d';
                _builtInNumberFormat[15] = 'dd-mmm-yy';
                _builtInNumberFormat[16] = 'dd-mmm';
                _builtInNumberFormat[17] = 'mmm-yy';
                _builtInNumberFormat[22] = 'yyyy/mm/dd h:mm';
                _builtInNumberFormat[27] = '[$-411]ge.m.d';
                _builtInNumberFormat[28] = '[$-411]ggge\"\u5e74\"m\"\u6708\"d\"';
                _builtInNumberFormat[29] = '[$-411]ggge\"\u5e74\"m\"\u6708\"d\"';
                _builtInNumberFormat[30] = 'm/d/yy';
                _builtInNumberFormat[31] = 'yyyy\"\u5e74\"m\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat[32] = 'h\"\u6642\"mm\"\u5206\"';
                _builtInNumberFormat[33] = 'h\"\u6642\"mm\"\u5206\"ss\"\u79d2\"';
                _builtInNumberFormat[34] = 'yyyy\"\u5e74\"m\"\u6708\"';
                _builtInNumberFormat[35] = 'm\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat[36] = '[$-411]ge.m.d';
                _builtInNumberFormat[38] = '#,##0;[Red]-#,##0';
                _builtInNumberFormat[39] = '#,##0.00;-#,##0.00';
                _builtInNumberFormat[40] = '#,##0.00;[Red]-#,##0.00';
                _builtInNumberFormat[50] = '[$-411]ge.m.d';
                _builtInNumberFormat[51] = '[$-411]ggge\"\u5e74\"m\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat[52] = 'yyyy\"\u5e74\"m\"\u6708\"';
                _builtInNumberFormat[53] = 'm\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat[54] = '[$-411]ggge\"\u5e74\"m\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat[55] = 'yyyy\"\u5e74\"m\"\u6708\"';
                _builtInNumberFormat[56] = 'm\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat[57] = '[$-411]ge.m.d';
                _builtInNumberFormat[58] = '[$-411]ggge\"\u5e74\"m\"\u6708\"d\"\u65e5\"';
                _builtInNumberFormat.count = 58;
            }
            else {
                var cultureInfo = ExtendedNumberFormatHelper.getCultureInfo();
                var localNumberFormat = cultureInfo && cultureInfo.LocalNumberFormat;
                if (common_1.isNullOrUndefined(localNumberFormat) || Array.isArray(localNumberFormat) || typeof localNumberFormat !== 'object') {
                    return;
                }
                for (var key in localNumberFormat) {
                    if (!isNaN(Number(key))) {
                        var format = localNumberFormat[key];
                        if (common_1.Util._isValidFormat(format)) {
                            _builtInNumberFormat[key] = localNumberFormat[key];
                        }
                    }
                }
                var count = 0;
                for (var key in _builtInNumberFormat) {
                    if (!isNaN(Number(key))) {
                        var num = Number(key);
                        if (num > count) {
                            count = num;
                        }
                    }
                }
                _builtInNumberFormat.count = count;
            }
        }
    };
    ExtendedNumberFormatHelper.initLanguageIndepedentNumberFormat = function () {
        var _languageIndepedentNumberFormat = ExtendedNumberFormatHelper._languageIndepedentNumberFormat;
        _languageIndepedentNumberFormat[27] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[28] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[29] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[30] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[31] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[32] = 'h:mm:ss';
        _languageIndepedentNumberFormat[33] = 'h:mm:ss';
        _languageIndepedentNumberFormat[34] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[35] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[36] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[50] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[51] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[52] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[53] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[54] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[55] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[56] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[57] = 'm/d/yyyy';
        _languageIndepedentNumberFormat[58] = 'm/d/yyyy';
    };
    ExtendedNumberFormatHelper.getFormatCode = function (format) {
        var builtInNumberFomrat = ExtendedNumberFormatHelper.builtInNumberFomrat(), customNumberFormat = ExtendedNumberFormatHelper.customNumberFormat(), languageIndepedentNumberFormat = ExtendedNumberFormatHelper.languageIndepedentNumberFormat(), numberFormatIndex = format.numberFormatIndex;
        if (format.numberFormat) {
            var numberFormat = format.numberFormat, numberFormatId = numberFormat.numberFormatId, numberFormatCode = numberFormat.numberFormatCode;
            if (builtInNumberFomrat[numberFormatId] && builtInNumberFomrat[numberFormatId] !== numberFormatCode) {
                builtInNumberFomrat[numberFormatId] = numberFormatCode;
                return numberFormatCode;
            }
            if (!customNumberFormat[numberFormatCode]) {
                customNumberFormat[numberFormatCode] = numberFormatId;
                customNumberFormat.count++;
            }
            return numberFormatCode;
        }
        if (builtInNumberFomrat[numberFormatIndex]) {
            return builtInNumberFomrat[numberFormatIndex];
        }
        else if (languageIndepedentNumberFormat[numberFormatIndex]) {
            return languageIndepedentNumberFormat[numberFormatIndex];
        }
        return 'General';
    };
    ExtendedNumberFormatHelper.getFormatId = function (excelFormatCode) {
        var formatIDCache = ExtendedNumberFormatHelper._getFormatIDCache();
        if (formatIDCache[excelFormatCode]) {
            return formatIDCache[excelFormatCode];
        }
        var result;
        var builtInNumberFormat = ExtendedNumberFormatHelper.builtInNumberFomrat();
        if (builtInNumberFormat) {
            for (var id in builtInNumberFormat) {
                if (builtInNumberFormat[id] === excelFormatCode) {
                    result = {
                        isBuiltIn: true,
                        id: parseInt(id, 10)
                    };
                    formatIDCache[excelFormatCode] = result;
                    return result;
                }
            }
        }
        var customNumberFormat = ExtendedNumberFormatHelper.customNumberFormat();
        if (customNumberFormat && customNumberFormat[excelFormatCode]) {
            result = {
                isBuiltIn: false,
                id: customNumberFormat[excelFormatCode]
            };
            formatIDCache[excelFormatCode] = result;
            return result;
        }
        var key = 0;
        if (customNumberFormat.count > 0) {
            var maxId = 0;
            for (var code in customNumberFormat) {
                if (customNumberFormat[code] > maxId) {
                    maxId = customNumberFormat[code];
                }
            }
            key = maxId;
        }
        key = Math.max(ExtendedNumberFormatHelper._startKey++, key) + 1;
        customNumberFormat[excelFormatCode] = key;
        result = {
            isBuiltIn: false,
            id: key
        };
        return result;
    };
    ExtendedNumberFormatHelper._getFormatIDCache = function () {
        if (!ExtendedNumberFormatHelper._formatIDCache) {
            ExtendedNumberFormatHelper._formatIDCache = {};
        }
        return ExtendedNumberFormatHelper._formatIDCache;
    };
    ExtendedNumberFormatHelper._formatCodeTable = null;
    ExtendedNumberFormatHelper._formatIDCache = null;
    ExtendedNumberFormatHelper._builtInNumberFomrat = { count: 0 };
    ExtendedNumberFormatHelper._languageIndepedentNumberFormat = { count: 0 };
    ExtendedNumberFormatHelper._customNumberFormat = { count: 0 };
    ExtendedNumberFormatHelper._startKey = 170;
    return ExtendedNumberFormatHelper;
}());
exports.ExtendedNumberFormatHelper = ExtendedNumberFormatHelper;
function roundToDecimal(value, digits) {
    var mult = Math.pow(10, digits);
    return Math.round(value * mult) / mult;
}
var UnitHelper = /** @class */ (function () {
    function UnitHelper() {
    }
    UnitHelper.pointToPixel = function (point) {
        return roundToDecimal(point * 96 / 72, 2);
    };
    UnitHelper.pixelToPoint = function (pixel) {
        return pixel * 72 / 96;
    };
    UnitHelper.emuToPixles = function (emu, digits) {
        return roundToDecimal(emu * 96 / 914400, digits || 2);
    };
    UnitHelper.pixelToEMU = function (px) {
        return Math.round(px * 914400 / 96);
    };
    UnitHelper.getMaxiumDigitWidth = function (font) {
        var maxWidth = 0;
        var maxDigitWidthCache = UnitHelper._getMaxiumDigitWidthCache();
        if (maxDigitWidthCache[font]) {
            return maxDigitWidthCache[font];
        }
        try {
            if (!UnitHelper._span) {
                UnitHelper._span = document.createElement('span');
            }
            var span = UnitHelper._span;
            span.style.font = font;
            var fontSize = span.style.fontSize;
            if (fontSize.indexOf('px') !== -1) {
                fontSize = parseInt(UnitHelper.pixelToPoint(parseFloat(fontSize)), 10);
            }
            else {
                fontSize = parseInt(fontSize, 10);
            }
            var fontFamily = span.style.fontFamily;
            if (excel_types_1.MaxDigitWidthMap[fontSize] && excel_types_1.MaxDigitWidthMap[fontSize][fontFamily]) {
                maxWidth = excel_types_1.MaxDigitWidthMap[fontSize][fontFamily];
                if (maxWidth > 0) {
                    maxDigitWidthCache[font] = maxWidth;
                    return maxWidth;
                }
            }
        }
        catch (e) {
        }
        var charArray = '0123456789';
        var size = 0;
        for (var i = 0; i < charArray.length; i++) {
            size = UnitHelper.measureText(charArray.charAt(i), font);
            if (size > maxWidth) {
                maxWidth = size;
            }
        }
        if (maxWidth > 0) {
            maxDigitWidthCache[font] = maxWidth;
            return maxWidth;
        }
        maxDigitWidthCache[font] = 7;
        return maxDigitWidthCache[font];
    };
    UnitHelper.truncate = function (value) {
        return Math.floor(value);
    };
    UnitHelper._getMaxiumDigitWidthCache = function () {
        if (!UnitHelper._maxiumDigitWidthCache) {
            UnitHelper._maxiumDigitWidthCache = {};
        }
        return UnitHelper._maxiumDigitWidthCache;
    };
    UnitHelper.measureText = function (text, font) {
        function getCanvas() {
            if (!UnitHelper._canvas) {
                UnitHelper._canvas = document.createElement('canvas');
            }
            return UnitHelper._canvas;
        }
        try {
            var canvas = getCanvas();
            var ctx = canvas.getContext('2d');
            ctx.font = font;
            return ctx.measureText(text).width;
        }
        catch (e) {
            return 8;
        }
    };
    UnitHelper._span = null;
    UnitHelper._maxiumDigitWidthCache = null;
    UnitHelper._canvas = null;
    return UnitHelper;
}());
exports.UnitHelper = UnitHelper;
var _Color = /** @class */ (function () {
    function _Color(a, r, g, b) {
        var self = this;
        self.a = a;
        self.r = r;
        self.g = g;
        self.b = b;
    }
    _Color.prototype.toString = function () {
        var self = this;
        if (self.a === 255) {
            return '#' + self.getColorUnitString(self.r) + self.getColorUnitString(self.g) + self.getColorUnitString(self.b);
        }
        return 'rgba(' + self.r + ',' + self.g + ',' + self.b + ',' + self.a + ')';
    };
    _Color.prototype.getColorUnitString = function (unit) {
        var s = unit.toString(16);
        if (s.length === 1) {
            s = '0' + s;
        }
        return s;
    };
    _Color.hueToRGB = function (n1, n2, hue) {
        if (hue < 0) {
            hue += 240;
        }
        if (hue > 240) {
            hue -= 240;
        }
        if (hue < 40) {
            return (n1 + ((((n2 - n1) * hue) + 20) / 40));
        }
        if (hue < 120) {
            return n2;
        }
        if (hue < 160) {
            return (n1 + ((((n2 - n1) * (160 - hue)) + 20) / 40));
        }
        return n1;
    };
    _Color.fromHLS = function (hue, luminosity, saturation) {
        var r, g, b;
        if (saturation === 0) {
            r = g = b = parseInt(((luminosity * 0xff) / 240), 10);
        }
        else {
            var n1 = void 0, n2 = void 0;
            if (luminosity <= 120) {
                n2 = ((luminosity * (240 + saturation)) + 120) / 240;
            }
            else {
                n2 = (luminosity + saturation) - (((luminosity * saturation) + 120) / 240);
            }
            n1 = (2 * luminosity) - n2;
            r = parseInt((((_Color.hueToRGB(n1, n2, hue + 80) * 0xff) + 120) / 240), 10);
            g = parseInt((((_Color.hueToRGB(n1, n2, hue) * 0xff) + 120) / 240), 10);
            b = parseInt((((_Color.hueToRGB(n1, n2, hue - 80) * 0xff) + 120) / 240), 10);
        }
        return new _Color(0xff, r, g, b);
    };
    return _Color;
}());
exports._Color = _Color;
var HLSColor = /** @class */ (function () {
    function HLSColor(rgbColor) {
        var self = this;
        var r = rgbColor.r, g = rgbColor.g, b = rgbColor.b;
        var maxUnit = Math.max(Math.max(r, g), b);
        var minUnit = Math.min(Math.min(r, g), b);
        var sum = maxUnit + minUnit;
        self.luminosity = parseInt((((sum * 240) + 0xff) / 510).toString(), 10);
        var diff = maxUnit - minUnit;
        if (diff === 0) {
            self.saturation = 0;
            self.hue = 160;
        }
        else {
            if (self.luminosity <= 120) {
                self.saturation = parseInt((((diff * 240) + (sum / 2)) / sum).toString(), 10);
            }
            else {
                self.saturation = parseInt((((diff * 240) + ((510 - sum) / 2)) / (510 - sum)).toString(), 10);
            }
            var partR = (((maxUnit - r) * 40) + (diff / 2)) / diff;
            var partG = (((maxUnit - g) * 40) + (diff / 2)) / diff;
            var partB = (((maxUnit - b) * 40) + (diff / 2)) / diff;
            if (r === maxUnit) {
                self.hue = parseInt((partB - partG).toString(), 10);
            }
            else if (g === maxUnit) {
                self.hue = parseInt(((80 + partR) - partB).toString(), 10);
            }
            else {
                self.hue = parseInt(((160 + partG) - partR).toString(), 10);
            }
            if (self.hue < 0) {
                self.hue += 240;
            }
            if (self.hue > 240) {
                self.hue -= 240;
            }
        }
    }
    HLSColor.prototype.toColor = function () {
        return _Color.fromHLS(this.hue, this.luminosity, this.saturation);
    };
    return HLSColor;
}());
var ColorHelper = /** @class */ (function () {
    function ColorHelper() {
    }
    ColorHelper.getThemeColorName = function (color) {
        if (!color || color.colorType() !== 3) {
            return null;
        }
        var tint = Math.round(color.tint() * 100);
        if (color.value() === 0 || color.value() === 0xF3) {
            return 'Background 1 ' + tint;
        }
        if (color.value() === 1 || color.value() === 0XF1) {
            return 'Text 1 ' + tint;
        }
        if (color.value() === 2 || color.value() === 0xF4) {
            return 'Background 2 ' + tint;
        }
        if (color.value() === 3 || color.value() === 0xF2) {
            return 'Text 2 ' + tint;
        }
        if (color.value() === 4) {
            return 'Accent 1 ' + tint;
        }
        if (color.value() === 5) {
            return 'Accent 2 ' + tint;
        }
        if (color.value() === 6) {
            return 'Accent 3 ' + tint;
        }
        if (color.value() === 7) {
            return 'Accent 4 ' + tint;
        }
        if (color.value() === 8) {
            return 'Accent 5 ' + tint;
        }
        if (color.value() === 9) {
            return 'Accent 6 ' + tint;
        }
        if (color.value() === 10) {
            return 'hyperlink';
        }
        if (color.value() === 11) {
            return 'followedHyperlink';
        }
        return null;
    };
    ColorHelper.getThemeColorIndex = function (themeColor, isChartTheme) {
        if (themeColor.substring(0, 12) === 'Background 1') {
            if (isChartTheme) {
                return 0xF3;
            }
            return 0;
        }
        if (themeColor.substring(0, 6) === 'Text 1') {
            if (isChartTheme) {
                return 0xF1;
            }
            return 1;
        }
        if (themeColor.substring(0, 12) === 'Background 2') {
            if (isChartTheme) {
                return 0xF4;
            }
            return 2;
        }
        if (themeColor.substring(0, 6) === 'Text 2') {
            if (isChartTheme) {
                return 0xF2;
            }
            return 3;
        }
        if (themeColor.substring(0, 8) === 'Accent 1') {
            return 4;
        }
        if (themeColor.substring(0, 8) === 'Accent 2') {
            return 5;
        }
        if (themeColor.substring(0, 8) === 'Accent 3') {
            return 6;
        }
        if (themeColor.substring(0, 8) === 'Accent 4') {
            return 7;
        }
        if (themeColor.substring(0, 8) === 'Accent 5') {
            return 8;
        }
        if (themeColor.substring(0, 8) === 'Accent 6') {
            return 9;
        }
        if (themeColor === 'hyperlink') {
            return 10;
        }
        if (themeColor === 'followedHyperlink') {
            return 11;
        }
    };
    ColorHelper._getThemeColorCache = function () {
        if (!ColorHelper._themeColorCache) {
            ColorHelper._themeColorCache = {};
        }
        return ColorHelper._themeColorCache;
    };
    ColorHelper.getExcelThemeColor = function (themeColor) {
        if (!common_1.StringEx._isNullOrEmpty(themeColor)) {
            var themeColorCache = ColorHelper._getThemeColorCache();
            if (themeColorCache[themeColor]) {
                return themeColorCache[themeColor];
            }
            var tint = 0;
            var themeColorParts = themeColor.split(' ');
            if (themeColorParts.length >= 3) {
                tint = parseFloat(themeColorParts[2]);
                if (!isNaN(tint)) {
                    tint = tint / 100;
                }
            }
            var result = new ExcelColor(3, ColorHelper.getThemeColorIndex(themeColor), tint);
            themeColorCache[themeColor] = result;
            return result;
        }
        return ExcelColor.EmptyColor;
    };
    ColorHelper.toRGBColor = function (excelColor) {
        if (!excelColor) {
            return null;
        }
        return ColorHelper.getRGBColor(excelColor).toString();
    };
    ColorHelper.colorFromIndex = function (index, alpha) {
        if (index === 32767) {
            return new _Color(0, 0, 0, 0);
        }
        if (index < 0 || index >= ColorHelper.palette.length) {
            return new _Color(255, 0, 0, 0);
        }
        if (!ColorHelper.useCustomPalette) {
            var value = ColorHelper.palette[index];
            var r = ((value >> 16) & 0xFF);
            var g = ((value >> 8) & 0xFF);
            var b = (value & 0xFF);
            return new _Color(alpha, r, g, b);
        }
        if (ColorHelper.customPalette[index] !== keyword_undefined) {
            return ColorHelper.customPalette[index];
        }
        if (index === 64) {
            return new _Color(255, 0, 0, 0);
        }
        else if (index === 65) {
            return new _Color(255, 255, 255, 255);
        }
        return new _Color(0, 255, 255, 255);
    };
    ColorHelper.updateTint = function (baseColor, tint) {
        if (tint === 0.0) {
            return baseColor;
        }
        var color = new HLSColor(baseColor);
        var num1, num2;
        if (tint > 0) {
            num1 = 240 - color.luminosity;
            num2 = num1 * tint;
            return _Color.fromHLS(color.hue, color.luminosity + num2, color.saturation);
        }
        num2 = color.luminosity * (-tint);
        return _Color.fromHLS(color.hue, color.luminosity - num2, color.saturation);
    };
    ColorHelper.getRGBColor = function (excelColor) {
        if (excelColor === null || excelColor === keyword_undefined) {
            return new _Color(0, 255, 255, 255);
        }
        if (excelColor.isAutoColor()) {
            return new _Color(255, 0, 0, 0);
        }
        if (excelColor.isIndexedColor()) {
            var color = ColorHelper.colorFromIndex(excelColor.value() | 0, 255);
            return ColorHelper.updateTint(color, excelColor.tint());
        }
        if (excelColor.isRGBColor()) {
            var value = ((excelColor.value() & 0xFFFFFF) + 0xFF000000);
            var color = ColorHelper.fromArgb(value);
            return ColorHelper.updateTint(color, excelColor.tint());
        }
        if (excelColor.isThemeColor()) {
            return ColorHelper.getThemeColorName(excelColor);
        }
        return new _Color(0, 255, 255, 255);
    };
    ColorHelper.fromArgb = function (value) {
        return new _Color(((value >> 24) & 0xFF), ((value >> 16) & 0xFF), ((value >> 8) & 0xFF), (value & 0xFF));
    };
    ColorHelper.getRGBAColorData = function (excelColor) {
        var color = ColorHelper.fromArgb(excelColor.value());
        return {
            rgb: color.getColorUnitString(color.r) + color.getColorUnitString(color.g) + color.getColorUnitString(color.b),
            alpha: color.a
        };
    };
    ColorHelper._getHtmlColorCache = function () {
        if (!ColorHelper._htmlColorCache) {
            ColorHelper._htmlColorCache = {};
        }
        return ColorHelper._htmlColorCache;
    };
    ColorHelper.fromHtmlColor = function (value) {
        if (!value) {
            return;
        }
        if (typeof value !== 'string') {
            return value;
        }
        var htmlColorCache = ColorHelper._getHtmlColorCache();
        if (htmlColorCache[value]) {
            return htmlColorCache[value];
        }
        var value2 = value.toLowerCase(), result;
        if (value2.substring(0, 1) === '#') {
            if (value2.length === 7) {
                value2 = '#ff' + value2.substring(1);
            }
            else if (value2.length === 4) {
                value2 = '#ff' + value2[1] + value2[1] + value2[2] + value2[2] + value2[3] + value2[3];
            }
            result = parseInt(value2.substring(1, value2.length), 16);
        }
        else if (value2.substring(0, 4) === 'rgb(') {
            var leftBracket = value2.indexOf('('), rightBracket = value2.indexOf(')');
            var colors = value2.substring(leftBracket + 1, rightBracket).split(',');
            result = 255 * Math.pow(16, 6) + parseInt(colors[0], 10) * Math.pow(16, 4) + parseInt(colors[1], 10) * Math.pow(16, 2) + parseInt(colors[2], 10);
        }
        else if (value2.substring(0, 5) === 'rgba(') {
            var leftBracket = value2.indexOf('(');
            var rightBracket = value2.indexOf(')');
            var colors = value2.substring(leftBracket + 1, rightBracket).split(',');
            result = parseInt(parseFloat(colors[3]) * 255, 10) * Math.pow(16, 6) + parseInt(colors[0], 10) * Math.pow(16, 4) + parseInt(colors[1], 10) * Math.pow(16, 2) + parseInt(colors[2], 10);
        }
        else if (ColorHelper._preSetColors[value2]) {
            result = ColorHelper._preSetColors[value2];
        }
        else {
            result = parseInt(value2, 10);
        }
        htmlColorCache[value] = result;
        return result;
    };
    ColorHelper.isThemeColor = function (value) {
        if (!value || typeof value !== 'string') {
            return false;
        }
        value = value.toLowerCase();
        var fl = value[0];
        switch (fl) {
            case 'b':
                return value.indexOf('background ') === 0;
            case 't':
                return value.indexOf('text ') === 0;
            case 'a':
                return value.indexOf('accent ') === 0;
            case 'h':
                return value.indexOf('hyperlink') === 0;
            case 'f':
                return value.indexOf('followedhyperlink') === 0;
            default:
                return false;
        }
    };
    ColorHelper.mixTranslucentColor = function (baseColor, color) {
        if (color.a === 255) {
            return color;
        }
        if (color.a === 0) {
            return baseColor;
        }
        var colorA = Math.round(((255 - baseColor.a) * color.a) / 255);
        var r = ColorHelper.getMaxInt(baseColor.a, color.a, baseColor.r, color.r, colorA + baseColor.a);
        var g = ColorHelper.getMaxInt(baseColor.a, color.a, baseColor.g, color.g, colorA + baseColor.a);
        var b = ColorHelper.getMaxInt(baseColor.a, color.a, baseColor.b, color.b, colorA + baseColor.a);
        return new _Color(Math.round(colorA + baseColor.a), r, g, b);
    };
    ColorHelper.getMaxInt = function (baseColorAlpha, colorAlpha, baseColorValue, colorValue, resultColorAlpha) {
        if (resultColorAlpha === 0) {
            return 0;
        }
        return ((colorAlpha * colorValue) + (255 - colorAlpha) * baseColorAlpha * baseColorValue / 255.0) / resultColorAlpha;
    };
    ColorHelper.toExcelColor = function (color, expectValue) {
        if (color instanceof ExcelColor) {
            return color;
        }
        if (expectValue === keyword_undefined) {
            expectValue = 0xffffff;
        }
        if (!color) {
            return null;
        }
        if (ColorHelper.isThemeColor(color)) {
            return ColorHelper.getExcelThemeColor(color);
        }
        var color1 = ColorHelper.fromHtmlColor(color);
        if (color1 !== expectValue) {
            return ColorHelper.fromColorToExcelColor(ColorHelper.fromArgb(color1));
        }
        return null;
    };
    ColorHelper.toExcelBackColor = function (backColor, isBackgroundColor) {
        var fillObj;
        if (typeof backColor === 'object') {
            if (backColor.stops) {
                fillObj = backColor;
                for (var i = 0; i < fillObj.stops.length; i++) {
                    fillObj.stops[i].color = ColorHelper.toExcelColor(fillObj.stops[i].color);
                }
            }
            else {
                fillObj = {
                    patternType: backColor.type,
                    fgColor: ColorHelper.toExcelColor(backColor.patternColor || '#000000'),
                    bgColor: ColorHelper.toExcelColor(backColor.backgroundColor || '#FFFFFF')
                };
            }
        }
        else {
            fillObj = backColor ? {
                patternType: 1,
                fgColor: ColorHelper.toExcelColor(backColor),
                bgColor: ColorHelper.toExcelColor(isBackgroundColor ? '#000000' : '#FFFFFF')
            } : {
                patternType: 0, fgColor: new ExcelColor(1, 64, 0),
                bgColor: new ExcelColor(1, 65, 0)
            };
        }
        return fillObj;
    };
    ColorHelper.toExcelIndexedColor = function (excelColor) {
        if (excelColor) {
            var colorIndex = ColorHelper.getPaletteColorIndex(excelColor, 63);
            return new ExcelColor(1, colorIndex);
        }
        return null;
    };
    ColorHelper.fromColorToExcelColor = function (color) {
        color = ColorHelper.mixTranslucentColor(ColorHelper.fromArgb(0xFFFFFF), color);
        if (color.a !== 255) {
            var bgColor = ColorHelper._whiteBGColor;
            var r = (bgColor.r - color.a) + ((color.a / 255) * color.r);
            var g = (bgColor.g - color.a) + ((color.a / 255) * color.g);
            var b = (bgColor.b - color.a) + ((color.a / 255) * color.b);
            color = new _Color(255, r, g, b);
        }
        var color1 = color.a * Math.pow(16, 6) + color.r * Math.pow(16, 4) + color.g * Math.pow(16, 2) + color.b;
        return new ExcelColor(2, color1, 0.0);
    };
    ColorHelper.getClosestColorIndex = function (color, startIndex) {
        if (startIndex === keyword_undefined) {
            startIndex = 64;
        }
        var bestMatchIndex = -1, bestDistance = Number.MAX_VALUE;
        for (var i = Math.min(ColorHelper.palette.length - 1, startIndex); i >= 0; i--) {
            var item = ColorHelper.palette[i];
            var r = (item & 0x00FF0000) >> 16;
            var g = (item & 0x0000FF00) >> 8;
            var b = item & 0xFF;
            var distance = Math.abs((r - color.r) * 0.30) + Math.abs((g - color.g) * 0.59) + Math.abs((b - color.b) * 0.11);
            if (distance < bestDistance) {
                bestDistance = distance;
                bestMatchIndex = i;
            }
        }
        return bestMatchIndex;
    };
    ColorHelper.getPaletteColorIndex = function (excelColor, startIndex) {
        if (startIndex === keyword_undefined) {
            startIndex = 64;
        }
        if (excelColor.isThemeColor()) {
            return ColorHelper.getClosestColorIndex(ColorHelper.getRGBColor(new ExcelColor(3, excelColor.value(), 0)));
        }
        return ColorHelper.getClosestColorIndex(ColorHelper.getRGBColor(excelColor), startIndex);
    };
    ColorHelper.toColorSchemeIndex = function (val) {
        if (val === 'ACCENT1') {
            return 4;
        }
        if (val === 'ACCENT2') {
            return 5;
        }
        if (val === 'ACCENT3') {
            return 6;
        }
        if (val === 'ACCENT4') {
            return 7;
        }
        if (val === 'ACCENT5') {
            return 8;
        }
        if (val === 'ACCENT6') {
            return 9;
        }
        if (val === 'DK1') {
            return 1;
        }
        if (val === 'DK2') {
            return 3;
        }
        if (val === 'LT1') {
            return 0;
        }
        if (val === 'LT2') {
            return 2;
        }
        if (val === 'HLIK') {
            return 10;
        }
        if (val === 'FOLHLINK') {
            return 11;
        }
        if (val === 'PHCLR') {
            return 240;
        }
        if (val === 'BG1') {
            return 243;
        }
        if (val === 'BG2') {
            return 244;
        }
        if (val === 'TX1') {
            return 241;
        }
        if (val === 'TX2') {
            return 242;
        }
        return 255;
    };
    ColorHelper.scRgbTosRgb = function (val) {
        if (val <= 0.0) {
            return 0;
        }
        if (val <= 0.0031308) {
            return ((255 * val) * 12.92) + 0.5;
        }
        if (val < 1.0) {
            return (255 * ((1.055 * (Math.pow(val, 0.41666666666666669))) - 0.055)) + 0.5;
        }
        return 0xff;
    };
    ColorHelper.convertHLSToRGB = function (hue, luminance, saturation) {
        var num1 = 0, num2 = 0, num3 = 0;
        if (saturation === 0.0) {
            num1 = ((luminance * 255.0) / 255.0) | 0;
            num2 = num1;
            num3 = num1;
        }
        else {
            var num5 = void 0;
            if (luminance <= 127.0) {
                num5 = ((luminance * (255.0 + saturation)) + 127.0) / 255.0;
            }
            else {
                num5 = (luminance + saturation) - (((luminance * saturation) + 127.0) / 255.0);
            }
            var num4 = (2.0 * luminance) - num5;
            num1 = parseInt((((ColorHelper.hueToRGB(num4, num5, hue + 85.0) * 255.0) + 127.0) / 255.0).toString(), 10);
            num2 = parseInt((((ColorHelper.hueToRGB(num4, num5, hue) * 255.0) + 127.0) / 255.0).toString(), 10);
            num3 = parseInt((((ColorHelper.hueToRGB(num4, num5, hue - 85.0) * 255.0) + 127.0) / 255.0).toString(), 10);
        }
        num1 = num1 > 0 ? num1 : 0;
        num2 = num2 > 0 ? num2 : 0;
        num3 = num3 > 0 ? num3 : 0;
        num1 = num1 < 0xFF ? num1 : 0xFF;
        num2 = num2 < 0xFF ? num2 : 0xFF;
        num3 = num3 > 0xFF ? num3 : 0xFF;
        return new _Color(0, num1, num2, num3);
    };
    ColorHelper.hueToRGB = function (n1, n2, hue) {
        if (hue < 0.0) {
            hue += 255.0;
        }
        if (hue > 255.0) {
            hue -= 255.0;
        }
        if (hue < 42.0) {
            return (n1 + ((((n2 - n1) * hue) + 21.0) / 42.0));
        }
        if (hue < 127.0) {
            return n2;
        }
        if (hue < 170.0) {
            return (n1 + ((((n2 - n1) * (170.0 - hue)) + 21.0) / 42.0));
        }
        return n1;
    };
    ColorHelper.fromPresetColorVal = function (preSetValue) {
        var value = ColorHelper._preSetColors[preSetValue];
        if (value !== keyword_undefined) {
            return ColorHelper.fromArgb(value);
        }
        return null;
    };
    ColorHelper._themeColorCache = null;
    ColorHelper._htmlColorCache = null;
    ColorHelper.useCustomPalette = false;
    ColorHelper.customPalette = null;
    ColorHelper.palette = [
        0xFF000000, 0xFFFFFFFF, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFFFF00FF,
        0xFF00FFFF, 0xFF000000, 0xFFFFFFFF, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFFFFFF00, 0xFFFF00FF, 0xFF00FFFF,
        0xFF800000, 0xFF008000, 0xFF000080, 0xFF808000, 0xFF800080, 0xFF008080, 0xFFC0C0C0, 0xFF808080, 0xFF9999FF,
        0xFF993366, 0xFFFFFFCC, 0xFFCCFFFF, 0xFF660066, 0xFFFF8080, 0xFF0066CC, 0xFFCCCCFF, 0xFF000080, 0xFFFF00FF,
        0xFFFFFF00, 0xFF00FFFF, 0xFF800080, 0xFF800000, 0xFF008080, 0xFF0000FF, 0xFF00CCFF, 0xFFCCFFFF, 0xFFCCFFCC,
        0xFFFFFF99, 0xFF99CCFF, 0xFFFF99CC, 0xFFCC99FF, 0xFFFFCC99, 0xFF3366FF, 0xFF33CCCC, 0xFF99CC00, 0xFFFFCC00,
        0xFFFF9900, 0xFFFF6600, 0xFF666699, 0xFF969696, 0xFF003366, 0xFF339966, 0xFF003300, 0xFF333300, 0xFF993300,
        0xFF993366, 0xFF333399, 0xFF333333, 0xFF000000
    ];
    ColorHelper._whiteBGColor = new _Color(255, 255, 255, 255);
    ColorHelper._preSetColors = {
        'aliceblue': 0xfff0f8ff,
        'antiquewhite': 0xfffaebd7,
        'aqua': 0xff00ffff,
        'aquamarine': 0xff7fffd4,
        'azure': 0xfff0ffff,
        'beige': 0xfff5f5dc,
        'bisque': 0xffffe4c4,
        'black': 0xff000000,
        'blanchedalmond': 0xffffebcd,
        'blue': 0xff0000ff,
        'blueviolet': 0xff8a2be2,
        'brown': 0xffa52a2a,
        'burlywood': 0xffdeb887,
        'cadetblue': 0xff5f9ea0,
        'chartreuse': 0xff7fff00,
        'chocolate': 0xffd2691e,
        'coral': 0xffff7f50,
        'cornflowerblue': 0xff6495ed,
        'cornsilk': 0xfffff8dc,
        'crimson': 0xffdc143c,
        'cyan': 0xff00ffff,
        'darkblue': 0xff00008b,
        'darkcyan': 0xff008b8b,
        'darkgoldenrod': 0xffb8860b,
        'darkgray': 0xffa9a9a9,
        'darkgreen': 0xff006400,
        'darkkhaki': 0xffbdb76b,
        'darkmagenta': 0xff8b008b,
        'darkolivegreen': 0xff556b2f,
        'darkorange': 0xffff8c00,
        'darkorchid': 0xff9932cc,
        'darkred': 0xff8b0000,
        'darksalmon': 0xffe9967a,
        'darkseagreen': 0xff8fbc8f,
        'darkslateblue': 0xff483d8b,
        'darkslategray': 0xff2f4f4f,
        'darkturquoise': 0xff00ced1,
        'darkviolet': 0xff9400d3,
        'deeppink': 0xffff1493,
        'deepskyblue': 0xff00bfff,
        'dimgray': 0xff696969,
        'dodgerblue': 0xff1e90ff,
        'feldspar': 0xffd19275,
        'firebrick': 0xffb22222,
        'floralwhite': 0xfffffaf0,
        'forestgreen': 0xff228b22,
        'fuchsia': 0xffff00ff,
        'gainsboro': 0xffdcdcdc,
        'ghostwhite': 0xfff8f8ff,
        'gold': 0xffffd700,
        'goldenrod': 0xffdaa520,
        'gray': 0xff808080,
        'green': 0xff008000,
        'greenyellow': 0xffadff2f,
        'honeydew': 0xfff0fff0,
        'hotpink': 0xffff69b4,
        'indianred ': 0xffcd5c5c,
        'indigo ': 0xff4b0082,
        'ivory': 0xfffffff0,
        'khaki': 0xfff0e68c,
        'lavender': 0xffe6e6fa,
        'lavenderblush': 0xfffff0f5,
        'lawngreen': 0xff7cfc00,
        'lemonchiffon': 0xfffffacd,
        'lightblue': 0xffadd8e6,
        'lightcoral': 0xfff08080,
        'lightcyan': 0xffe0ffff,
        'lightgoldenrodyellow': 0xfffafad2,
        'lightgrey': 0xffd3d3d3,
        'lightgreen': 0xff90ee90,
        'lightpink': 0xffffb6c1,
        'lightsalmon': 0xffffa07a,
        'lightseagreen': 0xff20b2aa,
        'lightskyblue': 0xff87cefa,
        'lightslateblue': 0xff8470ff,
        'lightslategray': 0xff778899,
        'lightsteelblue': 0xffb0c4de,
        'lightyellow': 0xffffffe0,
        'lime': 0xff00ff00,
        'limegreen': 0xff32cd32,
        'linen': 0xfffaf0e6,
        'magenta': 0xffff00ff,
        'maroon': 0xff800000,
        'mediumaquamarine': 0xff66cdaa,
        'mediumblue': 0xff0000cd,
        'mediumorchid': 0xffba55d3,
        'mediumpurple': 0xff9370d8,
        'mediumseagreen': 0xff3cb371,
        'mediumslateblue': 0xff7b68ee,
        'mediumspringgreen': 0xff00fa9a,
        'mediumturquoise': 0xff48d1cc,
        'mediumvioletred': 0xffc71585,
        'midnightblue': 0xff191970,
        'mintcream': 0xfff5fffa,
        'mistyrose': 0xffffe4e1,
        'moccasin': 0xffffe4b5,
        'navajowhite': 0xffffdead,
        'navy': 0xff000080,
        'oldlace': 0xfffdf5e6,
        'olive': 0xff808000,
        'olivedrab': 0xff6b8e23,
        'orange': 0xffffa500,
        'orangered': 0xffff4500,
        'orchid': 0xffda70d6,
        'palegoldenrod': 0xffeee8aa,
        'palegreen': 0xff98fb98,
        'paleturquoise': 0xffafeeee,
        'palevioletred': 0xffd87093,
        'papayawhip': 0xffffefd5,
        'peachpuff': 0xffffdab9,
        'peru': 0xffcd853f,
        'pink': 0xffffc0cb,
        'plum': 0xffdda0dd,
        'powderblue': 0xffb0e0e6,
        'purple': 0xff800080,
        'red': 0xffff0000,
        'rosybrown': 0xffbc8f8f,
        'royalblue': 0xff4169e1,
        'saddlebrown': 0xff8b4513,
        'salmon': 0xfffa8072,
        'sandybrown': 0xfff4a460,
        'seagreen': 0xff2e8b57,
        'seashell': 0xfffff5ee,
        'sienna': 0xffa0522d,
        'silver': 0xffc0c0c0,
        'skyblue': 0xff87ceeb,
        'slateblue': 0xff6a5acd,
        'slategray': 0xff708090,
        'snow': 0xfffffafa,
        'springgreen': 0xff00ff7f,
        'steelblue': 0xff4682b4,
        'tan': 0xffd2b48c,
        'teal': 0xff008080,
        'thistle': 0xffd8bfd8,
        'tomato': 0xffff6347,
        'turquoise': 0xff40e0d0,
        'violet': 0xffee82ee,
        'violetred': 0xffd02090,
        'wheat': 0xfff5deb3,
        'white': 0xffffffff,
        'whitesmoke': 0xfff5f5f5,
        'yellow': 0xffffff00,
        'yellowgreen': 0xff9acd32,
        'transparent': 0x00ffffff
    };
    return ColorHelper;
}());
exports.ColorHelper = ColorHelper;
var ConverterHelper = /** @class */ (function () {
    function ConverterHelper() {
    }
    ConverterHelper.getFontName = function (fontFamily) {
        if (!fontFamily) {
            return null;
        }
        var fontName = fontFamily, listSeparator = ',';
        if (fontName.indexOf(listSeparator) !== -1) {
            fontName = fontName.split(listSeparator)[0];
        }
        if (fontName) {
            var index = fontName.length - 1;
            while (index >= 0) {
                if (fontName[index] !== '/') {
                    index--;
                }
                else {
                    break;
                }
            }
            if (index >= 0) {
                fontName = fontName.substring(index);
            }
            if (fontName && fontName.substring(0, 2) === '/#') {
                fontName = fontName.substring(2);
            }
            if (fontName[0] === '"' && fontName[fontName.length - 1] === '"') {
                fontName = fontName.substring(1, fontName.length - 1);
            }
        }
        return fontName;
    };
    ConverterHelper.setStyleInfoFont = function (font, styleInfo, headingFont, bodyFont) {
        var fontstr, fontFamily = font.fontName;
        if (!fontFamily) {
            fontFamily = DEFAULT_FONT_FAMILY;
        }
        var fontSize = '';
        if (font.fontSize > 0) {
            fontSize = Math.round(UnitHelper.pointToPixel(font.fontSize) * 10) / 10 + 'px';
        }
        var italic = '';
        if (font.isItalic) {
            italic = 'italic';
        }
        else {
            italic = 'normal';
        }
        var fontWeight = '';
        if (font.isBold) {
            fontWeight = 'bold';
        }
        else {
            fontWeight = 'normal';
        }
        var foreColor = '';
        if (font.fontColor) {
            if (font.fontColor.isThemeColor()) {
                foreColor = ColorHelper.getThemeColorName(font.fontColor);
            }
            else {
                foreColor = ColorHelper.toRGBColor(font.fontColor);
            }
        }
        if (foreColor) {
            styleInfo.foreColor = foreColor;
        }
        else {
            styleInfo.foreColor = null;
        }
        if (font.isStrikeOut) {
            styleInfo.textDecoration = 0x02;
        }
        if (font.underLineStyle !== keyword_undefined) {
            var underLineStyle = 0x01;
            if (font.underLineStyle === 2) {
                underLineStyle = 0x08;
            }
            else if (font.underLineStyle === 0) {
                underLineStyle = 0x00;
            }
            if (styleInfo.textDecoration === keyword_undefined) {
                styleInfo.textDecoration = underLineStyle;
            }
            else {
                styleInfo.textDecoration = styleInfo.textDecoration | underLineStyle;
            }
        }
        if (font.fontScheme === 1) {
            styleInfo.themeFont = THEME_HEADINGS;
            if (headingFont) {
                fontFamily = headingFont;
            }
        }
        else if (font.fontScheme === 2) {
            styleInfo.themeFont = THEME_BODY;
            if (bodyFont) {
                fontFamily = bodyFont;
            }
        }
        fontstr = italic + ' ' + fontWeight + ' ' + fontSize + ' ' + fontFamily;
        if (fontstr) {
            styleInfo.font = fontstr;
        }
    };
    ConverterHelper._getFontParseCache = function () {
        if (!ConverterHelper._fontParseCache) {
            ConverterHelper._fontParseCache = {};
        }
        return ConverterHelper._fontParseCache;
    };
    ConverterHelper.fromHtmlFont = function (font) {
        if (common_1.StringEx._isNullOrEmpty(font)) {
            return;
        }
        var result = {}, fontCache = ConverterHelper._getFontParseCache();
        if (fontCache[font]) {
            return fontCache[font];
        }
        var t = ConverterHelper.splitFontString(font);
        if (t.length === 0) {
            return;
        }
        var n = 0, fontStyleSetted = false, fontVariantSetted = false, fontWeightSetted = false;
        while (n < t.length) {
            var fontSet = t[n].toLowerCase();
            if (fontSet === 'normal') {
            }
            else if (!fontStyleSetted && (fontSet === 'italic' || fontSet === 'oblique' || fontSet === 'inherit')) {
                fontStyleSetted = true;
                if (fontSet === 'oblique') {
                    fontSet = ITALIC;
                }
                result.fontStyle = fontSet;
            }
            else if (!fontVariantSetted && (fontSet === 'small-caps')) {
                fontVariantSetted = true;
                result.fontVariant = fontSet;
            }
            else if (!fontWeightSetted &&
                (fontSet === 'bold' ||
                    fontSet === 'bolder' ||
                    fontSet === 'lighter' ||
                    fontSet === '100' ||
                    fontSet === '200' ||
                    fontSet === '300' ||
                    fontSet === '400' ||
                    fontSet === '500' ||
                    fontSet === '600' ||
                    fontSet === '700' ||
                    fontSet === '800' ||
                    fontSet === '900' ||
                    fontSet === 'inherit')) {
                fontWeightSetted = true;
                if (fontSet === 'bolder' || parseInt(fontSet, 10) >= 700) {
                    result.fontWeight = BOLD;
                }
                else if (fontSet === 'lighter') {
                    result.fontWeight = 'ExtraLight';
                }
                else {
                    result.fontWeight = fontSet;
                }
            }
            else if (fontSet.substring(0, 1) === '/') {
                n++;
                break;
            }
            else if (fontSet === 'xx-small' || fontSet === 'x-small' || fontSet === 'small' || fontSet === 'medium' ||
                fontSet === 'large' || fontSet === 'x-large' || fontSet === 'xx-large' ||
                fontSet.indexOf('px') !== -1 || fontSet.indexOf('pt') !== -1) {
                break;
            }
            n++;
            if (fontStyleSetted && fontVariantSetted && fontWeightSetted) {
                break;
            }
        }
        if (n < t.length) {
            var fontSize = t[n].toLowerCase();
            if (fontSize === 'xx-small' || fontSize === 'x-small' || fontSize === 'small' || fontSize === 'medium' || fontSize === 'large' || fontSize === 'x-large' || fontSize === 'xx-large') {
                var d = 10;
                if (fontSize === 'xx-small' || fontSize === 'x-small') {
                    d = 6;
                }
                else if (fontSize === 'small') {
                    d = 8;
                }
                else if (fontSize === 'medium') {
                    d = 10;
                }
                else if (fontSize === 'large') {
                    d = 14;
                }
                else if (fontSize === 'x-large') {
                    d = 18;
                }
                else if (fontSize === 'xx-large') {
                    d = 22;
                }
                result.fontSize = d;
            }
            else {
                var size = void 0;
                if (fontSize.indexOf('px') !== -1) {
                    size = parseFloat(fontSize);
                }
                else if (fontSize.indexOf('pt') !== -1) {
                    var x = parseFloat(fontSize);
                    if (!isNaN(x)) {
                        size = UnitHelper.pointToPixel(x);
                    }
                }
                if (!isNaN(size)) {
                    result.fontSize = size;
                }
            }
            n++;
        }
        if (n < t.length) {
            var lineHeight = t[n].toLowerCase();
            if (lineHeight.substring(0, 1) === '/') {
                n++;
            }
        }
        if (n < t.length) {
            var fontFamily = t[n];
            n++;
            for (; n < t.length; n++) {
                fontFamily = fontFamily + ' ' + t[n];
            }
            result.fontFamily = fontFamily;
        }
        fontCache[font] = result;
        return result;
    };
    ConverterHelper.composeFontWeightAndFontStyleToDestFont = function (srcFont, destFont) {
        var srcFontInfo = ConverterHelper.fromHtmlFont(srcFont);
        var destFontInfo = ConverterHelper.fromHtmlFont(destFont);
        if (srcFontInfo.fontWeight) {
            destFontInfo.fontWeight = srcFontInfo.fontWeight;
        }
        if (srcFontInfo.fontStyle) {
            destFontInfo.fontStyle = srcFontInfo.fontStyle;
        }
        return (destFontInfo.fontWeight ? destFontInfo.fontWeight : 'normal') + ' ' +
            (destFontInfo.fontStyle ? destFontInfo.fontStyle : 'normal') + ' ' +
            destFontInfo.fontSize + 'px ' +
            destFontInfo.fontFamily + ' ' +
            (destFontInfo.fontVariant ? destFontInfo.fontVariant : '');
    };
    ConverterHelper.splitFontString = function (font) {
        if (common_1.StringEx._isNullOrEmpty(font)) {
            return [];
        }
        font = font.trim();
        var list = [], sb = '';
        for (var i = 0, len = font.length; i < len; i++) {
            var currentChar = font[i];
            if (currentChar === ' ' || currentChar === '/') {
                list.push(sb);
                sb = '';
                if (currentChar === '/') {
                    sb += '/';
                }
            }
            else if (currentChar === '\'' || currentChar === '\"') {
                i++;
                while (font[i] !== currentChar && i < len) {
                    sb += font[i];
                    i++;
                }
            }
            else {
                sb += currentChar;
            }
        }
        if (sb.length > 0) {
            list.push(sb);
        }
        return list;
    };
    ConverterHelper.toVerticalAlignment = function (verticalAlignment) {
        switch (verticalAlignment) {
            case 0:
                return 0;
            case 1:
                return 1;
            case 2:
                return 2;
            default:
                return 2;
        }
    };
    ConverterHelper.toExcelVerticalAlignment = function (verticalAlignment) {
        switch (verticalAlignment) {
            case 0:
                return 0;
            case 1:
                return 1;
            case 2:
                return 2;
            default:
                return 0;
        }
    };
    ConverterHelper.toHorizontalAlignment = function (horizontalAlignment) {
        switch (horizontalAlignment) {
            case 0:
                return 3;
            case 1:
            case 6:
                return 0;
            case 2:
                return 1;
            case 3:
                return 2;
            case 4:
            case 5:
            case 7:
                return 3;
            default:
                return 3;
        }
    };
    ConverterHelper.toExcelHorizontalAlignment = function (horizontalAlignment) {
        switch (horizontalAlignment) {
            case 1:
                return 2;
            case 0:
                return 1;
            case 2:
                return 3;
            case 3:
                return 0;
            default:
                return 0;
        }
    };
    ConverterHelper.toBorderLine = function (borderside) {
        if (!borderside) {
            return undefined;
        }
        var result = null;
        if (borderside.lineStyle === 0) {
            return null;
        }
        if (!borderside.color) {
            borderside.color = new ExcelColor(1, 0, 0);
        }
        if (borderside.color.isThemeColor()) {
            result = {
                color: ColorHelper.getThemeColorName(borderside.color),
                style: borderside.lineStyle
            };
        }
        else {
            result = {
                color: ColorHelper.getRGBColor(borderside.color).toString(),
                style: borderside.lineStyle
            };
        }
        return result;
    };
    ConverterHelper.toExcelBorderSide = function (borderLine) {
        var border = new ExcelBorderSide();
        if (!borderLine) {
            return border;
        }
        var borderColor = borderLine.color;
        if (ColorHelper.isThemeColor(borderColor)) {
            border.color = ColorHelper.getExcelThemeColor(borderColor);
        }
        else {
            var color = borderLine.color;
            border.color = new ExcelColor(2, ColorHelper.fromHtmlColor(color), 0.0);
        }
        border.lineStyle = borderLine.style;
        return border;
    };
    ConverterHelper.setStyleInfoBorders = function (border, styleInfo) {
        styleInfo.borderLeft = ConverterHelper.toBorderLine(border.left);
        styleInfo.borderRight = ConverterHelper.toBorderLine(border.right);
        styleInfo.borderTop = ConverterHelper.toBorderLine(border.top);
        styleInfo.borderBottom = ConverterHelper.toBorderLine(border.bottom);
        styleInfo.borderVertical = ConverterHelper.toBorderLine(border.vertical);
        styleInfo.borderHorizontal = ConverterHelper.toBorderLine(border.horizontal);
        styleInfo.diagonalUp = ConverterHelper.toBorderLine(border.diagonalUp);
        styleInfo.diagonalDown = ConverterHelper.toBorderLine(border.diagonalDown);
    };
    ConverterHelper.toCellStyle = function (format, headingFont, bodyFont) {
        var result = {};
        if (!format) {
            return null;
        }
        if (((!format.isStyleFormat && format.applyFont !== false) || (format.isStyleFormat && (format.applyFont === keyword_undefined || format.applyFont))) && format.font) {
            ConverterHelper.setStyleInfoFont(format.font, result, headingFont, bodyFont);
        }
        if (!format.isStyleFormat || (format.isStyleFormat && (format.applyProtection === keyword_undefined || format.applyProtection))) {
            result.locked = format.isLocked;
        }
        if (!format.isStyleFormat || (format.isStyleFormat && (format.applyAlignment === keyword_undefined || format.applyAlignment))) {
            if (format.indent !== keyword_undefined) {
                result.textIndent = format.indent;
                if (result.textIndent > 0) {
                    var indent = result.textIndent, smallNum = Math.floor(indent);
                    if (indent - smallNum === 0.5 && (smallNum & 1) === 0) {
                        result.textIndent = smallNum;
                    }
                    else {
                        result.textIndent = Math.round(indent);
                    }
                }
            }
            result.wordWrap = format.isWordWrap;
            result.vAlign = ConverterHelper.toVerticalAlignment(format.verticalAlign);
            result.hAlign = ConverterHelper.toHorizontalAlignment(format.horizontalAlign);
            if (format.rotation === 255) {
                result.isVerticalText = true;
            }
        }
        if (format.border) {
            var border = format.border;
            if (format.isStyleFormat && format.applyBorder !== keyword_undefined && !format.applyBorder) {
                border = null;
            }
            if (border) {
                ConverterHelper.setStyleInfoBorders(border, result);
            }
        }
        if (format.fill && format.fill.patternType !== 0) {
            if (!format.isStyleFormat || (format.isStyleFormat && (format.applyFill === keyword_undefined || format.applyFill))) {
                ConverterHelper._setStyleInfoFill(format.fill, result);
            }
        }
        else {
            result.backColor = keyword_null;
        }
        if (format.isShrinkToFit) {
            result.shrinkToFit = true;
        }
        if (format.rotation) {
            result.textOrientation = format.rotation > 90 ? 90 - format.rotation : format.rotation;
        }
        var excelFormatCode = ExtendedNumberFormatHelper.getFormatCode(format), isStyleFormat = format.isStyleFormat, applyNumberFormat = format.applyNumberFormat;
        if (!isStyleFormat ||
            ((applyNumberFormat === keyword_undefined || applyNumberFormat) && excelFormatCode !== 'General')) {
            result.formatter = excelFormatCode;
        }
        if (!common_1._isNullOrUndefined(format.quotePrefix)) {
            result.quotePrefix = format.quotePrefix;
        }
        return result;
    };
    ConverterHelper.toRichTextStyle = function (styleFont, headingFont, bodyFont) {
        var style = {};
        ConverterHelper.setStyleInfoFont(styleFont, style, headingFont, bodyFont);
        style.charSetIndex = styleFont.charSetIndex;
        style.isCondense = styleFont.isCondense;
        style.isExtend = styleFont.isExtend;
        style.fontFamily = styleFont.fontFamily;
        style.isOutlineStyle = styleFont.isOutlineStyle;
        style.isShadowStyle = styleFont.isShadowStyle;
        style.vertAlign = styleFont.vertAlign;
        return style;
    };
    ConverterHelper.fromRichTextStyle = function (styleFont) {
        if (common_1._isNullOrUndefined(styleFont)) {
            return;
        }
        var fontName = DEFAULT_FONT_FAMILY;
        var style = {};
        if (styleFont.font) {
            var fontStyle = ConverterHelper.fromHtmlFont(styleFont.font);
            if (fontStyle.fontFamily) {
                fontName = ConverterHelper.getFontName(fontStyle.fontFamily);
            }
            if (common_1.StringEx._isNullOrEmpty(fontName)) {
                fontName = DEFAULT_FONT_FAMILY;
            }
            style.fontFamily = fontName;
            if (fontStyle.fontSize) {
                style.fontSize = Math.round(UnitHelper.pixelToPoint(fontStyle.fontSize));
            }
            if (fontStyle.fontStyle === ITALIC) {
                style.isItalic = true;
            }
            if (fontStyle.fontWeight === BOLD) {
                style.isBold = true;
            }
        }
        if (styleFont.foreColor) {
            if (ColorHelper.isThemeColor(styleFont.foreColor)) {
                style.foreColor = ColorHelper.getExcelThemeColor(styleFont.foreColor);
            }
            else {
                var color = ColorHelper.fromHtmlColor(styleFont.foreColor);
                var color1 = ColorHelper.mixTranslucentColor(ColorHelper.fromArgb(0xFFFFFF), ColorHelper.fromArgb(color));
                color = color1.a * Math.pow(16, 6) + color1.r * Math.pow(16, 4) + color1.g * Math.pow(16, 2) + color1.b;
                style.foreColor = new ExcelColor(2, color, 0.0);
            }
        }
        if (styleFont.themeFont) {
            if (styleFont.themeFont.toUpperCase() === 'Headings'.toUpperCase()) {
                style.fontScheme = 1;
            }
            else if (styleFont.themeFont.toUpperCase() === 'Body'.toUpperCase()) {
                style.fontScheme = 2;
            }
        }
        if ((styleFont.textDecoration & 0x01) === 0x01) {
            style.underLineStyle = 1;
        }
        if ((styleFont.textDecoration & 0x08) === 0x08) {
            style.underLineStyle = 2;
        }
        style.isStrikeOut = ((styleFont.textDecoration & 0x02) === 0x02);
        style.charSetIndex = styleFont.charSetIndex;
        style.isCondense = styleFont.isCondense;
        style.isExtend = styleFont.isExtend;
        style.fontFamilySet = styleFont.fontFamily;
        style.isOutlineStyle = styleFont.isOutlineStyle;
        style.isShadowStyle = styleFont.isShadowStyle;
        style.vertAlign = styleFont.vertAlign;
        return style;
    };
    ConverterHelper.toSchemeClrValue = function (scheme) {
        switch (scheme) {
            case 255:
                return '';
            case 1:
                return 'dk1';
            case 0:
                return 'lt1';
            case 3:
                return 'dk2';
            case 2:
                return 'lt2';
            case 4:
                return 'accent1';
            case 5:
                return 'accent2';
            case 6:
                return 'accent3';
            case 7:
                return 'accent4';
            case 8:
                return 'accent5';
            case 9:
                return 'accent6';
            case 10:
                return 'hlink';
            case 11:
                return 'folHlink';
            case 240:
                return 'phClr';
            case 241:
                return 'tx1';
            case 242:
                return 'tx2';
            case 243:
                return 'bg1';
            case 244:
                return 'bg2';
            default:
                return '';
        }
    };
    ConverterHelper._setStyleInfoFill = function (fill, style) {
        if (fill.patternType === 1) {
            ConverterHelper._setStyleInfoFill_String(fill.fgColor, style);
        }
        else if (fill.patternType) {
            ConverterHelper._setStyleInfoFill_Pattern(fill.patternType, fill.fgColor, fill.bgColor, style);
        }
        else if (fill.stops) {
            ConverterHelper._setStyleInfoFill_Gradient(fill, style);
        }
    };
    ConverterHelper._setStyleInfoFill_String = function (bgColor, styleInfo) {
        if (!common_1._isNullOrUndefined(bgColor)) {
            var isNullColor = (bgColor.isRGBColor() && bgColor.value() === 0);
            if ((bgColor.isRGBColor() && bgColor.value() === 0) || (bgColor.isIndexedColor() && bgColor.value() === 64) || (bgColor.isIndexedColor() && bgColor.value() === 65)) {
                if (isNullColor) {
                    styleInfo.backColor = null;
                }
                return;
            }
            if (bgColor.isThemeColor()) {
                styleInfo.backColor = ColorHelper.getThemeColorName(bgColor);
            }
            else {
                styleInfo.backColor = ColorHelper.toRGBColor(bgColor);
            }
        }
        else {
            styleInfo.backColor = '#000000';
        }
    };
    ConverterHelper._setStyleInfoFill_Pattern = function (patternType, fgColor, bgColor, styleInfo) {
        styleInfo.backColor = {
            type: patternType,
            patternColor: null,
            backgroundColor: null
        };
        if (fgColor) {
            if (fgColor.isThemeColor()) {
                styleInfo.backColor.patternColor = ColorHelper.getThemeColorName(fgColor);
            }
            else {
                styleInfo.backColor.patternColor = ColorHelper.toRGBColor(fgColor);
            }
        }
        if (bgColor) {
            if (bgColor.isThemeColor()) {
                styleInfo.backColor.backgroundColor = ColorHelper.getThemeColorName(bgColor);
            }
            else {
                styleInfo.backColor.backgroundColor = ColorHelper.toRGBColor(bgColor);
            }
        }
    };
    ConverterHelper._setStyleInfoFill_Gradient = function (fill, styleInfo) {
        styleInfo.backColor = fill;
        for (var i = 0; i < fill.stops.length; i++) {
            var color = fill.stops[i].color;
            if (typeof color === 'string') {
                continue;
            }
            if (color.isThemeColor()) {
                fill.stops[i].color = ColorHelper.getThemeColorName(color);
            }
            else {
                fill.stops[i].color = ColorHelper.toRGBColor(color);
            }
        }
    };
    ConverterHelper.getStyleFormatter = function (style) {
        var retValue = keyword_null, formatterString = style.formatter;
        if (typeof formatterString === 'string' && (formatterString.charAt(0) === '=' || (formatterString.indexOf('{{') >= 0 && formatterString.indexOf('}}') >= 0))) {
            return retValue;
        }
        if (typeof formatterString === 'string' && formatterString !== ' ') {
            retValue = formatterString;
        }
        else if (style.autoFormatter) {
            var formatCached = style.autoFormatter.formatCached;
            if (formatCached && !common_1.StringEx._isNullOrWhiteSpace(formatCached)) {
                retValue = formatCached;
            }
        }
        else if (formatterString) {
            var formatCached1 = formatterString.formatCached;
            if (formatCached1 && !common_1.StringEx._isNullOrWhiteSpace(formatCached1)) {
                retValue = formatCached1;
            }
        }
        return retValue;
    };
    ConverterHelper.toExtendedFormat = function (style, writerDataModel) {
        if (!style) {
            return;
        }
        var result = new ExtendedFormat();
        var formatString = ConverterHelper.getStyleFormatter(style);
        if (formatString) {
            var ret = ExtendedNumberFormatHelper.getFormatId(formatString);
            var id = ret.id, isBuiltIn = ret.isBuiltIn;
            if (isBuiltIn) {
                result.numberFormatIndex = id;
            }
            else {
                result.numberFormat = new ExcelNumerFormat(id, formatString);
            }
            var parentStyle = writerDataModel._getStyleByName(style.parentName);
            var parentFormat = parentStyle && ConverterHelper.getStyleFormatter(parentStyle);
            if (id !== 0 || (parentFormat && ExtendedNumberFormatHelper.getFormatId(parentFormat).id !== 0)) {
                result.applyNumberFormat = true;
            }
        }
        else {
            result.numberFormatIndex = 0;
        }
        if (style.backColor && style.backColor.type !== 0) {
            result.applyFill = true;
            var fill = new ExcelFill();
            if (typeof style.backColor === 'string') {
                fill.patternType = 1;
                fill.fgColor = style.backColor;
            }
            else if (!common_1._isNullOrUndefined(style.backColor.type) && style.backColor.type !== 'path') {
                fill.patternType = style.backColor.type;
                fill.fgColor = style.backColor.patternColor;
                fill.bgColor = style.backColor.backgroundColor;
            }
            else {
                for (var k in style.backColor) {
                    fill[k] = style.backColor[k];
                }
            }
            if (!common_1._isNullOrUndefined(fill.fgColor)) {
                fill.fgColor = ColorHelper.toExcelColor(fill.fgColor);
            }
            if (!common_1._isNullOrUndefined(fill.bgColor)) {
                fill.bgColor = ColorHelper.toExcelColor(fill.bgColor);
            }
            var length_1 = fill.stops && fill.stops.length;
            for (var i = 0; i < length_1; i++) {
                fill.stops[i].color = ColorHelper.toExcelColor(fill.stops[i].color);
            }
            result.fill = fill;
        }
        if (style.borderLeft || style.borderRight || style.borderTop || style.borderBottom || style.diagonalUp || style.diagonalDown) {
            result.border = new ExcelBorder();
            if (style.borderLeft) {
                result.border.left = ConverterHelper.toExcelBorderSide(style.borderLeft);
            }
            if (style.borderRight) {
                result.border.right = ConverterHelper.toExcelBorderSide(style.borderRight);
            }
            if (style.borderTop) {
                result.border.top = ConverterHelper.toExcelBorderSide(style.borderTop);
            }
            if (style.borderBottom) {
                result.border.bottom = ConverterHelper.toExcelBorderSide(style.borderBottom);
            }
            if (style.diagonalDown) {
                result.border.diagonalDown = ConverterHelper.toExcelBorderSide(style.diagonalDown);
            }
            if (style.diagonalUp) {
                result.border.diagonalUp = ConverterHelper.toExcelBorderSide(style.diagonalUp);
            }
            result.applyBorder = true;
        }
        if (style.font || style.fontForColumnWidth || style.foreColor || style.themeFont || (style.textDecoration !== keyword_undefined && style.textDecoration !== null)) {
            result.applyFont = true;
            var fontName = DEFAULT_FONT_FAMILY;
            var appliedFont = style.fontForColumnWidth ? style.fontForColumnWidth : style.font;
            if (appliedFont) {
                var styleFont = ConverterHelper.fromHtmlFont(appliedFont);
                if (styleFont.fontFamily) {
                    fontName = ConverterHelper.getFontName(styleFont.fontFamily);
                }
                if (common_1.StringEx._isNullOrEmpty(fontName)) {
                    fontName = DEFAULT_FONT_FAMILY;
                }
                result.font = new ExcelFont(fontName.trim(), null, 0);
                if (styleFont.fontSize) {
                    result.font.fontSize = Math.round(UnitHelper.pixelToPoint(styleFont.fontSize));
                }
                if (styleFont.fontStyle === ITALIC) {
                    result.font.isItalic = true;
                }
                if (styleFont.fontWeight === BOLD) {
                    result.font.isBold = true;
                }
            }
            if ((style.textDecoration & 0x01) === 0x01) {
                result.font.underLineStyle = 1;
            }
            if ((style.textDecoration & 0x08) === 0x08) {
                result.font.underLineStyle = 2;
            }
            if (style.foreColor) {
                if (ColorHelper.isThemeColor(style.foreColor)) {
                    result.font.fontColor = ColorHelper.getExcelThemeColor(style.foreColor);
                }
                else {
                    var color = ColorHelper.fromHtmlColor(style.foreColor);
                    var color1 = ColorHelper.mixTranslucentColor(ColorHelper.fromArgb(0xFFFFFF), ColorHelper.fromArgb(color));
                    color = color1.a * Math.pow(16, 6) + color1.r * Math.pow(16, 4) + color1.g * Math.pow(16, 2) + color1.b;
                    result.font.fontColor = new ExcelColor(2, color, 0.0);
                }
            }
            result.font.isStrikeOut = ((style.textDecoration & 0x02) === 0x02);
        }
        if (style.themeFont) {
            if (style.themeFont.toUpperCase() === 'Headings'.toUpperCase()) {
                result.font.fontScheme = 1;
            }
            else if (style.themeFont.toUpperCase() === 'Body'.toUpperCase()) {
                result.font.fontScheme = 2;
            }
        }
        if (style.shrinkToFit) {
            result.isShrinkToFit = true;
        }
        if (style.textOrientation) {
            result.rotation = style.textOrientation < 0 ? 90 - style.textOrientation : style.textOrientation;
        }
        if (style.locked !== keyword_undefined) {
            result.isLocked = style.locked;
        }
        else {
            result.isLocked = true;
        }
        if (style.wordWrap !== keyword_null && style.wordWrap !== keyword_undefined) {
            result.isWordWrap = style.wordWrap;
        }
        if (style.textIndent !== keyword_null && style.textIndent !== keyword_undefined) {
            result.indent = Math.ceil(style.textIndent);
        }
        result.verticalAlign = ConverterHelper.toExcelVerticalAlignment(style.vAlign);
        result.horizontalAlign = ConverterHelper.toExcelHorizontalAlignment(style.hAlign);
        if (style.isVerticalText === true) {
            result.isVerticalText = style.isVerticalText;
        }
        if (!common_1._isNullOrUndefined(style.quotePrefix)) {
            result.quotePrefix = style.quotePrefix;
        }
        if (!common_1._isNullOrUndefined(style.parentName)) {
            result.parentName = style.parentName;
        }
        return result;
    };
    ConverterHelper.toDifferentialFormatting = function (style, writerDataModel) {
        var result = {};
        if (!common_1.isNullOrUndefined(style.parentName) && writerDataModel) {
            var namedStyle = common_1._StyleHelper._getByName(writerDataModel._namedStyles, style.parentName);
            style = namedStyle ? namedStyle : style;
        }
        var isSlicerHeader = style.isSlicerHeader, isFormatStyle = style.isFormatStyle;
        var formatString = style.formatter;
        if (typeof formatString === 'string' && formatString !== ' ') {
            var ret = ExtendedNumberFormatHelper.getFormatId(formatString);
            var id = ret.id, isBuiltIn = ret.isBuiltIn;
            if (isBuiltIn) {
                result.numberFormatIndex = id;
                result.numberFormatCode = formatString;
            }
            else {
                result.numberFormat = new ExcelNumerFormat(id, formatString);
            }
        }
        if (style.backColor !== keyword_undefined) {
            var backColor = style.backColor;
            if (backColor) {
                result.fill = ColorHelper.toExcelBackColor(backColor, true);
            }
            else {
                result.fill = backColor;
            }
        }
        if (isFormatStyle || style.borderLeft || style.borderRight || style.borderTop || style.borderBottom || style.borderVertical || style.borderHorizontal) {
            result.border = new ExcelBorder();
            if (style.borderLeft) {
                result.border.left = ConverterHelper.toExcelBorderSide(style.borderLeft);
            }
            else if (isSlicerHeader || (style.borderLeft === keyword_undefined && isFormatStyle)) {
                result.border.left = keyword_undefined;
            }
            if (style.borderRight) {
                result.border.right = ConverterHelper.toExcelBorderSide(style.borderRight);
            }
            else if (isSlicerHeader || (style.borderRight === keyword_undefined && isFormatStyle)) {
                result.border.right = keyword_undefined;
            }
            if (style.borderTop) {
                result.border.top = ConverterHelper.toExcelBorderSide(style.borderTop);
            }
            else if (isSlicerHeader || (style.borderTop === keyword_undefined && isFormatStyle)) {
                result.border.top = keyword_undefined;
            }
            if (style.borderBottom) {
                result.border.bottom = ConverterHelper.toExcelBorderSide(style.borderBottom);
            }
            else if (isSlicerHeader || (style.borderBottom === keyword_undefined && isFormatStyle)) {
                result.border.bottom = keyword_undefined;
            }
            if (style.borderVertical) {
                result.border.vertical = ConverterHelper.toExcelBorderSide(style.borderVertical);
            }
            if (style.borderHorizontal) {
                result.border.horizontal = ConverterHelper.toExcelBorderSide(style.borderHorizontal);
            }
        }
        if (style.font ||
            style.foreColor !== keyword_undefined ||
            style.themeFont ||
            (style.textDecoration !== keyword_undefined && style.textDecoration !== null)) {
            var fontName = DEFAULT_FONT_FAMILY, color = void 0;
            if (style.font) {
                var styleFont = ConverterHelper.fromHtmlFont(style.font);
                if (styleFont.fontFamily) {
                    fontName = ConverterHelper.getFontName(styleFont.fontFamily);
                }
                if (common_1.StringEx._isNullOrEmpty(fontName)) {
                    fontName = DEFAULT_FONT_FAMILY;
                }
                result.font = new ExcelFont(fontName.trim(), null, 0);
                if (styleFont.fontSize) {
                    result.font.fontSize = Math.round(UnitHelper.pixelToPoint(styleFont.fontSize));
                }
                if (styleFont.fontStyle === 'italic') {
                    result.font.isItalic = true;
                }
                if (styleFont.fontWeight === 'bold') {
                    result.font.isBold = true;
                }
            }
            if (!result.font) {
                result.font = new ExcelFont(fontName.trim(), null, 0);
            }
            if ((style.textDecoration & 0x01) === 0x01) {
                result.font.underLineStyle = 1;
            }
            if ((style.textDecoration & 0x08) === 0x08) {
                result.font.underLineStyle = 2;
            }
            if (style.foreColor) {
                if (ColorHelper.isThemeColor(style.foreColor)) {
                    result.font.fontColor = ColorHelper.getExcelThemeColor(style.foreColor);
                }
                else {
                    color = ColorHelper.fromHtmlColor(style.foreColor);
                    var color1 = ColorHelper.mixTranslucentColor(ColorHelper.fromArgb(0xFFFFFF), ColorHelper.fromArgb(color));
                    color = color1.a * Math.pow(16, 6) + color1.r * Math.pow(16, 4) + color1.g * Math.pow(16, 2) + color1.b;
                    result.font.fontColor = new ExcelColor(2, color, 0.0);
                }
            }
            if (style.foreColor === null) {
                result.font.fontColor = null;
            }
            result.font.isStrikeOut = ((style.textDecoration & 0x02) === 0x02);
        }
        result.isPartFontStyle = style.isPartFontStyle;
        result.isSlicerHeader = isSlicerHeader;
        return result;
    };
    ConverterHelper.cloneSpreadJSStyle = function (style) {
        if (common_1.isNullOrUndefined(style)) {
            return;
        }
        var result = {};
        result.backColor = style.backColor;
        result.foreColor = style.foreColor;
        result.hAlign = style.hAlign;
        result.vAlign = style.vAlign;
        result.font = style.font;
        result.themeFont = style.themeFont;
        result.formatter = style.formatter;
        result.borderLeft = style.borderLeft;
        result.borderTop = style.borderTop;
        result.borderRight = style.borderRight;
        result.borderBottom = style.borderBottom;
        result.diagonalDown = style.diagonalDown;
        result.diagonalUp = style.diagonalUp;
        result.locked = style.locked;
        result.textIndent = style.textIndent;
        result.wordWrap = style.wordWrap;
        result.shrinkToFit = style.shrinkToFit;
        result.textDecoration = style.textDecoration;
        result.textOrientation = style.textOrientation;
        result.isVerticalText = style.isVerticalText;
        result.quotePrefix = style.quotePrefix;
        result.autoFormatter = style.autoFormatter;
        result.name = style.name;
        result.parentName = style.parentName;
        result.fontForColumnWidth = style.fontForColumnWidth;
        return result;
    };
    ConverterHelper.convertDxfToStyle = function (dxf, headingFont, bodyFont) {
        var style = {};
        if (dxf.font) {
            ConverterHelper.setStyleInfoFont(dxf.font, style, headingFont, bodyFont);
        }
        if (dxf.fill) {
            if (common_1.isNullOrUndefined(dxf.fill.patternType) && dxf.fill.bgColor) {
                dxf.fill.patternType = 1;
            }
            if (dxf.fill.patternType === 1) {
                dxf.fill.fgColor = dxf.fill.bgColor;
            }
            ConverterHelper._setStyleInfoFill(dxf.fill, style);
        }
        if (dxf.border) {
            ConverterHelper.setStyleInfoBorders(dxf.border, style);
        }
        if (dxf.numberFormat) {
            var excelFormatCode = ExtendedNumberFormatHelper.getFormatCode(dxf);
            if (excelFormatCode !== 'General') {
                style.formatter = excelFormatCode;
            }
        }
        return style;
    };
    ConverterHelper._fontParseCache = null;
    return ConverterHelper;
}());
exports.ConverterHelper = ConverterHelper;
var DefaultStyle = /** @class */ (function () {
    function DefaultStyle() {
    }
    DefaultStyle._getDefaultStyle = function (workbook) {
        var defaultStyle = {
            foreColor: 'black',
            font: 'normal normal normal 11pt/normal Calibri',
            locked: true,
            name: 'Normal',
            hAlign: 3,
            vAlign: 0,
            formatter: 'General'
        };
        for (var sheetName in workbook.sheets) {
            if (workbook.sheets.hasOwnProperty(sheetName)) {
                var sheet = workbook.sheets[sheetName];
                if (sheet.data && sheet.data.defaultDataNode && sheet.data.defaultDataNode.style) {
                    var sheetDefaultStyle = sheet.data.defaultDataNode.style;
                    for (var p in sheetDefaultStyle) {
                        if (sheetDefaultStyle.hasOwnProperty(p) && !common_1._isNullOrUndefined(sheetDefaultStyle[p])) {
                            defaultStyle[p] = sheetDefaultStyle[p];
                        }
                    }
                    break;
                }
            }
        }
        return defaultStyle;
    };
    return DefaultStyle;
}());
exports.DefaultStyle = DefaultStyle;
var GcSystemColors = /** @class */ (function () {
    function GcSystemColors() {
    }
    GcSystemColors.getSystemColor = function (index) {
        return ColorHelper.fromArgb(GcSystemColors._systemColors[index]);
    };
    GcSystemColors._systemColors = [
        0xFFB4B4B4, 0xFF99B4D1, 0xFF000000, 0xFFABABAB, 0xFFF0F0F0, 0xFFA0A0A0, 0xFF696969, 0xFFE3E3E3,
        0xFFFFFFFF, 0xFF000000, 0xFF000000, 0xFFB9D1EA, 0xFFD7E4F2, 0xFF6D6D6D, 0xFF3399FF, 0xFFFFFFFF, 0xFF0066CC, 0xFFF4F7FC,
        0xFFBFCDDB, 0xFF434E54, 0xFFFFFFE1, 0xFF000000, 0xFFF0F0F0, 0xFFF0F0F0, 0xFF3399FF, 0xFF000000, 0xFFC8C8C8, 0xFFFFFFFF,
        0xFF646464, 0xFF000000, 0xFFA0A0A0, 0xFFE3E3E3, 0xFFF0F0F0, 0xFFFFFFFF, 0xFFA0A0A0, 0xFF000000
    ];
    return GcSystemColors;
}());
var ExcelSystemColor = /** @class */ (function () {
    function ExcelSystemColor() {
    }
    ExcelSystemColor.getSystemColor = function (name) {
        return ExcelSystemColor.systemColors[name.toUpperCase()];
    };
    ExcelSystemColor.systemColors = {
        'length': 0,
        '3DDKSHADOW': GcSystemColors.getSystemColor(30),
        '3DLIGHT': GcSystemColors.getSystemColor(31),
        'ACTIVEBORDER': GcSystemColors.getSystemColor(0),
        'ACTIVECAPTION': GcSystemColors.getSystemColor(1),
        'APPWORKSPACE': GcSystemColors.getSystemColor(3),
        'BACKGROUND': GcSystemColors.getSystemColor(10),
        'BTNFACE': GcSystemColors.getSystemColor(32),
        'BTNHIGHLIGHT': GcSystemColors.getSystemColor(33),
        'BTNSHADOW': GcSystemColors.getSystemColor(34),
        'BTNTEXT': GcSystemColors.getSystemColor(35),
        'CAPTIONTEXT': GcSystemColors.getSystemColor(2),
        'GRAYTEXT': GcSystemColors.getSystemColor(13),
        'HIGHLIGHT': GcSystemColors.getSystemColor(14),
        'HIGHLIGHTTEXT': GcSystemColors.getSystemColor(15),
        'INACTIVEBORDER': GcSystemColors.getSystemColor(17),
        'INACTIVECAPTION': GcSystemColors.getSystemColor(18),
        'INACTIVECAPTIONTEXT': GcSystemColors.getSystemColor(19),
        'INFOBK': GcSystemColors.getSystemColor(20),
        'INFOTEXT': GcSystemColors.getSystemColor(21),
        'MENU': GcSystemColors.getSystemColor(22),
        'GRADIENTACTIVECAPTION': GcSystemColors.getSystemColor(11),
        'HOTLIGHT': GcSystemColors.getSystemColor(16),
        'GRADIENTINACTIVECAPTION': GcSystemColors.getSystemColor(12),
        'MENUBAR': GcSystemColors.getSystemColor(23),
        'MENUHIGHLIGHT': GcSystemColors.getSystemColor(24),
        'MENUTEXT': GcSystemColors.getSystemColor(25),
        'SCROLLBAR': GcSystemColors.getSystemColor(26),
        'WINDOW': GcSystemColors.getSystemColor(27),
        'WINDOWFRAME': GcSystemColors.getSystemColor(28),
        'WINDOWTEXT': GcSystemColors.getSystemColor(29)
    };
    return ExcelSystemColor;
}());
exports.ExcelSystemColor = ExcelSystemColor;
function clearCache() {
    UnitHelper._maxiumDigitWidthCache = keyword_undefined;
    ExtendedNumberFormatHelper._formatIDCache = keyword_undefined;
    ExtendedNumberFormatHelper._customNumberFormat = { count: 0 };
    ExtendedNumberFormatHelper._builtInNumberFomrat = { count: 0 };
    ConverterHelper._fontParseCache = keyword_undefined;
    ColorHelper._themeColorCache = keyword_undefined;
    ColorHelper._htmlColorCache = keyword_undefined;
    ColorHelper.useCustomPalette = false;
    ColorHelper.customPalette = keyword_null;
}
exports.clearCache = clearCache;
/***/ }),

/***/ './src/excel-io.ts':
/*!*************************!*\
  !*** ./src/excel-io.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });
var file_loader_1 = __webpack_require__(/*! ./xlsx-io/common/file-loader */ './src/xlsx-io/common/file-loader.ts');
var xlsx_reader_1 = __webpack_require__(/*! ./xlsx-io/reader/xlsx-reader */ './src/xlsx-io/reader/xlsx-reader.ts');
var xlsx_writer_1 = __webpack_require__(/*! ./xlsx-io/writer/xlsx-writer */ './src/xlsx-io/writer/xlsx-writer.ts');
var xlsxEncryptionHelper_1 = __webpack_require__(/*! ./xlsx-io/password/xlsxEncryptionHelper */ './src/xlsx-io/password/xlsxEncryptionHelper.ts');
var errorcode_1 = __webpack_require__(/*! ./xlsx-io/common/errorcode */ './src/xlsx-io/common/errorcode.ts');
var errorMessage_1 = __webpack_require__(/*! ./xlsx-io/common/errorMessage */ './src/xlsx-io/common/errorMessage.ts');
var common_1 = __webpack_require__(/*! ./common/common */ './src/common/common.ts');
exports.ErrorCode = errorcode_1.errorCode;
var ls = __webpack_require__(/*! license */ './src/lc/debugLc.js');
if (ls) {
    ls._ns && ls._ns(exports);
    var productType = ls._productType;
    if (productType === 1) {
        ls._replace();
    }
}
var IO = /** @class */ (function () {
    function IO() {
        this._fileLoader = new file_loader_1.FileLoader();
    }
    IO.prototype.open = function (file, successCallBack, errorCallBack, options) {
        var self = this;
        if (!successCallBack) {
            successCallBack = function () {
            };
        }
        if (!errorCallBack) {
            errorCallBack = function () {
            };
        }
        self._fileLoader.onFileLoad = function (filesData) {
            try {
                var xlsxReader = new xlsx_reader_1.XlsxReader();
                xlsxReader._load(filesData, function (json) {
                    successCallBack(json);
                });
            }
            catch (e) {
                errorCallBack({ errorCode: errorcode_1.errorCode.fileFormatError,
                    errorMessage: errorMessage_1.sR().EXP_FILE_FORMAT
                });
            }
        };
        self._fileLoader.onError = errorCallBack;
        self._fileLoader.loadFile(file, options);
    };
    IO.prototype.save = function (json, successCallBack, errorCallBack, options) {
        if (!successCallBack) {
            successCallBack = function () {
            };
        }
        if (!errorCallBack) {
            errorCallBack = function () {
            };
        }
        var spreadObj, useArrayBuffer;
        if (typeof json === 'object') {
            spreadObj = JSON.parse(JSON.stringify(json));
        }
        if (typeof json === 'string') {
            spreadObj = JSON.parse(json);
        }
        new xlsx_writer_1.XlsxWriter(spreadObj, function () {
            try {
                var xlsxWriter = this;
                xlsxWriter.onZip = function (data) {
                    if (options && options.password) {
                        try {
                            data = xlsxEncryptionHelper_1.XlsxEncryptionHelper._encrypt(data, options.password);
                            if (!useArrayBuffer) {
                                data = xlsxEncryptionHelper_1.XlsxEncryptionHelper._arrayBufferToBlob(data);
                            }
                        }
                        catch (e) {
                            errorCallBack({ errorCode: errorcode_1.errorCode.fileFormatError,
                                errorMessage: errorMessage_1.sR().EXP_FILE_FORMAT
                            });
                            return;
                        }
                    }
                    successCallBack(data);
                };
                xlsxWriter.onError = function () {
                    errorCallBack({ errorCode: errorcode_1.errorCode.fileFormatError,
                        errorMessage: errorMessage_1.sR().EXP_FILE_FORMAT
                    });
                };
                if (common_1._isNullOrUndefined(options)) {
                    options = {};
                }
                if (common_1._isNullOrUndefined(options.xlsxStrictMode)) {
                    options.xlsxStrictMode = true;
                }
                if (options && options.password) {
                    useArrayBuffer = options.useArrayBuffer;
                    options.useArrayBuffer = true;
                }
                xlsxWriter._options = options;
                xlsxWriter._save();
            }
            catch (e) {
                errorCallBack({ errorCode: errorcode_1.errorCode.fileFormatError,
                    errorMessage: errorMessage_1.sR().EXP_FILE_FORMAT
                });
            }
        });
    };
    return IO;
}());
exports.IO = IO;
/***/ }),

/***/ './src/lc/debugLc.js':
/*!***************************!*\
  !*** ./src/lc/debugLc.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {
(function() {
    'use strict';

    /*eslint-disable */
    
    module.exports = {
        _productType: 0
    };

}());

/***/ }),

/***/ "./src/lib/jszip.min.js":
/*!******************************!*\
  !*** ./src/lib/jszip.min.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate) {var require;var require;/*!

JSZip v3.7.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

!function(t){if(true)module.exports=t();else {}}(function(){return function s(a,o,h){function u(r,t){if(!o[r]){if(!a[r]){var e="function"==typeof require&&require;if(!t&&e)return require(r,!0);if(l)return l(r,!0);var i=new Error("Cannot find module '"+r+"'");throw i.code="MODULE_NOT_FOUND",i}var n=o[r]={exports:{}};a[r][0].call(n.exports,function(t){var e=a[r][1][t];return u(e||t)},n,n.exports,s,a,o,h)}return o[r].exports}for(var l="function"==typeof require&&require,t=0;t<h.length;t++)u(h[t]);return u}({1:[function(t,e,r){"use strict";var c=t("./utils"),d=t("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(t){for(var e,r,i,n,s,a,o,h=[],u=0,l=t.length,f=l,d="string"!==c.getTypeOf(t);u<t.length;)f=l-u,i=d?(e=t[u++],r=u<l?t[u++]:0,u<l?t[u++]:0):(e=t.charCodeAt(u++),r=u<l?t.charCodeAt(u++):0,u<l?t.charCodeAt(u++):0),n=e>>2,s=(3&e)<<4|r>>4,a=1<f?(15&r)<<2|i>>6:64,o=2<f?63&i:64,h.push(p.charAt(n)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join("")},r.decode=function(t){var e,r,i,n,s,a,o=0,h=0,u="data:";if(t.substr(0,u.length)===u)throw new Error("Invalid base64 input, it looks like a data url.");var l,f=3*(t=t.replace(/[^A-Za-z0-9\+\/\=]/g,"")).length/4;if(t.charAt(t.length-1)===p.charAt(64)&&f--,t.charAt(t.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(l=d.uint8array?new Uint8Array(0|f):new Array(0|f);o<t.length;)e=p.indexOf(t.charAt(o++))<<2|(n=p.indexOf(t.charAt(o++)))>>4,r=(15&n)<<4|(s=p.indexOf(t.charAt(o++)))>>2,i=(3&s)<<6|(a=p.indexOf(t.charAt(o++))),l[h++]=e,64!==s&&(l[h++]=r),64!==a&&(l[h++]=i);return l}},{"./support":30,"./utils":32}],2:[function(t,e,r){"use strict";var i=t("./external"),n=t("./stream/DataWorker"),s=t("./stream/Crc32Probe"),a=t("./stream/DataLengthProbe");function o(t,e,r,i,n){this.compressedSize=t,this.uncompressedSize=e,this.crc32=r,this.compression=i,this.compressedContent=n}o.prototype={getContentWorker:function(){var t=new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")),e=this;return t.on("end",function(){if(this.streamInfo.data_length!==e.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),t},getCompressedWorker:function(){return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(t,e,r){return t.pipe(new s).pipe(new a("uncompressedSize")).pipe(e.compressWorker(r)).pipe(new a("compressedSize")).withStreamInfo("compression",e)},e.exports=o},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(t,e,r){"use strict";var i=t("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(t){return new i("STORE compression")},uncompressWorker:function(){return new i("STORE decompression")}},r.DEFLATE=t("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(t,e,r){"use strict";var i=t("./utils");var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e){return void 0!==t&&t.length?"string"!==i.getTypeOf(t)?function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}(0|e,t,t.length,0):function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e.charCodeAt(a))];return-1^t}(0|e,t,t.length,0):0}},{"./utils":32}],5:[function(t,e,r){"use strict";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(t,e,r){"use strict";var i=null;i="undefined"!=typeof Promise?Promise:t("lie"),e.exports={Promise:i}},{lie:37}],7:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,n=t("pako"),s=t("./utils"),a=t("./stream/GenericWorker"),o=i?"uint8array":"array";function h(t,e){a.call(this,"FlateWorker/"+t),this._pako=null,this._pakoAction=t,this._pakoOptions=e,this.meta={}}r.magic="\b\0",s.inherits(h,a),h.prototype.processChunk=function(t){this.meta=t.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,t.data),!1)},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},h.prototype._createPako=function(){this._pako=new n[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var e=this;this._pako.onData=function(t){e.push({data:t,meta:e.meta})}},r.compressWorker=function(t){return new h("Deflate",t)},r.uncompressWorker=function(){return new h("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(t,e,r){"use strict";function A(t,e){var r,i="";for(r=0;r<e;r++)i+=String.fromCharCode(255&t),t>>>=8;return i}function i(t,e,r,i,n,s){var a,o,h=t.file,u=t.compression,l=s!==O.utf8encode,f=I.transformTo("string",s(h.name)),d=I.transformTo("string",O.utf8encode(h.name)),c=h.comment,p=I.transformTo("string",s(c)),m=I.transformTo("string",O.utf8encode(c)),_=d.length!==h.name.length,g=m.length!==c.length,b="",v="",y="",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};e&&!r||(x.crc32=t.crc32,x.compressedSize=t.compressedSize,x.uncompressedSize=t.uncompressedSize);var S=0;e&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),"UNIX"===n?(C=798,z|=function(t,e){var r=t;return t||(r=e?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(t){return 63&(t||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+d,b+="up"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+="uc"+A(y.length,2)+y);var E="";return E+="\n\0",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+"\0\0\0\0"+A(z,4)+A(i,4)+f+b+p}}var I=t("../utils"),n=t("../stream/GenericWorker"),O=t("../utf8"),B=t("../crc32"),R=t("../signature");function s(t,e,r,i){n.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=e,this.zipPlatform=r,this.encodeFileName=i,this.streamFiles=t,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}I.inherits(s,n),s.prototype.push=function(t){var e=t.meta.percent||0,r=this.entriesCount,i=this._sources.length;this.accumulate?this.contentBuffer.push(t):(this.bytesWritten+=t.data.length,n.prototype.push.call(this,{data:t.data,meta:{currentFile:this.currentFile,percent:r?(e+100*(r-i-1))/r:100}}))},s.prototype.openedSource=function(t){this.currentSourceOffset=this.bytesWritten,this.currentFile=t.file.name;var e=this.streamFiles&&!t.file.dir;if(e){var r=i(t,e,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},s.prototype.closedSource=function(t){this.accumulate=!1;var e=this.streamFiles&&!t.file.dir,r=i(t,e,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),e)this.push({data:function(t){return R.DATA_DESCRIPTOR+A(t.crc32,4)+A(t.compressedSize,4)+A(t.uncompressedSize,4)}(t),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},s.prototype.flush=function(){for(var t=this.bytesWritten,e=0;e<this.dirRecords.length;e++)this.push({data:this.dirRecords[e],meta:{percent:100}});var r=this.bytesWritten-t,i=function(t,e,r,i,n){var s=I.transformTo("string",n(i));return R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+A(t,2)+A(t,2)+A(e,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,t,this.zipComment,this.encodeFileName);this.push({data:i,meta:{percent:100}})},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},s.prototype.registerPrevious=function(t){this._sources.push(t);var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.closedSource(e.previous.streamInfo),e._sources.length?e.prepareNextSource():e.end()}),t.on("error",function(t){e.error(t)}),this},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(t){var e=this._sources;if(!n.prototype.error.call(this,t))return!1;for(var r=0;r<e.length;r++)try{e[r].error(t)}catch(t){}return!0},s.prototype.lock=function(){n.prototype.lock.call(this);for(var t=this._sources,e=0;e<t.length;e++)t[e].lock()},e.exports=s},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(t,e,r){"use strict";var u=t("../compressions"),i=t("./ZipFileWorker");r.generateWorker=function(t,a,e){var o=new i(a.streamFiles,e,a.platform,a.encodeFileName),h=0;try{t.forEach(function(t,e){h++;var r=function(t,e){var r=t||e,i=u[r];if(!i)throw new Error(r+" is not a valid compression method !");return i}(e.options.compression,a.compression),i=e.options.compressionOptions||a.compressionOptions||{},n=e.dir,s=e.date;e._compressWorker(r,i).withStreamInfo("file",{name:t,dir:n,date:s,comment:e.comment||"",unixPermissions:e.unixPermissions,dosPermissions:e.dosPermissions}).pipe(o)}),o.entriesCount=h}catch(t){o.error(t)}return o}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(t,e,r){"use strict";function i(){if(!(this instanceof i))return new i;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var t=new i;for(var e in this)"function"!=typeof this[e]&&(t[e]=this[e]);return t}}(i.prototype=t("./object")).loadAsync=t("./load"),i.support=t("./support"),i.defaults=t("./defaults"),i.version="3.7.1",i.loadAsync=function(t,e){return(new i).loadAsync(t,e)},i.external=t("./external"),e.exports=i},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(t,e,r){"use strict";var i=t("./utils"),n=t("./external"),o=t("./utf8"),h=t("./zipEntries"),s=t("./stream/Crc32Probe"),u=t("./nodejsUtils");function l(i){return new n.Promise(function(t,e){var r=i.decompressed.getContentWorker().pipe(new s);r.on("error",function(t){e(t)}).on("end",function(){r.streamInfo.crc32!==i.decompressed.crc32?e(new Error("Corrupted zip : CRC32 mismatch")):t()}).resume()})}e.exports=function(t,s){var a=this;return s=i.extend(s||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),u.isNode&&u.isStream(t)?n.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):i.prepareContent("the loaded zip file",t,!0,s.optimizedBinaryString,s.base64).then(function(t){var e=new h(s);return e.load(t),e}).then(function(t){var e=[n.Promise.resolve(t)],r=t.files;if(s.checkCRC32)for(var i=0;i<r.length;i++)e.push(l(r[i]));return n.Promise.all(e)}).then(function(t){for(var e=t.shift(),r=e.files,i=0;i<r.length;i++){var n=r[i];a.file(n.fileNameStr,n.decompressed,{binary:!0,optimizedBinaryString:!0,date:n.date,dir:n.dir,comment:n.fileCommentStr.length?n.fileCommentStr:null,unixPermissions:n.unixPermissions,dosPermissions:n.dosPermissions,createFolders:s.createFolders})}return e.zipComment.length&&(a.comment=e.zipComment),a})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../stream/GenericWorker");function s(t,e){n.call(this,"Nodejs stream input adapter for "+t),this._upstreamEnded=!1,this._bindStream(e)}i.inherits(s,n),s.prototype._bindStream=function(t){var e=this;(this._stream=t).pause(),t.on("data",function(t){e.push({data:t,meta:{percent:0}})}).on("error",function(t){e.isPaused?this.generatedError=t:e.error(t)}).on("end",function(){e.isPaused?e._upstreamEnded=!0:e.end()})},s.prototype.pause=function(){return!!n.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},e.exports=s},{"../stream/GenericWorker":28,"../utils":32}],13:[function(t,e,r){"use strict";var n=t("readable-stream").Readable;function i(t,e,r){n.call(this,e),this._helper=t;var i=this;t.on("data",function(t,e){i.push(t)||i._helper.pause(),r&&r(e)}).on("error",function(t){i.emit("error",t)}).on("end",function(){i.push(null)})}t("../utils").inherits(i,n),i.prototype._read=function(){this._helper.resume()},e.exports=i},{"../utils":32,"readable-stream":16}],14:[function(t,e,r){"use strict";e.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(t,e){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(t,e);if("number"==typeof t)throw new Error('The "data" argument must not be a number');return new Buffer(t,e)},allocBuffer:function(t){if(Buffer.alloc)return Buffer.alloc(t);var e=new Buffer(t);return e.fill(0),e},isBuffer:function(t){return Buffer.isBuffer(t)},isStream:function(t){return t&&"function"==typeof t.on&&"function"==typeof t.pause&&"function"==typeof t.resume}}},{}],15:[function(t,e,r){"use strict";function s(t,e,r){var i,n=u.getTypeOf(e),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(t=g(t)),s.createFolders&&(i=_(t))&&b.call(this,i,!0);var a="string"===n&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(e instanceof d&&0===e.uncompressedSize||s.dir||!e||0===e.length)&&(s.base64=!1,s.binary=!0,e="",s.compression="STORE",n="string");var o=null;o=e instanceof d||e instanceof l?e:p.isNode&&p.isStream(e)?new m(t,e):u.prepareContent(t,e,s.binary,s.optimizedBinaryString,s.base64);var h=new c(t,o,s);this.files[t]=h}var n=t("./utf8"),u=t("./utils"),l=t("./stream/GenericWorker"),a=t("./stream/StreamHelper"),f=t("./defaults"),d=t("./compressedObject"),c=t("./zipObject"),o=t("./generate"),p=t("./nodejsUtils"),m=t("./nodejs/NodejsStreamInputAdapter"),_=function(t){"/"===t.slice(-1)&&(t=t.substring(0,t.length-1));var e=t.lastIndexOf("/");return 0<e?t.substring(0,e):""},g=function(t){return"/"!==t.slice(-1)&&(t+="/"),t},b=function(t,e){return e=void 0!==e?e:f.createFolders,t=g(t),this.files[t]||s.call(this,t,null,{dir:!0,createFolders:e}),this.files[t]};function h(t){return"[object RegExp]"===Object.prototype.toString.call(t)}var i={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(t){var e,r,i;for(e in this.files)i=this.files[e],(r=e.slice(this.root.length,e.length))&&e.slice(0,this.root.length)===this.root&&t(r,i)},filter:function(r){var i=[];return this.forEach(function(t,e){r(t,e)&&i.push(e)}),i},file:function(t,e,r){if(1!==arguments.length)return t=this.root+t,s.call(this,t,e,r),this;if(h(t)){var i=t;return this.filter(function(t,e){return!e.dir&&i.test(t)})}var n=this.files[this.root+t];return n&&!n.dir?n:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(t,e){return e.dir&&r.test(t)});var t=this.root+r,e=b.call(this,t),i=this.clone();return i.root=e.name,i},remove:function(r){r=this.root+r;var t=this.files[r];if(t||("/"!==r.slice(-1)&&(r+="/"),t=this.files[r]),t&&!t.dir)delete this.files[r];else for(var e=this.filter(function(t,e){return e.name.slice(0,r.length)===r}),i=0;i<e.length;i++)delete this.files[e[i].name];return this},generate:function(t){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(t){var e,r={};try{if((r=u.extend(t||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:n.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");u.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var i=r.comment||this.comment||"";e=o.generateWorker(this,r,i)}catch(t){(e=new l("error")).error(t)}return new a(e,r.type||"string",r.mimeType)},generateAsync:function(t,e){return this.generateInternalStream(t).accumulate(e)},generateNodeStream:function(t,e){return(t=t||{}).type||(t.type="nodebuffer"),this.generateInternalStream(t).toNodejsStream(e)}};e.exports=i},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(t,e,r){e.exports=t("stream")},{stream:void 0}],17:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t);for(var e=0;e<this.data.length;e++)t[e]=255&t[e]}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data[this.zero+t]},n.prototype.lastIndexOfSignature=function(t){for(var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===e&&this.data[s+1]===r&&this.data[s+2]===i&&this.data[s+3]===n)return s-this.zero;return-1},n.prototype.readAndCheckSignature=function(t){var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.readData(4);return e===s[0]&&r===s[1]&&i===s[2]&&n===s[3]},n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return[];var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],18:[function(t,e,r){"use strict";var i=t("../utils");function n(t){this.data=t,this.length=t.length,this.index=0,this.zero=0}n.prototype={checkOffset:function(t){this.checkIndex(this.index+t)},checkIndex:function(t){if(this.length<this.zero+t||t<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+t+"). Corrupted zip ?")},setIndex:function(t){this.checkIndex(t),this.index=t},skip:function(t){this.setIndex(this.index+t)},byteAt:function(t){},readInt:function(t){var e,r=0;for(this.checkOffset(t),e=this.index+t-1;e>=this.index;e--)r=(r<<8)+this.byteAt(e);return this.index+=t,r},readString:function(t){return i.transformTo("string",this.readData(t))},readData:function(t){},lastIndexOfSignature:function(t){},readAndCheckSignature:function(t){},readDate:function(){var t=this.readInt(4);return new Date(Date.UTC(1980+(t>>25&127),(t>>21&15)-1,t>>16&31,t>>11&31,t>>5&63,(31&t)<<1))}},e.exports=n},{"../utils":32}],19:[function(t,e,r){"use strict";var i=t("./Uint8ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data.charCodeAt(this.zero+t)},n.prototype.lastIndexOfSignature=function(t){return this.data.lastIndexOf(t)-this.zero},n.prototype.readAndCheckSignature=function(t){return t===this.readData(4)},n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],21:[function(t,e,r){"use strict";var i=t("./ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return new Uint8Array(0);var e=this.data.subarray(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./ArrayReader":17}],22:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../support"),s=t("./ArrayReader"),a=t("./StringReader"),o=t("./NodeBufferReader"),h=t("./Uint8ArrayReader");e.exports=function(t){var e=i.getTypeOf(t);return i.checkSupport(e),"string"!==e||n.uint8array?"nodebuffer"===e?new o(t):n.uint8array?new h(i.transformTo("uint8array",t)):new s(i.transformTo("array",t)):new a(t)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(t,e,r){"use strict";r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b"},{}],24:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../utils");function s(t){i.call(this,"ConvertWorker to "+t),this.destType=t}n.inherits(s,i),s.prototype.processChunk=function(t){this.push({data:n.transformTo(this.destType,t.data),meta:t.meta})},e.exports=s},{"../utils":32,"./GenericWorker":28}],25:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../crc32");function s(){i.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}t("../utils").inherits(s,i),s.prototype.processChunk=function(t){this.streamInfo.crc32=n(t.data,this.streamInfo.crc32||0),this.push(t)},e.exports=s},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataLengthProbe for "+t),this.propName=t,this.withStreamInfo(t,0)}i.inherits(s,n),s.prototype.processChunk=function(t){if(t){var e=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=e+t.data.length}n.prototype.processChunk.call(this,t)},e.exports=s},{"../utils":32,"./GenericWorker":28}],27:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataWorker");var e=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,t.then(function(t){e.dataIsReady=!0,e.data=t,e.max=t&&t.length||0,e.type=i.getTypeOf(t),e.isPaused||e._tickAndRepeat()},function(t){e.error(t)})}i.inherits(s,n),s.prototype.cleanUp=function(){n.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,i.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(i.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var t=null,e=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":t=this.data.substring(this.index,e);break;case"uint8array":t=this.data.subarray(this.index,e);break;case"array":case"nodebuffer":t=this.data.slice(this.index,e)}return this.index=e,this.push({data:t,meta:{percent:this.max?this.index/this.max*100:0}})},e.exports=s},{"../utils":32,"./GenericWorker":28}],28:[function(t,e,r){"use strict";function i(t){this.name=t||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}i.prototype={push:function(t){this.emit("data",t)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(t){this.emit("error",t)}return!0},error:function(t){return!this.isFinished&&(this.isPaused?this.generatedError=t:(this.isFinished=!0,this.emit("error",t),this.previous&&this.previous.error(t),this.cleanUp()),!0)},on:function(t,e){return this._listeners[t].push(e),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(t,e){if(this._listeners[t])for(var r=0;r<this._listeners[t].length;r++)this._listeners[t][r].call(this,e)},pipe:function(t){return t.registerPrevious(this)},registerPrevious:function(t){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=t.streamInfo,this.mergeStreamInfo(),this.previous=t;var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.end()}),t.on("error",function(t){e.error(t)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var t=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),t=!0),this.previous&&this.previous.resume(),!t},flush:function(){},processChunk:function(t){this.push(t)},withStreamInfo:function(t,e){return this.extraStreamInfo[t]=e,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var t in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(t)&&(this.streamInfo[t]=this.extraStreamInfo[t])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var t="Worker "+this.name;return this.previous?this.previous+" -> "+t:t}},e.exports=i},{}],29:[function(t,e,r){"use strict";var h=t("../utils"),n=t("./ConvertWorker"),s=t("./GenericWorker"),u=t("../base64"),i=t("../support"),a=t("../external"),o=null;if(i.nodestream)try{o=t("../nodejs/NodejsStreamOutputAdapter")}catch(t){}function l(t,o){return new a.Promise(function(e,r){var i=[],n=t._internalType,s=t._outputType,a=t._mimeType;t.on("data",function(t,e){i.push(t),o&&o(e)}).on("error",function(t){i=[],r(t)}).on("end",function(){try{var t=function(t,e,r){switch(t){case"blob":return h.newBlob(h.transformTo("arraybuffer",e),r);case"base64":return u.encode(e);default:return h.transformTo(t,e)}}(s,function(t,e){var r,i=0,n=null,s=0;for(r=0;r<e.length;r++)s+=e[r].length;switch(t){case"string":return e.join("");case"array":return Array.prototype.concat.apply([],e);case"uint8array":for(n=new Uint8Array(s),r=0;r<e.length;r++)n.set(e[r],i),i+=e[r].length;return n;case"nodebuffer":return Buffer.concat(e);default:throw new Error("concat : unsupported type '"+t+"'")}}(n,i),a);e(t)}catch(t){r(t)}i=[]}).resume()})}function f(t,e,r){var i=e;switch(e){case"blob":case"arraybuffer":i="uint8array";break;case"base64":i="string"}try{this._internalType=i,this._outputType=e,this._mimeType=r,h.checkSupport(i),this._worker=t.pipe(new n(i)),t.lock()}catch(t){this._worker=new s("error"),this._worker.error(t)}}f.prototype={accumulate:function(t){return l(this,t)},on:function(t,e){var r=this;return"data"===t?this._worker.on(t,function(t){e.call(r,t.data,t.meta)}):this._worker.on(t,function(){h.delay(e,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(t){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},t)}},e.exports=f},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(t,e,r){"use strict";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else{var i=new ArrayBuffer(0);try{r.blob=0===new Blob([i],{type:"application/zip"}).size}catch(t){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);n.append(i),r.blob=0===n.getBlob("application/zip").size}catch(t){r.blob=!1}}}try{r.nodestream=!!t("readable-stream").Readable}catch(t){r.nodestream=!1}},{"readable-stream":16}],31:[function(t,e,s){"use strict";for(var o=t("./utils"),h=t("./support"),r=t("./nodejsUtils"),i=t("./stream/GenericWorker"),u=new Array(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;u[254]=u[254]=1;function a(){i.call(this,"utf-8 decode"),this.leftOver=null}function l(){i.call(this,"utf-8 encode")}s.utf8encode=function(t){return h.nodebuffer?r.newBufferFrom(t,"utf-8"):function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=h.uint8array?new Uint8Array(o):new Array(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e}(t)},s.utf8decode=function(t){return h.nodebuffer?o.transformTo("nodebuffer",t).toString("utf-8"):function(t){var e,r,i,n,s=t.length,a=new Array(2*s);for(e=r=0;e<s;)if((i=t[e++])<128)a[r++]=i;else if(4<(n=u[i]))a[r++]=65533,e+=n-1;else{for(i&=2===n?31:3===n?15:7;1<n&&e<s;)i=i<<6|63&t[e++],n--;1<n?a[r++]=65533:i<65536?a[r++]=i:(i-=65536,a[r++]=55296|i>>10&1023,a[r++]=56320|1023&i)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(t=o.transformTo(h.uint8array?"uint8array":"array",t))},o.inherits(a,i),a.prototype.processChunk=function(t){var e=o.transformTo(h.uint8array?"uint8array":"array",t.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=e;(e=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),e.set(r,this.leftOver.length)}else e=this.leftOver.concat(e);this.leftOver=null}var i=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}(e),n=e;i!==e.length&&(h.uint8array?(n=e.subarray(0,i),this.leftOver=e.subarray(i,e.length)):(n=e.slice(0,i),this.leftOver=e.slice(i,e.length))),this.push({data:s.utf8decode(n),meta:t.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(l,i),l.prototype.processChunk=function(t){this.push({data:s.utf8encode(t.data),meta:t.meta})},s.Utf8EncodeWorker=l},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(t,e,a){"use strict";var o=t("./support"),h=t("./base64"),r=t("./nodejsUtils"),i=t("set-immediate-shim"),u=t("./external");function n(t){return t}function l(t,e){for(var r=0;r<t.length;++r)e[r]=255&t.charCodeAt(r);return e}a.newBlob=function(e,r){a.checkSupport("blob");try{return new Blob([e],{type:r})}catch(t){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return i.append(e),i.getBlob(r)}catch(t){throw new Error("Bug : can't construct the Blob.")}}};var s={stringifyByChunk:function(t,e,r){var i=[],n=0,s=t.length;if(s<=r)return String.fromCharCode.apply(null,t);for(;n<s;)"array"===e||"nodebuffer"===e?i.push(String.fromCharCode.apply(null,t.slice(n,Math.min(n+r,s)))):i.push(String.fromCharCode.apply(null,t.subarray(n,Math.min(n+r,s)))),n+=r;return i.join("")},stringifyByChar:function(t){for(var e="",r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(t){return!1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(t){return!1}}()}};function f(t){var e=65536,r=a.getTypeOf(t),i=!0;if("uint8array"===r?i=s.applyCanBeUsed.uint8array:"nodebuffer"===r&&(i=s.applyCanBeUsed.nodebuffer),i)for(;1<e;)try{return s.stringifyByChunk(t,r,e)}catch(t){e=Math.floor(e/2)}return s.stringifyByChar(t)}function d(t,e){for(var r=0;r<t.length;r++)e[r]=t[r];return e}a.applyFromCharCode=f;var c={};c.string={string:n,array:function(t){return l(t,new Array(t.length))},arraybuffer:function(t){return c.string.uint8array(t).buffer},uint8array:function(t){return l(t,new Uint8Array(t.length))},nodebuffer:function(t){return l(t,r.allocBuffer(t.length))}},c.array={string:f,array:n,arraybuffer:function(t){return new Uint8Array(t).buffer},uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(t)}},c.arraybuffer={string:function(t){return f(new Uint8Array(t))},array:function(t){return d(new Uint8Array(t),new Array(t.byteLength))},arraybuffer:n,uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(new Uint8Array(t))}},c.uint8array={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return t.buffer},uint8array:n,nodebuffer:function(t){return r.newBufferFrom(t)}},c.nodebuffer={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return c.nodebuffer.uint8array(t).buffer},uint8array:function(t){return d(t,new Uint8Array(t.length))},nodebuffer:n},a.transformTo=function(t,e){if(e=e||"",!t)return e;a.checkSupport(t);var r=a.getTypeOf(e);return c[r][t](e)},a.getTypeOf=function(t){return"string"==typeof t?"string":"[object Array]"===Object.prototype.toString.call(t)?"array":o.nodebuffer&&r.isBuffer(t)?"nodebuffer":o.uint8array&&t instanceof Uint8Array?"uint8array":o.arraybuffer&&t instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(t){if(!o[t.toLowerCase()])throw new Error(t+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(t){var e,r,i="";for(r=0;r<(t||"").length;r++)i+="\\x"+((e=t.charCodeAt(r))<16?"0":"")+e.toString(16).toUpperCase();return i},a.delay=function(t,e,r){i(function(){t.apply(r||null,e||[])})},a.inherits=function(t,e){function r(){}r.prototype=e.prototype,t.prototype=new r},a.extend=function(){var t,e,r={};for(t=0;t<arguments.length;t++)for(e in arguments[t])arguments[t].hasOwnProperty(e)&&void 0===r[e]&&(r[e]=arguments[t][e]);return r},a.prepareContent=function(r,t,i,n,s){return u.Promise.resolve(t).then(function(i){return o.blob&&(i instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(i)))&&"undefined"!=typeof FileReader?new u.Promise(function(e,r){var t=new FileReader;t.onload=function(t){e(t.target.result)},t.onerror=function(t){r(t.target.error)},t.readAsArrayBuffer(i)}):i}).then(function(t){var e=a.getTypeOf(t);return e?("arraybuffer"===e?t=a.transformTo("uint8array",t):"string"===e&&(s?t=h.decode(t):i&&!0!==n&&(t=function(t){return l(t,o.uint8array?new Uint8Array(t.length):new Array(t.length))}(t))),t):u.Promise.reject(new Error("Can't read the data of '"+r+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"set-immediate-shim":54}],33:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),n=t("./utils"),s=t("./signature"),a=t("./zipEntry"),o=(t("./utf8"),t("./support"));function h(t){this.files=[],this.loadOptions=t}h.prototype={checkSignature:function(t){if(!this.reader.readAndCheckSignature(t)){this.reader.index-=4;var e=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+n.pretty(e)+", expected "+n.pretty(t)+")")}},isSignature:function(t,e){var r=this.reader.index;this.reader.setIndex(t);var i=this.reader.readString(4)===e;return this.reader.setIndex(r),i},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var t=this.reader.readData(this.zipCommentLength),e=o.uint8array?"uint8array":"array",r=n.transformTo(e,t);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var t,e,r,i=this.zip64EndOfCentralSize-44;0<i;)t=this.reader.readInt(2),e=this.reader.readInt(4),r=this.reader.readData(e),this.zip64ExtensibleData[t]={id:t,length:e,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var t,e;for(t=0;t<this.files.length;t++)e=this.files[t],this.reader.setIndex(e.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),e.readLocalPart(this.reader),e.handleUTF8(),e.processAttributes()},readCentralDir:function(){var t;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(t=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(t);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var t=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(t<0)throw!this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(t);var e=t;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===n.MAX_VALUE_16BITS||this.diskWithCentralDirStart===n.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===n.MAX_VALUE_16BITS||this.centralDirRecords===n.MAX_VALUE_16BITS||this.centralDirSize===n.MAX_VALUE_32BITS||this.centralDirOffset===n.MAX_VALUE_32BITS){if(this.zip64=!0,(t=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(t),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var i=e-r;if(0<i)this.isSignature(e,s.CENTRAL_FILE_HEADER)||(this.reader.zero=i);else if(i<0)throw new Error("Corrupted zip: missing "+Math.abs(i)+" bytes.")},prepareReader:function(t){this.reader=i(t)},load:function(t){this.prepareReader(t),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},e.exports=h},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),s=t("./utils"),n=t("./compressedObject"),a=t("./crc32"),o=t("./utf8"),h=t("./compressions"),u=t("./support");function l(t,e){this.options=t,this.loadOptions=e}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(t){var e,r;if(t.skip(22),this.fileNameLength=t.readInt(2),r=t.readInt(2),this.fileName=t.readData(this.fileNameLength),t.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(e=function(t){for(var e in h)if(h.hasOwnProperty(e)&&h[e].magic===t)return h[e];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new n(this.compressedSize,this.uncompressedSize,this.crc32,e,t.readData(this.compressedSize))},readCentralPart:function(t){this.versionMadeBy=t.readInt(2),t.skip(2),this.bitFlag=t.readInt(2),this.compressionMethod=t.readString(2),this.date=t.readDate(),this.crc32=t.readInt(4),this.compressedSize=t.readInt(4),this.uncompressedSize=t.readInt(4);var e=t.readInt(2);if(this.extraFieldsLength=t.readInt(2),this.fileCommentLength=t.readInt(2),this.diskNumberStart=t.readInt(2),this.internalFileAttributes=t.readInt(2),this.externalFileAttributes=t.readInt(4),this.localHeaderOffset=t.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");t.skip(e),this.readExtraFields(t),this.parseZIP64ExtraField(t),this.fileComment=t.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var t=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==t&&(this.dosPermissions=63&this.externalFileAttributes),3==t&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(t){if(this.extraFields[1]){var e=i(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(t){var e,r,i,n=t.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});t.index+4<n;)e=t.readInt(2),r=t.readInt(2),i=t.readData(r),this.extraFields[e]={id:e,length:r,value:i};t.setIndex(n)},handleUTF8:function(){var t=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var e=this.findExtraFieldUnicodePath();if(null!==e)this.fileNameStr=e;else{var r=s.transformTo(t,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var i=this.findExtraFieldUnicodeComment();if(null!==i)this.fileCommentStr=i;else{var n=s.transformTo(t,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(n)}}},findExtraFieldUnicodePath:function(){var t=this.extraFields[28789];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileName)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null},findExtraFieldUnicodeComment:function(){var t=this.extraFields[25461];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileComment)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null}},e.exports=l},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(t,e,r){"use strict";function i(t,e,r){this.name=t,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=e,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=t("./stream/StreamHelper"),n=t("./stream/DataWorker"),a=t("./utf8"),o=t("./compressedObject"),h=t("./stream/GenericWorker");i.prototype={internalStream:function(t){var e=null,r="string";try{if(!t)throw new Error("No output type specified.");var i="string"===(r=t.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),e=this._decompressWorker();var n=!this._dataBinary;n&&!i&&(e=e.pipe(new a.Utf8EncodeWorker)),!n&&i&&(e=e.pipe(new a.Utf8DecodeWorker))}catch(t){(e=new h("error")).error(t)}return new s(e,r,"")},async:function(t,e){return this.internalStream(t).accumulate(e)},nodeStream:function(t,e){return this.internalStream(t||"nodebuffer").toNodejsStream(e)},_compressWorker:function(t,e){if(this._data instanceof o&&this._data.compression.magic===t.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,t,e)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new n(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],l=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},f=0;f<u.length;f++)i.prototype[u[f]]=l;e.exports=i},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(t,l,e){(function(e){"use strict";var r,i,t=e.MutationObserver||e.WebKitMutationObserver;if(t){var n=0,s=new t(u),a=e.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=n=++n%2}}else if(e.setImmediate||void 0===e.MessageChannel)r="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){u(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(u,0)};else{var o=new e.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0)}}var h=[];function u(){var t,e;i=!0;for(var r=h.length;r;){for(e=h,h=[],t=-1;++t<r;)e[t]();r=h.length}i=!1}l.exports=function(t){1!==h.push(t)||i||r()}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],37:[function(t,e,r){"use strict";var n=t("immediate");function u(){}var l={},s=["REJECTED"],a=["FULFILLED"],i=["PENDING"];function o(t){if("function"!=typeof t)throw new TypeError("resolver must be a function");this.state=i,this.queue=[],this.outcome=void 0,t!==u&&c(this,t)}function h(t,e,r){this.promise=t,"function"==typeof e&&(this.onFulfilled=e,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function f(e,r,i){n(function(){var t;try{t=r(i)}catch(t){return l.reject(e,t)}t===e?l.reject(e,new TypeError("Cannot resolve promise with itself")):l.resolve(e,t)})}function d(t){var e=t&&t.then;if(t&&("object"==typeof t||"function"==typeof t)&&"function"==typeof e)return function(){e.apply(t,arguments)}}function c(e,t){var r=!1;function i(t){r||(r=!0,l.reject(e,t))}function n(t){r||(r=!0,l.resolve(e,t))}var s=p(function(){t(n,i)});"error"===s.status&&i(s.value)}function p(t,e){var r={};try{r.value=t(e),r.status="success"}catch(t){r.status="error",r.value=t}return r}(e.exports=o).prototype.finally=function(e){if("function"!=typeof e)return this;var r=this.constructor;return this.then(function(t){return r.resolve(e()).then(function(){return t})},function(t){return r.resolve(e()).then(function(){throw t})})},o.prototype.catch=function(t){return this.then(null,t)},o.prototype.then=function(t,e){if("function"!=typeof t&&this.state===a||"function"!=typeof e&&this.state===s)return this;var r=new this.constructor(u);this.state!==i?f(r,this.state===a?t:e,this.outcome):this.queue.push(new h(r,t,e));return r},h.prototype.callFulfilled=function(t){l.resolve(this.promise,t)},h.prototype.otherCallFulfilled=function(t){f(this.promise,this.onFulfilled,t)},h.prototype.callRejected=function(t){l.reject(this.promise,t)},h.prototype.otherCallRejected=function(t){f(this.promise,this.onRejected,t)},l.resolve=function(t,e){var r=p(d,e);if("error"===r.status)return l.reject(t,r.value);var i=r.value;if(i)c(t,i);else{t.state=a,t.outcome=e;for(var n=-1,s=t.queue.length;++n<s;)t.queue[n].callFulfilled(e)}return t},l.reject=function(t,e){t.state=s,t.outcome=e;for(var r=-1,i=t.queue.length;++r<i;)t.queue[r].callRejected(e);return t},o.resolve=function(t){if(t instanceof this)return t;return l.resolve(new this(u),t)},o.reject=function(t){var e=new this(u);return l.reject(e,t)},o.all=function(t){var r=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var i=t.length,n=!1;if(!i)return this.resolve([]);var s=new Array(i),a=0,e=-1,o=new this(u);for(;++e<i;)h(t[e],e);return o;function h(t,e){r.resolve(t).then(function(t){s[e]=t,++a!==i||n||(n=!0,l.resolve(o,s))},function(t){n||(n=!0,l.reject(o,t))})}},o.race=function(t){var e=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var r=t.length,i=!1;if(!r)return this.resolve([]);var n=-1,s=new this(u);for(;++n<r;)a=t[n],e.resolve(a).then(function(t){i||(i=!0,l.resolve(s,t))},function(t){i||(i=!0,l.reject(s,t))});var a;return s}},{immediate:36}],38:[function(t,e,r){"use strict";var i={};(0,t("./lib/utils/common").assign)(i,t("./lib/deflate"),t("./lib/inflate"),t("./lib/zlib/constants")),e.exports=i},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(t,e,r){"use strict";var a=t("./zlib/deflate"),o=t("./utils/common"),h=t("./utils/strings"),n=t("./zlib/messages"),s=t("./zlib/zstream"),u=Object.prototype.toString,l=0,f=-1,d=0,c=8;function p(t){if(!(this instanceof p))return new p(t);this.options=o.assign({level:f,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:""},t||{});var e=this.options;e.raw&&0<e.windowBits?e.windowBits=-e.windowBits:e.gzip&&0<e.windowBits&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(r!==l)throw new Error(n[r]);if(e.header&&a.deflateSetHeader(this.strm,e.header),e.dictionary){var i;if(i="string"==typeof e.dictionary?h.string2buf(e.dictionary):"[object ArrayBuffer]"===u.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,(r=a.deflateSetDictionary(this.strm,i))!==l)throw new Error(n[r]);this._dict_set=!0}}function i(t,e){var r=new p(e);if(r.push(t,!0),r.err)throw r.msg||n[r.err];return r.result}p.prototype.push=function(t,e){var r,i,n=this.strm,s=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:!0===e?4:0,"string"==typeof t?n.input=h.string2buf(t):"[object ArrayBuffer]"===u.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new o.Buf8(s),n.next_out=0,n.avail_out=s),1!==(r=a.deflate(n,i))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==n.avail_out&&(0!==n.avail_in||4!==i&&2!==i)||("string"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(n.output,n.next_out))):this.onData(o.shrinkBuf(n.output,n.next_out)))}while((0<n.avail_in||0===n.avail_out)&&1!==r);return 4===i?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==i||(this.onEnd(l),!(n.avail_out=0))},p.prototype.onData=function(t){this.chunks.push(t)},p.prototype.onEnd=function(t){t===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Deflate=p,r.deflate=i,r.deflateRaw=function(t,e){return(e=e||{}).raw=!0,i(t,e)},r.gzip=function(t,e){return(e=e||{}).gzip=!0,i(t,e)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(t,e,r){"use strict";var d=t("./zlib/inflate"),c=t("./utils/common"),p=t("./utils/strings"),m=t("./zlib/constants"),i=t("./zlib/messages"),n=t("./zlib/zstream"),s=t("./zlib/gzheader"),_=Object.prototype.toString;function a(t){if(!(this instanceof a))return new a(t);this.options=c.assign({chunkSize:16384,windowBits:0,to:""},t||{});var e=this.options;e.raw&&0<=e.windowBits&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(0<=e.windowBits&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),15<e.windowBits&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new n,this.strm.avail_out=0;var r=d.inflateInit2(this.strm,e.windowBits);if(r!==m.Z_OK)throw new Error(i[r]);this.header=new s,d.inflateGetHeader(this.strm,this.header)}function o(t,e){var r=new a(e);if(r.push(t,!0),r.err)throw r.msg||i[r.err];return r.result}a.prototype.push=function(t,e){var r,i,n,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return!1;i=e===~~e?e:!0===e?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof t?h.input=p.binstring2buf(t):"[object ArrayBuffer]"===_.call(t)?h.input=new Uint8Array(t):h.input=t,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new c.Buf8(u),h.next_out=0,h.avail_out=u),(r=d.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o="string"==typeof l?p.string2buf(l):"[object ArrayBuffer]"===_.call(l)?new Uint8Array(l):l,r=d.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||i!==m.Z_FINISH&&i!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(n=p.utf8border(h.output,h.next_out),s=h.next_out-n,a=p.buf2string(h.output,n),h.next_out=s,h.avail_out=u-s,s&&c.arraySet(h.output,h.output,n,s,0),this.onData(a)):this.onData(c.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0)}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(i=m.Z_FINISH),i===m.Z_FINISH?(r=d.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):i!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(t){this.chunks.push(t)},a.prototype.onEnd=function(t){t===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=c.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(t,e){return(e=e||{}).raw=!0,o(t,e)},r.ungzip=o},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var r=e.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var i in r)r.hasOwnProperty(i)&&(t[i]=r[i])}}return t},r.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,r,i,n){if(e.subarray&&t.subarray)t.set(e.subarray(r,r+i),n);else for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){var e,r,i,n,s,a;for(e=i=0,r=t.length;e<r;e++)i+=t[e].length;for(a=new Uint8Array(i),e=n=0,r=t.length;e<r;e++)s=t[e],a.set(s,n),n+=s.length;return a}},s={arraySet:function(t,e,r,i,n){for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){return[].concat.apply([],t)}};r.setTyped=function(t){t?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,n)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(i)},{}],42:[function(t,e,r){"use strict";var h=t("./common"),n=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){n=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var u=new h.Buf8(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;function l(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&n))return String.fromCharCode.apply(null,h.shrinkBuf(t,e));for(var r="",i=0;i<e;i++)r+=String.fromCharCode(t[i]);return r}u[254]=u[254]=1,r.string2buf=function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=new h.Buf8(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e},r.buf2binstring=function(t){return l(t,t.length)},r.binstring2buf=function(t){for(var e=new h.Buf8(t.length),r=0,i=e.length;r<i;r++)e[r]=t.charCodeAt(r);return e},r.buf2string=function(t,e){var r,i,n,s,a=e||t.length,o=new Array(2*a);for(r=i=0;r<a;)if((n=t[r++])<128)o[i++]=n;else if(4<(s=u[n]))o[i++]=65533,r+=s-1;else{for(n&=2===s?31:3===s?15:7;1<s&&r<a;)n=n<<6|63&t[r++],s--;1<s?o[i++]=65533:n<65536?o[i++]=n:(n-=65536,o[i++]=55296|n>>10&1023,o[i++]=56320|1023&n)}return l(o,i)},r.utf8border=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}},{"./common":41}],43:[function(t,e,r){"use strict";e.exports=function(t,e,r,i){for(var n=65535&t|0,s=t>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(n=n+e[i++]|0)|0,--a;);n%=65521,s%=65521}return n|s<<16|0}},{}],44:[function(t,e,r){"use strict";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(t,e,r){"use strict";var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}},{}],46:[function(t,e,r){"use strict";var h,d=t("../utils/common"),u=t("./trees"),c=t("./adler32"),p=t("./crc32"),i=t("./messages"),l=0,f=4,m=0,_=-2,g=-1,b=4,n=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(t,e){return t.msg=i[e],e}function T(t){return(t<<1)-(4<t?9:0)}function D(t){for(var e=t.length;0<=--e;)t[e]=0}function F(t){var e=t.state,r=e.pending;r>t.avail_out&&(r=t.avail_out),0!==r&&(d.arraySet(t.output,e.pending_buf,e.pending_out,r,t.next_out),t.next_out+=r,e.pending_out+=r,t.total_out+=r,t.avail_out-=r,e.pending-=r,0===e.pending&&(e.pending_out=0))}function N(t,e){u._tr_flush_block(t,0<=t.block_start?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,F(t.strm)}function U(t,e){t.pending_buf[t.pending++]=e}function P(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function L(t,e){var r,i,n=t.max_chain_length,s=t.strstart,a=t.prev_length,o=t.nice_match,h=t.strstart>t.w_size-z?t.strstart-(t.w_size-z):0,u=t.window,l=t.w_mask,f=t.prev,d=t.strstart+S,c=u[s+a-1],p=u[s+a];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(u[(r=e)+a]===p&&u[r+a-1]===c&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<d);if(i=S-(d-s),s=d-S,a<i){if(t.match_start=e,o<=(a=i))break;c=u[s+a-1],p=u[s+a]}}}while((e=f[e&l])>h&&0!=--n);return a<=t.lookahead?a:t.lookahead}function j(t){var e,r,i,n,s,a,o,h,u,l,f=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=f+(f-z)){for(d.arraySet(t.window,t.window,f,f,0),t.match_start-=f,t.strstart-=f,t.block_start-=f,e=r=t.hash_size;i=t.head[--e],t.head[e]=f<=i?i-f:0,--r;);for(e=r=f;i=t.prev[--e],t.prev[e]=f<=i?i-f:0,--r;);n+=f}if(0===t.strm.avail_in)break;if(a=t.strm,o=t.window,h=t.strstart+t.lookahead,u=n,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,d.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=c(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),t.lookahead+=r,t.lookahead+t.insert>=x)for(s=t.strstart-t.insert,t.ins_h=t.window[s],t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+x-1])&t.hash_mask,t.prev[s&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=s,s++,t.insert--,!(t.lookahead+t.insert<x)););}while(t.lookahead<z&&0!==t.strm.avail_in)}function Z(t,e){for(var r,i;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==r&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r)),t.match_length>=x)if(i=u._tr_tally(t,t.strstart-t.match_start,t.match_length-x),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=x){for(t.match_length--;t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart,0!=--t.match_length;);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function W(t,e){for(var r,i,n;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=x-1,0!==r&&t.prev_length<t.max_lazy_match&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r),t.match_length<=5&&(1===t.strategy||t.match_length===x&&4096<t.strstart-t.match_start)&&(t.match_length=x-1)),t.prev_length>=x&&t.match_length<=t.prev_length){for(n=t.strstart+t.lookahead-x,i=u._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-x),t.lookahead-=t.prev_length-1,t.prev_length-=2;++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!=--t.prev_length;);if(t.match_available=0,t.match_length=x-1,t.strstart++,i&&(N(t,!1),0===t.strm.avail_out))return A}else if(t.match_available){if((i=u._tr_tally(t,0,t.window[t.strstart-1]))&&N(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return A}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=u._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function M(t,e,r,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=r,this.max_chain=i,this.func=n}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*w),this.dyn_dtree=new d.Buf16(2*(2*a+1)),this.bl_tree=new d.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(k+1),this.heap=new d.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function G(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=n,(e=t.state).pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?C:E,t.adler=2===e.wrap?0:1,e.last_flush=l,u._tr_init(e),m):R(t,_)}function K(t){var e=G(t);return e===m&&function(t){t.window_size=2*t.w_size,D(t.head),t.max_lazy_match=h[t.level].max_lazy,t.good_match=h[t.level].good_length,t.nice_match=h[t.level].nice_length,t.max_chain_length=h[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=x-1,t.match_available=0,t.ins_h=0}(t.state),e}function Y(t,e,r,i,n,s){if(!t)return _;var a=1;if(e===g&&(e=6),i<0?(a=0,i=-i):15<i&&(a=2,i-=16),n<1||y<n||r!==v||i<8||15<i||e<0||9<e||s<0||b<s)return R(t,_);8===i&&(i=9);var o=new H;return(t.state=o).strm=t,o.wrap=a,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new d.Buf8(2*o.w_size),o.head=new d.Buf16(o.hash_size),o.prev=new d.Buf16(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new d.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=e,o.strategy=s,o.method=r,K(t)}h=[new M(0,0,0,0,function(t,e){var r=65535;for(r>t.pending_buf_size-5&&(r=t.pending_buf_size-5);;){if(t.lookahead<=1){if(j(t),0===t.lookahead&&e===l)return A;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+r;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,N(t,!1),0===t.strm.avail_out))return A;if(t.strstart-t.block_start>=t.w_size-z&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):(t.strstart>t.block_start&&(N(t,!1),t.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(t,e){return Y(t,e,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(t,e){return t&&t.state?2!==t.state.wrap?_:(t.state.gzhead=e,m):_},r.deflate=function(t,e){var r,i,n,s;if(!t||!t.state||5<e||e<0)return t?R(t,_):_;if(i=t.state,!t.output||!t.input&&0!==t.avail_in||666===i.status&&e!==f)return R(t,0===t.avail_out?-5:_);if(i.strm=t,r=i.last_flush,i.last_flush=e,i.status===C)if(2===i.wrap)t.adler=0,U(i,31),U(i,139),U(i,8),i.gzhead?(U(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),U(i,255&i.gzhead.time),U(i,i.gzhead.time>>8&255),U(i,i.gzhead.time>>16&255),U(i,i.gzhead.time>>24&255),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(U(i,255&i.gzhead.extra.length),U(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(t.adler=p(t.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=69):(U(i,0),U(i,0),U(i,0),U(i,0),U(i,0),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,3),i.status=E);else{var a=v+(i.w_bits-8<<4)<<8;a|=(2<=i.strategy||i.level<2?0:i.level<6?1:6===i.level?2:3)<<6,0!==i.strstart&&(a|=32),a+=31-a%31,i.status=E,P(i,a),0!==i.strstart&&(P(i,t.adler>>>16),P(i,65535&t.adler)),t.adler=1}if(69===i.status)if(i.gzhead.extra){for(n=i.pending;i.gzindex<(65535&i.gzhead.extra.length)&&(i.pending!==i.pending_buf_size||(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending!==i.pending_buf_size));)U(i,255&i.gzhead.extra[i.gzindex]),i.gzindex++;i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=73)}else i.status=73;if(73===i.status)if(i.gzhead.name){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.gzindex=0,i.status=91)}else i.status=91;if(91===i.status)if(i.gzhead.comment){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.status=103)}else i.status=103;if(103===i.status&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&F(t),i.pending+2<=i.pending_buf_size&&(U(i,255&t.adler),U(i,t.adler>>8&255),t.adler=0,i.status=E)):i.status=E),0!==i.pending){if(F(t),0===t.avail_out)return i.last_flush=-1,m}else if(0===t.avail_in&&T(e)<=T(r)&&e!==f)return R(t,-5);if(666===i.status&&0!==t.avail_in)return R(t,-5);if(0!==t.avail_in||0!==i.lookahead||e!==l&&666!==i.status){var o=2===i.strategy?function(t,e){for(var r;;){if(0===t.lookahead&&(j(t),0===t.lookahead)){if(e===l)return A;break}if(t.match_length=0,r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):3===i.strategy?function(t,e){for(var r,i,n,s,a=t.window;;){if(t.lookahead<=S){if(j(t),t.lookahead<=S&&e===l)return A;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=x&&0<t.strstart&&(i=a[n=t.strstart-1])===a[++n]&&i===a[++n]&&i===a[++n]){s=t.strstart+S;do{}while(i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&n<s);t.match_length=S-(s-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=x?(r=u._tr_tally(t,1,t.match_length-x),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):h[i.level].func(i,e);if(o!==O&&o!==B||(i.status=666),o===A||o===O)return 0===t.avail_out&&(i.last_flush=-1),m;if(o===I&&(1===e?u._tr_align(i):5!==e&&(u._tr_stored_block(i,0,0,!1),3===e&&(D(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),F(t),0===t.avail_out))return i.last_flush=-1,m}return e!==f?m:i.wrap<=0?1:(2===i.wrap?(U(i,255&t.adler),U(i,t.adler>>8&255),U(i,t.adler>>16&255),U(i,t.adler>>24&255),U(i,255&t.total_in),U(i,t.total_in>>8&255),U(i,t.total_in>>16&255),U(i,t.total_in>>24&255)):(P(i,t.adler>>>16),P(i,65535&t.adler)),F(t),0<i.wrap&&(i.wrap=-i.wrap),0!==i.pending?m:1)},r.deflateEnd=function(t){var e;return t&&t.state?(e=t.state.status)!==C&&69!==e&&73!==e&&91!==e&&103!==e&&e!==E&&666!==e?R(t,_):(t.state=null,e===E?R(t,-3):m):_},r.deflateSetDictionary=function(t,e){var r,i,n,s,a,o,h,u,l=e.length;if(!t||!t.state)return _;if(2===(s=(r=t.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(t.adler=c(t.adler,e,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new d.Buf8(r.w_size),d.arraySet(u,e,l-r.w_size,r.w_size,0),e=u,l=r.w_size),a=t.avail_in,o=t.next_in,h=t.input,t.avail_in=l,t.next_in=0,t.input=e,j(r);r.lookahead>=x;){for(i=r.strstart,n=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[i+x-1])&r.hash_mask,r.prev[i&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=i,i++,--n;);r.strstart=i,r.lookahead=x-1,j(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,t.next_in=o,t.input=h,t.avail_in=a,r.wrap=s,m},r.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(t,e,r){"use strict";e.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(t,e,r){"use strict";e.exports=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C;r=t.state,i=t.next_in,z=t.input,n=i+(t.avail_in-5),s=t.next_out,C=t.output,a=s-(e-t.avail_out),o=s+(t.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,d=r.window,c=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;t:do{p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=m[c&g];e:for(;;){if(c>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else{if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(c&(1<<y)-1)];continue e}if(32&y){r.mode=12;break t}t.msg="invalid literal/length code",r.mode=30;break t}w=65535&v,(y&=15)&&(p<y&&(c+=z[i++]<<p,p+=8),w+=c&(1<<y)-1,c>>>=y,p-=y),p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=_[c&b];r:for(;;){if(c>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(c&(1<<y)-1)];continue r}t.msg="invalid distance code",r.mode=30;break t}if(k=65535&v,p<(y&=15)&&(c+=z[i++]<<p,(p+=8)<y&&(c+=z[i++]<<p,p+=8)),h<(k+=c&(1<<y)-1)){t.msg="invalid distance too far back",r.mode=30;break t}if(c>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){t.msg="invalid distance too far back",r.mode=30;break t}if(S=d,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=d[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=d[x++],--y;);x=s-k,S=C}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]))}else{for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]))}break}}break}}while(i<n&&s<o);i-=w=p>>3,c&=(1<<(p-=w<<3))-1,t.next_in=i,t.next_out=s,t.avail_in=i<n?n-i+5:5-(i-n),t.avail_out=s<o?o-s+257:257-(s-o),r.hold=c,r.bits=p}},{}],49:[function(t,e,r){"use strict";var I=t("../utils/common"),O=t("./adler32"),B=t("./crc32"),R=t("./inffast"),T=t("./inftrees"),D=1,F=2,N=0,U=-2,P=1,i=852,n=592;function L(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=P,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new I.Buf32(i),e.distcode=e.distdyn=new I.Buf32(n),e.sane=1,e.back=-1,N):U}function o(t){var e;return t&&t.state?((e=t.state).wsize=0,e.whave=0,e.wnext=0,a(t)):U}function h(t,e){var r,i;return t&&t.state?(i=t.state,e<0?(r=0,e=-e):(r=1+(e>>4),e<48&&(e&=15)),e&&(e<8||15<e)?U:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=r,i.wbits=e,o(t))):U}function u(t,e){var r,i;return t?(i=new s,(t.state=i).window=null,(r=h(t,e))!==N&&(t.state=null),r):U}var l,f,d=!0;function j(t){if(d){var e;for(l=new I.Buf32(512),f=new I.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(T(D,t.lens,0,288,l,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;T(F,t.lens,0,32,f,0,t.work,{bits:5}),d=!1}t.lencode=l,t.lenbits=9,t.distcode=f,t.distbits=5}function Z(t,e,r,i){var n,s=t.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),i>=s.wsize?(I.arraySet(s.window,e,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(i<(n=s.wsize-s.wnext)&&(n=i),I.arraySet(s.window,e,r-i,n,s.wnext),(i-=n)?(I.arraySet(s.window,e,r-i,i,0),s.wnext=i,s.whave=s.wsize):(s.wnext+=n,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=n))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(t){return u(t,15)},r.inflateInit2=u,r.inflate=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return U;12===(r=t.state).mode&&(r.mode=13),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,f=o,d=h,x=N;t:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){t.msg="incorrect header check",r.mode=30;break}if(8!=(15&u)){t.msg="unknown compression method",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){t.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,t.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.flags=u,8!=(255&r.flags)){t.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){t.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(c=r.length)&&(c=o),c&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,i,s,c,k)),512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,r.length-=c),r.length))break t;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(65535&r.check)){t.msg="header crc mismatch",r.mode=30;break}l=u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),t.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}t.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,2;t.adler=r.check=1,r.mode=12;case 12:if(5===e||6===e)break t;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==e)break;u>>>=2,l-=2;break t;case 2:r.mode=17;break;case 3:t.msg="invalid block type",r.mode=30}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if((65535&u)!=(u>>>16^65535)){t.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===e)break t;case 15:r.mode=16;case 16:if(c=r.length){if(o<c&&(c=o),h<c&&(c=h),0===c)break t;I.arraySet(n,i,s,c,a),o-=c,s+=c,h-=c,a+=c,r.length-=c;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){t.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else{if(16===b){for(z=_+2;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u>>>=_,l-=_,0===r.have){t.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],c=3+(3&u),u>>>=2,l-=2}else if(17===b){for(z=_+3;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=3+(7&(u>>>=_)),u>>>=3,l-=3}else{for(z=_+7;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=11+(127&(u>>>=_)),u>>>=7,l-=7}if(r.have+c>r.nlen+r.ndist){t.msg="invalid bit length repeat",r.mode=30;break}for(;c--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){t.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){t.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===e)break t;case 20:r.mode=21;case 21:if(6<=o&&258<=h){t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,R(t,d),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){t.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,64&g){t.msg="invalid distance code",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){t.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===h)break t;if(c=d-h,r.offset>c){if((c=r.offset-c)>r.whave&&r.sane){t.msg="invalid distance too far back",r.mode=30;break}p=c>r.wnext?(c-=r.wnext,r.wsize-c):r.wnext-c,c>r.length&&(c=r.length),m=r.window}else m=n,p=a-r.offset,c=r.length;for(h<c&&(c=h),h-=c,r.length-=c;n[a++]=m[p++],--c;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break t;n[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break t;o--,u|=i[s++]<<l,l+=8}if(d-=h,t.total_out+=d,r.total+=d,d&&(t.adler=r.check=r.flags?B(r.check,n,d,a-d):O(r.check,n,d,a-d)),d=h,(r.flags?u:L(u))!==r.check){t.msg="incorrect data check",r.mode=30;break}l=u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(4294967295&r.total)){t.msg="incorrect length check",r.mode=30;break}l=u=0}r.mode=29;case 29:x=1;break t;case 30:x=-3;break t;case 31:return-4;case 32:default:return U}return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,(r.wsize||d!==t.avail_out&&r.mode<30&&(r.mode<27||4!==e))&&Z(t,t.output,t.next_out,d-t.avail_out)?(r.mode=31,-4):(f-=t.avail_in,d-=t.avail_out,t.total_in+=f,t.total_out+=d,r.total+=d,r.wrap&&d&&(t.adler=r.check=r.flags?B(r.check,n,d,t.next_out-d):O(r.check,n,d,t.next_out-d)),t.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===d||4===e)&&x===N&&(x=-5),x)},r.inflateEnd=function(t){if(!t||!t.state)return U;var e=t.state;return e.window&&(e.window=null),t.state=null,N},r.inflateGetHeader=function(t,e){var r;return t&&t.state?0==(2&(r=t.state).wrap)?U:((r.head=e).done=!1,N):U},r.inflateSetDictionary=function(t,e){var r,i=e.length;return t&&t.state?0!==(r=t.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,e,i,0)!==r.check?-3:Z(t,e,i,i)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(t,e,r){"use strict";var D=t("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,r,i,n,s,a,o){var h,u,l,f,d,c,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<i;v++)O[e[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return n[s++]=20971520,n[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return-1;if(0<z&&(0===t||1!==w))return-1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<i;v++)0!==e[r+v]&&(a[B[e[r+v]]++]=v);if(c=0===t?(A=R=a,19):1===t?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,d=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===t&&852<C||2===t&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<c?(m=0,a[v]):a[v]>c?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;n[d+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=e[r+a[v]]}if(k<b&&(E&f)!==l){for(0===S&&(S=k),d+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===t&&852<C||2===t&&592<C)return 1;n[l=E&f]=k<<24|x<<16|d-s|0}}return 0!==E&&(n[d+E]=b-S<<24|64<<16|0),o.bits=k,0}},{"../utils/common":41}],51:[function(t,e,r){"use strict";e.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(t,e,r){"use strict";var n=t("../utils/common"),o=0,h=1;function i(t){for(var e=t.length;0<=--e;)t[e]=0}var s=0,a=29,u=256,l=u+1+a,f=30,d=19,_=2*l+1,g=15,c=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));i(z);var C=new Array(2*f);i(C);var E=new Array(512);i(E);var A=new Array(256);i(A);var I=new Array(a);i(I);var O,B,R,T=new Array(f);function D(t,e,r,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=r,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function F(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function N(t){return t<256?E[t]:E[256+(t>>>7)]}function U(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function P(t,e,r){t.bi_valid>c-r?(t.bi_buf|=e<<t.bi_valid&65535,U(t,t.bi_buf),t.bi_buf=e>>c-t.bi_valid,t.bi_valid+=r-c):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=r)}function L(t,e,r){P(t,r[2*e],r[2*e+1])}function j(t,e){for(var r=0;r|=1&t,t>>>=1,r<<=1,0<--e;);return r>>>1}function Z(t,e,r){var i,n,s=new Array(g+1),a=0;for(i=1;i<=g;i++)s[i]=a=a+r[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=j(s[o]++,o))}}function W(t){var e;for(e=0;e<l;e++)t.dyn_ltree[2*e]=0;for(e=0;e<f;e++)t.dyn_dtree[2*e]=0;for(e=0;e<d;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*m]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function M(t){8<t.bi_valid?U(t,t.bi_buf):0<t.bi_valid&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function H(t,e,r,i){var n=2*e,s=2*r;return t[n]<t[s]||t[n]===t[s]&&i[e]<=i[r]}function G(t,e,r){for(var i=t.heap[r],n=r<<1;n<=t.heap_len&&(n<t.heap_len&&H(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!H(e,i,t.heap[n],t.depth));)t.heap[r]=t.heap[n],r=n,n<<=1;t.heap[r]=i}function K(t,e,r){var i,n,s,a,o=0;if(0!==t.last_lit)for(;i=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],n=t.pending_buf[t.l_buf+o],o++,0===i?L(t,n,e):(L(t,(s=A[n])+u+1,e),0!==(a=w[s])&&P(t,n-=I[s],a),L(t,s=N(--i),r),0!==(a=k[s])&&P(t,i-=T[s],a)),o<t.last_lit;);L(t,m,e)}function Y(t,e){var r,i,n,s=e.dyn_tree,a=e.stat_desc.static_tree,o=e.stat_desc.has_stree,h=e.stat_desc.elems,u=-1;for(t.heap_len=0,t.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(t.heap[++t.heap_len]=u=r,t.depth[r]=0):s[2*r+1]=0;for(;t.heap_len<2;)s[2*(n=t.heap[++t.heap_len]=u<2?++u:0)]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=a[2*n+1]);for(e.max_code=u,r=t.heap_len>>1;1<=r;r--)G(t,s,r);for(n=h;r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],G(t,s,1),i=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=i,s[2*n]=s[2*r]+s[2*i],t.depth[n]=(t.depth[r]>=t.depth[i]?t.depth[r]:t.depth[i])+1,s[2*r+1]=s[2*i+1]=n,t.heap[1]=n++,G(t,s,1),2<=t.heap_len;);t.heap[--t.heap_max]=t.heap[1],function(t,e){var r,i,n,s,a,o,h=e.dyn_tree,u=e.max_code,l=e.stat_desc.static_tree,f=e.stat_desc.has_stree,d=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,m=0;for(s=0;s<=g;s++)t.bl_count[s]=0;for(h[2*t.heap[t.heap_max]+1]=0,r=t.heap_max+1;r<_;r++)p<(s=h[2*h[2*(i=t.heap[r])+1]+1]+1)&&(s=p,m++),h[2*i+1]=s,u<i||(t.bl_count[s]++,a=0,c<=i&&(a=d[i-c]),o=h[2*i],t.opt_len+=o*(s+a),f&&(t.static_len+=o*(l[2*i+1]+a)));if(0!==m){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(i=t.bl_count[s];0!==i;)u<(n=t.heap[--r])||(h[2*n+1]!==s&&(t.opt_len+=(s-h[2*n+1])*h[2*n],h[2*n+1]=s),i--)}}(t,e),Z(s,u,t.bl_count)}function X(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),e[2*(r+1)+1]=65535,i=0;i<=r;i++)n=a,a=e[2*(i+1)+1],++o<h&&n===a||(o<u?t.bl_tree[2*n]+=o:0!==n?(n!==s&&t.bl_tree[2*n]++,t.bl_tree[2*b]++):o<=10?t.bl_tree[2*v]++:t.bl_tree[2*y]++,s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4))}function V(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),i=0;i<=r;i++)if(n=a,a=e[2*(i+1)+1],!(++o<h&&n===a)){if(o<u)for(;L(t,n,t.bl_tree),0!=--o;);else 0!==n?(n!==s&&(L(t,n,t.bl_tree),o--),L(t,b,t.bl_tree),P(t,o-3,2)):o<=10?(L(t,v,t.bl_tree),P(t,o-3,3)):(L(t,y,t.bl_tree),P(t,o-11,7));s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4)}}i(T);var q=!1;function J(t,e,r,i){P(t,(s<<1)+(i?1:0),3),function(t,e,r,i){M(t),i&&(U(t,r),U(t,~r)),n.arraySet(t.pending_buf,t.window,e,r,t.pending),t.pending+=r}(t,e,r,!0)}r._tr_init=function(t){q||(function(){var t,e,r,i,n,s=new Array(g+1);for(i=r=0;i<a-1;i++)for(I[i]=r,t=0;t<1<<w[i];t++)A[r++]=i;for(A[r-1]=i,i=n=0;i<16;i++)for(T[i]=n,t=0;t<1<<k[i];t++)E[n++]=i;for(n>>=7;i<f;i++)for(T[i]=n<<7,t=0;t<1<<k[i]-7;t++)E[256+n++]=i;for(e=0;e<=g;e++)s[e]=0;for(t=0;t<=143;)z[2*t+1]=8,t++,s[8]++;for(;t<=255;)z[2*t+1]=9,t++,s[9]++;for(;t<=279;)z[2*t+1]=7,t++,s[7]++;for(;t<=287;)z[2*t+1]=8,t++,s[8]++;for(Z(z,l+1,s),t=0;t<f;t++)C[2*t+1]=5,C[2*t]=j(t,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,d,p)}(),q=!0),t.l_desc=new F(t.dyn_ltree,O),t.d_desc=new F(t.dyn_dtree,B),t.bl_desc=new F(t.bl_tree,R),t.bi_buf=0,t.bi_valid=0,W(t)},r._tr_stored_block=J,r._tr_flush_block=function(t,e,r,i){var n,s,a=0;0<t.level?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,r=4093624447;for(e=0;e<=31;e++,r>>>=1)if(1&r&&0!==t.dyn_ltree[2*e])return o;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return h;for(e=32;e<u;e++)if(0!==t.dyn_ltree[2*e])return h;return o}(t)),Y(t,t.l_desc),Y(t,t.d_desc),a=function(t){var e;for(X(t,t.dyn_ltree,t.l_desc.max_code),X(t,t.dyn_dtree,t.d_desc.max_code),Y(t,t.bl_desc),e=d-1;3<=e&&0===t.bl_tree[2*S[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),n=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=n&&(n=s)):n=s=r+5,r+4<=n&&-1!==e?J(t,e,r,i):4===t.strategy||s===n?(P(t,2+(i?1:0),3),K(t,z,C)):(P(t,4+(i?1:0),3),function(t,e,r,i){var n;for(P(t,e-257,5),P(t,r-1,5),P(t,i-4,4),n=0;n<i;n++)P(t,t.bl_tree[2*S[n]+1],3);V(t,t.dyn_ltree,e-1),V(t,t.dyn_dtree,r-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,a+1),K(t,t.dyn_ltree,t.dyn_dtree)),W(t),i&&M(t)},r._tr_tally=function(t,e,r){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&r,t.last_lit++,0===e?t.dyn_ltree[2*r]++:(t.matches++,e--,t.dyn_ltree[2*(A[r]+u+1)]++,t.dyn_dtree[2*N(e)]++),t.last_lit===t.lit_bufsize-1},r._tr_align=function(t){P(t,2,3),L(t,m,z),function(t){16===t.bi_valid?(U(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):8<=t.bi_valid&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},{"../utils/common":41}],53:[function(t,e,r){"use strict";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(t,e,r){"use strict";e.exports="function"==typeof setImmediate?setImmediate:function(){var t=[].slice.apply(arguments);t.splice(1,0,0),setTimeout.apply(null,t)}},{}]},{},[10])(10)});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./src/xlsx-io/common/chart-helper.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/common/chart-helper.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var chart_model_1 = __webpack_require__(/*! ./../../datamodel/chart-model */ "./src/datamodel/chart-model.ts");
var ST_SystemColorVal = chart_model_1.Charts.ST_SystemColorVal, ST_SchemeColorVal = chart_model_1.Charts.ST_SchemeColorVal, ST_SplitType = chart_model_1.Charts.ST_SplitType, ST_MarkerStyle = chart_model_1.Charts.ST_MarkerStyle, ST_SeriesLayout = chart_model_1.Charts.ST_SeriesLayout;
var ChartHelper = /** @class */ (function () {
    function ChartHelper() {
    }
    ChartHelper.ToKnownColor = function (sysColor) {
        var result = null;
        switch (sysColor) {
            case ST_SystemColorVal.scrollBar:
                result = 0x17;
                break;
            case ST_SystemColorVal.activeCaption:
                result = 2;
                break;
            case ST_SystemColorVal.inactiveCaption:
                result = 0x11;
                break;
            case ST_SystemColorVal.menu:
                result = 0x15;
                break;
            case ST_SystemColorVal.window:
                result = 0x18;
                break;
            case ST_SystemColorVal.windowFrame:
                result = 0x19;
                break;
            case ST_SystemColorVal.menuText:
                result = 0x16;
                break;
            case ST_SystemColorVal.windowText:
                result = 0x1a;
                break;
            case ST_SystemColorVal.activeBorder:
                result = 1;
                break;
            case ST_SystemColorVal.inactiveBorder:
                result = 0x10;
                break;
            case ST_SystemColorVal.appWorkspace:
                result = 4;
                break;
            case ST_SystemColorVal.highlight:
                result = 13;
                break;
            case ST_SystemColorVal.highlightText:
                result = 14;
                break;
            case ST_SystemColorVal.btnFace:
                result = 0xa8;
                break;
            case ST_SystemColorVal.btnShadow:
                result = 170;
                break;
            case ST_SystemColorVal.grayText:
                result = 12;
                break;
            case ST_SystemColorVal.inactiveCaptionText:
                result = 0x12;
                break;
            case ST_SystemColorVal.btnHighlight:
                result = 0xa9;
                break;
            case ST_SystemColorVal.infoText:
                result = 20;
                break;
            case ST_SystemColorVal.infoBk:
                result = 0x13;
                break;
            case ST_SystemColorVal.gradientActiveCaption:
                result = 0xab;
                break;
            case ST_SystemColorVal.gradientInactiveCaption:
                result = 0xac;
                break;
            case ST_SystemColorVal.menuHighlight:
                result = 0xae;
                break;
            case ST_SystemColorVal.menuBar:
                result = 0xad;
                break;
            default:
                break;
        }
        return result;
    };
    ChartHelper.ToST_SystemColorVal = function (knowColor) {
        var result = null;
        switch (knowColor) {
            case 1:
                result = ST_SystemColorVal.activeBorder;
                break;
            case 2:
                result = ST_SystemColorVal.activeCaption;
                break;
            case 0xa8:
                result = ST_SystemColorVal.btnFace;
                break;
            case 0xa9:
                result = ST_SystemColorVal.btnHighlight;
                break;
            case 170:
                result = ST_SystemColorVal.btnShadow;
                break;
            case 0xab:
                result = ST_SystemColorVal.gradientActiveCaption;
                break;
            case 0xac:
                result = ST_SystemColorVal.gradientInactiveCaption;
                break;
            case 12:
                result = ST_SystemColorVal.grayText;
                break;
            case 13:
                result = ST_SystemColorVal.highlight;
                break;
            case 14:
                result = ST_SystemColorVal.highlightText;
                break;
            case 0x10:
                result = ST_SystemColorVal.inactiveBorder;
                break;
            case 0x11:
                result = ST_SystemColorVal.inactiveCaption;
                break;
            case 0x12:
                result = ST_SystemColorVal.inactiveCaptionText;
                break;
            case 20:
                result = ST_SystemColorVal.infoText;
                break;
            case 0x15:
                result = ST_SystemColorVal.menu;
                break;
            case 0xad:
                result = ST_SystemColorVal.menuBar;
                break;
            case 0xae:
                result = ST_SystemColorVal.menuHighlight;
                break;
            case 0x16:
                result = ST_SystemColorVal.menuText;
                break;
            case 0x18:
                result = ST_SystemColorVal.window;
                break;
            case 0x19:
                result = ST_SystemColorVal.windowFrame;
                break;
            case 0x1a:
                result = ST_SystemColorVal.windowText;
                break;
            default:
                break;
        }
        return result;
    };
    ChartHelper.ToST_SchemeColorVal = function (schemeIndex) {
        var result = ST_SchemeColorVal.accent1;
        switch (schemeIndex) {
            case 4:
                result = ST_SchemeColorVal.accent1;
                break;
            case 5:
                result = ST_SchemeColorVal.accent2;
                break;
            case 6:
                result = ST_SchemeColorVal.accent3;
                break;
            case 7:
                result = ST_SchemeColorVal.accent4;
                break;
            case 8:
                result = ST_SchemeColorVal.accent5;
                break;
            case 9:
                result = ST_SchemeColorVal.accent6;
                break;
            case 0:
                result = ST_SchemeColorVal.bg1;
                break;
            case 2:
                result = ST_SchemeColorVal.bg2;
                break;
            case 11:
                result = ST_SchemeColorVal.folHlink;
                break;
            case 10:
                result = ST_SchemeColorVal.hlink;
                break;
            case 12:
                result = ST_SchemeColorVal.phClr;
                break;
            case 13:
                result = ST_SchemeColorVal.dk1;
                break;
            case 14:
                result = ST_SchemeColorVal.lt1;
                break;
            case 15:
                result = ST_SchemeColorVal.dk2;
                break;
            case 16:
                result = ST_SchemeColorVal.lt2;
                break;
            case 1:
                result = ST_SchemeColorVal.tx1;
                break;
            case 3:
                result = ST_SchemeColorVal.tx2;
                break;
            default:
                break;
        }
        return result;
    };
    ChartHelper.ToColorSchemeIndex = function (schemeIndex) {
        var result = 4;
        switch (schemeIndex) {
            case ST_SchemeColorVal.bg1:
                result = 0;
                break;
            case ST_SchemeColorVal.tx1:
                result = 1;
                break;
            case ST_SchemeColorVal.bg2:
                result = 2;
                break;
            case ST_SchemeColorVal.tx2:
                result = 3;
                break;
            case ST_SchemeColorVal.accent1:
                result = 4;
                break;
            case ST_SchemeColorVal.accent2:
                result = 5;
                break;
            case ST_SchemeColorVal.accent3:
                result = 6;
                break;
            case ST_SchemeColorVal.accent4:
                result = 7;
                break;
            case ST_SchemeColorVal.accent5:
                result = 8;
                break;
            case ST_SchemeColorVal.accent6:
                result = 9;
                break;
            case ST_SchemeColorVal.hlink:
                result = 10;
                break;
            case ST_SchemeColorVal.folHlink:
                result = 11;
                break;
            case ST_SchemeColorVal.phClr:
                result = 12;
                break;
            case ST_SchemeColorVal.dk1:
                result = 13;
                break;
            case ST_SchemeColorVal.lt1:
                result = 14;
                break;
            case ST_SchemeColorVal.dk2:
                result = 15;
                break;
            case ST_SchemeColorVal.lt2:
                result = 16;
                break;
            default:
                break;
        }
        return result;
    };
    ChartHelper.ToST_PresetLineDashVal = function (value) {
        if (value === 11) {
            value = 1;
        }
        return value;
    };
    ChartHelper.ToPatternType = function (type) {
        var result = 0;
        switch (type) {
            case 0:
                result = 1;
                break;
            case 1:
                result = 2;
                break;
            case 2:
                result = 3;
                break;
            case 3:
                result = 4;
                break;
            case 4:
                result = 5;
                break;
            case 5:
                result = 6;
                break;
            case 6:
                result = 7;
                break;
            case 7:
                result = 8;
                break;
            case 8:
                result = 9;
                break;
            case 9:
                result = 10;
                break;
            case 10:
                result = 11;
                break;
            case 11:
                result = 12;
                break;
            case 16:
                result = 13;
                break;
            case 17:
                result = 14;
                break;
            case 27:
                result = 15;
                break;
            case 28:
                result = 16;
                break;
            case 34:
                result = 17;
                break;
            case 52:
                result = 18;
                break;
            case 14:
                result = 19;
                break;
            case 15:
                result = 20;
                break;
            case 25:
                result = 21;
                break;
            case 26:
                result = 22;
                break;
            case 36:
                result = 23;
                break;
            case 45:
                result = 24;
                break;
            case 29:
                result = 25;
                break;
            case 30:
                result = 26;
                break;
            case 32:
                result = 27;
                break;
            case 31:
                result = 28;
                break;
            case 19:
                result = 29;
                break;
            case 18:
                result = 30;
                break;
            case 21:
                result = 31;
                break;
            case 20:
                result = 32;
                break;
            case 40:
                result = 33;
                break;
            case 37:
                result = 34;
                break;
            case 41:
                result = 35;
                break;
            case 35:
                result = 36;
                break;
            case 39:
                result = 37;
                break;
            case 53:
                result = 38;
                break;
            case 43:
                result = 39;
                break;
            case 42:
                result = 40;
                break;
            case 44:
                result = 41;
                break;
            case 46:
                result = 42;
                break;
            case 47:
                result = 43;
                break;
            case 48:
                result = 44;
                break;
            case 38:
                result = 45;
                break;
            case 49:
                result = 46;
                break;
            case 50:
                result = 47;
                break;
            case 51:
                result = 48;
                break;
            case 12:
                result = 49;
                break;
            case 13:
                result = 50;
                break;
            case 22:
                result = 51;
                break;
            case 23:
                result = 52;
                break;
            case 24:
                result = 53;
                break;
            case 33:
                result = 54;
                break;
        }
        return result;
    };
    ChartHelper.ToST_PresetPatternVal = function (type) {
        var result = 0;
        switch (type) {
            case 1:
                result = 0;
                break;
            case 2:
                result = 1;
                break;
            case 3:
                result = 2;
                break;
            case 4:
                result = 3;
                break;
            case 5:
                result = 4;
                break;
            case 6:
                result = 5;
                break;
            case 7:
                result = 6;
                break;
            case 8:
                result = 7;
                break;
            case 9:
                result = 8;
                break;
            case 10:
                result = 9;
                break;
            case 11:
                result = 10;
                break;
            case 12:
                result = 11;
                break;
            case 13:
                result = 16;
                break;
            case 14:
                result = 17;
                break;
            case 15:
                result = 27;
                break;
            case 16:
                result = 28;
                break;
            case 17:
                result = 34;
                break;
            case 18:
                result = 52;
                break;
            case 19:
                result = 14;
                break;
            case 20:
                result = 15;
                break;
            case 21:
                result = 25;
                break;
            case 22:
                result = 26;
                break;
            case 23:
                result = 36;
                break;
            case 24:
                result = 45;
                break;
            case 25:
                result = 29;
                break;
            case 26:
                result = 30;
                break;
            case 27:
                result = 32;
                break;
            case 28:
                result = 31;
                break;
            case 29:
                result = 19;
                break;
            case 30:
                result = 18;
                break;
            case 31:
                result = 21;
                break;
            case 32:
                result = 20;
                break;
            case 33:
                result = 40;
                break;
            case 34:
                result = 37;
                break;
            case 35:
                result = 41;
                break;
            case 36:
                result = 35;
                break;
            case 37:
                result = 39;
                break;
            case 38:
                result = 53;
                break;
            case 39:
                result = 43;
                break;
            case 40:
                result = 42;
                break;
            case 41:
                result = 44;
                break;
            case 42:
                result = 46;
                break;
            case 43:
                result = 47;
                break;
            case 44:
                result = 48;
                break;
            case 45:
                result = 38;
                break;
            case 46:
                result = 49;
                break;
            case 47:
                result = 50;
                break;
            case 48:
                result = 51;
                break;
            case 49:
                result = 12;
                break;
            case 50:
                result = 13;
                break;
            case 51:
                result = 22;
                break;
            case 52:
                result = 23;
                break;
            case 53:
                result = 24;
                break;
            case 54:
                result = 33;
                break;
        }
        return result;
    };
    ChartHelper.ToST_PresetShadowVal = function (type) {
        if (type > 19) {
            return 0;
        }
        return type;
    };
    ChartHelper.ToST_SplitType = function (splitType) {
        var result = ST_SplitType.pos;
        switch (splitType) {
            case 0:
                result = ST_SplitType.pos;
                break;
            case 1:
                result = ST_SplitType.val;
                break;
            case 2:
                result = ST_SplitType.percent;
                break;
            case 3:
                result = ST_SplitType.cust;
                break;
            default:
                break;
        }
        return result;
    };
    ChartHelper.ToChartSplitType = function (splitType) {
        var result = 0;
        switch (splitType) {
            case ST_SplitType.auto:
                result = 0;
                break;
            case ST_SplitType.cust:
                result = 3;
                break;
            case ST_SplitType.percent:
                result = 2;
                break;
            case ST_SplitType.pos:
                result = 0;
                break;
            case ST_SplitType.val:
                result = 1;
                break;
            default:
                break;
        }
        return result;
    };
    ChartHelper.ToST_LightRigDirection = function (type) {
        var result = 1;
        switch (type) {
            case 0:
                result = 1;
                break;
            case 1:
                result = 4;
                break;
            case 2:
                result = 6;
                break;
            case 3:
                result = 1;
                break;
            case 4:
                result = 1;
                break;
            case 5:
                result = 6;
                break;
            case 6:
                result = 1;
                break;
            case 7:
                result = 3;
                break;
            case 8:
                result = 6;
                break;
        }
        return result;
    };
    ChartHelper.ToST_MarkerStyle = function (style) {
        if (style === 11) {
            style = ST_MarkerStyle.circle;
        }
        return style;
    };
    ChartHelper.ToST_LegendPos = function (position) {
        var result = 0;
        switch (position) {
            case 0:
                break;
            case 1:
                result = 4;
                break;
            case 2:
                result = 3;
                break;
            case 3:
                result = 2;
                break;
            case 4:
                result = 0;
                break;
            case 5:
                result = 1;
                break;
            default:
                break;
        }
        return result;
    };
    ChartHelper.ToLegendPosition = function (position) {
        var result = 4;
        switch (position) {
            case 0:
                result = 4;
                break;
            case 1:
                result = 5;
                break;
            case 2:
                result = 3;
                break;
            case 3:
                result = 2;
                break;
            case 4:
                result = 1;
                break;
            default:
                break;
        }
        return result;
    };
    ChartHelper.ToST_PresetCameraType = function (value) {
        if (value === 62) {
            value = 0;
        }
        return value;
    };
    ChartHelper.ToST_BuiltInUnit = function (value) {
        if (value > 8) {
            value = 0;
        }
        return value;
    };
    ChartHelper.ToST_Crosses = function (crosses) {
        var result = 0;
        switch (crosses) {
            case 0:
                break;
            case 1:
                result = 0;
                break;
            case 2:
                result = 1;
                break;
            case 3:
                result = 2;
                break;
            default:
                break;
        }
        return result;
    };
    ChartHelper.ToAxisCrosses = function (crosses) {
        var result = 1;
        switch (crosses) {
            case 0:
                result = 1;
                break;
            case 1:
                result = 2;
                break;
            case 2:
                result = 3;
                break;
            default:
                break;
        }
        return result;
    };
    ChartHelper.ToCT_ChartType = function (crosses) {
        var result = 16;
        switch (crosses) {
            case ST_SeriesLayout.boxWhisker:
                result = 16;
                break;
            case ST_SeriesLayout.funnel:
                result = 17;
                break;
            case ST_SeriesLayout.paretoLine:
                result = 18;
                break;
            case ST_SeriesLayout.regionMap:
                result = 19;
                break;
            case ST_SeriesLayout.sunburst:
                result = 20;
                break;
            case ST_SeriesLayout.treemap:
                result = 21;
                break;
            case ST_SeriesLayout.waterfall:
                result = 22;
                break;
            case ST_SeriesLayout.clusteredColumn:
                result = 23;
                break;
            default:
                break;
        }
        return result;
    };
    ChartHelper.ToST_SeriesLayout = function (crosses) {
        var result = 0;
        switch (crosses) {
            case 16:
                result = ST_SeriesLayout.boxWhisker;
                break;
            case 17:
                result = ST_SeriesLayout.funnel;
                break;
            case 18:
                result = ST_SeriesLayout.paretoLine;
                break;
            case 19:
                result = ST_SeriesLayout.regionMap;
                break;
            case 20:
                result = ST_SeriesLayout.sunburst;
                break;
            case 21:
                result = ST_SeriesLayout.treemap;
                break;
            case 22:
                result = ST_SeriesLayout.waterfall;
                break;
            case 23:
                result = ST_SeriesLayout.clusteredColumn;
                break;
            default:
                break;
        }
        return result;
    };
    return ChartHelper;
}());
exports.ChartHelper = ChartHelper;


/***/ }),

/***/ "./src/xlsx-io/common/color-reader.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/common/color-reader.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var xml_reader_1 = __webpack_require__(/*! ./../../xml-io/xml-reader */ "./src/xml-io/xml-reader.ts");
function readColor(obj) {
    var color = excel_style_1.ExcelColor.EmptyColor, auto = false, themeColorIndex = -1, tint = 0, rgb = '', index = -1;
    if (obj && obj instanceof xml_reader_1.XmlReader) {
        var reader = obj;
        while (reader.moveToNextAttribute()) {
            switch (reader.readAttributeNameAsString()) {
                case 'auto':
                    auto = reader.readContentAsBoolean(false);
                    break;
                case 'theme':
                    themeColorIndex = reader.readContentAsInt(-1);
                    break;
                case 'tint':
                    tint = reader.readContentAsDouble(0.0);
                    break;
                case 'rgb':
                    rgb = reader.readContentAsString();
                    break;
                case 'indexed':
                    index = reader.readContentAsInt(-1);
                    break;
                default:
                    break;
            }
        }
    }
    else if (obj) {
        auto = !!obj._attr.auto;
        if (obj._attr.theme) {
            themeColorIndex = parseInt(obj._attr.theme, 10);
        }
        if (obj._attr.tint) {
            tint = parseFloat(obj._attr.tint);
        }
        rgb = obj._attr.rgb || '';
        if (obj._attr.indexed) {
            index = parseInt(obj._attr.indexed, 10);
        }
    }
    if (auto) {
        color.isAutoColor(true);
        return color;
    }
    if (themeColorIndex !== -1) {
        color = new excel_style_1.ExcelColor(3, themeColorIndex, tint);
        return color;
    }
    if (!common_1.StringEx._isNullOrEmpty(rgb)) {
        var argb = parseInt(rgb, 16);
        color = new excel_style_1.ExcelColor(2, argb, tint);
        return color;
    }
    if (index >= 0) {
        color = new excel_style_1.ExcelColor(1, index, 0.0);
        return color;
    }
    return color;
}
exports.readColor = readColor;


/***/ }),

/***/ "./src/xlsx-io/common/color-writer.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/common/color-writer.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
function writeColor(writer, node, color) {
    if (color === undefined) {
        return;
    }
    writer.writeLeafElement(node, function () {
        if (color === null || color.isAutoColor()) {
            writer.writeAttributeString('auto', '1');
            return;
        }
        if (color.isIndexedColor()) {
            writer.writeAttributeString('indexed', color.value().toString());
        }
        else if (color.isThemeColor()) {
            writer.writeAttributeString('theme', color.value().toString());
            if (color.tint() !== 0.0) {
                writer.writeAttributeString('tint', color.tint().toString());
            }
        }
        else if (color.isRGBColor()) {
            var colorStr = color.value().toString(16);
            writer.writeAttributeString('rgb', colorStr.toUpperCase());
            if (color.tint() !== 0.0) {
                writer.writeAttributeString('tint', color.tint().toString());
            }
        }
    });
}
exports.writeColor = writeColor;
function writeColorScheme(writer, node, color) {
    if (!color) {
        return;
    }
    writer.writeElement(node, undefined, function () {
        if (node === 'a:dk1') {
            writer.writeLeafElement('a:sysClr', function () {
                writer.writeAttributeString('val', 'windowText');
                writer.writeAttributeString('lastClr', '000000');
            });
        }
        else if (node === 'a:lt1') {
            writer.writeLeafElement('a:sysClr', function () {
                writer.writeAttributeString('val', 'window');
                writer.writeAttributeString('lastClr', 'FFFFFF');
            });
        }
        else if (color.colorType() === 2) {
            writer.writeLeafElement('a:srgbClr', function () {
                writer.writeAttributeString('val', color.value().toString(16).substring(2));
            });
        }
        else if (color.colorType() === 3) {
            writer.writeLeafElement('a:schemeClr', function () {
                writer.writeAttributeString('val', excel_style_1.ConverterHelper.toSchemeClrValue(color.value()));
            });
        }
        else if (color.colorType() === 1) {
            var rgbColor_1 = excel_style_1.ColorHelper.toExcelIndexedColor(color);
            writer.writeLeafElement('a:srgbClr', function () {
                writer.writeAttributeString('val', rgbColor_1 && rgbColor_1.value ? rgbColor_1.value().toString(16) : '0');
            });
        }
    });
}
exports.writeColorScheme = writeColorScheme;


/***/ }),

/***/ "./src/xlsx-io/common/errorMessage.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/common/errorMessage.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var errorRes = {
    en: {
        EXP_IO: 'File read and write exception.',
        EXP_FILE_FORMAT: 'Incorrect file format.',
        EXP_NO_PASSWORD: 'The Excel file cannot be opened because the workbook/worksheet is password protected.',
        EXP_INVALID_PASSWORD: 'The specified password is incorrect.'
    },
    ja: {
        EXP_IO: '\u30d5\u30a1\u30a4\u30ebIO\u306b\u95a2\u3059\u308b\u4f8b\u5916\u304c\u767a\u751f\u3057\u307e\u3057\u305f\u3002',
        EXP_FILE_FORMAT: '\u30d5\u30a1\u30a4\u30eb\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u306b\u8aa4\u308a\u304c\u3042\u308a\u307e\u3059\u3002',
        EXP_NO_PASSWORD: '\u30ef\u30fc\u30af\u30d6\u30c3\u30af/\u30ef\u30fc\u30af\u30b7\u30fc\u30c8\u306f\u30d1\u30b9\u30ef\u30fc\u30c9\u3067\u4fdd\u8b77\u3055\u308c\u3066\u3044\u307e\u3059\u3002Excel\u30d5\u30a1\u30a4\u30eb\u3092\u958b\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u305b\u3093\u3067\u3057\u305f\u3002',
        EXP_INVALID_PASSWORD: '\u30d1\u30b9\u30ef\u30fc\u30c9\u304c\u4e0d\u6b63\u3067\u3059\u3002'
    },
    zh: {
        EXP_IO: '\u6587\u4ef6\u8bfb\u5199\u5f02\u5e38',
        EXP_FILE_FORMAT: '\u6587\u4ef6\u683c\u5f0f\u9519\u8bef',
        EXP_NO_PASSWORD: 'Excel\u6587\u4ef6\u53d7\u5bc6\u7801\u4fdd\u62a4\uff0c\u65e0\u6cd5\u88ab\u6253\u5f00',
        EXP_INVALID_PASSWORD: '\u5bc6\u7801\u9519\u8bef'
    }
};
function sR() {
    var cultureStr = common_1._getCulture() || "en";
    var cultureRes = errorRes[cultureStr.split('-')[0]];
    return cultureRes ? cultureRes : errorRes.en;
}
exports.sR = sR;


/***/ }),

/***/ "./src/xlsx-io/common/errorcode.ts":
/*!*****************************************!*\
  !*** ./src/xlsx-io/common/errorcode.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.errorCode = {
    fileIOError: 0,
    fileFormatError: 1,
    noPassword: 2,
    invalidPassword: 3
};


/***/ }),

/***/ "./src/xlsx-io/common/file-loader.ts":
/*!*******************************************!*\
  !*** ./src/xlsx-io/common/file-loader.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var compoundFile_1 = __webpack_require__(/*! ./../password/compoundFile */ "./src/xlsx-io/password/compoundFile.ts");
var xlsxEncryptionHelper_1 = __webpack_require__(/*! ./../password/xlsxEncryptionHelper */ "./src/xlsx-io/password/xlsxEncryptionHelper.ts");
var errorcode_1 = __webpack_require__(/*! ./errorcode */ "./src/xlsx-io/common/errorcode.ts");
var errorMessage_1 = __webpack_require__(/*! ./errorMessage */ "./src/xlsx-io/common/errorMessage.ts");
var JSZip = __webpack_require__(/*! ./../../lib/jszip.min.js */ "./src/lib/jszip.min.js");
var keyword_undefined = void 0, const_undefined = 'undefined';
var FileLoader = /** @class */ (function () {
    function FileLoader(loadType) {
        var self = this;
        if (loadType === keyword_undefined) {
            self.loadType = 1;
        }
        else {
            self.loadType = loadType;
        }
        if (typeof FileReader === const_undefined) {
            throw new Error('The browser doesn\'t support FileReader!');
        }
        else {
            self.fileReader = new FileReader();
            self.passwordFileReader = new FileReader();
            self.compoundFile = new compoundFile_1.CompoundFile();
        }
    }
    FileLoader.prototype.loadFile = function (file, options) {
        var self = this, reader = self.fileReader;
        if (file instanceof ArrayBuffer) {
            self.fileLoad(file, options);
            return;
        }
        if (file && reader) {
            reader.onload = function (e) {
                self.fileLoad(e.target.result, options);
            };
            reader.onerror = function () {
                self._errorFileIO();
            };
            switch (self.loadType) {
                case 1:
                    if (reader.readAsArrayBuffer) {
                        reader.readAsArrayBuffer(file);
                        break;
                    }
                    self.loadType = 0;
                    break;
                default:
                    if (reader.readAsDataURL) {
                        reader.readAsDataURL(file);
                    }
                    break;
            }
        }
    };
    FileLoader.prototype._errorFileIO = function () {
        this.onError({
            errorCode: errorcode_1.errorCode.fileIOError,
            errorMessage: errorMessage_1.sR().EXP_IO
        });
    };
    FileLoader.prototype._errorFileFormat = function () {
        this.onError({
            errorCode: errorcode_1.errorCode.fileFormatError,
            errorMessage: errorMessage_1.sR().EXP_FILE_FORMAT
        });
    };
    FileLoader.prototype._errorNoPassword = function () {
        this.onError({
            errorCode: errorcode_1.errorCode.noPassword,
            errorMessage: errorMessage_1.sR().EXP_NO_PASSWORD
        });
    };
    FileLoader.prototype._errorInvalidPassword = function () {
        this.onError({
            errorCode: errorcode_1.errorCode.invalidPassword,
            errorMessage: errorMessage_1.sR().EXP_INVALID_PASSWORD
        });
    };
    FileLoader.prototype.fileLoad = function (fileData, options) {
        var self = this;
        if (options && options.password) {
            try {
                fileData = xlsxEncryptionHelper_1.XlsxEncryptionHelper._decrypt(fileData, options.password);
                if (!fileData) {
                    self._errorInvalidPassword();
                    return;
                }
            }
            catch (err) {
                self._errorInvalidPassword();
                return;
            }
        }
        else if (xlsxEncryptionHelper_1.XlsxEncryptionHelper._hasPassword(fileData)) {
            self._errorNoPassword();
            return;
        }
        var zip = new JSZip();
        switch (self.loadType) {
            case 1:
                zip.loadAsync(fileData).then(loadFileArrays).catch(function () {
                    self._errorFileFormat();
                });
                break;
            case 0:
            default:
                var baseText = 'base64,', textIndex = fileData.indexOf(baseText);
                if (textIndex !== -1) {
                    var data = fileData.substring(textIndex + baseText.length);
                    zip.loadAsync(data, { base64: true }).then(loadFileArrays).catch(function () {
                        self._errorFileFormat();
                    });
                }
                break;
        }
        function loadFileArrays() {
            var files = zip.files, filesData = {};
            for (var file in files) {
                if (files[file]) {
                    var fileType = void 0;
                    var fileExtendName = file.substring(file.lastIndexOf("."));
                    if (fileExtendName === '.xml' || fileExtendName === '.rels') {
                        fileType = 'text';
                    }
                    else {
                        fileType = (file.indexOf('/media/') === -1) ? 'binarystring' : 'base64';
                    }
                    files[file].async(fileType).then(function (name) {
                        return function (content) {
                            filesData[name.toLowerCase()] = content;
                            for (var fileName in files) {
                                if (filesData[fileName.toLowerCase()] === keyword_undefined) {
                                    return;
                                }
                            }
                            self.onFileLoad(filesData);
                        };
                    }(file)).catch(function () {
                        self._errorFileFormat();
                    });
                }
            }
        }
    };
    return FileLoader;
}());
exports.FileLoader = FileLoader;


/***/ }),

/***/ "./src/xlsx-io/password/aes.ts":
/*!*************************************!*\
  !*** ./src/xlsx-io/password/aes.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var createBuffer = null, copyBuffer = null;
var slowCreateBuffer = function (arg) {
    var result = [];
    if (typeof arg === 'number') {
        for (var i = 0; i < arg; i++) {
            result.push(0);
        }
        return result;
    }
    for (var i = 0; i < arg.length; i++) {
        if (arg[i] < 0 || arg[i] >= 256 || typeof arg[i] !== 'number') {
            throw new Error('invalid byte (' + arg[i] + ':' + i + ')');
        }
    }
    if (arg.slice) {
        return arg.slice(0);
    }
    for (var i = 0; i < arg.length; i++) {
        result.push(arg[i]);
    }
    return result;
};
createBuffer = slowCreateBuffer;
copyBuffer = function (sourceBuffer, targetBuffer, targetStart, sourceStart, sourceEnd) {
    if (targetStart === null) {
        targetStart = 0;
    }
    if (sourceStart === null) {
        sourceStart = 0;
    }
    if (sourceEnd === null) {
        sourceEnd = sourceBuffer.length;
    }
    for (var i = sourceStart; i < sourceEnd; i++) {
        targetBuffer[targetStart++] = sourceBuffer[i];
    }
};
var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];
var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
var Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];
var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];
var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];
var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];
function convertToInt32(bytes) {
    var result = [];
    for (var i = 0; i < bytes.length; i += 4) {
        result.push((bytes[i] << 24) |
            (bytes[i + 1] << 16) |
            (bytes[i + 2] << 8) |
            bytes[i + 3]);
    }
    return result;
}
var AES = function (key) {
    if (!(this instanceof AES)) {
        throw Error('AES must be instanitated with `new`');
    }
    this.key = createBuffer(key);
    this._prepare();
};
AES.prototype._prepare = function () {
    var rounds = numberOfRounds[this.key.length];
    if (rounds === null) {
        throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
    }
    this._Ke = [];
    this._Kd = [];
    var i;
    for (i = 0; i <= rounds; i++) {
        this._Ke.push([0, 0, 0, 0]);
        this._Kd.push([0, 0, 0, 0]);
    }
    var roundKeyCount = (rounds + 1) * 4;
    var KC = this.key.length / 4;
    var tk = convertToInt32(this.key);
    var index;
    for (i = 0; i < KC; i++) {
        index = i >> 2;
        this._Ke[index][i % 4] = tk[i];
        this._Kd[rounds - index][i % 4] = tk[i];
    }
    var rconpointer = 0;
    var t = KC, tt;
    while (t < roundKeyCount) {
        tt = tk[KC - 1];
        tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
            (S[(tt >> 8) & 0xFF] << 16) ^
            (S[tt & 0xFF] << 8) ^
            S[(tt >> 24) & 0xFF] ^
            (rcon[rconpointer] << 24));
        rconpointer += 1;
        if (KC !== 8) {
            for (i = 1; i < KC; i++) {
                tk[i] ^= tk[i - 1];
            }
        }
        else {
            for (i = 1; i < (KC / 2); i++) {
                tk[i] ^= tk[i - 1];
            }
            tt = tk[(KC / 2) - 1];
            tk[KC / 2] ^= (S[tt & 0xFF] ^
                (S[(tt >> 8) & 0xFF] << 8) ^
                (S[(tt >> 16) & 0xFF] << 16) ^
                (S[(tt >> 24) & 0xFF] << 24));
            for (i = (KC / 2) + 1; i < KC; i++) {
                tk[i] ^= tk[i - 1];
            }
        }
        i = 0;
        var r = void 0, c = void 0;
        while (i < KC && t < roundKeyCount) {
            r = t >> 2;
            c = t % 4;
            this._Ke[r][c] = tk[i];
            this._Kd[rounds - r][c] = tk[i++];
            t++;
        }
    }
    for (var r = 1; r < rounds; r++) {
        for (var c = 0; c < 4; c++) {
            tt = this._Kd[r][c];
            this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^
                U2[(tt >> 16) & 0xFF] ^
                U3[(tt >> 8) & 0xFF] ^
                U4[tt & 0xFF]);
        }
    }
};
AES.prototype.encrypt = function (plaintext) {
    if (plaintext.length !== 16) {
        throw new Error('invalid plaintext size (must be 16 bytes)');
    }
    var rounds = this._Ke.length - 1;
    var a = [0, 0, 0, 0];
    var t = convertToInt32(plaintext);
    for (var i = 0; i < 4; i++) {
        t[i] ^= this._Ke[0][i];
    }
    for (var r = 1; r < rounds; r++) {
        for (var i = 0; i < 4; i++) {
            a[i] = (T1[(t[i] >> 24) & 0xff] ^
                T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
                T3[(t[(i + 2) % 4] >> 8) & 0xff] ^
                T4[t[(i + 3) % 4] & 0xff] ^
                this._Ke[r][i]);
        }
        t = a.slice(0);
    }
    var result = createBuffer(16), tt;
    for (var i = 0; i < 4; i++) {
        tt = this._Ke[rounds][i];
        result[4 * i] = (S[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
        result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
        result[4 * i + 2] = (S[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;
        result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;
    }
    return result;
};
AES.prototype.decrypt = function (ciphertext) {
    if (ciphertext.length !== 16) {
        throw new Error('invalid ciphertext size (must be 16 bytes)');
    }
    var rounds = this._Kd.length - 1;
    var a = [0, 0, 0, 0];
    var t = convertToInt32(ciphertext);
    for (var i = 0; i < 4; i++) {
        t[i] ^= this._Kd[0][i];
    }
    for (var r = 1; r < rounds; r++) {
        for (var i = 0; i < 4; i++) {
            a[i] = (T5[(t[i] >> 24) & 0xff] ^
                T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
                T7[(t[(i + 2) % 4] >> 8) & 0xff] ^
                T8[t[(i + 1) % 4] & 0xff] ^
                this._Kd[r][i]);
        }
        t = a.slice(0);
    }
    var result = createBuffer(16), tt;
    for (var i = 0; i < 4; i++) {
        tt = this._Kd[rounds][i];
        result[4 * i] = (Si[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
        result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
        result[4 * i + 2] = (Si[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;
        result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;
    }
    return result;
};
var ModeOfOperationECB = function (key) {
    if (!(this instanceof ModeOfOperationECB)) {
        throw Error('AES must be instanitated with `new`');
    }
    this.description = "Electronic Code Block";
    this.name = "ecb";
    this._aes = new AES(key);
};
ModeOfOperationECB.prototype.encrypt = function (plaintext) {
    if ((plaintext.length % 16) !== 0) {
        throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
    }
    var ciphertext = createBuffer(plaintext.length);
    var block = createBuffer(16);
    for (var i = 0; i < plaintext.length; i += 16) {
        copyBuffer(plaintext, block, 0, i, i + 16);
        block = this._aes.encrypt(block);
        copyBuffer(block, ciphertext, i, 0, 16);
    }
    return ciphertext;
};
ModeOfOperationECB.prototype.decrypt = function (ciphertext) {
    if ((ciphertext.length % 16) !== 0) {
        throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
    }
    var plaintext = createBuffer(ciphertext.length);
    var block = createBuffer(16);
    for (var i = 0; i < ciphertext.length; i += 16) {
        copyBuffer(ciphertext, block, 0, i, i + 16);
        block = this._aes.decrypt(block);
        copyBuffer(block, plaintext, i, 0, 16);
    }
    return plaintext;
};
var ModeOfOperationCBC = function (key, iv) {
    if (!(this instanceof ModeOfOperationCBC)) {
        throw Error('AES must be instanitated with `new`');
    }
    this.description = "Cipher Block Chaining";
    this.name = "cbc";
    if (!iv) {
        iv = createBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    }
    else if (iv.length !== 16) {
        throw new Error('invalid initialation vector size (must be 16 bytes)');
    }
    this._lastCipherblock = createBuffer(iv);
    this._aes = new AES(key);
};
ModeOfOperationCBC.prototype.encrypt = function (plaintext) {
    if ((plaintext.length % 16) !== 0) {
        throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
    }
    var ciphertext = createBuffer(plaintext.length);
    var block = createBuffer(16);
    for (var i = 0; i < plaintext.length; i += 16) {
        copyBuffer(plaintext, block, 0, i, i + 16);
        for (var j = 0; j < 16; j++) {
            block[j] ^= this._lastCipherblock[j];
        }
        this._lastCipherblock = this._aes.encrypt(block);
        copyBuffer(this._lastCipherblock, ciphertext, i, 0, 16);
    }
    return ciphertext;
};
ModeOfOperationCBC.prototype.decrypt = function (ciphertext) {
    if ((ciphertext.length % 16) !== 0) {
        throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
    }
    var plaintext = createBuffer(ciphertext.length);
    var block = createBuffer(16);
    for (var i = 0; i < ciphertext.length; i += 16) {
        copyBuffer(ciphertext, block, 0, i, i + 16);
        block = this._aes.decrypt(block);
        for (var j = 0; j < 16; j++) {
            plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
        }
        copyBuffer(ciphertext, this._lastCipherblock, 0, i, i + 16);
    }
    return plaintext;
};
var ModeOfOperation = {
    ecb: ModeOfOperationECB,
    cbc: ModeOfOperationCBC
};
exports.aesJS = {
    AES: AES,
    ModeOfOperation: ModeOfOperation,
    util: {
        _slowCreateBuffer: slowCreateBuffer
    }
};


/***/ }),

/***/ "./src/xlsx-io/password/aesEngine.ts":
/*!*******************************************!*\
  !*** ./src/xlsx-io/password/aesEngine.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ../../common/common */ "./src/common/common.ts");
var xml_parser_1 = __webpack_require__(/*! ../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var aes_1 = __webpack_require__(/*! ./aes */ "./src/xlsx-io/password/aes.ts");
var node_helper_1 = __webpack_require__(/*! ../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var Sha = __webpack_require__(/*! ./sha512.js */ "./src/xlsx-io/password/sha512.js");
var Sha1 = __webpack_require__(/*! ./sha1.js */ "./src/xlsx-io/password/sha1.js");
var getAsArray = node_helper_1.XmlNodeHelper._getAsArray;
var seekOrigin = {
    Begin: 0,
    Current: 1,
    End: 2
};
function base64ToBytes(base64) {
    var root = common_1._getRoot();
    var binary_string = root && root.atob && root.atob(base64);
    var len = binary_string ? binary_string.length : 0;
    var bytes = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
        bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes;
}
function arrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    var j = destinationIndex;
    for (var i = sourceIndex; i < sourceIndex + length; i++) {
        destinationArray[j] = sourceArray[i];
        j++;
    }
}
function stringToByteArray(str) {
    var bytesv2 = [];
    for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        bytesv2 = bytesv2.concat([code & 0xff, (parseInt(code / 256, 10)) >>> 0]);
    }
    return bytesv2;
}
function getBytesFromInt(i, x) {
    var bytes = [];
    do {
        bytes[--i] = x & (255);
        x = x >> 8;
    } while (i);
    return bytes.reverse();
}
function getBytesFromString(str) {
    var bytes = [];
    var charCode;
    for (var i = 0; i < str.length; ++i) {
        charCode = str.charCodeAt(i);
        bytes.push(charCode & 0xFF);
        bytes.push((charCode & 0xFF00) >> 8);
    }
    return bytes;
}
function hashByte(b1, b2, hashAlgorithm) {
    var sha = Sha;
    switch (hashAlgorithm) {
        case "SHA1":
            sha = Sha1;
            break;
    }
    var t = [];
    for (var i = 0; i < b1.length; i++) {
        t.push(b1[i]);
    }
    return sha.hash(t.concat(b2));
}
function reader(view) {
    var readUInt = function (n) {
        var sign = 0;
        common_1.BufferHelper._slice(view, view._pos, view._pos + n).reverse().forEach(function (i) {
            sign = sign * 256 + i;
        });
        view._pos += n;
        return sign;
    };
    var readInt = function (n) {
        var sign = 0;
        common_1.BufferHelper._slice(view, view._pos, view._pos + n).reverse().forEach(function (i) {
            sign = ((sign << 8) + i);
        });
        view._pos += n;
        return sign;
    };
    var _readBytes = function (n) {
        var subView = common_1.BufferHelper._slice(view, view._pos, view._pos + n);
        view._pos += n;
        return subView;
    };
    return {
        readUInt64: function () {
            return readUInt(8);
        },
        readInt64: function () {
            return readInt(8);
        },
        readInt32: function () {
            return readInt(4);
        },
        readUInt32: function () {
            return readUInt(4);
        },
        readInt16: function () {
            return readInt(2);
        },
        readUInt16: function () {
            return readInt(2);
        },
        readByte: function () {
            return _readBytes(1);
        },
        readBytes: function (count) {
            return _readBytes(count);
        },
        readChars: function (count) {
            var bytes = _readBytes(count);
            var chars = [];
            bytes.forEach(function (byte) {
                chars.push(String.fromCharCode(byte));
            });
            return chars;
        },
        seek: function (offset, origin) {
            if (origin === seekOrigin.Begin) {
                view._pos = offset;
            }
            else if (origin === seekOrigin.Current) {
                view._pos += offset;
            }
            else if (origin === seekOrigin.End) {
                view._pos = view.length + offset;
            }
        }
    };
}
function writer(view) {
    var write = function (n, value) {
        var result = getBytesFromInt(n, value);
        var pos = view._pos;
        for (var i = 0; i < result.length; i++) {
            view[i + pos] = result[i];
        }
        view._pos = pos + n;
    };
    return {
        writeBytes: function (value) {
            var pos = view._pos;
            for (var i = 0; i < value.length; i++) {
                view[i + pos] = value[i];
            }
            view._pos = pos + value.length;
        },
        writeByte: function (value) {
            this.writeBytes([value]);
        },
        writeUshort: function (value) {
            write(2, value);
        },
        writeShort: function (value) {
            write(2, value);
        },
        writeInt: function (value) {
            write(4, value);
        },
        writeUint: function (value) {
            write(4, value);
        },
        writeLong: function (value) {
            write(8, value);
        },
        seek: function (offset, origin) {
            if (origin === seekOrigin.Begin) {
                view._pos = offset;
            }
            else if (origin === seekOrigin.Current) {
                view._pos += offset;
            }
            else if (origin === seekOrigin.End) {
                view._pos = view.length + offset;
            }
        },
        getView: function () {
            return view;
        }
    };
}
function create2DArray(d1, d2, defaultValue) {
    var result = [];
    for (var i = 0; i < d1; i++) {
        result[i] = result[i] || [];
        for (var j = 0; j < d2; j++) {
            if (defaultValue) {
                result[i][j] = defaultValue;
            }
            else {
                result[i][j] = 0;
            }
        }
    }
    return result;
}
function buildSbox() {
    return [
        [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76],
        [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0],
        [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15],
        [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75],
        [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84],
        [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf],
        [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8],
        [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2],
        [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73],
        [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb],
        [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79],
        [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08],
        [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a],
        [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e],
        [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf],
        [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]
    ];
}
function buildInvSbox() {
    return [
        [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb],
        [0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb],
        [0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e],
        [0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25],
        [0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92],
        [0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84],
        [0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06],
        [0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b],
        [0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73],
        [0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e],
        [0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b],
        [0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4],
        [0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f],
        [0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef],
        [0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61],
        [0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]
    ];
}
function buildRcon() {
    return [
        [0x00, 0x00, 0x00, 0x00],
        [0x01, 0x00, 0x00, 0x00],
        [0x02, 0x00, 0x00, 0x00],
        [0x04, 0x00, 0x00, 0x00],
        [0x08, 0x00, 0x00, 0x00],
        [0x10, 0x00, 0x00, 0x00],
        [0x20, 0x00, 0x00, 0x00],
        [0x40, 0x00, 0x00, 0x00],
        [0x80, 0x00, 0x00, 0x00],
        [0x1b, 0x00, 0x00, 0x00],
        [0x36, 0x00, 0x00, 0x00]
    ];
}
function keyExpansion(nb, nr, nk, key, rcon, sbox) {
    var w = create2DArray(nb * (nr + 1), 4, 0);
    for (var row = 0; row < nk; ++row) {
        w[row][0] = key[4 * row];
        w[row][1] = key[4 * row + 1];
        w[row][2] = key[4 * row + 2];
        w[row][3] = key[4 * row + 3];
    }
    var temp = [];
    for (var row = nk; row < nb * (nr + 1); ++row) {
        temp[0] = w[row - 1][0];
        temp[1] = w[row - 1][1];
        temp[2] = w[row - 1][2];
        temp[3] = w[row - 1][3];
        if (row % nk === 0) {
            temp = subWord(rotWord(temp), sbox);
            var t = rcon[parseInt(row / nk, 10)];
            temp[0] = (temp[0] ^ t[0]) % 256;
            temp[1] = (temp[1] ^ t[1]) % 256;
            temp[2] = (temp[2] ^ t[2]) % 256;
            temp[3] = (temp[3] ^ t[3]) % 256;
        }
        else if (nk > 6 && (row % nk === 4)) {
            temp = subWord(temp);
        }
        w[row][0] = (w[row - nk][0] ^ temp[0]) % 256;
        w[row][1] = (w[row - nk][1] ^ temp[1]) % 256;
        w[row][2] = (w[row - nk][2] ^ temp[2]) % 256;
        w[row][3] = (w[row - nk][3] ^ temp[3]) % 256;
    }
    return w;
}
function subWord(word, sbox) {
    var result = [];
    result[0] = sbox[word[0] >> 4][word[0] & 0x0f];
    result[1] = sbox[word[1] >> 4][word[1] & 0x0f];
    result[2] = sbox[word[2] >> 4][word[2] & 0x0f];
    result[3] = sbox[word[3] >> 4][word[3] & 0x0f];
    return result;
}
function rotWord(word) {
    var result = [];
    result[0] = word[1];
    result[1] = word[2];
    result[2] = word[3];
    result[3] = word[0];
    return result;
}
function gfmultby01(b) {
    return b;
}
function gfmultby02(b) {
    if (b < 0x80) {
        return (b << 1) % 256;
    }
    return ((b << 1) ^ (0x1b)) % 256;
}
function gfmultby03(b) {
    return (gfmultby02(b) ^ b) % 256;
}
function gfmultby09(b) {
    return (gfmultby02(gfmultby02(gfmultby02(b))) ^ b) % 256;
}
function gfmultby0b(b) {
    return (gfmultby02(gfmultby02(gfmultby02(b))) ^ gfmultby02(b) ^ b) % 256;
}
function gfmultby0d(b) {
    return (gfmultby02(gfmultby02(gfmultby02(b))) ^ gfmultby02(gfmultby02(b)) ^ (b)) % 256;
}
function gfmultby0e(b) {
    return (gfmultby02(gfmultby02(gfmultby02(b))) ^ gfmultby02(gfmultby02(b)) ^ gfmultby02(b)) % 256;
}
function stgGenerateRootEntry(customSectID) {
    var view = [];
    for (var i = 0; i < 128; i++) {
        view[i] = 0;
    }
    view._pos = 0;
    var rootWriter = writer(view);
    rootWriter.writeBytes(stringToByteArray("Root Entry"));
    rootWriter.seek(0x40, seekOrigin.Begin);
    rootWriter.writeShort(0x16);
    rootWriter.writeByte(5);
    rootWriter.writeByte(0);
    rootWriter.writeInt(-1);
    rootWriter.writeInt(-1);
    rootWriter.writeInt(1);
    rootWriter.seek(0x64, seekOrigin.Begin);
    rootWriter.writeInt(0);
    rootWriter.writeInt(0);
    rootWriter.writeInt(0);
    rootWriter.writeInt(0);
    rootWriter.writeInt(customSectID);
    rootWriter.writeInt(0x340);
    return rootWriter.getView();
}
function stgGenerateEncryptionInfo() {
    var view = [];
    for (var i = 0; i < 128; i++) {
        view[i] = 0;
    }
    view._pos = 0;
    var enInfoWriter = writer(view);
    enInfoWriter.writeBytes(stringToByteArray("EncryptionInfo"));
    enInfoWriter.seek(0x40, seekOrigin.Begin);
    enInfoWriter.writeShort(0x1E);
    enInfoWriter.writeByte(2);
    enInfoWriter.writeByte(1);
    enInfoWriter.writeInt(0x03);
    enInfoWriter.writeInt(0x02);
    enInfoWriter.writeInt(-1);
    enInfoWriter.seek(0x64, seekOrigin.Begin);
    enInfoWriter.writeInt(0);
    enInfoWriter.writeInt(0);
    enInfoWriter.writeInt(0);
    enInfoWriter.writeInt(0);
    enInfoWriter.writeInt(0);
    enInfoWriter.writeInt(0xF8);
    return enInfoWriter.getView();
}
function stgGenerateEncryptedPackage(propertyCount, size) {
    var view = [];
    for (var i = 0; i < 128; i++) {
        view[i] = 0;
    }
    view._pos = 0;
    var enPackageWriter = writer(view);
    enPackageWriter.writeBytes(stringToByteArray("EncryptedPackage"));
    enPackageWriter.seek(0x40, seekOrigin.Begin);
    enPackageWriter.writeShort(0x22);
    enPackageWriter.writeByte(2);
    enPackageWriter.writeByte(0);
    enPackageWriter.writeInt(-1);
    enPackageWriter.writeInt(-1);
    enPackageWriter.writeInt(-1);
    enPackageWriter.seek(0x64, seekOrigin.Begin);
    enPackageWriter.writeInt(0);
    enPackageWriter.writeInt(0);
    enPackageWriter.writeInt(0);
    enPackageWriter.writeInt(0);
    enPackageWriter.writeInt(propertyCount);
    enPackageWriter.writeInt(size);
    return enPackageWriter.getView();
}
function stgGenerateDataSpaces() {
    var view = [];
    for (var i = 0; i < 128; i++) {
        view[i] = 0;
    }
    view._pos = 0;
    var dataSpaceWriter = writer(view);
    dataSpaceWriter.writeShort(0x06);
    dataSpaceWriter.writeBytes(stringToByteArray("DataSpaces"));
    dataSpaceWriter.seek(0x40, seekOrigin.Begin);
    dataSpaceWriter.writeShort(0x18);
    dataSpaceWriter.writeByte(1);
    dataSpaceWriter.writeByte(0);
    dataSpaceWriter.writeInt(-1);
    dataSpaceWriter.writeInt(-1);
    dataSpaceWriter.writeInt(5);
    dataSpaceWriter.seek(0x64, seekOrigin.Begin);
    dataSpaceWriter.writeInt(0);
    dataSpaceWriter.writeInt(0);
    dataSpaceWriter.writeInt(0);
    dataSpaceWriter.writeInt(0);
    dataSpaceWriter.writeInt(0);
    dataSpaceWriter.writeInt(0);
    return dataSpaceWriter.getView();
}
function stgGenerateVersion() {
    var view = [];
    for (var i = 0; i < 128; i++) {
        view[i] = 0;
    }
    view._pos = 0;
    var versionWriter = writer(view);
    versionWriter.writeBytes(stringToByteArray("Version"));
    versionWriter.seek(0x40, seekOrigin.Begin);
    versionWriter.writeShort(0x10);
    versionWriter.writeByte(2);
    versionWriter.writeByte(1);
    versionWriter.writeInt(-1);
    versionWriter.writeInt(-1);
    versionWriter.writeInt(-1);
    versionWriter.seek(0x64, seekOrigin.Begin);
    versionWriter.writeInt(0);
    versionWriter.writeInt(0);
    versionWriter.writeInt(0);
    versionWriter.writeInt(0);
    versionWriter.writeInt(4);
    versionWriter.writeInt(76);
    return versionWriter.getView();
}
function stgGenerateDataSpaceMap() {
    var view = [];
    for (var i = 0; i < 128; i++) {
        view[i] = 0;
    }
    view._pos = 0;
    var dataSpaceMapWriter = writer(view);
    dataSpaceMapWriter.writeBytes(stringToByteArray("DataSpaceMap"));
    dataSpaceMapWriter.seek(0x40, seekOrigin.Begin);
    dataSpaceMapWriter.writeShort(0x1A);
    dataSpaceMapWriter.writeByte(2);
    dataSpaceMapWriter.writeByte(1);
    dataSpaceMapWriter.writeInt(0x04);
    dataSpaceMapWriter.writeInt(0x06);
    dataSpaceMapWriter.writeInt(-1);
    dataSpaceMapWriter.seek(0x64, seekOrigin.Begin);
    dataSpaceMapWriter.writeInt(0);
    dataSpaceMapWriter.writeInt(0);
    dataSpaceMapWriter.writeInt(0);
    dataSpaceMapWriter.writeInt(0);
    dataSpaceMapWriter.writeInt(6);
    dataSpaceMapWriter.writeInt(112);
    return dataSpaceMapWriter.getView();
}
function stgGenerateDataSpaceInfo() {
    var view = [];
    for (var i = 0; i < 128; i++) {
        view[i] = 0;
    }
    view._pos = 0;
    var dataSpaceInfoWriter = writer(view);
    dataSpaceInfoWriter.writeBytes(stringToByteArray("DataSpaceInfo"));
    dataSpaceInfoWriter.seek(0x40, seekOrigin.Begin);
    dataSpaceInfoWriter.writeShort(0x1C);
    dataSpaceInfoWriter.writeByte(1);
    dataSpaceInfoWriter.writeByte(1);
    dataSpaceInfoWriter.writeInt(-1);
    dataSpaceInfoWriter.writeInt(8);
    dataSpaceInfoWriter.writeInt(7);
    dataSpaceInfoWriter.seek(0x64, seekOrigin.Begin);
    dataSpaceInfoWriter.writeInt(0);
    dataSpaceInfoWriter.writeInt(0);
    dataSpaceInfoWriter.writeInt(0);
    dataSpaceInfoWriter.writeInt(0);
    dataSpaceInfoWriter.writeInt(0);
    dataSpaceInfoWriter.writeInt(0);
    return dataSpaceInfoWriter.getView();
}
function stgGenerateStrongEncryptionDataSpace() {
    var view = [];
    for (var i = 0; i < 128; i++) {
        view[i] = 0;
    }
    view._pos = 0;
    var senDataSpaceWriter = writer(view);
    senDataSpaceWriter.writeBytes(stringToByteArray("StrongEncryptionDataSpace"));
    senDataSpaceWriter.seek(0x40, seekOrigin.Begin);
    senDataSpaceWriter.writeShort(0x34);
    senDataSpaceWriter.writeByte(2);
    senDataSpaceWriter.writeByte(1);
    senDataSpaceWriter.writeInt(-1);
    senDataSpaceWriter.writeInt(-1);
    senDataSpaceWriter.writeInt(-1);
    senDataSpaceWriter.seek(0x64, seekOrigin.Begin);
    senDataSpaceWriter.writeInt(0);
    senDataSpaceWriter.writeInt(0);
    senDataSpaceWriter.writeInt(0);
    senDataSpaceWriter.writeInt(0);
    senDataSpaceWriter.writeInt(8);
    senDataSpaceWriter.writeInt(64);
    return senDataSpaceWriter.getView();
}
function stgGenerateTransformInfo() {
    var view = [];
    for (var i = 0; i < 128; i++) {
        view[i] = 0;
    }
    view._pos = 0;
    var transformInfoWriter = writer(view);
    transformInfoWriter.writeBytes(stringToByteArray("TransformInfo"));
    transformInfoWriter.seek(0x40, seekOrigin.Begin);
    transformInfoWriter.writeShort(0x1C);
    transformInfoWriter.writeByte(1);
    transformInfoWriter.writeByte(0);
    transformInfoWriter.writeInt(-1);
    transformInfoWriter.writeInt(-1);
    transformInfoWriter.writeInt(9);
    transformInfoWriter.seek(0x64, seekOrigin.Begin);
    transformInfoWriter.writeInt(0);
    transformInfoWriter.writeInt(0);
    transformInfoWriter.writeInt(0);
    transformInfoWriter.writeInt(0);
    transformInfoWriter.writeInt(0);
    transformInfoWriter.writeInt(0);
    return transformInfoWriter.getView();
}
function stgGenerateStrongEncryptionTransform() {
    var view = [];
    for (var i = 0; i < 128; i++) {
        view[i] = 0;
    }
    view._pos = 0;
    var seTransformWriter = writer(view);
    seTransformWriter.writeBytes(stringToByteArray("StrongEncryptionTransform"));
    seTransformWriter.seek(0x40, seekOrigin.Begin);
    seTransformWriter.writeShort(0x34);
    seTransformWriter.writeByte(1);
    seTransformWriter.writeByte(1);
    seTransformWriter.writeInt(-1);
    seTransformWriter.writeInt(-1);
    seTransformWriter.writeInt(0x0A);
    seTransformWriter.seek(0x64, seekOrigin.Begin);
    seTransformWriter.writeInt(0);
    seTransformWriter.writeInt(0);
    seTransformWriter.writeInt(0);
    seTransformWriter.writeInt(0);
    seTransformWriter.writeInt(0);
    seTransformWriter.writeInt(0);
    return seTransformWriter.getView();
}
function stgGeneratePrimary() {
    var view = [];
    for (var i = 0; i < 128; i++) {
        view[i] = 0;
    }
    view._pos = 0;
    var primaryWriter = writer(view);
    primaryWriter.writeShort(0x06);
    primaryWriter.writeBytes(stringToByteArray("Primary"));
    primaryWriter.seek(0x40, seekOrigin.Begin);
    primaryWriter.writeShort(0x12);
    primaryWriter.writeByte(2);
    primaryWriter.writeByte(1);
    primaryWriter.writeInt(-1);
    primaryWriter.writeInt(-1);
    primaryWriter.writeInt(-1);
    primaryWriter.seek(0x64, seekOrigin.Begin);
    primaryWriter.writeInt(0);
    primaryWriter.writeInt(0);
    primaryWriter.writeInt(0);
    primaryWriter.writeInt(0);
    primaryWriter.writeInt(9);
    primaryWriter.writeInt(208);
    return primaryWriter.getView();
}
function stgGenerateNoneDir() {
    var view = [];
    for (var i = 0; i < 128; i++) {
        view[i] = 0;
    }
    view._pos = 0;
    var noneWriter = writer(view);
    noneWriter.seek(0x40, seekOrigin.Begin);
    noneWriter.writeShort(0x00);
    noneWriter.writeShort(0x00);
    noneWriter.writeInt(-1);
    noneWriter.writeInt(-1);
    noneWriter.writeInt(-1);
    return noneWriter.getView();
}
function stgGenerateDirectoryEntry(propertyCount, customSectID, size) {
    var view = [];
    view._pos = 0;
    var dirEntryStream = writer(view);
    if (size < 0) {
        size = 0;
    }
    var rootEntry = stgGenerateRootEntry(customSectID);
    dirEntryStream.writeBytes(rootEntry);
    var encryptionInfoEntry = stgGenerateEncryptionInfo();
    dirEntryStream.writeBytes(encryptionInfoEntry);
    var enPackageEntry = stgGenerateEncryptedPackage(propertyCount, size);
    dirEntryStream.writeBytes(enPackageEntry);
    var dataSpace = stgGenerateDataSpaces();
    dirEntryStream.writeBytes(dataSpace);
    var version = stgGenerateVersion();
    dirEntryStream.writeBytes(version);
    var dataSpaceMap = stgGenerateDataSpaceMap();
    dirEntryStream.writeBytes(dataSpaceMap);
    var dataSpaceInfo = stgGenerateDataSpaceInfo();
    dirEntryStream.writeBytes(dataSpaceInfo);
    var sedataSpace = stgGenerateStrongEncryptionDataSpace();
    dirEntryStream.writeBytes(sedataSpace);
    var transformInfo = stgGenerateTransformInfo();
    dirEntryStream.writeBytes(transformInfo);
    var seTransform = stgGenerateStrongEncryptionTransform();
    dirEntryStream.writeBytes(seTransform);
    var primary = stgGeneratePrimary();
    dirEntryStream.writeBytes(primary);
    var none = stgGenerateNoneDir();
    dirEntryStream.writeBytes(none);
    return dirEntryStream.getView();
}
function stgGenerateVersionStream() {
    var view = [];
    view._pos = 0;
    var versionWrite = writer(view);
    versionWrite.writeInt(0x3c);
    versionWrite.writeBytes(stringToByteArray("Microsoft.Container.DataSpaces"));
    versionWrite.writeInt(0x01);
    versionWrite.writeInt(0x01);
    versionWrite.writeInt(0x01);
    return versionWrite.getView();
}
function stgGenarateDataSpaceMapStream() {
    var view = [];
    view._pos = 0;
    var dataSpaceMapWrite = writer(view);
    dataSpaceMapWrite.writeUint(0x08);
    dataSpaceMapWrite.writeUint(0x01);
    dataSpaceMapWrite.writeUint(0x68);
    dataSpaceMapWrite.writeUint(0x01);
    dataSpaceMapWrite.writeUint(0x00);
    dataSpaceMapWrite.writeUint(0x20);
    dataSpaceMapWrite.writeBytes(stringToByteArray("EncryptedPackage"));
    dataSpaceMapWrite.writeUint(0x32);
    dataSpaceMapWrite.writeBytes(stringToByteArray("StrongEncryptionDataSpace"));
    dataSpaceMapWrite.writeShort(0x00);
    return dataSpaceMapWrite.getView();
}
function stgGenarateStrongEncryptionDataSpaceStream() {
    var view = [];
    view._pos = 0;
    var sEptDataSpaceWrite = writer(view);
    sEptDataSpaceWrite.writeUint(0x08);
    sEptDataSpaceWrite.writeUint(0x01);
    sEptDataSpaceWrite.writeUint(0x32);
    sEptDataSpaceWrite.writeBytes(stringToByteArray("StrongEncryptionTransform"));
    sEptDataSpaceWrite.writeShort(0x00);
    return sEptDataSpaceWrite.getView();
}
function stgGenaratePrimaryStream() {
    var view = [];
    view._pos = 0;
    var primaryWrite = writer(view);
    primaryWrite.writeUint(0x6C);
    primaryWrite.writeUint(0x01);
    primaryWrite.writeInt(0x4C);
    primaryWrite.writeBytes(stringToByteArray("{FF9A3F03-56EF-4613-BDD5-5A41C1D07246}"));
    primaryWrite.writeInt(0x4E);
    primaryWrite.writeBytes(stringToByteArray("Microsoft.Container.EncryptionTransform"));
    primaryWrite.writeShort(0x00);
    primaryWrite.writeInt(0x01);
    primaryWrite.writeInt(0x01);
    primaryWrite.writeInt(0x01);
    primaryWrite.writeInt(0x07);
    primaryWrite.writeBytes(stringToByteArray("AES128"));
    primaryWrite.writeByte(0);
    primaryWrite.writeInt(0x10);
    primaryWrite.writeInt(0x00);
    primaryWrite.writeInt(0x04);
    return primaryWrite.getView();
}
function stgGenerateCustomFileStream(encStreamInfo, ssatList) {
    var view = [];
    view._pos = 0;
    var customFile = writer(view);
    var miniPropertyCount = 0;
    var encStream = new Array(0x100);
    if (encStreamInfo !== null) {
        arrayCopy(encStreamInfo, 0, encStream, 0, encStreamInfo.length);
    }
    customFile.writeBytes(encStream);
    var encStreamBlockCount = parseInt(encStream.length / 64, 10);
    if (encStream.length % 64 > 0) {
        encStreamBlockCount++;
    }
    for (var i = 1; i < encStreamBlockCount; i++) {
        ssatList.push(i);
    }
    ssatList.push(-2);
    miniPropertyCount += encStreamBlockCount;
    var versionStream = new Array(0x80);
    var version = stgGenerateVersionStream();
    arrayCopy(version, 0, versionStream, 0, version.length);
    customFile.writeBytes(versionStream);
    var versionBlockCount = parseInt(versionStream.length / 64, 10);
    if (versionStream.length % 64 > 0) {
        versionBlockCount++;
    }
    for (var i = 1; i < versionBlockCount; i++) {
        ssatList.push(i + miniPropertyCount);
    }
    ssatList.push(-2);
    miniPropertyCount += versionBlockCount;
    var dataSpaceMap = new Array(0x80);
    var datasm = stgGenarateDataSpaceMapStream();
    arrayCopy(datasm, 0, dataSpaceMap, 0, datasm.length);
    customFile.writeBytes(dataSpaceMap);
    var dataSpaceMapBlockCount = parseInt(dataSpaceMap.length / 64, 10);
    if (dataSpaceMap.length % 64 > 0) {
        dataSpaceMapBlockCount++;
    }
    for (var i = 1; i < dataSpaceMapBlockCount; i++) {
        ssatList.push(i + miniPropertyCount);
    }
    ssatList.push(-2);
    miniPropertyCount += dataSpaceMapBlockCount;
    var seDataSpace = stgGenarateStrongEncryptionDataSpaceStream();
    customFile.writeBytes(seDataSpace);
    var seDataSpaceBlockCount = parseInt(seDataSpace.length / 64, 10);
    if (seDataSpace.length % 64 > 0) {
        seDataSpaceBlockCount++;
    }
    for (var i = 1; i < seDataSpaceBlockCount; i++) {
        ssatList.push(i + miniPropertyCount);
    }
    ssatList.push(-2);
    miniPropertyCount += seDataSpaceBlockCount;
    var primaryStream = new Array(0x1C0);
    var primary = stgGenaratePrimaryStream();
    arrayCopy(primary, 0, primaryStream, 0, primary.length);
    customFile.writeBytes(primaryStream);
    var primaryBlockCount = parseInt(primary.length / 64, 10);
    if (primary.length % 64 > 0) {
        primaryBlockCount++;
    }
    for (var i = 1; i < primaryBlockCount; i++) {
        ssatList.push(i + miniPropertyCount);
    }
    ssatList.push(-2);
    if (ssatList.length < 128) {
        for (var i = ssatList.length; i < 128; i++) {
            ssatList.push(-1);
        }
    }
    customFile.seek(0, seekOrigin.Begin);
    return customFile.getView();
}
function addRoundKey(round, state, w) {
    for (var r = 0; r < 4; ++r) {
        for (var c = 0; c < 4; ++c) {
            state[r][c] = (state[r][c] ^ w[(round * 4) + c][r]) % 256;
        }
    }
    return state;
}
function shiftRows(state, nb) {
    var temp = create2DArray(4, 4, 0);
    for (var r = 0; r < 4; ++r) {
        for (var c = 0; c < 4; ++c) {
            temp[r][c] = state[r][c];
        }
    }
    for (var r = 1; r < 4; ++r) {
        for (var c = 0; c < 4; ++c) {
            state[r][c] = temp[r][(c + r) % nb];
        }
    }
    return state;
}
function mixColumns(state) {
    var temp = create2DArray(4, 4, 0);
    for (var r = 0; r < 4; ++r) {
        for (var c = 0; c < 4; ++c) {
            temp[r][c] = state[r][c];
        }
    }
    for (var c = 0; c < 4; ++c) {
        state[0][c] = (gfmultby02(temp[0][c]) ^ gfmultby03(temp[1][c]) ^ gfmultby01(temp[2][c]) ^ gfmultby01(temp[3][c])) % 256;
        state[1][c] = (gfmultby01(temp[0][c]) ^ gfmultby02(temp[1][c]) ^ gfmultby03(temp[2][c]) ^ gfmultby01(temp[3][c])) % 256;
        state[2][c] = (gfmultby01(temp[0][c]) ^ gfmultby01(temp[1][c]) ^ gfmultby02(temp[2][c]) ^ gfmultby03(temp[3][c])) % 256;
        state[3][c] = (gfmultby03(temp[0][c]) ^ gfmultby01(temp[1][c]) ^ gfmultby01(temp[2][c]) ^ gfmultby02(temp[3][c])) % 256;
    }
    return state;
}
function subBytes(state, sbox) {
    for (var r = 0; r < 4; ++r) {
        for (var c = 0; c < 4; ++c) {
            state[r][c] = sbox[(state[r][c] >> 4)][(state[r][c] & 0x0f)];
        }
    }
    return state;
}
var keyType = {
    Bits128: 'Bits128',
    Bits192: 'Bits192',
    Bits256: 'Bits256'
};
var AesEngine = /** @class */ (function () {
    function AesEngine() {
        this.salt = new Array(16);
        this.pwdVerifier = new Array(16);
        this.pwdVerifierHash = new Array(32);
        this.blockLen = 16;
        this._isAgileEncrypt = false;
        this.hashAlgorithm = "SHA1";
        this.cipherChaining = "ChainingModeCBC";
        this.cipherAlgorithm = "AES";
        this.iterator = 100000;
        this.blockSize = 16;
        this.keyBits = 128;
        this.saltSize = 16;
        this.hashSize = 20;
        this.encryptedKeyValueBlockKey = [0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6];
        this.encryptedVerifierHashInputBlockKey = [0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79];
        this.encryptedVerifierHashValueBlockKey = [0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e];
    }
    AesEngine.prototype._progressStream = function (view) {
        view._pos = 0;
        var read = reader(view);
        var vMajor = read.readInt16();
        var vMinor = read.readInt16();
        if ((vMajor === 0x0003 || vMajor === 0x0004) && vMinor === 0x0002) {
            read.seek(0x08, seekOrigin.Begin);
            var length_1 = read.readUInt32() + 12;
            read.seek(0x1C, seekOrigin.Begin);
            var key = read.readInt32();
            if (key === 128) {
                this.keySize = keyType.Bits128;
            }
            else if (key === 192) {
                this.keySize = keyType.Bits192;
            }
            else if (key === 256) {
                this.keySize = keyType.Bits256;
            }
            read.seek(length_1, seekOrigin.Begin);
            var saltSize = read.readInt32();
            length_1 += 4;
            read.seek(length_1, seekOrigin.Begin);
            this.salt = read.readBytes(saltSize);
            length_1 += saltSize;
            read.seek(length_1, seekOrigin.Begin);
            this.pwdVerifier = read.readBytes(saltSize);
            length_1 += saltSize;
            read.seek(length_1, seekOrigin.Begin);
            read.readInt32();
            length_1 += 4;
            read.seek(length_1, seekOrigin.Begin);
            this.pwdVerifierHash = read.readBytes(saltSize * 2);
            return true;
        }
        else if (vMajor === 0x0004 && vMinor === 0x0004) {
            var reserved = read.readUInt32();
            if (reserved === 0x40) {
                var buffer = read.readBytes(view.length - 8);
                if (buffer !== null) {
                    var obj = xml_parser_1.parseXmlToObject(String.fromCharCode.apply(null, buffer));
                    var encryption_1 = {};
                    var rootNode = obj.encryption;
                    var keyEncryptors_1 = [];
                    var keyDataNode = rootNode.keyData;
                    var keyData = {};
                    keyData.SaltSize = keyDataNode._attr.saltSize ? keyDataNode._attr.saltSize : 16;
                    keyData.BlockSize = keyDataNode._attr.blockSize ? keyDataNode._attr.blockSize : 16;
                    keyData.KeyBits = keyDataNode._attr.keyBits ? keyDataNode._attr.keyBits : 128;
                    keyData.HashSize = keyDataNode._attr.hashSize ? keyDataNode._attr.hashSize : 20;
                    keyData.CipherAlgorithm = keyDataNode._attr.cipherAlgorithm ? keyDataNode._attr.cipherAlgorithm : "AES";
                    keyData.CipherChaining = keyDataNode._attr.cipherChaining ? keyDataNode._attr.cipherChaining : 'ChainingModeCBC';
                    keyData.HashAlgorithm = keyDataNode._attr.hashAlgorithm ? keyDataNode._attr.hashAlgorithm : "SHA1";
                    keyData.SaltValue = base64ToBytes(keyDataNode._attr.saltValue);
                    encryption_1.KeyData = keyData;
                    var dataIntegrityNode = rootNode.dataIntegrity;
                    var dataIntegrity = {};
                    dataIntegrity.EncryptedHmacKey = dataIntegrityNode._attr.encryptedHmacKey;
                    dataIntegrity.EncryptedHmacValue = dataIntegrityNode._attr.encryptedHmacValue;
                    encryption_1.DataIntegrity = dataIntegrity;
                    var keyEncryptorsNode = rootNode.keyEncryptors;
                    var keyEncrptor_1 = {};
                    keyEncrptor_1.Uri = keyEncryptorsNode._attr.uri ? keyEncryptorsNode._attr.uri : "http://schemas.microsoft.com/office/2006/keyEncryptor/password";
                    keyEncrptor_1.Any = {};
                    var keyEncryptorNode = getAsArray(keyEncryptorsNode.keyEncryptor);
                    if (keyEncryptorNode && keyEncryptorNode.length) {
                        keyEncryptorNode.forEach(function (node) {
                            var encryptedKeyNode = node['p:encryptedKey'];
                            keyEncrptor_1.Any.SpinCount = encryptedKeyNode._attr.spinCount ? encryptedKeyNode._attr.spinCount : 100000;
                            keyEncrptor_1.Any.SaltSize = encryptedKeyNode._attr.saltSize ? encryptedKeyNode._attr.saltSize : 16;
                            keyEncrptor_1.Any.BlockSize = encryptedKeyNode._attr.blockSize ? encryptedKeyNode._attr.blockSize : 16;
                            keyEncrptor_1.Any.KeyBits = encryptedKeyNode._attr.keyBits ? encryptedKeyNode._attr.keyBits : 128;
                            keyEncrptor_1.Any.HashSize = encryptedKeyNode._attr.hashSize ? encryptedKeyNode._attr.hashSize : 20;
                            keyEncrptor_1.Any.CipherAlgorithm = encryptedKeyNode._attr.cipherAlgorithm ? encryptedKeyNode._attr.cipherAlgorithm : "AES";
                            keyEncrptor_1.Any.CipherChaining = encryptedKeyNode._attr.cipherChaining ? encryptedKeyNode._attr.cipherChaining : "ChainingModeCBC";
                            keyEncrptor_1.Any.HashAlgorithm = encryptedKeyNode._attr.hashAlgorithm ? encryptedKeyNode._attr.hashAlgorithm : "SHA1";
                            keyEncrptor_1.Any.SaltValue = base64ToBytes(encryptedKeyNode._attr.saltValue);
                            keyEncrptor_1.Any.EncryptedVerifierHashInput = base64ToBytes(encryptedKeyNode._attr.encryptedVerifierHashInput);
                            keyEncrptor_1.Any.EncryptedVerifierHashValue = base64ToBytes(encryptedKeyNode._attr.encryptedVerifierHashValue);
                            keyEncrptor_1.Any.EncryptedKeyValue = base64ToBytes(encryptedKeyNode._attr.encryptedKeyValue);
                            keyEncryptors_1.push(keyEncrptor_1);
                            encryption_1.KeyEncryptors = keyEncryptors_1;
                        });
                    }
                    var passKeyEncrypt = encryption_1.KeyEncryptors[0].Any;
                    this.iterator = parseInt(passKeyEncrypt.SpinCount, 10);
                    this.blockSize = passKeyEncrypt.BlockSize;
                    this.saltSize = passKeyEncrypt.SaltSize;
                    this.hashSize = passKeyEncrypt.HashSize;
                    this.keyBits = passKeyEncrypt.KeyBits;
                    this.hashAlgorithm = passKeyEncrypt.HashAlgorithm;
                    this.cipherAlgorithm = passKeyEncrypt.CipherAlgorithm;
                    this.cipherChaining = passKeyEncrypt.CipherChaining;
                    this.encryptedKeyValue = passKeyEncrypt.EncryptedKeyValue;
                    this.encryptedVerifierHashInput = passKeyEncrypt.EncryptedVerifierHashInput;
                    this.encryptedVerifierHashValue = passKeyEncrypt.EncryptedVerifierHashValue;
                    this.salt = passKeyEncrypt.SaltValue;
                    this.saltForIV = encryption_1.KeyData.SaltValue;
                    this._isAgileEncrypt = true;
                    return this.cipherAlgorithm === "AES";
                }
            }
        }
        return false;
    };
    AesEngine.prototype._agileVerifyPassWord = function (passWord) {
        this.userPassWord = passWord;
        var iv = this._agileInitializationVector(this.salt, null, this.blockSize);
        var encryptionKey = this._agileEncryptionKeyCreateKey(passWord, this.encryptedVerifierHashInputBlockKey, this.salt);
        var tmp = this._agileDecrypt(this.saltSize, encryptionKey, this.encryptedVerifierHashInput, iv);
        if (this.hashAlgorithm === "SHA1") {
            tmp = Sha1.hash(tmp);
        }
        else {
            tmp = Sha.hash(tmp);
        }
        var hashInput = new Array(this.saltSize);
        arrayCopy(tmp, 0, hashInput, 0, this.saltSize);
        encryptionKey = this._agileEncryptionKeyCreateKey(passWord, this.encryptedVerifierHashValueBlockKey, this.salt);
        var hashValue = this._agileEncrypt(hashInput, encryptionKey, iv);
        var length = this.encryptedVerifierHashValue.length;
        if (length > hashValue.length) {
            length = hashValue.length;
        }
        for (var i = 0; i < length; i++) {
            if (hashValue[i] !== this.encryptedVerifierHashValue[i]) {
                return false;
            }
        }
        return true;
    };
    AesEngine.prototype._agileEncrypt = function (unEncryptedBytes, encryptionKey, initVectorBytes) {
        var aesCbc = new aes_1.aesJS.ModeOfOperation.cbc(encryptionKey, initVectorBytes);
        return aesCbc.encrypt(unEncryptedBytes);
    };
    AesEngine.prototype._agileDecrypt = function (unEncryptedLength, encryptionKey, encryptedBytes, iv) {
        var decryptedBytes = null;
        var aseBuffer = [];
        var subAseBuffer;
        var blockStartIndex = 0;
        var blockUnit = 4096;
        var blockCount = parseInt(encryptedBytes.length / blockUnit, 10);
        var uIv;
        for (var i = 0; i < blockCount; i++) {
            if (!iv) {
                uIv = this._agileInitializationVector(this.saltForIV, getBytesFromInt(4, i), this.blockSize);
            }
            else {
                uIv = iv;
            }
            var aesCbc = new aes_1.aesJS.ModeOfOperation.cbc(encryptionKey, uIv);
            subAseBuffer = aesCbc.decrypt(common_1.BufferHelper._slice(encryptedBytes, blockStartIndex, blockStartIndex + blockUnit));
            arrayCopy(subAseBuffer, 0, aseBuffer, blockStartIndex, blockUnit);
            blockStartIndex += blockUnit;
        }
        var byteLeft = encryptedBytes.length % blockUnit;
        if (byteLeft > 0) {
            if (!iv) {
                uIv = this._agileInitializationVector(this.saltForIV, getBytesFromInt(4, blockCount), this.blockSize);
            }
            else {
                uIv = iv;
            }
            var aesCbc = new aes_1.aesJS.ModeOfOperation.cbc(encryptionKey, uIv);
            subAseBuffer = aesCbc.decrypt(common_1.BufferHelper._slice(encryptedBytes, blockStartIndex, blockStartIndex + byteLeft));
            arrayCopy(subAseBuffer, 0, aseBuffer, blockStartIndex, byteLeft);
        }
        decryptedBytes = new Array(unEncryptedLength);
        arrayCopy(aseBuffer, 0, decryptedBytes, 0, unEncryptedLength);
        return decryptedBytes;
    };
    AesEngine.prototype._agileInitializationVector = function (keySalt, blockKey, ivSize) {
        var tmp = keySalt;
        if (blockKey !== null) {
            tmp = hashByte(tmp, blockKey, this.hashAlgorithm);
        }
        ivSize = +ivSize;
        var iv = new Uint8Array(ivSize);
        var ivLength = tmp.length;
        arrayCopy(tmp, 0, iv, 0, Math.min(ivSize, ivLength));
        for (var i = ivLength; i < ivSize; i++) {
            iv[i] = 0x36;
        }
        return iv;
    };
    AesEngine.prototype._agileEncryptionKeyCreateKey = function (passWord, blockKey, saltValue) {
        var pwd = getBytesFromString(passWord);
        var tmp = hashByte(saltValue, pwd, this.hashAlgorithm);
        for (var i = 0; i < this.iterator; i++) {
            var tmpI = getBytesFromInt(4, i);
            tmp = hashByte(tmpI, tmp, this.hashAlgorithm);
        }
        tmp = hashByte(tmp, blockKey, this.hashAlgorithm);
        var keyBytes = this.keyBits / 8;
        var encryptionKey = [];
        var keyLength = tmp.length;
        var minValue = Math.min(keyLength, keyBytes);
        for (var k = 0; k < minValue; k++) {
            encryptionKey[k] = tmp[k];
        }
        for (var i = keyLength; i < keyBytes; i++) {
            encryptionKey[i] = 54;
        }
        return encryptionKey;
    };
    AesEngine.prototype._agileDecryptStream = function (view) {
        var result = { success: false };
        if (view === null) {
            return result;
        }
        view._pos = 0;
        var read = reader(view);
        var length = read.readUInt64();
        var encryptedBytes = read.readBytes(view.length - 8);
        this._agileIntermediateKeyCreateKey(this.userPassWord);
        var decryptedBytes = this._agileDecrypt(length, this.key, encryptedBytes, null);
        if (decryptedBytes !== null) {
            result.data = decryptedBytes;
            result.success = true;
        }
        return result;
    };
    AesEngine.prototype._agileIntermediateKeyCreateKey = function (passWord) {
        var encryptionKey = this._agileEncryptionKeyCreateKey(passWord, this.encryptedKeyValueBlockKey, this.salt);
        var iv = this._agileInitializationVector(this.salt, null, this.blockSize);
        var keyBytes = this.keyBits / 8;
        this.key = this._agileDecrypt(keyBytes, encryptionKey, this.encryptedKeyValue, iv);
    };
    AesEngine.prototype._decryptStream = function (inStream) {
        if (!inStream) {
            return false;
        }
        inStream._pos = 0;
        var read = reader(inStream);
        var length = read.readInt64();
        var encsuffer = read.readBytes(inStream.length - 8);
        var biffBuffer = null;
        var aesCbc = new aes_1.aesJS.ModeOfOperation.ecb(this.key);
        var aseBuffer = aesCbc.decrypt(encsuffer);
        var buf = new Array(length);
        if (aseBuffer) {
            arrayCopy(aseBuffer, 0, buf, 0, buf.length);
        }
        else {
            arrayCopy(biffBuffer, 0, buf, 0, buf.length);
        }
        return { success: true, data: buf };
    };
    AesEngine.prototype._createKey = function (password, salt, hashAlgorithm) {
        var pwd = stringToByteArray(password);
        var tmp = hashByte(salt, pwd, hashAlgorithm);
        for (var i = 0; i < 50000; i++) {
            var tmpI = getBytesFromInt(4, i);
            tmp = hashByte(tmpI, tmp, hashAlgorithm);
        }
        tmp = hashByte(tmp, getBytesFromInt(4, 0), hashAlgorithm);
        var XorBuff = [];
        for (var i = 0; i < 64; i++) {
            XorBuff[i] = 0x36;
        }
        for (var i = 0; i < tmp.length; i++) {
            XorBuff[i] ^= tmp[i];
        }
        tmp = Sha1.hash(XorBuff);
        var _key = [];
        arrayCopy(tmp, 0, _key, 0, 16);
        return _key;
    };
    AesEngine.prototype._createEncryptInfo = function (password) {
        if (!password || password.length > 256) {
            return;
        }
        var view = [];
        view._pos = 0;
        var write = writer(view);
        write.writeUshort(0x0003);
        write.writeUshort(0x0002);
        write.writeInt(0x24);
        write.writeUint(0xA4);
        write.writeInt(0x24);
        write.writeInt(0x00);
        write.writeInt(0x660E);
        write.writeInt(0x8004);
        write.writeUint(0x80);
        write.writeInt(0x18);
        write.writeLong(0x00);
        var providerName = "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)";
        write.writeBytes(stringToByteArray(providerName));
        write.writeShort(0x00);
        write.writeInt(0x10);
        this._generalEncryptHead(password);
        if (this._verifyPassword()) {
            write.writeBytes(this.salt);
            write.writeBytes(this.pwdVerifier);
            write.writeUint(0x14);
            write.writeBytes(this.pwdVerifierHash);
        }
        write.seek(0, seekOrigin.Begin);
        return write.getView();
    };
    AesEngine.prototype._generalEncryptHead = function (password) {
        var tempSalt = [];
        var verifier = [];
        for (var i = 0; i < this.blockLen; i++) {
            tempSalt[i] = parseInt(Math.random() * 255, 10);
            verifier[i] = parseInt(Math.random() * 255, 10);
        }
        this.salt = tempSalt;
        this.key = this._createKey(password, this.salt, this.hashAlgorithm);
        this._initAesEngine(keyType.Bits128, this.key);
        var verifierHash = Sha1.hash(verifier);
        this.pwdVerifier = this._cipher(verifier);
        this.pwdVerifierHash = this._cipher(verifierHash);
        return true;
    };
    AesEngine.prototype._initAesEngine = function (keySize, keyBytes) {
        this.Nb = 4;
        if (keySize === keyType.Bits128) {
            this.Nk = 4;
            this.Nr = 10;
        }
        else if (keySize === keyType.Bits192) {
            this.Nk = 6;
            this.Nr = 12;
        }
        else if (keySize === keyType.Bits256) {
            this.Nk = 8;
            this.Nr = 14;
        }
        this.key = [].concat(keyBytes);
        this.Sbox = buildSbox();
        this.iSbox = buildInvSbox();
        this.Rcon = buildRcon();
        this.w = keyExpansion(this.Nb, this.Nr, this.Nk, this.key, this.Rcon, this.Sbox);
    };
    AesEngine.prototype._cipher = function (input) {
        var outputLen = input.length;
        var rem = input.length % this.blockLen;
        if (rem !== 0) {
            outputLen += this.blockLen - rem;
        }
        var output = [];
        arrayCopy(input, 0, output, 0, input.length);
        var tmpInput = [];
        var tmpOutput = [];
        for (var i = 0; i < outputLen; i += this.blockLen) {
            arrayCopy(output, i, tmpInput, 0, this.blockLen);
            this._cipherInternal(tmpInput, tmpOutput);
            arrayCopy(tmpOutput, 0, output, i, this.blockLen);
        }
        return output;
    };
    AesEngine.prototype._cipherInternal = function (input, output) {
        this.State = create2DArray(4, this.Nb);
        for (var i = 0; i < (4 * this.Nb); ++i) {
            this.State[i % 4][parseInt(i / 4, 10)] = input[i];
        }
        this.State = addRoundKey(0, this.State, this.w);
        for (var round = 1; round <= (this.Nr - 1); ++round) {
            this.State = subBytes(this.State, this.Sbox);
            this.State = shiftRows(this.State, this.Nb);
            this.State = mixColumns(this.State);
            this.State = addRoundKey(round, this.State, this.w);
        }
        this.State = subBytes(this.State, this.Sbox);
        this.State = shiftRows(this.State, this.Nb);
        this.State = addRoundKey(this.Nr, this.State, this.w);
        for (var i = 0; i < (4 * this.Nb); ++i) {
            output[i] = this.State[i % 4][parseInt(i / 4, 10)];
        }
    };
    AesEngine.prototype._verifyPassword = function () {
        var sha = Sha1;
        var pwdVerifierDec = this._invCipher(this.pwdVerifier);
        var pwdVerifierHashDec = this._invCipher(this.pwdVerifierHash);
        pwdVerifierDec = sha.hash(pwdVerifierDec);
        for (var i = 0; i < pwdVerifierDec.length; i++) {
            if (pwdVerifierDec[i] !== pwdVerifierHashDec[i]) {
                return false;
            }
        }
        return true;
    };
    AesEngine.prototype._invCipher = function (input) {
        if (input === null) {
            return null;
        }
        var outputLength = input.length;
        if (input.length % this.blockLen !== 0) {
            return;
        }
        if (outputLength > input.length) {
            return;
        }
        var output = [];
        var tmpInput = [];
        var tmpOutput = [];
        for (var i = 0; i < input.length; i += this.blockLen) {
            arrayCopy(input, i, tmpInput, 0, this.blockLen);
            this._invCipherInternal(tmpInput, tmpOutput);
            var len = i + this.blockLen - outputLength;
            arrayCopy(tmpOutput, 0, output, i, len > 0 ? this.blockLen - len : this.blockLen);
        }
        return output;
    };
    AesEngine.prototype._invCipherInternal = function (input, output) {
        this.State = create2DArray(4, this.Nb);
        for (var i = 0; i < (4 * this.Nb); ++i) {
            this.State[i % 4][parseInt(i / 4, 10)] = input[i];
        }
        this.State = addRoundKey(this.Nr, this.State, this.w);
        for (var round = this.Nr - 1; round >= 1; --round) {
            this._invShiftRows();
            this._invSubBytes();
            this.State = addRoundKey(round, this.State, this.w);
            this._invMixColumns();
        }
        this._invShiftRows();
        this._invSubBytes();
        this.State = addRoundKey(0, this.State, this.w);
        for (var i = 0; i < (4 * this.Nb); ++i) {
            output[i] = this.State[i % 4][parseInt(i / 4, 10)];
        }
    };
    AesEngine.prototype._invShiftRows = function () {
        var temp = create2DArray(4, 4);
        for (var r = 0; r < 4; ++r) {
            for (var c = 0; c < 4; ++c) {
                temp[r][c] = this.State[r][c];
            }
        }
        for (var r = 1; r < 4; ++r) {
            for (var c = 0; c < 4; ++c) {
                this.State[r][(c + r) % this.Nb] = temp[r][c];
            }
        }
    };
    AesEngine.prototype._invSubBytes = function () {
        for (var r = 0; r < 4; ++r) {
            for (var c = 0; c < 4; ++c) {
                this.State[r][c] = this.iSbox[(this.State[r][c] >> 4)][(this.State[r][c] & 0x0f)];
            }
        }
    };
    AesEngine.prototype._invMixColumns = function () {
        var temp = create2DArray(4, 4);
        for (var r = 0; r < 4; ++r) {
            for (var c = 0; c < 4; ++c) {
                temp[r][c] = this.State[r][c];
            }
        }
        for (var c = 0; c < 4; ++c) {
            this.State[0][c] = (gfmultby0e(temp[0][c]) ^ gfmultby0b(temp[1][c]) ^ gfmultby0d(temp[2][c]) ^ gfmultby09(temp[3][c])) % 256;
            this.State[1][c] = (gfmultby09(temp[0][c]) ^ gfmultby0e(temp[1][c]) ^ gfmultby0b(temp[2][c]) ^ gfmultby0d(temp[3][c])) % 256;
            this.State[2][c] = (gfmultby0d(temp[0][c]) ^ gfmultby09(temp[1][c]) ^ gfmultby0e(temp[2][c]) ^ gfmultby0b(temp[3][c])) % 256;
            this.State[3][c] = (gfmultby0b(temp[0][c]) ^ gfmultby0d(temp[1][c]) ^ gfmultby09(temp[2][c]) ^ gfmultby0e(temp[3][c])) % 256;
        }
    };
    AesEngine.prototype._encryptPackageStream = function (inStream) {
        var view = new Uint8Array(inStream);
        view._pos = 0;
        var read = reader(view);
        var length = view.length;
        var input = read.readBytes(length);
        var encBuffer = this._cipher(input);
        var encTotal = [];
        arrayCopy(getBytesFromInt(8, length), 0, encTotal, 0, 8);
        arrayCopy(encBuffer, 0, encTotal, 8, encBuffer.length);
        read.seek(0, seekOrigin.Begin);
        return encTotal;
    };
    AesEngine.prototype._stgOpenXmlStreamWrite = function (encStreamInfo, encstreamPackage) {
        var view = [];
        view._pos = 0;
        var write = writer(view);
        var i = 0;
        var dirctoryBlockCount = 3;
        var customFileBlockCount = 2;
        var ssatBolckCount = 1;
        var msatList = [];
        var satList = [];
        var ssaList = [];
        var size = Math.max(encstreamPackage.length, 4096);
        var streamBlockCount = parseInt(encstreamPackage.length / 0x200, 10);
        if (encstreamPackage.length % 0x200 > 0) {
            streamBlockCount++;
        }
        var propertyBlockCount = dirctoryBlockCount + customFileBlockCount + ssatBolckCount;
        var blockIndexArraySize = (streamBlockCount + propertyBlockCount) * 4;
        var satBlocksNeeded = parseInt(blockIndexArraySize / 0x200, 10);
        if (blockIndexArraySize % 0x200 > 0) {
            satBlocksNeeded++;
        }
        var msatBlocksNeeded = 0;
        var blocksChanged = true;
        while (blocksChanged) {
            var newSatBlocksNeeded = 0;
            var newMSatBlocksNeeded = 0;
            blocksChanged = false;
            blockIndexArraySize = (streamBlockCount + propertyBlockCount + satBlocksNeeded + msatBlocksNeeded) * 4;
            newSatBlocksNeeded = parseInt(blockIndexArraySize / 0x200, 10);
            if (blockIndexArraySize % 0x200 > 0) {
                newSatBlocksNeeded++;
            }
            if (newSatBlocksNeeded > satBlocksNeeded) {
                satBlocksNeeded = newSatBlocksNeeded;
                blocksChanged = true;
                continue;
            }
            if (satBlocksNeeded > 109) {
                var batArrayListRemainingSize = (satBlocksNeeded - 109) * 4;
                newMSatBlocksNeeded = parseInt(batArrayListRemainingSize / 0x200, 10);
                var batArrayListRemainingSizeRemainder = batArrayListRemainingSize % 0x200;
                if (batArrayListRemainingSizeRemainder > 0) {
                    newMSatBlocksNeeded++;
                }
                if (batArrayListRemainingSizeRemainder + (4 * newMSatBlocksNeeded) > 0x200) {
                    newMSatBlocksNeeded++;
                }
                if (newMSatBlocksNeeded > msatBlocksNeeded) {
                    msatBlocksNeeded = newMSatBlocksNeeded;
                    blocksChanged = true;
                }
            }
        }
        if (msatBlocksNeeded > 0) {
            var count = msatBlocksNeeded * 128 + 109;
            var msatIndex = 0;
            for (i = 0; i < count; i++) {
                if (i < satBlocksNeeded) {
                    var xbatIndexCount = i - 109;
                    if (xbatIndexCount > 0 && xbatIndexCount % 0x80 === 0) {
                        msatList.push(++msatIndex);
                    }
                    msatList.push(i + msatBlocksNeeded);
                }
                else {
                    msatList.push(-1);
                }
            }
        }
        else {
            for (i = 0; i < 109; i++) {
                if (i < satBlocksNeeded) {
                    msatList.push(i);
                }
                else {
                    msatList.push(-1);
                }
            }
        }
        var blockCount = 0;
        if (satBlocksNeeded > 0) {
            for (i = 1; i <= msatBlocksNeeded; i++) {
                satList.push(-4);
            }
            blockCount = msatBlocksNeeded;
            for (i = 1; i <= satBlocksNeeded; i++) {
                satList.push(-3);
            }
            blockCount += satBlocksNeeded;
            for (i = 1; i < ssatBolckCount; i++) {
                satList.push(i);
            }
            satList.push(-2);
            blockCount += ssatBolckCount;
            for (i = 1; i < dirctoryBlockCount; i++) {
                satList.push(i + blockCount);
            }
            satList.push(-2);
            blockCount += dirctoryBlockCount;
            for (i = 1; i < customFileBlockCount; i++) {
                satList.push(i + blockCount);
            }
            satList.push(-2);
            blockCount += customFileBlockCount;
            for (i = 1; i < streamBlockCount; i++) {
                satList.push(i + blockCount);
            }
            satList.push(-2);
        }
        write.writeInt(0xE011CFD0);
        write.writeInt(0xE11AB1A1);
        write.writeLong(0x00);
        write.writeLong(0x00);
        write.writeShort(0x003E);
        write.writeShort(0x0003);
        write.writeShort(-2);
        write.writeShort(9);
        write.writeInt(6);
        write.writeInt(0);
        write.writeInt(0);
        write.writeInt(satBlocksNeeded);
        write.writeInt(msatBlocksNeeded + satBlocksNeeded + ssatBolckCount);
        write.writeInt(0);
        write.writeInt(0x00001000);
        write.writeInt(satBlocksNeeded + msatBlocksNeeded);
        write.writeInt(ssatBolckCount);
        if (msatBlocksNeeded > 0) {
            write.writeInt(0);
            write.writeInt(msatBlocksNeeded);
        }
        else {
            write.writeInt(-2);
            write.writeInt(0);
        }
        msatList.forEach(function (value) {
            write.writeInt(value);
        });
        for (var j = 0; j < satBlocksNeeded * 128; j++) {
            if (j < satList.length) {
                write.writeInt(satList[j]);
            }
            else {
                write.writeInt(-1);
            }
        }
        var customFileStream = stgGenerateCustomFileStream(encStreamInfo, ssaList);
        ssaList.forEach(function (value) {
            write.writeInt(value);
        });
        var dirctoryEntry = stgGenerateDirectoryEntry(blockCount, blockCount - customFileBlockCount, size);
        write.writeBytes(dirctoryEntry);
        write.writeBytes(customFileStream);
        write.writeBytes(encstreamPackage);
        return { success: true, data: write.getView() };
    };
    return AesEngine;
}());
exports.AesEngine = AesEngine;


/***/ }),

/***/ "./src/xlsx-io/password/compoundFile.ts":
/*!**********************************************!*\
  !*** ./src/xlsx-io/password/compoundFile.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ../../common/common */ "./src/common/common.ts");
var compoundFileObjectType = {
    Unknown: 0,
    Storage: 1,
    Stream: 2,
    RootStorage: 5
};
var nodeColor = {
    Red: 0,
    Black: 1
};
var headerSignature = 0xE11AB1A1E011CFD0;
var endOfChain = -2;
var directoryEntrySize = 0x80;
var maxRegSect = -6;
var freeSect = -1;
var rootName = "Root Entry";
var noStream = -1;
var compoundFileHeaderSize = 0x200;
var maxDifatArrayLength = 109;
var sectorSize = 0x200;
var minisectorSize = 0x40;
function makeSectors(input) {
    var sectors = { StartSectorIndex: 0, SectorCount: 0 };
    var result = [];
    for (var i = 0; i < input.length; i++) {
        var isNew = (sectors.SectorCount === 0);
        if (isNew) {
            sectors.StartSectorIndex = input[i];
            sectors.SectorCount = 1;
        }
        else {
            var isContinuous = (input[i] === (sectors.SectorCount + sectors.StartSectorIndex));
            if (isContinuous) {
                sectors.SectorCount += 1;
            }
            else {
                result.push(sectors);
                sectors.SectorCount = 0;
                i--;
            }
        }
    }
    result.push(sectors);
    return result;
}
var DirectoryEntry = function () {
    this._name = new Array(0x20);
    this._nameLength = 0;
    this._type = 5;
    this._leftSiblingID = noStream;
    this._rightSiblingID = noStream;
    this._childID = noStream;
    this._startSector = freeSect;
    this._streamSize = 0;
    this._bytes = [];
};
DirectoryEntry.prototype = {
    getName: function () {
        var name = '';
        this._name.forEach(function (n) {
            var i = n.indexOf('\0');
            if (i !== -1) {
                name += n.substring(0, i);
            }
            else {
                name += n;
            }
        });
        while (name.length > 0) {
            if (name[name.length - 1] === 0x0000) {
                name.substring(0, name.length - 2);
            }
            else {
                break;
            }
        }
        return name;
    },
    setName: function (value) {
        for (var i = 0; i < this._name.length && i < value.length; i++) {
            this._name[i] = value[i];
        }
        this._nameLength = Math.min(this._name.length * 2, (value.length + 1) * 2);
    },
    read: function (reader) {
        this._name = reader.readChars(this._name.length);
        this._nameLength = reader.readInt16();
        switch (this.getName()) {
            case "R":
                this.setName(rootName);
                break;
            case "Book":
                this.setName("Workbook");
                break;
            default:
                break;
        }
        this._type = reader.readByte()[0];
        reader.readByte();
        this._leftSiblingID = reader.readInt32();
        this._rightSiblingID = reader.readInt32();
        this._childID = reader.readInt32();
        reader.readInt32();
        reader.readInt32();
        reader.readInt32();
        reader.readInt32();
        reader.readInt32();
        reader.readInt64();
        reader.readInt64();
        this._startSector = reader.readInt32();
        this._streamSize = reader.readInt32();
        reader.readInt32();
    }
};
var CompoundFileHeader = /** @class */ (function () {
    function CompoundFileHeader() {
        this._headerSignature = headerSignature;
        this._revisionNo = 0x003E;
        this._versionNo = 0x0003;
        this._byteOrder = 0xFFFE;
        this._sectorShift = 9;
        this._miniSectorShift = 6;
        this._reserved1 = 0;
        this._reserved2 = 0;
        this._directorySectorCount = 0;
        this._fatSectorCount = 0;
        this._firstDirectorySector = 0;
        this._transactionSignature = 0;
        this._miniStreamCufoffSize = 0x00001000;
        this._firstMiniFatSector = endOfChain;
        this._miniFatSectorCount = 0;
        this._firstDifatSector = endOfChain;
        this._difatSectorCount = 0;
        this._difatArray = [];
    }
    CompoundFileHeader.prototype.sectorSize = function () {
        return Math.pow(2, this._sectorShift);
    };
    CompoundFileHeader.prototype.minisectorSize = function () {
        return Math.pow(2, this._miniSectorShift);
    };
    CompoundFileHeader.prototype.read = function (reader) {
        this._headerSignature = reader.readUInt64();
        reader.readInt32();
        reader.readInt32();
        reader.readInt32();
        reader.readInt32();
        this._revisionNo = reader.readUInt16();
        this._versionNo = reader.readUInt16();
        if (this._versionNo > 3) {
            return false;
        }
        this._byteOrder = reader.readUInt16();
        this._sectorShift = reader.readInt16();
        this._miniSectorShift = reader.readInt32();
        this._reserved1 = reader.readInt32();
        this._reserved2 = reader.readInt16();
        this._directorySectorCount = reader.readInt16();
        this._fatSectorCount = reader.readInt32();
        this._firstDirectorySector = reader.readInt32();
        this._transactionSignature = reader.readInt32();
        this._miniStreamCufoffSize = reader.readInt32();
        this._firstMiniFatSector = reader.readInt32();
        this._miniFatSectorCount = reader.readInt32();
        this._firstDifatSector = reader.readInt32();
        this._difatSectorCount = reader.readInt32();
        var fatCount = Math.min(this._fatSectorCount, maxDifatArrayLength);
        this._difatArray = [];
        for (var i = 0; i < fatCount; i++) {
            this._difatArray[i] = reader.readInt32();
        }
    };
    return CompoundFileHeader;
}());
var FileAllocationTable = /** @class */ (function () {
    function FileAllocationTable() {
        this._innerList = [];
    }
    FileAllocationTable.prototype.length = function () {
        return this._innerList.length;
    };
    FileAllocationTable.prototype.getList = function () {
        return this._innerList;
    };
    FileAllocationTable.prototype.getSectorList = function (startIndex) {
        var result = [];
        var index = startIndex;
        while (index <= maxRegSect || index > freeSect) {
            result.push(index);
            index = this._innerList[index];
        }
        return result;
    };
    FileAllocationTable.prototype.addRange = function (collection) {
        var self = this;
        if (collection && collection.length) {
            collection.forEach(function (c) {
                self._innerList.push(c);
            });
        }
    };
    FileAllocationTable.prototype.read = function (reader, count) {
        for (var i = 0; i < count; i++) {
            this._innerList.push(reader.readInt32());
        }
    };
    return FileAllocationTable;
}());
var DirectoryEntryCollection = /** @class */ (function () {
    function DirectoryEntryCollection() {
        this._directoryEntries = [];
    }
    DirectoryEntryCollection.prototype.add = function (directoryEntry) {
        if (directoryEntry.getName() === rootName) {
            this._directoryEntries.splice(0, 0, directoryEntry);
        }
        else {
            this._directoryEntries.push(directoryEntry);
        }
    };
    DirectoryEntryCollection.prototype.clear = function () {
        this._directoryEntries = [];
    };
    DirectoryEntryCollection.prototype.length = function () {
        return this._directoryEntries.length;
    };
    DirectoryEntryCollection.prototype.entries = function () {
        return this._directoryEntries;
    };
    DirectoryEntryCollection.prototype.read = function (reader, count) {
        for (var i = 0; i < count; i++) {
            var property = new DirectoryEntry();
            property.read(reader);
            this._directoryEntries.push(property);
        }
    };
    return DirectoryEntryCollection;
}());
var CompoundFile = /** @class */ (function () {
    function CompoundFile(isReadOnly) {
        this._pos = 0;
        this._header = new CompoundFileHeader();
        this._directoryEntries = new DirectoryEntryCollection();
        this._difatList = new FileAllocationTable();
        this._fatList = new FileAllocationTable();
        this._miniFatList = new FileAllocationTable();
        var rootEntry = new DirectoryEntry();
        rootEntry.setName(rootName);
        rootEntry._type = compoundFileObjectType.Stream;
        rootEntry._nodeColor = nodeColor.Black;
        rootEntry._childID = noStream;
        if (!isReadOnly) {
            rootEntry._creationTime = new Date().getTime();
            rootEntry._modifiedTime = new Date().getTime();
        }
        rootEntry._leftSiblingID = noStream;
        rootEntry._rightSiblingID = noStream;
        rootEntry._childID = noStream;
        rootEntry._type = compoundFileObjectType.RootStorage;
        rootEntry._startSector = endOfChain;
        rootEntry._streamSize = 0;
        rootEntry.Bytes = null;
        this._directoryEntries.add(rootEntry);
    }
    CompoundFile.prototype._getStream = function (name, parentName) {
        if (arguments.length === 1) {
            parentName = rootName;
        }
        var parentId = -1;
        for (var i = 0; i < this._directoryEntries.length(); i++) {
            var de = this._directoryEntries.entries()[i];
            if (de.getName() === parentName && (de._type === compoundFileObjectType.Storage || de._type === compoundFileObjectType.RootStorage)) {
                parentId = i;
                break;
            }
        }
        if (parentId === -1) {
            return null;
        }
        if (this._directoryEntries.entries()[parentId]._childID === noStream) {
            return null;
        }
        var ids = [];
        ids.push(this._directoryEntries.entries()[parentId]._childID);
        this._getSiblingDirectoryEntryIds(this._directoryEntries.entries()[parentId]._childID, ids);
        for (var i = 0; i < ids.length; i++) {
            var de = this._directoryEntries.entries()[ids[i]];
            if (de.getName() === name && de._type === compoundFileObjectType.Stream) {
                return de._bytes;
            }
        }
        return null;
    };
    CompoundFile.prototype._getSiblingDirectoryEntryIds = function (id, ids) {
        if (this._directoryEntries.entries()[id]._leftSiblingID !== noStream) {
            ids.push(this._directoryEntries.entries()[id]._leftSiblingID);
            this._getSiblingDirectoryEntryIds(this._directoryEntries.entries()[id]._leftSiblingID, ids);
        }
        if (this._directoryEntries.entries()[id]._rightSiblingID !== noStream) {
            ids.push(this._directoryEntries.entries()[id]._rightSiblingID);
            this._getSiblingDirectoryEntryIds(this._directoryEntries.entries()[id]._rightSiblingID, ids);
        }
    };
    CompoundFile.prototype._read = function (view) {
        this.view = view;
        var reader = this._reader();
        this._readHeader(reader);
        this._readFatList(reader);
        this._readDirectoryEntries(reader);
    };
    CompoundFile.prototype._readHeader = function (reader) {
        this._header.read(reader);
        sectorSize = this._header.sectorSize();
        minisectorSize = this._header.minisectorSize();
    };
    CompoundFile.prototype._readFatList = function (reader) {
        this._difatList.addRange(this._header._difatArray);
        var remainFatSectorCount = this._header._fatSectorCount - (this._header._difatArray ? this._header._difatArray.length : 0);
        var difatSector = this._header._firstDifatSector;
        var countInSector = (sectorSize - 4) / 4;
        while (remainFatSectorCount > 0) {
            this._moveToSector(difatSector);
            this._difatList.read(reader, Math.min(countInSector, remainFatSectorCount));
            remainFatSectorCount -= Math.min(countInSector, remainFatSectorCount);
            if (remainFatSectorCount > 0) {
                difatSector = reader.readInt32();
            }
        }
        for (var i = 0; i < this._difatList.length(); i++) {
            this._moveToSector(this._difatList.getList()[i]);
            this._fatList.read(reader, sectorSize / 4);
        }
        var miniFats = this._fatList.getSectorList(this._header._firstMiniFatSector);
        for (var i = 0; i < miniFats.length; i++) {
            this._moveToSector(miniFats[i]);
            this._miniFatList.read(reader, sectorSize / 4);
        }
    };
    CompoundFile.prototype._readDirectoryEntries = function (reader) {
        this._directoryEntries.clear();
        var firstSector = this._header._firstDirectorySector;
        var sectors = this._fatList.getSectorList(firstSector);
        for (var i = 0; i < sectors.length; i++) {
            this._moveToSector(sectors[i]);
            this._directoryEntries.read(reader, sectorSize / directoryEntrySize);
        }
        var rootEntity = this._directoryEntries.entries()[0];
        if (rootEntity.getName() === rootName.replace(" ", "")) {
            rootEntity.setName(rootName);
        }
        if (rootEntity.getName() !== rootName) {
            return;
        }
        for (var i = 1; i < this._directoryEntries.length(); i++) {
            var de = this._directoryEntries.entries()[i];
            if (de._type === compoundFileObjectType.Stream) {
                de._bytes = this._getDirectoryEntryBytes(de, reader);
            }
        }
    };
    CompoundFile.prototype._getDirectoryEntryBytes = function (directoryEntry, reader) {
        if (directoryEntry === null) {
            return null;
        }
        if (directoryEntry._streamSize < this._header._miniStreamCufoffSize) {
            return this._getMiniSectorBytes(directoryEntry._startSector, directoryEntry._streamSize, reader);
        }
        return this._getSectorBytes(directoryEntry._startSector, directoryEntry._streamSize, reader);
    };
    CompoundFile.prototype._getMiniSectorBytes = function (startSector, streamSize, reader) {
        var result = [];
        var sectors = this._miniFatList.getSectorList(startSector);
        for (var i = 0; i < sectors.length; i++) {
            this._moveToMiniSector(sectors[i]);
            var count = minisectorSize;
            if (i === sectors.length - 1 && streamSize % minisectorSize !== 0) {
                count = streamSize % minisectorSize;
            }
            var bytes = reader.readBytes(count);
            for (var j = 0; j < bytes.length; j++) {
                result.push(bytes[j]);
            }
        }
        return result;
    };
    CompoundFile.prototype._moveToSector = function (index) {
        this._pos = compoundFileHeaderSize + this._header.sectorSize() * index;
    };
    CompoundFile.prototype._moveToMiniSector = function (index) {
        var miniSectorCountInNormalSector = sectorSize / minisectorSize;
        var normalSectorIndex = Math.floor(index / miniSectorCountInNormalSector);
        var normalSectors = this._fatList.getSectorList(this._directoryEntries.entries()[0]._startSector);
        this._moveToSector(normalSectors[normalSectorIndex]);
        this._pos += (index % miniSectorCountInNormalSector) * minisectorSize;
    };
    CompoundFile.prototype._getSectorBytes = function (startSector, streamSize, reader) {
        var blocks = this._fatList.getSectorList(startSector);
        var continuousSector = makeSectors(blocks);
        var result = [];
        for (var i = 0; i < continuousSector.length; i++) {
            this._moveToSector(continuousSector[i].StartSectorIndex);
            var count = sectorSize * continuousSector[i].SectorCount;
            if (i === continuousSector.length - 1 && streamSize % sectorSize !== 0) {
                count -= sectorSize - streamSize % sectorSize;
            }
            count = Math.min(count, (this.view.length - this._pos));
            var bytes = reader.readBytes(count);
            for (var j = 0; j < bytes.length; j++) {
                result.push(bytes[j]);
            }
        }
        return result;
    };
    CompoundFile.prototype._reader = function () {
        var self = this;
        var reverse = function (arr) {
            var result = [];
            for (var i = 0; i < arr.length; i++) {
                result[i] = arr[arr.length - i - 1];
            }
            return result;
        };
        var readUInt = function (n) {
            var sign = 0;
            reverse(common_1.BufferHelper._slice(self.view, self._pos, self._pos + n)).forEach(function (i) {
                sign = sign * 256 + i;
            });
            self._pos += n;
            return sign;
        };
        var readInt = function (n) {
            var sign = 0;
            reverse(common_1.BufferHelper._slice(self.view, self._pos, self._pos + n)).forEach(function (i) {
                sign = (sign << 8) + i;
            });
            self._pos += n;
            return sign;
        };
        var _readBytes = function (n) {
            var subView = common_1.BufferHelper._slice(self.view, self._pos, self._pos + n);
            self._pos += n;
            return subView;
        };
        return {
            readUInt64: function () {
                return readUInt(8);
            },
            readInt64: function () {
                return readInt(8);
            },
            readInt32: function () {
                return readInt(4);
            },
            readUInt32: function () {
                return readUInt(4);
            },
            readInt16: function () {
                return readInt(2);
            },
            readUInt16: function () {
                return readInt(2);
            },
            readByte: function () {
                return _readBytes(1);
            },
            readBytes: function (count) {
                return _readBytes(count);
            },
            readChars: function (count) {
                var chars = [];
                for (var i = 0; i < count; i++) {
                    var bytes = _readBytes(2);
                    chars.push(String.fromCharCode.apply(null, bytes));
                }
                return chars;
            }
        };
    };
    return CompoundFile;
}());
exports.CompoundFile = CompoundFile;


/***/ }),

/***/ "./src/xlsx-io/password/sha1.js":
/*!**************************************!*\
  !*** ./src/xlsx-io/password/sha1.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Created by PaulPei on 10/28/2016.
 */
/*
 * js-sha1 v0.3.0
 * https://github.com/emn178/js-sha1
 *
 * Copyright 2014-2015, emn178@gmail.com
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
(function (root) {
    'use strict';
    var Sha1 = {};
    var EXTRA = [-2147483648, 8388608, 32768, 128];
    var SHIFT = [24, 16, 8, 0];

    var blocks = [];

    var sha1 = function (message) {


        var h0, h1, h2, h3, h4, block = 0, end = false, t, f,
            i, j, index = 0, start = 0, bytes = 0, length = message.length;

        h0 = 0x67452301;
        h1 = 0xEFCDAB89;
        h2 = 0x98BADCFE;
        h3 = 0x10325476;
        h4 = 0xC3D2E1F0;

        do {
            blocks[0] = block;
            blocks[16] = blocks[1] = blocks[2] = blocks[3] =
                blocks[4] = blocks[5] = blocks[6] = blocks[7] =
                    blocks[8] = blocks[9] = blocks[10] = blocks[11] =
                        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            for (i = start; index < length && i < 64; ++index) {
                blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }

            bytes += i - start;
            start = i - 64;
            if (index === length) {
                blocks[i >> 2] |= EXTRA[i & 3];
                ++index;
            }
            block = blocks[16];
            if (index > length && i < 56) {
                blocks[15] = bytes << 3;
                end = true;
            }

            for (j = 16; j < 80; ++j) {
                t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];
                blocks[j] = (t << 1) | (t >>> 31);
            }

            var a = h0, b = h1, c = h2, d = h3, e = h4;
            for (j = 0; j < 20; j += 5) {
                f = (b & c) | ((~b) & d);
                t = (a << 5) | (a >>> 27);
                e = t + f + e + 1518500249 + blocks[j] << 0;
                b = (b << 30) | (b >>> 2);

                f = (a & b) | ((~a) & c);
                t = (e << 5) | (e >>> 27);
                d = t + f + d + 1518500249 + blocks[j + 1] << 0;
                a = (a << 30) | (a >>> 2);

                f = (e & a) | ((~e) & b);
                t = (d << 5) | (d >>> 27);
                c = t + f + c + 1518500249 + blocks[j + 2] << 0;
                e = (e << 30) | (e >>> 2);

                f = (d & e) | ((~d) & a);
                t = (c << 5) | (c >>> 27);
                b = t + f + b + 1518500249 + blocks[j + 3] << 0;
                d = (d << 30) | (d >>> 2);

                f = (c & d) | ((~c) & e);
                t = (b << 5) | (b >>> 27);
                a = t + f + a + 1518500249 + blocks[j + 4] << 0;
                c = (c << 30) | (c >>> 2);
            }

            for (; j < 40; j += 5) {
                f = b ^ c ^ d;
                t = (a << 5) | (a >>> 27);
                e = t + f + e + 1859775393 + blocks[j] << 0;
                b = (b << 30) | (b >>> 2);

                f = a ^ b ^ c;
                t = (e << 5) | (e >>> 27);
                d = t + f + d + 1859775393 + blocks[j + 1] << 0;
                a = (a << 30) | (a >>> 2);

                f = e ^ a ^ b;
                t = (d << 5) | (d >>> 27);
                c = t + f + c + 1859775393 + blocks[j + 2] << 0;
                e = (e << 30) | (e >>> 2);

                f = d ^ e ^ a;
                t = (c << 5) | (c >>> 27);
                b = t + f + b + 1859775393 + blocks[j + 3] << 0;
                d = (d << 30) | (d >>> 2);

                f = c ^ d ^ e;
                t = (b << 5) | (b >>> 27);
                a = t + f + a + 1859775393 + blocks[j + 4] << 0;
                c = (c << 30) | (c >>> 2);
            }

            for (; j < 60; j += 5) {
                f = (b & c) | (b & d) | (c & d);
                t = (a << 5) | (a >>> 27);
                e = t + f + e - 1894007588 + blocks[j] << 0;
                b = (b << 30) | (b >>> 2);

                f = (a & b) | (a & c) | (b & c);
                t = (e << 5) | (e >>> 27);
                d = t + f + d - 1894007588 + blocks[j + 1] << 0;
                a = (a << 30) | (a >>> 2);

                f = (e & a) | (e & b) | (a & b);
                t = (d << 5) | (d >>> 27);
                c = t + f + c - 1894007588 + blocks[j + 2] << 0;
                e = (e << 30) | (e >>> 2);

                f = (d & e) | (d & a) | (e & a);
                t = (c << 5) | (c >>> 27);
                b = t + f + b - 1894007588 + blocks[j + 3] << 0;
                d = (d << 30) | (d >>> 2);

                f = (c & d) | (c & e) | (d & e);
                t = (b << 5) | (b >>> 27);
                a = t + f + a - 1894007588 + blocks[j + 4] << 0;
                c = (c << 30) | (c >>> 2);
            }

            for (; j < 80; j += 5) {
                f = b ^ c ^ d;
                t = (a << 5) | (a >>> 27);
                e = t + f + e - 899497514 + blocks[j] << 0;
                b = (b << 30) | (b >>> 2);

                f = a ^ b ^ c;
                t = (e << 5) | (e >>> 27);
                d = t + f + d - 899497514 + blocks[j + 1] << 0;
                a = (a << 30) | (a >>> 2);

                f = e ^ a ^ b;
                t = (d << 5) | (d >>> 27);
                c = t + f + c - 899497514 + blocks[j + 2] << 0;
                e = (e << 30) | (e >>> 2);

                f = d ^ e ^ a;
                t = (c << 5) | (c >>> 27);
                b = t + f + b - 899497514 + blocks[j + 3] << 0;
                d = (d << 30) | (d >>> 2);

                f = c ^ d ^ e;
                t = (b << 5) | (b >>> 27);
                a = t + f + a - 899497514 + blocks[j + 4] << 0;
                c = (c << 30) | (c >>> 2);
            }

            h0 = h0 + a << 0;
            h1 = h1 + b << 0;
            h2 = h2 + c << 0;
            h3 = h3 + d << 0;
            h4 = h4 + e << 0;
        } while (!end);

        return [
            16 * ((h0 >> 28) & 0x0F) + ((h0 >> 24) & 0x0F),
            16 * ((h0 >> 20) & 0x0F) + ((h0 >> 16) & 0x0F),
            16 * ((h0 >> 12) & 0x0F) + ((h0 >> 8) & 0x0F),
            16 * ((h0 >> 4) & 0x0F) + (h0 & 0x0F),
            16 * ((h1 >> 28) & 0x0F) + ((h1 >> 24) & 0x0F),
            16 * ((h1 >> 20) & 0x0F) + ((h1 >> 16) & 0x0F),
            16 * ((h1 >> 12) & 0x0F) + ((h1 >> 8) & 0x0F),
            16 * ((h1 >> 4) & 0x0F) + (h1 & 0x0F),
            16 * ((h2 >> 28) & 0x0F) + ((h2 >> 24) & 0x0F),
            16 * ((h2 >> 20) & 0x0F) + ((h2 >> 16) & 0x0F),
            16 * ((h2 >> 12) & 0x0F) + ((h2 >> 8) & 0x0F),
            16 * ((h2 >> 4) & 0x0F) + (h2 & 0x0F),
            16 * ((h3 >> 28) & 0x0F) + ((h3 >> 24) & 0x0F),
            16 * ((h3 >> 20) & 0x0F) + ((h3 >> 16) & 0x0F),
            16 * ((h3 >> 12) & 0x0F) + ((h3 >> 8) & 0x0F),
            16 * ((h3 >> 4) & 0x0F) + (h3 & 0x0F),
            16 * ((h4 >> 28) & 0x0F) + ((h4 >> 24) & 0x0F),
            16 * ((h4 >> 20) & 0x0F) + ((h4 >> 16) & 0x0F),
            16 * ((h4 >> 12) & 0x0F) + ((h4 >> 8) & 0x0F),
            16 * ((h4 >> 4) & 0x0F) + (h4 & 0x0F)
        ];

    };

    root.sha1 = sha1;
    Sha1.hash = sha1;
    module.exports = Sha1;
}(this));


/***/ }),

/***/ "./src/xlsx-io/password/sha512.js":
/*!****************************************!*\
  !*** ./src/xlsx-io/password/sha512.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * js-sha512 v0.2.2
 * https://github.com/emn178/js-sha512
 *
 * Copyright 2014-2015, emn178@gmail.com
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
(function (root) {
    'use strict';
    var Sha512 = {};
    var EXTRA = [-2147483648, 8388608, 32768, 128];
    var SHIFT = [24, 16, 8, 0];
    var K = [0x428A2F98, 0xD728AE22, 0x71374491, 0x23EF65CD,
        0xB5C0FBCF, 0xEC4D3B2F, 0xE9B5DBA5, 0x8189DBBC,
        0x3956C25B, 0xF348B538, 0x59F111F1, 0xB605D019,
        0x923F82A4, 0xAF194F9B, 0xAB1C5ED5, 0xDA6D8118,
        0xD807AA98, 0xA3030242, 0x12835B01, 0x45706FBE,
        0x243185BE, 0x4EE4B28C, 0x550C7DC3, 0xD5FFB4E2,
        0x72BE5D74, 0xF27B896F, 0x80DEB1FE, 0x3B1696B1,
        0x9BDC06A7, 0x25C71235, 0xC19BF174, 0xCF692694,
        0xE49B69C1, 0x9EF14AD2, 0xEFBE4786, 0x384F25E3,
        0x0FC19DC6, 0x8B8CD5B5, 0x240CA1CC, 0x77AC9C65,
        0x2DE92C6F, 0x592B0275, 0x4A7484AA, 0x6EA6E483,
        0x5CB0A9DC, 0xBD41FBD4, 0x76F988DA, 0x831153B5,
        0x983E5152, 0xEE66DFAB, 0xA831C66D, 0x2DB43210,
        0xB00327C8, 0x98FB213F, 0xBF597FC7, 0xBEEF0EE4,
        0xC6E00BF3, 0x3DA88FC2, 0xD5A79147, 0x930AA725,
        0x06CA6351, 0xE003826F, 0x14292967, 0x0A0E6E70,
        0x27B70A85, 0x46D22FFC, 0x2E1B2138, 0x5C26C926,
        0x4D2C6DFC, 0x5AC42AED, 0x53380D13, 0x9D95B3DF,
        0x650A7354, 0x8BAF63DE, 0x766A0ABB, 0x3C77B2A8,
        0x81C2C92E, 0x47EDAEE6, 0x92722C85, 0x1482353B,
        0xA2BFE8A1, 0x4CF10364, 0xA81A664B, 0xBC423001,
        0xC24B8B70, 0xD0F89791, 0xC76C51A3, 0x0654BE30,
        0xD192E819, 0xD6EF5218, 0xD6990624, 0x5565A910,
        0xF40E3585, 0x5771202A, 0x106AA070, 0x32BBD1B8,
        0x19A4C116, 0xB8D2D0C8, 0x1E376C08, 0x5141AB53,
        0x2748774C, 0xDF8EEB99, 0x34B0BCB5, 0xE19B48A8,
        0x391C0CB3, 0xC5C95A63, 0x4ED8AA4A, 0xE3418ACB,
        0x5B9CCA4F, 0x7763E373, 0x682E6FF3, 0xD6B2B8A3,
        0x748F82EE, 0x5DEFB2FC, 0x78A5636F, 0x43172F60,
        0x84C87814, 0xA1F0AB72, 0x8CC70208, 0x1A6439EC,
        0x90BEFFFA, 0x23631E28, 0xA4506CEB, 0xDE82BDE9,
        0xBEF9A3F7, 0xB2C67915, 0xC67178F2, 0xE372532B,
        0xCA273ECE, 0xEA26619C, 0xD186B8C7, 0x21C0C207,
        0xEADA7DD6, 0xCDE0EB1E, 0xF57D4F7F, 0xEE6ED178,
        0x06F067AA, 0x72176FBA, 0x0A637DC5, 0xA2C898A6,
        0x113F9804, 0xBEF90DAE, 0x1B710B35, 0x131C471B,
        0x28DB77F5, 0x23047D84, 0x32CAAB7B, 0x40C72493,
        0x3C9EBE0A, 0x15C9BEBC, 0x431D67C4, 0x9C100D4C,
        0x4CC5D4BE, 0xCB3E42B6, 0x597F299C, 0xFC657E2A,
        0x5FCB6FAB, 0x3AD6FAEC, 0x6C44198C, 0x4A475817];

    var blocks = [];


    var sha512 = function (message) {

        var h0h, h0l, h1h, h1l, h2h, h2l, h3h, h3l,
            h4h, h4l, h5h, h5l, h6h, h6l, h7h, h7l, block, end = false,
            i, j, index = 0, start = 0, bytes = 0, length = message.length,
            s0h, s0l, s1h, s1l, c1, c2, c3, c4,
            abh, abl, dah, dal, cdh, cdl, bch, bcl,
            majh, majl, t1h, t1l, t2h, t2l, chh, chl;


        h0h = 0x6A09E667;
        h0l = 0xF3BCC908;
        h1h = 0xBB67AE85;
        h1l = 0x84CAA73B;
        h2h = 0x3C6EF372;
        h2l = 0xFE94F82B;
        h3h = 0xA54FF53A;
        h3l = 0x5F1D36F1;
        h4h = 0x510E527F;
        h4l = 0xADE682D1;
        h5h = 0x9B05688C;
        h5l = 0x2B3E6C1F;
        h6h = 0x1F83D9AB;
        h6l = 0xFB41BD6B;
        h7h = 0x5BE0CD19;
        h7l = 0x137E2179;

        block = 0;
        do {
            blocks[0] = block;
            blocks[1] = blocks[2] = blocks[3] = blocks[4] =
                blocks[5] = blocks[6] = blocks[7] = blocks[8] =
                    blocks[9] = blocks[10] = blocks[11] = blocks[12] =
                        blocks[13] = blocks[14] = blocks[15] = blocks[16] =
                            blocks[17] = blocks[18] = blocks[19] = blocks[20] =
                                blocks[21] = blocks[22] = blocks[23] = blocks[24] =
                                    blocks[25] = blocks[26] = blocks[27] = blocks[28] =
                                        blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;

            for (i = start; index < length && i < 128; ++index) {
                blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }

            bytes += i - start;
            start = i - 128;
            if (index === length) {
                blocks[i >> 2] |= EXTRA[i & 3];
                ++index;
            }
            block = blocks[32];
            if (index > length && i < 112) {
                blocks[31] = bytes << 3;
                end = true;
            }

            for (j = 32; j < 160; j += 2) {
                t1h = blocks[j - 30];
                t1l = blocks[j - 29];
                s0h = ((t1h >>> 1) | (t1l << 31)) ^ ((t1h >>> 8) | (t1l << 24)) ^ (t1h >>> 7);
                s0l = ((t1l >>> 1) | (t1h << 31)) ^ ((t1l >>> 8) | (t1h << 24)) ^ ((t1l >>> 7) | t1h << 25);

                t1h = blocks[j - 4];
                t1l = blocks[j - 3];
                s1h = ((t1h >>> 19) | (t1l << 13)) ^ ((t1l >>> 29) | (t1h << 3)) ^ (t1h >>> 6);
                s1l = ((t1l >>> 19) | (t1h << 13)) ^ ((t1h >>> 29) | (t1l << 3)) ^ ((t1l >>> 6) | t1h << 26);

                t1h = blocks[j - 32];
                t1l = blocks[j - 31];
                t2h = blocks[j - 14];
                t2l = blocks[j - 13];

                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (s0l & 0xFFFF) + (s1l & 0xFFFF);
                c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (s0h & 0xFFFF) + (s1h & 0xFFFF) + (c2 >>> 16);
                c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);

                blocks[j] = (c4 << 16) | (c3 & 0xFFFF);
                blocks[j + 1] = (c2 << 16) | (c1 & 0xFFFF);
            }

            var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
            bch = bh & ch;
            bcl = bl & cl;
            for (j = 0; j < 160; j += 8) {
                s0h = ((ah >>> 28) | (al << 4)) ^ ((al >>> 2) | (ah << 30)) ^ ((al >>> 7) | (ah << 25));
                s0l = ((al >>> 28) | (ah << 4)) ^ ((ah >>> 2) | (al << 30)) ^ ((ah >>> 7) | (al << 25));

                s1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((el >>> 9) | (eh << 23));
                s1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((eh >>> 9) | (el << 23));

                abh = ah & bh;
                abl = al & bl;
                majh = abh ^ (ah & ch) ^ bch;
                majl = abl ^ (al & cl) ^ bcl;

                chh = (eh & fh) ^ (~eh & gh);
                chl = (el & fl) ^ (~el & gl);

                t1h = blocks[j];
                t1l = blocks[j + 1];
                t2h = K[j];
                t2l = K[j + 1];

                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (hl & 0xFFFF);
                c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (hh & 0xFFFF) + (c2 >>> 16);
                c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);

                t1h = (c4 << 16) | (c3 & 0xFFFF);
                t1l = (c2 << 16) | (c1 & 0xFFFF);

                c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
                c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
                c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
                c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);

                t2h = (c4 << 16) | (c3 & 0xFFFF);
                t2l = (c2 << 16) | (c1 & 0xFFFF);

                c1 = (dl & 0xFFFF) + (t1l & 0xFFFF);
                c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                c3 = (dh & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
                c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);

                hh = (c4 << 16) | (c3 & 0xFFFF);
                hl = (c2 << 16) | (c1 & 0xFFFF);

                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
                c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
                c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);

                dh = (c4 << 16) | (c3 & 0xFFFF);
                dl = (c2 << 16) | (c1 & 0xFFFF);

                s0h = ((dh >>> 28) | (dl << 4)) ^ ((dl >>> 2) | (dh << 30)) ^ ((dl >>> 7) | (dh << 25));
                s0l = ((dl >>> 28) | (dh << 4)) ^ ((dh >>> 2) | (dl << 30)) ^ ((dh >>> 7) | (dl << 25));

                s1h = ((hh >>> 14) | (hl << 18)) ^ ((hh >>> 18) | (hl << 14)) ^ ((hl >>> 9) | (hh << 23));
                s1l = ((hl >>> 14) | (hh << 18)) ^ ((hl >>> 18) | (hh << 14)) ^ ((hh >>> 9) | (hl << 23));

                dah = dh & ah;
                dal = dl & al;
                majh = dah ^ (dh & bh) ^ abh;
                majl = dal ^ (dl & bl) ^ abl;

                chh = (hh & eh) ^ (~hh & fh);
                chl = (hl & el) ^ (~hl & fl);

                t1h = blocks[j + 2];
                t1l = blocks[j + 3];
                t2h = K[j + 2];
                t2l = K[j + 3];

                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (gl & 0xFFFF);
                c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (gh & 0xFFFF) + (c2 >>> 16);
                c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);

                t1h = (c4 << 16) | (c3 & 0xFFFF);
                t1l = (c2 << 16) | (c1 & 0xFFFF);

                c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
                c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
                c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
                c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);

                t2h = (c4 << 16) | (c3 & 0xFFFF);
                t2l = (c2 << 16) | (c1 & 0xFFFF);

                c1 = (cl & 0xFFFF) + (t1l & 0xFFFF);
                c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                c3 = (ch & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
                c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);

                gh = (c4 << 16) | (c3 & 0xFFFF);
                gl = (c2 << 16) | (c1 & 0xFFFF);

                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
                c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
                c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);

                ch = (c4 << 16) | (c3 & 0xFFFF);
                cl = (c2 << 16) | (c1 & 0xFFFF);

                s0h = ((ch >>> 28) | (cl << 4)) ^ ((cl >>> 2) | (ch << 30)) ^ ((cl >>> 7) | (ch << 25));
                s0l = ((cl >>> 28) | (ch << 4)) ^ ((ch >>> 2) | (cl << 30)) ^ ((ch >>> 7) | (cl << 25));

                s1h = ((gh >>> 14) | (gl << 18)) ^ ((gh >>> 18) | (gl << 14)) ^ ((gl >>> 9) | (gh << 23));
                s1l = ((gl >>> 14) | (gh << 18)) ^ ((gl >>> 18) | (gh << 14)) ^ ((gh >>> 9) | (gl << 23));

                cdh = ch & dh;
                cdl = cl & dl;
                majh = cdh ^ (ch & ah) ^ dah;
                majl = cdl ^ (cl & al) ^ dal;

                chh = (gh & hh) ^ (~gh & eh);
                chl = (gl & hl) ^ (~gl & el);

                t1h = blocks[j + 4];
                t1l = blocks[j + 5];
                t2h = K[j + 4];
                t2l = K[j + 5];

                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (fl & 0xFFFF);
                c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (fh & 0xFFFF) + (c2 >>> 16);
                c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);

                t1h = (c4 << 16) | (c3 & 0xFFFF);
                t1l = (c2 << 16) | (c1 & 0xFFFF);

                c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
                c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
                c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
                c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);

                t2h = (c4 << 16) | (c3 & 0xFFFF);
                t2l = (c2 << 16) | (c1 & 0xFFFF);

                c1 = (bl & 0xFFFF) + (t1l & 0xFFFF);
                c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                c3 = (bh & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
                c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);

                fh = (c4 << 16) | (c3 & 0xFFFF);
                fl = (c2 << 16) | (c1 & 0xFFFF);

                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
                c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
                c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);

                bh = (c4 << 16) | (c3 & 0xFFFF);
                bl = (c2 << 16) | (c1 & 0xFFFF);

                s0h = ((bh >>> 28) | (bl << 4)) ^ ((bl >>> 2) | (bh << 30)) ^ ((bl >>> 7) | (bh << 25));
                s0l = ((bl >>> 28) | (bh << 4)) ^ ((bh >>> 2) | (bl << 30)) ^ ((bh >>> 7) | (bl << 25));

                s1h = ((fh >>> 14) | (fl << 18)) ^ ((fh >>> 18) | (fl << 14)) ^ ((fl >>> 9) | (fh << 23));
                s1l = ((fl >>> 14) | (fh << 18)) ^ ((fl >>> 18) | (fh << 14)) ^ ((fh >>> 9) | (fl << 23));

                bch = bh & ch;
                bcl = bl & cl;
                majh = bch ^ (bh & dh) ^ cdh;
                majl = bcl ^ (bl & dl) ^ cdl;

                chh = (fh & gh) ^ (~fh & hh);
                chl = (fl & gl) ^ (~fl & hl);

                t1h = blocks[j + 6];
                t1l = blocks[j + 7];
                t2h = K[j + 6];
                t2l = K[j + 7];

                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (el & 0xFFFF);
                c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (eh & 0xFFFF) + (c2 >>> 16);
                c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);

                t1h = (c4 << 16) | (c3 & 0xFFFF);
                t1l = (c2 << 16) | (c1 & 0xFFFF);

                c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
                c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
                c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
                c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);

                t2h = (c4 << 16) | (c3 & 0xFFFF);
                t2l = (c2 << 16) | (c1 & 0xFFFF);

                c1 = (al & 0xFFFF) + (t1l & 0xFFFF);
                c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                c3 = (ah & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
                c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);

                eh = (c4 << 16) | (c3 & 0xFFFF);
                el = (c2 << 16) | (c1 & 0xFFFF);

                c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
                c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
                c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);

                ah = (c4 << 16) | (c3 & 0xFFFF);
                al = (c2 << 16) | (c1 & 0xFFFF);
            }

            c1 = (h0l & 0xFFFF) + (al & 0xFFFF);
            c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
            c3 = (h0h & 0xFFFF) + (ah & 0xFFFF) + (c2 >>> 16);
            c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);

            h0h = (c4 << 16) | (c3 & 0xFFFF);
            h0l = (c2 << 16) | (c1 & 0xFFFF);

            c1 = (h1l & 0xFFFF) + (bl & 0xFFFF);
            c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
            c3 = (h1h & 0xFFFF) + (bh & 0xFFFF) + (c2 >>> 16);
            c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);

            h1h = (c4 << 16) | (c3 & 0xFFFF);
            h1l = (c2 << 16) | (c1 & 0xFFFF);

            c1 = (h2l & 0xFFFF) + (cl & 0xFFFF);
            c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
            c3 = (h2h & 0xFFFF) + (ch & 0xFFFF) + (c2 >>> 16);
            c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);

            h2h = (c4 << 16) | (c3 & 0xFFFF);
            h2l = (c2 << 16) | (c1 & 0xFFFF);

            c1 = (h3l & 0xFFFF) + (dl & 0xFFFF);
            c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
            c3 = (h3h & 0xFFFF) + (dh & 0xFFFF) + (c2 >>> 16);
            c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);

            h3h = (c4 << 16) | (c3 & 0xFFFF);
            h3l = (c2 << 16) | (c1 & 0xFFFF);

            c1 = (h4l & 0xFFFF) + (el & 0xFFFF);
            c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
            c3 = (h4h & 0xFFFF) + (eh & 0xFFFF) + (c2 >>> 16);
            c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);

            h4h = (c4 << 16) | (c3 & 0xFFFF);
            h4l = (c2 << 16) | (c1 & 0xFFFF);

            c1 = (h5l & 0xFFFF) + (fl & 0xFFFF);
            c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
            c3 = (h5h & 0xFFFF) + (fh & 0xFFFF) + (c2 >>> 16);
            c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);

            h5h = (c4 << 16) | (c3 & 0xFFFF);
            h5l = (c2 << 16) | (c1 & 0xFFFF);

            c1 = (h6l & 0xFFFF) + (gl & 0xFFFF);
            c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
            c3 = (h6h & 0xFFFF) + (gh & 0xFFFF) + (c2 >>> 16);
            c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);

            h6h = (c4 << 16) | (c3 & 0xFFFF);
            h6l = (c2 << 16) | (c1 & 0xFFFF);

            c1 = (h7l & 0xFFFF) + (hl & 0xFFFF);
            c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
            c3 = (h7h & 0xFFFF) + (hh & 0xFFFF) + (c2 >>> 16);
            c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);

            h7h = (c4 << 16) | (c3 & 0xFFFF);
            h7l = (c2 << 16) | (c1 & 0xFFFF);
        } while (!end);
        return [16 * ((h0h >> 28) & 0x0F) + ((h0h >> 24) & 0x0F),
            16 * ((h0h >> 20) & 0x0F) + ((h0h >> 16) & 0x0F),
            16 * ((h0h >> 12) & 0x0F) + ((h0h >> 8) & 0x0F),
            16 * ((h0h >> 4) & 0x0F) + (h0h & 0x0F),
            16 * ((h0l >> 28) & 0x0F) + ((h0l >> 24) & 0x0F),
            16 * ((h0l >> 20) & 0x0F) + ((h0l >> 16) & 0x0F),
            16 * ((h0l >> 12) & 0x0F) + ((h0l >> 8) & 0x0F),
            16 * ((h0l >> 4) & 0x0F) + (h0l & 0x0F),
            16 * ((h1h >> 28) & 0x0F) + ((h1h >> 24) & 0x0F),
            16 * ((h1h >> 20) & 0x0F) + ((h1h >> 16) & 0x0F),
            16 * ((h1h >> 12) & 0x0F) + ((h1h >> 8) & 0x0F),
            16 * ((h1h >> 4) & 0x0F) + (h1h & 0x0F),
            16 * ((h1l >> 28) & 0x0F) + ((h1l >> 24) & 0x0F),
            16 * ((h1l >> 20) & 0x0F) + ((h1l >> 16) & 0x0F),
            16 * ((h1l >> 12) & 0x0F) + ((h1l >> 8) & 0x0F),
            16 * ((h1l >> 4) & 0x0F) + (h1l & 0x0F),
            16 * ((h2h >> 28) & 0x0F) + ((h2h >> 24) & 0x0F),
            16 * ((h2h >> 20) & 0x0F) + ((h2h >> 16) & 0x0F),
            16 * ((h2h >> 12) & 0x0F) + ((h2h >> 8) & 0x0F),
            16 * ((h2h >> 4) & 0x0F) + (h2h & 0x0F),
            16 * ((h2l >> 28) & 0x0F) + ((h2l >> 24) & 0x0F),
            16 * ((h2l >> 20) & 0x0F) + ((h2l >> 16) & 0x0F),
            16 * ((h2l >> 12) & 0x0F) + ((h2l >> 8) & 0x0F),
            16 * ((h2l >> 4) & 0x0F) + (h2l & 0x0F),
            16 * ((h3h >> 28) & 0x0F) + ((h3h >> 24) & 0x0F),
            16 * ((h3h >> 20) & 0x0F) + ((h3h >> 16) & 0x0F),
            16 * ((h3h >> 12) & 0x0F) + ((h3h >> 8) & 0x0F),
            16 * ((h3h >> 4) & 0x0F) + (h3h & 0x0F),
            16 * ((h3l >> 28) & 0x0F) + ((h3l >> 24) & 0x0F),
            16 * ((h3l >> 20) & 0x0F) + ((h3l >> 16) & 0x0F),
            16 * ((h3l >> 12) & 0x0F) + ((h3l >> 8) & 0x0F),
            16 * ((h3l >> 4) & 0x0F) + (h3l & 0x0F),
            16 * ((h4h >> 28) & 0x0F) + ((h4h >> 24) & 0x0F),
            16 * ((h4h >> 20) & 0x0F) + ((h4h >> 16) & 0x0F),
            16 * ((h4h >> 12) & 0x0F) + ((h4h >> 8) & 0x0F),
            16 * ((h4h >> 4) & 0x0F) + (h4h & 0x0F),
            16 * ((h4l >> 28) & 0x0F) + ((h4l >> 24) & 0x0F),
            16 * ((h4l >> 20) & 0x0F) + ((h4l >> 16) & 0x0F),
            16 * ((h4l >> 12) & 0x0F) + ((h4l >> 8) & 0x0F),
            16 * ((h4l >> 4) & 0x0F) + (h4l & 0x0F),
            16 * ((h5h >> 28) & 0x0F) + ((h5h >> 24) & 0x0F),
            16 * ((h5h >> 20) & 0x0F) + ((h5h >> 16) & 0x0F),
            16 * ((h5h >> 12) & 0x0F) + ((h5h >> 8) & 0x0F),
            16 * ((h5h >> 4) & 0x0F) + (h5h & 0x0F),
            16 * ((h5l >> 28) & 0x0F) + ((h5l >> 24) & 0x0F),
            16 * ((h5l >> 20) & 0x0F) + ((h5l >> 16) & 0x0F),
            16 * ((h5l >> 12) & 0x0F) + ((h5l >> 8) & 0x0F),
            16 * ((h5l >> 4) & 0x0F) + (h5l & 0x0F),
            16 * ((h6h >> 28) & 0x0F) + ((h6h >> 24) & 0x0F),
            16 * ((h6h >> 20) & 0x0F) + ((h6h >> 16) & 0x0F),
            16 * ((h6h >> 12) & 0x0F) + ((h6h >> 8) & 0x0F),
            16 * ((h6h >> 4) & 0x0F) + (h6h & 0x0F),
            16 * ((h6l >> 28) & 0x0F) + ((h6l >> 24) & 0x0F),
            16 * ((h6l >> 20) & 0x0F) + ((h6l >> 16) & 0x0F),
            16 * ((h6l >> 12) & 0x0F) + ((h6l >> 8) & 0x0F),
            16 * ((h6l >> 4) & 0x0F) + (h6l & 0x0F),
            16 * ((h7h >> 28) & 0x0F) + ((h7h >> 24) & 0x0F),
            16 * ((h7h >> 20) & 0x0F) + ((h7h >> 16) & 0x0F),
            16 * ((h7h >> 12) & 0x0F) + ((h7h >> 8) & 0x0F),
            16 * ((h7h >> 4) & 0x0F) + (h7h & 0x0F),
            16 * ((h7l >> 28) & 0x0F) + ((h7l >> 24) & 0x0F),
            16 * ((h7l >> 20) & 0x0F) + ((h7l >> 16) & 0x0F),
            16 * ((h7l >> 12) & 0x0F) + ((h7l >> 8) & 0x0F),
            16 * ((h7l >> 4) & 0x0F) + (h7l & 0x0F)];
    };


    root.sha512 = sha512;
    Sha512.hash = sha512;
    module.exports = Sha512;
}(this));

/***/ }),

/***/ "./src/xlsx-io/password/xlsxEncryptionHelper.ts":
/*!******************************************************!*\
  !*** ./src/xlsx-io/password/xlsxEncryptionHelper.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var compoundFile_1 = __webpack_require__(/*! ./compoundFile */ "./src/xlsx-io/password/compoundFile.ts");
var aesEngine_1 = __webpack_require__(/*! ./aesEngine */ "./src/xlsx-io/password/aesEngine.ts");
var common_1 = __webpack_require__(/*! ../../common/common */ "./src/common/common.ts");
function readEncryptedStgStream(fileData) {
    var result = { success: false, encryptionInfoStream: null, encryptPagStream: null };
    var compoundFile = new compoundFile_1.CompoundFile();
    var view = new Uint8Array(fileData);
    compoundFile._read(view);
    var encryptionInfoStreamBytes = compoundFile._getStream("EncryptionInfo");
    var encryptPagStreamBytes = compoundFile._getStream("EncryptedPackage");
    if (encryptionInfoStreamBytes === null || encryptPagStreamBytes === null) {
        return result;
    }
    result.success = true;
    result.encryptionInfoStream = encryptionInfoStreamBytes;
    result.encryptPagStream = encryptPagStreamBytes;
    return result;
}
function decryptData(fileData, password) {
    var result = { success: false };
    var encryptedStgResult = readEncryptedStgStream(fileData);
    if (!encryptedStgResult.success) {
        return result;
    }
    var encryptionInfoStream = encryptedStgResult.encryptionInfoStream;
    var encryptPagStream = encryptedStgResult.encryptPagStream;
    if (encryptionInfoStream !== null && encryptPagStream !== null) {
        var aes = new aesEngine_1.AesEngine();
        if (aes._progressStream(encryptionInfoStream)) {
            if (aes._isAgileEncrypt) {
                if (aes._agileVerifyPassWord(password)) {
                    result = aes._agileDecryptStream(encryptPagStream);
                }
            }
            else {
                aes.key = aes._createKey(password, aes.salt, aes.hashAlgorithm);
                aes._initAesEngine(aes.keySize, aes.key);
                if (aes._verifyPassword()) {
                    result = aes._decryptStream(encryptPagStream);
                }
            }
        }
    }
    return result;
}
function base64toBlob(base64Data, contentType) {
    var sliceSize = 1024;
    var byteCharacters = atob(base64Data);
    var bytesLength = byteCharacters.length;
    var slicesCount = Math.ceil(bytesLength / sliceSize);
    var byteArrays = new Array(slicesCount);
    for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
        var begin = sliceIndex * sliceSize;
        var end = Math.min(begin + sliceSize, bytesLength);
        var bytes = new Array(end - begin);
        for (var offset = begin, i = 0; offset < end; ++i, ++offset) {
            bytes[i] = byteCharacters[offset].charCodeAt(0);
        }
        byteArrays[sliceIndex] = new Uint8Array(bytes);
    }
    return new Blob(byteArrays, { type: contentType });
}
var XlsxEncryptionHelper = /** @class */ (function () {
    function XlsxEncryptionHelper() {
    }
    XlsxEncryptionHelper._decrypt = function (fileData, password) {
        var valid = XlsxEncryptionHelper._hasPassword(fileData);
        if (valid) {
            var isEncryptedOffice12 = decryptData(fileData, password);
            if (isEncryptedOffice12 && isEncryptedOffice12.success) {
                return isEncryptedOffice12.data;
            }
            return null;
        }
        return fileData;
    };
    XlsxEncryptionHelper._encrypt = function (arrayBuffer, password) {
        var aes = new aesEngine_1.AesEngine();
        var encStreamInfo = aes._createEncryptInfo(password);
        var encStreamPackage = aes._encryptPackageStream(arrayBuffer);
        if (encStreamInfo !== null && encStreamPackage !== null) {
            var result = aes._stgOpenXmlStreamWrite(encStreamInfo, encStreamPackage);
            if (result.success) {
                return result.data;
            }
        }
    };
    XlsxEncryptionHelper._arrayBufferToBlob = function (arrayBuffer) {
        var stringArray = [];
        for (var i = 0; i < arrayBuffer.length; i++) {
            stringArray[i] = String.fromCharCode(arrayBuffer[i]);
        }
        return base64toBlob(btoa(stringArray.join("")), "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
    };
    XlsxEncryptionHelper._hasPassword = function (fileData) {
        var sign0 = 0;
        var sign1 = 0;
        var reverse = function (arr) {
            var result = [];
            for (var i = 0; i < arr.length; i++) {
                result[i] = arr[arr.length - i - 1];
            }
            return result;
        };
        reverse(new Uint8Array(common_1.BufferHelper._slice(fileData, 0, 4))).forEach(function (i) {
            sign0 = sign0 * 256 + i;
        });
        reverse(new Uint8Array(common_1.BufferHelper._slice(fileData, 4, 8))).forEach(function (i) {
            sign1 = sign1 * 256 + i;
        });
        if (sign0.toString(16).toUpperCase() === 'E011CFD0' && sign1.toString(16).toUpperCase() === 'E11AB1A1') {
            try {
                var encryptedStgResult = readEncryptedStgStream(fileData);
                return encryptedStgResult.success && encryptedStgResult.encryptionInfoStream && encryptedStgResult.encryptPagStream;
            }
            catch (err) {
                return false;
            }
        }
        return false;
    };
    return XlsxEncryptionHelper;
}());
exports.XlsxEncryptionHelper = XlsxEncryptionHelper;


/***/ }),

/***/ "./src/xlsx-io/reader/autofilter-reader.ts":
/*!*************************************************!*\
  !*** ./src/xlsx-io/reader/autofilter-reader.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var range_parser_1 = __webpack_require__(/*! ./../../common/range-parser */ "./src/common/range-parser.ts");
var node_helper_1 = __webpack_require__(/*! ./../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var xmlDecode = common_1.Util._xmlDecode;
var getAttrValueOrDefaultOfBooleanType = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType, getAttrValueOrDefaultOfDoubleType = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfDoubleType, getAttributeValueOrDefaultOfIntType = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType, getAsArray = node_helper_1.XmlNodeHelper._getAsArray, isNullOrWhiteSpace = common_1.StringEx._isNullOrWhiteSpace;
var DynamicFilterType = {
    null: -1,
    aboveAverage: 100,
    belowAverage: 101,
    tomorrow: 2,
    today: 0,
    yesterday: 1,
    nextWeek: 9,
    thisWeek: 7,
    lastWeek: 8,
    nextMonth: 6,
    thisMonth: 4,
    lastMonth: 5,
    nextQuarter: 10,
    thisQuarter: 11,
    lastQuarter: 12,
    nextYear: 13,
    thisYear: 14,
    lastYear: 15,
    yearToDate: 16,
    Q1: 17,
    Q2: 18,
    Q3: 19,
    Q4: 20,
    M1: 21,
    M2: 22,
    M3: 23,
    M4: 24,
    M5: 25,
    M6: 26,
    M7: 27,
    M8: 28,
    M9: 29,
    M10: 30,
    M11: 31,
    M12: 32
};
function readColorFilter(colorFilterNode) {
    var colorFilter = {};
    colorFilter.cellColor = getAttrValueOrDefaultOfBooleanType(colorFilterNode._attr.cellColor, true);
    colorFilter.dxfId = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(colorFilterNode._attr.dxfId, 0);
    return colorFilter;
}
function readFilters(filtersNode) {
    var filters = {};
    filters.filter = [];
    filters.blank = filtersNode._attr.blank;
    var filtersArrayNode = getAsArray(filtersNode.filter);
    filtersArrayNode.forEach(function (filterItemNode) {
        var decodeValue = xmlDecode(filterItemNode._attr.val);
        filters.filter.push(decodeValue);
    });
    filters.dateGroupItem = [];
    var dateGroupArrayNode = getAsArray(filtersNode.dateGroupItem);
    dateGroupArrayNode.forEach(function (dateGroupItemNode) {
        var dateItem = {}, attr = dateGroupItemNode._attr;
        dateItem.day = getAttributeValueOrDefaultOfIntType(attr.day, 1);
        dateItem.hour = getAttributeValueOrDefaultOfIntType(attr.hour, 0);
        dateItem.minute = getAttributeValueOrDefaultOfIntType(attr.minute, 0);
        dateItem.month = getAttributeValueOrDefaultOfIntType(attr.month, 0);
        dateItem.second = getAttributeValueOrDefaultOfIntType(attr.second, 0);
        dateItem.year = getAttributeValueOrDefaultOfIntType(attr.year, 0);
        filters.dateGroupItem.push(dateItem);
    });
    return filters;
}
function readCustomFilters(customFiltersNode) {
    var customFilters = {};
    var and = customFiltersNode._attr.and;
    if (!isNullOrWhiteSpace(and)) {
        customFilters.and = (and === '1');
    }
    var customFiltersArrayNode = getAsArray(customFiltersNode.customFilter);
    if (customFiltersArrayNode.length > 0) {
        var filter1 = customFilters.filter1 = {};
        filter1.operator = customFiltersArrayNode[0]._attr.operator;
        filter1.value = customFiltersArrayNode[0]._attr.val;
    }
    if (customFiltersArrayNode.length > 1) {
        var filter2 = customFilters.filter2 = {};
        filter2.operator = customFiltersArrayNode[1]._attr.operator;
        filter2.value = customFiltersArrayNode[1]._attr.val;
    }
    return customFilters;
}
function readDynamicFilter(dynamicFilterNode) {
    var dynamicFilter = {};
    dynamicFilter.type = DynamicFilterType[dynamicFilterNode._attr.type];
    var valStr = dynamicFilterNode._attr.val;
    var maxValStr = dynamicFilterNode._attr.maxVal;
    if (!isNullOrWhiteSpace(valStr)) {
        dynamicFilter.value = valStr;
    }
    if (!isNullOrWhiteSpace(maxValStr)) {
        dynamicFilter.maxValue = maxValStr;
    }
    return dynamicFilter;
}
function readTop10Filter(top10FilterNode) {
    var top10Filter = {};
    top10Filter.value = getAttrValueOrDefaultOfDoubleType(top10FilterNode._attr.val, NaN);
    top10Filter.percent = getAttrValueOrDefaultOfBooleanType(top10FilterNode._attr.percent, false);
    top10Filter.top = getAttrValueOrDefaultOfBooleanType(top10FilterNode._attr.top, true);
    return top10Filter;
}
function readSortInfo(sortNode) {
    var sortInfo = {};
    var attr = sortNode.sortCondition._attr;
    if (attr) {
        sortInfo.ascending = !attr.descending;
        sortInfo.index = range_parser_1.getRangesFromString(attr.ref)[0].col;
        if (attr.sortBy === 'fontColor' || attr.sortBy === 'cellColor') {
            sortInfo.isBackColor = (attr.sortBy === 'cellColor');
            sortInfo.dxfId = getAttributeValueOrDefaultOfIntType(attr.dxfId, 0);
        }
    }
    return sortInfo;
}
exports.readSortInfo = readSortInfo;
function readAutoFilter(autoFilterNode) {
    var autoFilter = {};
    var refInA1Style = autoFilterNode._attr.ref.toUpperCase();
    if (!refInA1Style || refInA1Style === '#REF!') {
        return null;
    }
    var ranges = range_parser_1.getRangesFromString(refInA1Style);
    if (ranges[0]) {
        autoFilter.range = ranges[0];
    }
    autoFilter.filterColumns = [];
    var filterColumnsNode = getAsArray(autoFilterNode.filterColumn);
    filterColumnsNode.forEach(function (filterColumnNode) {
        var filterColumn = {};
        var colId = filterColumnNode._attr.colId;
        filterColumn.hiddenButton = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(filterColumnNode._attr.hiddenButton, false);
        if (!isNullOrWhiteSpace(colId)) {
            filterColumn.autoFilterColumnId = parseInt(colId, 10);
        }
        if (filterColumnNode.colorFilter) {
            filterColumn.colorFilter = readColorFilter(filterColumnNode.colorFilter);
        }
        if (filterColumnNode.filters) {
            filterColumn.filters = readFilters(filterColumnNode.filters);
        }
        if (filterColumnNode.customFilters) {
            filterColumn.customFilters = readCustomFilters(filterColumnNode.customFilters);
        }
        if (filterColumnNode.dynamicFilter) {
            filterColumn.dynamicFilter = readDynamicFilter(filterColumnNode.dynamicFilter);
        }
        if (filterColumnNode.top10) {
            filterColumn.top10Filter = readTop10Filter(filterColumnNode.top10);
        }
        autoFilter.filterColumns.push(filterColumn);
    });
    return autoFilter;
}
exports.readAutoFilter = readAutoFilter;
function readAutoFilterForSheet(reader, sheetName, readerDataModel) {
    var autoFilterNode = xml_parser_1.parseXmlToObject(reader.readFullElement()).autoFilter;
    var autoFilter = readAutoFilter(autoFilterNode);
    if (autoFilterNode.sortState) {
        autoFilter.sortInfo = readSortInfo(autoFilterNode.sortState);
    }
    readerDataModel._setAutoFilter(sheetName, autoFilter);
}
exports.readAutoFilterForSheet = readAutoFilterForSheet;


/***/ }),

/***/ "./src/xlsx-io/reader/chart-reader.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/reader/chart-reader.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var chart_model_1 = __webpack_require__(/*! ./../../datamodel/chart-model */ "./src/datamodel/chart-model.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var chart_helper_1 = __webpack_require__(/*! ./../common/chart-helper */ "./src/xlsx-io/common/chart-helper.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var node_helper_1 = __webpack_require__(/*! ./../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var emuToPixles = excel_style_1.UnitHelper.emuToPixles;
var xmlDecode = common_1.Util._xmlDecode;
var getAttrValueOrDefaultOfBooleanType = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType;
var getAttrValueOrDefaultOfDoubleType = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfDoubleType;
var getAttributeValueOrDefaultOfIntType = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType;
var keyword_null = null, CONST_VAL = 'val', CONST_NAME = 'name', CONST_TYPE = 'type', CONST_PRST = 'prst', CONST_EXTLST = 'extLst', CONST_CNVPR = 'cNvPr', CONST_MACRO = 'macro', CONST_EFFECTLST = 'effectLst', CONST_EFFECT_DAG = 'effectDag', CONST_FPUBLISHED = 'fPublished', CONST_GRAPHIC_FRAME = 'graphicFrame', CONST_DUMY = 'dumy', CONST_EXT = 'ext', CONST_SCRGBCLR = 'scrgbClr', CONST_SRGBCLR = 'srgbClr', CONST_HSLCLR = 'hslClr', CONST_SYSCLR = 'sysClr', CONST_SCHEMECLR = 'schemeClr', CONST_PRSTCLR = 'prstClr', CONST_STYLECLR = 'styleClr', CONST_NO_FILL = 'noFill', CONST_SOLID_FILL = 'solidFill', CONST_GRAD_FILL = 'gradFill', CONST_BLIP_FILL = 'blipFill', CONST_PATT_FILL = 'pattFill', CONST_GRP_FILL = 'grpFill', CONST_DELETE = 'delete', CONST_IDX = 'idx', CONST_SCENE_3D = 'scene3d', CONST_SPPR = 'spPr', CONST_TXPR = 'txPr', CONST_SQREF = 'sqref', CONST_INVERT_IF_NEGATIVE = 'invertIfNegative', CONST_BUBBLE_3D = 'bubble3D', CONST_MARKER = 'marker', CONST_GRPSP = 'grpSp', CONST_CXNSP = 'cxnSp', CONST_CLR_SCHEME = 'clrScheme', CONST_FONT_SCHEME = 'fontScheme', CONST_FMT_SCHEME = 'fmtScheme', CONST_LAYOUT = 'layout', CONST_PICTURE_OPTIONS = 'pictureOptions', CONST_ORDER = 'order', CONST_GAP_WIDTH = 'gapWidth', COSNT_DLBLS = 'dLbls', CONST_TRENDLINE = 'trendline', CONST_ERR_BARS = 'errBars', CONST_SER = 'ser', CONST_DROP_LINES = 'dropLines', CONST_AXID = 'axId', CONST_GROUPING = 'grouping', CONST_VARY_COLORS = 'varyColors', CONST_SCALING = 'scaling', CONST_AX_POS = 'axPos', CONST_MAJOR_GRIDLINES = 'majorGridlines', CONST_MINOR_GRIDLINES = 'minorGridlines', CONST_TITLE = 'title', CONST_NUMFMT = 'numFmt', CONST_MAJOR_TICK_MARK = 'majorTickMark', CONST_MINOR_TICK_MARK = 'minorTickMark', CONST_TICK_LBLPOS = 'tickLblPos', CONST_CROSSAX = 'crossAx', CONST_CROSSES = 'crosses', CONST_CROSSAT = 'crossesAt', CONST_STYLE = 'style', CONST_TOT_WITH_SHAPE = 'rotWithShape', CONST_REQUIRES = 'Requires';
function getValidValue(value, defaultValue) {
    return !common_1._isNullOrUndefined(value) ? value : defaultValue;
}
function getAttributeName(reader) {
    var attrName = reader.readAttributeNameAsString().split(':');
    return attrName.length > 1 ? attrName[1] : attrName[0];
}
function getElementName(reader) {
    var elementName = reader.name().split(':');
    return elementName.length > 1 ? elementName[1] : elementName[0];
}
function readSingleAttributeNode(reader, attrName, convertDataTypeFunc) {
    while (reader.moveToNextAttribute()) {
        var tempAttrName = getAttributeName(reader);
        if (tempAttrName === attrName) {
            var tempValue = reader.readContentAsString();
            if (convertDataTypeFunc) {
                tempValue = convertDataTypeFunc(tempValue);
            }
            return tempValue;
        }
    }
}
function readSingleSubElementNode(reader, elementName, readElementFunc, instance) {
    var tempInstance = instance || {};
    if (reader.elementType === 3) {
        return tempInstance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var tempElementName = getElementName(reader);
        if (tempElementName === elementName) {
            tempInstance[elementName] = readElementFunc(reader);
        }
    }
    return tempInstance;
}
function readSubColorElements(reader, instance) {
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_SCRGBCLR:
                instance.scrgbClr = ReadCT_ScRgbColor(reader);
                break;
            case CONST_SRGBCLR:
                instance.srgbClr = ReadCT_SRgbColor(reader);
                break;
            case CONST_HSLCLR:
                instance.hslClr = ReadCT_HslColor(reader);
                break;
            case CONST_SYSCLR:
                instance.sysClr = ReadCT_SystemColor(reader);
                break;
            case CONST_SCHEMECLR:
                instance.schemeClr = ReadCT_SchemeColor(reader);
                break;
            case CONST_PRSTCLR:
                instance.prstClr = ReadCT_PresetColor(reader);
                break;
        }
    }
    return instance;
}
function readFillProperties(reader, instance) {
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_NO_FILL:
                instance.noFill = ReadCT_NoFillProperties();
                break;
            case CONST_SOLID_FILL:
                instance.solidFill = ReadCT_SolidColorFillProperties(reader);
                break;
            case CONST_GRAD_FILL:
                instance.gradFill = ReadCT_GradientFillProperties(reader);
                break;
            case CONST_BLIP_FILL:
                instance.blipFill = ReadCT_BlipFillProperties(reader);
                break;
            case CONST_PATT_FILL:
                instance.pattFill = ReadCT_PatternFillProperties(reader);
                break;
            case CONST_GRP_FILL:
                instance.grpFill = ReadCT_GroupFillProperties();
                break;
        }
    }
    return instance;
}
exports.DrawingReader = {};
function readFillPropertiesAsArrayItem(reader, instance) {
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_NO_FILL:
                instance.items.push(exports.DrawingReader.ReadCT_NoFillProperties(reader));
                break;
            case CONST_SOLID_FILL:
                instance.items.push(exports.DrawingReader.ReadCT_SolidColorFillProperties(reader));
                break;
            case CONST_GRAD_FILL:
                instance.items.push(exports.DrawingReader.ReadCT_GradientFillProperties(reader));
                break;
            case CONST_BLIP_FILL:
                instance.items.push(exports.DrawingReader.ReadCT_BlipFillProperties(reader));
                break;
            case CONST_PATT_FILL:
                instance.items.push(exports.DrawingReader.ReadCT_PatternFillProperties(reader));
                break;
            case CONST_GRP_FILL:
                instance.items.push(exports.DrawingReader.ReadCT_GroupFillProperties(reader));
                break;
        }
    }
    return instance;
}
function readColorSubElement(reader, instance) {
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "tint":
                instance.tint = [ReadCT_PositiveFixedPercentage(reader)];
                break;
            case "shade":
                instance.shade = [ReadCT_PositiveFixedPercentage(reader)];
                break;
            case "comp":
                instance.comp = [ReadCT_ComplementTransform()];
                break;
            case "inv":
                instance.inv = [ReadCT_InverseTransform()];
                break;
            case "gray":
                instance.gray = [ReadCT_GrayscaleTransform()];
                break;
            case "alpha":
                instance.alpha = [ReadCT_PositiveFixedPercentage(reader)];
                break;
            case "alphaMod":
                instance.alphaMod = [ReadCT_PositivePercentage(reader)];
                break;
            case "alphaOff":
                instance.alphaOff = [ReadCT_FixedPercentage(reader)];
                break;
            case "hue":
                instance.hue = [ReadCT_PositiveFixedAngle(reader)];
                break;
            case "hueMod":
                instance.hueMod = [ReadCT_PositivePercentage(reader)];
                break;
            case "hueOff":
                instance.hueOff = [ReadCT_Angle(reader)];
                break;
            case "sat":
                instance.sat = [ReadCT_Percentage(reader)];
                break;
            case "satMod":
                instance.satMod = [ReadCT_Percentage(reader)];
                break;
            case "satOff":
                instance.satOff = [ReadCT_Percentage(reader)];
                break;
            case "lum":
                instance.lum = [ReadCT_Percentage(reader)];
                break;
            case "lumMod":
                instance.lumMod = [ReadCT_Percentage(reader)];
                break;
            case "lumOff":
                instance.lumOff = [ReadCT_Percentage(reader)];
                break;
            case "red":
                instance.red = [ReadCT_Percentage(reader)];
                break;
            case "redMod":
                instance.redMod = [ReadCT_Percentage(reader)];
                break;
            case "redOff":
                instance.redOff = [ReadCT_Percentage(reader)];
                break;
            case "green":
                instance.green = [ReadCT_Percentage(reader)];
                break;
            case "greenMod":
                instance.greenMod = [ReadCT_Percentage(reader)];
                break;
            case "greenOff":
                instance.greenOff = [ReadCT_Percentage(reader)];
                break;
            case "blue":
                instance.blue = [ReadCT_Percentage(reader)];
                break;
            case "blueMod":
                instance.blueMod = [ReadCT_Percentage(reader)];
                break;
            case "blueOff":
                instance.blueOff = [ReadCT_Percentage(reader)];
                break;
            case "gamma":
                instance.gamma = [ReadCT_GammaTransform()];
                break;
            case "invGamma":
                instance.invGamma = [ReadCT_InverseGammaTransform()];
                break;
        }
    }
    return instance;
}
function readSurfaceChartSubElement(reader, instance) {
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "wireframe":
                instance.wireframe = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_SurfaceSer(reader));
                break;
            case "bandFmts":
                instance.bandFmts = ReadCT_BandFmts(reader);
                break;
            case CONST_AXID:
                instance.axId.push(ReadCT_Int(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
function readGraphicFrameNonVisualSubElement(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_CNVPR) {
            instance.cNvPr = ReadCT_NonVisualDrawingProps(reader);
        }
    }
    return instance;
}
function readSubSqrefElement(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_SQREF) {
            instance.sqref = reader.readElementContentAsString();
        }
    }
    return instance;
}
var Chart2016Reader = {};
Chart2016Reader.ReadContentValueAsString = function (reader) {
    var instance = '';
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "val":
                instance = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadElementContentAsString = function (reader) {
    var instance = '';
    if (reader.elementType === 3) {
        return instance;
    }
    if (reader.elementType === 1) {
        instance = reader.readElementContentAsString();
    }
    while (reader.read()) {
        if (reader.elementType === 2) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ChartStyle = function (reader) {
    var instance = { attribute: {} };
    while (reader.moveToNextAttribute()) {
        var attributeName = getAttributeName(reader);
        instance.attribute[attributeName] = reader.readContentAsString();
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        if (elementName === 'dataPointMarkerLayout') {
            instance.dataPointMarkerLayout = Chart2016Reader.ReadCT_DataPointMarkerLayout(reader);
        }
        else if (elementName === 'extLst') {
            instance.extLst = ReadCT_OfficeArtExtensionList(reader);
        }
        else {
            instance[elementName] = Chart2016Reader.ReadCT_ChartStyleElement(reader);
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ChartStyleElement = function (reader) {
    var instance = { attribute: {} };
    var startDepth = reader.depth;
    while (reader.moveToNextAttribute()) {
        var attributeName = getAttributeName(reader);
        if (attributeName === 'mods') {
            instance.attribute[attributeName] = reader.readContentAsString();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        if (elementName === "lnRef" || elementName === "fillRef" || elementName === "effectRef") {
            instance[elementName] = ReadCT_StyleMatrixReference(reader);
        }
        else if (elementName === "fontRef") {
            instance.fontRef = ReadCT_FontReference(reader);
        }
        else if (elementName === CONST_SPPR) {
            instance.spPr = ReadCT_ShapeProperties(reader);
        }
        else if (elementName === "defRPr") {
            instance.defRPr = ReadCT_TextCharacterProperties(reader);
        }
        else if (elementName === 'bodyPr') {
            instance.bodyPr = ReadCT_TextBodyProperties(reader);
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_DataPointMarkerLayout = function (reader) {
    var instance = { attribute: {} };
    while (reader.moveToNextAttribute()) {
        var attributeName = getAttributeName(reader);
        instance.attribute[attributeName] = reader.readContentAsString();
    }
    return instance;
};
Chart2016Reader.ReadCT_Extension = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "uri":
                instance.uri = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return instance;
};
Chart2016Reader.ReadCT_chartColors = function (reader) {
    var instance = { schemeClr: [], variation: [], attribute: {} };
    var startDepth = reader.depth;
    while (reader.moveToNextAttribute()) {
        var attributeName = getAttributeName(reader);
        instance.attribute[attributeName] = reader.readContentAsString();
    }
    if (reader.elementType === 3) {
        return instance;
    }
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        if (elementName === "schemeClr") {
            instance.schemeClr.push(ReadCT_SchemeColor(reader));
        }
        else if (elementName === "variation") {
            instance.variation.push(Chart2016Reader.ReadCT_Variation(reader));
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Variation = function (reader) {
    var instance = {};
    var startDepth = reader.depth;
    if (reader.elementType === 3) {
        return instance;
    }
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        if (elementName === "lumMod") {
            instance.lumMod = ReadCT_Percentage(reader);
        }
        else if (elementName === "lumOff") {
            instance.lumOff = ReadCT_Percentage(reader);
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ExtensionList = function (reader) {
    var instance = { ext: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "ext":
                instance.ext.push(Chart2016Reader.ReadCT_Extension(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_NumberFormat = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "formatCode":
                instance.formatCode = xmlDecode(reader.readContentAsString());
                break;
            case "sourceLinked":
                instance.sourceLinked = reader.readContentAsBoolean();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ValueColors = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "minColor":
                instance.minColor = ReadCT_SolidColorFillProperties(reader);
                break;
            case "midColor":
                instance.midColor = ReadCT_SolidColorFillProperties(reader);
                break;
            case "maxColor":
                instance.maxColor = ReadCT_SolidColorFillProperties(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ExternalData = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "id":
                instance.id = reader.readContentAsString();
                break;
            case "autoUpdate":
                instance.autoUpdate = reader.readContentAsBoolean();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Formula = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "dir":
                instance.dir = chart_model_1.Charts.ST_FormulaDirection[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    if (reader.elementType === 1) {
        instance.formula = reader.readElementContentAsString();
    }
    while (reader.read()) {
        if (reader.elementType === 2) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Value = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    if (reader.elementType === 1) {
        instance.value = reader.readElementContentAsString();
    }
    while (reader.read()) {
        if (reader.elementType === 2) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_DataId = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "val":
                instance.val = parseInt(reader.readContentAsString(), 10);
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadST_AxisId = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "val":
                instance.val = parseInt(reader.readContentAsString(), 10);
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_StringValue = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "idx":
                instance.idx = reader.readContentAsInt();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    if (reader.elementType === 1) {
        instance.value = reader.readElementContentAsString();
    }
    while (reader.read()) {
        if (reader.elementType === 2) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_StringLevel = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "ptCount":
                instance.ptCount = parseInt(reader.readContentAsString(), 10);
                break;
            case "name":
                instance.name = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "pt":
                instance.pt.push(Chart2016Reader.ReadCT_StringValue(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_StringDimension = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "type":
                instance.type = chart_model_1.Charts.ST_StringDimensionType[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "lvl":
                instance.lvl.push(Chart2016Reader.ReadCT_StringLevel(reader));
                break;
            case "nf":
                instance.nf = Chart2016Reader.ReadCT_Formula(reader);
                break;
            case "f":
                instance.f = Chart2016Reader.ReadCT_Formula(reader);
                break;
            default:
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_NumericValue = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "idx":
                instance.idx = reader.readContentAsInt();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    if (reader.elementType === 1) {
        instance.value = reader.readElementContentAsDouble();
    }
    while (reader.read()) {
        if (reader.elementType === 2) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_NumericLevel = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "ptCount":
                instance.ptCount = parseInt(reader.readContentAsString(), 10);
                break;
            case "formatCode":
                instance.formatCode = reader.readContentAsString();
                break;
            case "name":
                instance.name = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "pt":
                instance.pt.push(Chart2016Reader.ReadCT_NumericValue(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_NumericDimension = function (reader) {
    var instance = { lvl: [] };
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "type":
                instance.type = chart_model_1.Charts.ST_NumericDimensionType[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "lvl":
                instance.lvl.push(Chart2016Reader.ReadCT_NumericLevel(reader));
                break;
            case "nf":
                instance.nf = Chart2016Reader.ReadCT_Formula(reader);
                break;
            case "f":
                instance.f = Chart2016Reader.ReadCT_Formula(reader);
                break;
            default:
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Data = function (reader) {
    var instance = { numDim: [], strDim: [] };
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "id":
                instance.id = parseInt(reader.readContentAsString(), 10);
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
            case "numDim":
                instance.numDim.push(Chart2016Reader.ReadCT_NumericDimension(reader));
                break;
            case "strDim":
                instance.strDim.push(Chart2016Reader.ReadCT_StringDimension(reader));
                break;
            default:
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ChartData = function (reader) {
    var instance = { data: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "externalData":
                instance.externalData = Chart2016Reader.ReadCT_ExternalData(reader);
                break;
            case "data":
                instance.data.push(Chart2016Reader.ReadCT_Data(reader));
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_TextData = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "f":
                instance.f = Chart2016Reader.ReadCT_Formula(reader);
                break;
            case "v":
                instance.v = Chart2016Reader.ReadCT_Value(reader);
                break;
            default:
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Text = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "txData":
                instance.txData = Chart2016Reader.ReadCT_TextData(reader);
                break;
            case "rich":
                instance.rich = ReadCT_TextBody(reader);
                break;
            default:
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ChartTitle = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "pos":
                instance.pos = chart_model_1.Charts.ST_SidePos[reader.readContentAsString()];
                break;
            case "align":
                instance.align = chart_model_1.Charts.ST_PosAlign[reader.readContentAsString()];
                break;
            case "overlay":
                instance.overlay = reader.readContentAsBoolean();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "tx":
                instance.tx = Chart2016Reader.ReadCT_Text(reader);
                break;
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "txPr":
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_CategoryAxisScaling = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "gapWidth":
                instance.gapWidth = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ValueAxisScaling = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "max":
                instance.max = reader.readContentAsString();
                break;
            case "min":
                instance.min = reader.readContentAsString();
                break;
            case "majorUnit":
                instance.majorUnit = reader.readContentAsString();
                break;
            case "minorUnit":
                instance.minorUnit = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_AxisTitle = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "tx":
                instance.tx = Chart2016Reader.ReadCT_Text(reader);
                break;
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "txPr":
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_AxisUnitsLabel = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "tx":
                instance.tx = Chart2016Reader.ReadCT_Text(reader);
                break;
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "txPr":
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_AxisUnits = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "unit":
                instance.unit = chart_model_1.Charts.ST_AxisUnit[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "unitsLabel":
                instance.unitsLabel = Chart2016Reader.ReadCT_AxisUnitsLabel(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Gridlines = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_TickMarks = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "type":
                instance = chart_model_1.Charts.ST_TickMarksType[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_TickLabels = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Axis = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "id":
                instance.id = parseInt(reader.readContentAsString(), 10);
                break;
            case "hidden":
                instance.hidden = reader.readContentAsBoolean();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "title":
                instance.title = Chart2016Reader.ReadCT_AxisTitle(reader);
                break;
            case "units":
                instance.units = Chart2016Reader.ReadCT_AxisUnits(reader);
                break;
            case "majorGridlines":
                instance.majorGridlines = Chart2016Reader.ReadCT_Gridlines(reader);
                break;
            case "minorGridlines":
                instance.minorGridlines = Chart2016Reader.ReadCT_Gridlines(reader);
                break;
            case "majorTickMarks":
                instance.majorTickMarks = Chart2016Reader.ReadCT_TickMarks(reader);
                break;
            case "minorTickMarks":
                instance.minorTickMarks = Chart2016Reader.ReadCT_TickMarks(reader);
                break;
            case "tickLabels":
                instance.tickLabels = Chart2016Reader.ReadCT_TickLabels(reader);
                break;
            case "numFmt":
                instance.numFmt = Chart2016Reader.ReadCT_NumberFormat(reader);
                break;
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "txPr":
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
            case "catScaling":
                instance.catScaling = Chart2016Reader.ReadCT_CategoryAxisScaling(reader);
                break;
            case "valScaling":
                instance.valScaling = Chart2016Reader.ReadCT_ValueAxisScaling(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ParentLabelLayout = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "val":
                instance.val = chart_model_1.Charts.ST_ParentLabelLayout[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_RegionLabelLayout = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "val":
                instance.val = chart_model_1.Charts.ST_RegionLabelLayout[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_SeriesElementVisibilities = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "connectorLines":
                instance.connectorLines = reader.readContentAsBoolean();
                break;
            case "meanLine":
                instance.meanLine = reader.readContentAsBoolean();
                break;
            case "meanMarker":
                instance.meanMarker = reader.readContentAsBoolean();
                break;
            case "nonoutliers":
                instance.nonoutliers = reader.readContentAsBoolean();
                break;
            case "outliers":
                instance.outliers = reader.readContentAsBoolean();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Aggregation = function () {
    return {};
};
Chart2016Reader.ReadCT_Binning = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "intervalClosed":
                instance.intervalClosed = chart_model_1.Charts.ST_IntervalClosedSide[reader.readContentAsString()];
                break;
            case "underflow":
                instance.underflow = reader.readContentAsString();
                break;
            case "overflow":
                instance.overflow = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "binSize":
                instance.binSize = Chart2016Reader.ReadBinSize(reader);
                break;
            case "binCount":
                instance.binCount = Chart2016Reader.ReadBinCount(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadBinSize = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "val":
                instance.val = reader.readContentAsDouble();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadBinCount = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "val":
                instance.val = reader.readContentAsInt();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoLocationQuery = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "countryRegion":
                instance.countryRegion = reader.readContentAsString();
                break;
            case "adminDistrict1":
                instance.adminDistrict1 = reader.readContentAsString();
                break;
            case "adminDistrict2":
                instance.adminDistrict2 = reader.readContentAsString();
                break;
            case "postalCode":
                instance.postalCode = reader.readContentAsString();
                break;
            case "entityType":
                instance.entityType = chart_model_1.Charts.ST_EntityType[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Address = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "address1":
                instance.address1 = reader.readContentAsString();
                break;
            case "countryRegion":
                instance.countryRegion = reader.readContentAsString();
                break;
            case "adminDistrict1":
                instance.adminDistrict1 = reader.readContentAsString();
                break;
            case "adminDistrict2":
                instance.adminDistrict2 = reader.readContentAsString();
                break;
            case "postalCode":
                instance.postalCode = reader.readContentAsString();
                break;
            case "locality":
                instance.locality = reader.readContentAsString();
                break;
            case "isoCountryCode":
                instance.isoCountryCode = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoLocation = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "latitude":
                instance.latitude = reader.readContentAsDouble();
                break;
            case "longitude":
                instance.longitude = reader.readContentAsDouble();
                break;
            case "entityName":
                instance.entityName = reader.readContentAsString();
                break;
            case "entityType":
                instance.entityType = chart_model_1.Charts.ST_EntityType[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "address":
                instance.address = Chart2016Reader.ReadCT_Address(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoLocations = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "geoLocation":
                instance.geoLocation = Chart2016Reader.ReadCT_GeoLocation(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoLocationQueryResult = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "geoLocationQuery":
                instance.geoLocationQuery = Chart2016Reader.ReadCT_GeoLocationQuery(reader);
                break;
            case "geoLocations":
                instance.geoLocations = Chart2016Reader.ReadCT_GeoLocations(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoLocationQueryResults = function (reader) {
    var instance = { geoLocationQueryResult: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "geoLocationQueryResult":
                instance.geoLocationQueryResult.push(Chart2016Reader.ReadCT_GeoLocationQueryResult(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoPolygon = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "polygonId":
                instance.polygonId = reader.readContentAsString();
                break;
            case "numPoints":
                break;
            case "pcaRings":
                instance.pcaRings = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoPolygons = function (reader) {
    var instance = { geoPolygon: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "geoPolygon":
                instance.geoPolygon.push(Chart2016Reader.ReadCT_GeoPolygon(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Copyrights = function (reader) {
    var instance = { copyright: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "copyright":
                instance.copyright.push(Chart2016Reader.ReadElementContentAsString(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoData = function (reader) {
    var instance = { geoPolygons: [], copyrights: [] };
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "entityName":
                instance.entityName = reader.readContentAsString();
                break;
            case "entityId":
                instance.entityId = reader.readContentAsString();
                break;
            case "east":
                instance.east = reader.readContentAsDouble();
                break;
            case "west":
                instance.west = reader.readContentAsDouble();
                break;
            case "north":
                instance.north = reader.readContentAsDouble();
                break;
            case "south":
                instance.south = reader.readContentAsDouble();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "geoPolygons":
                instance.geoPolygons.push(Chart2016Reader.ReadCT_GeoPolygon(reader));
                break;
            case "copyrights":
                instance.copyrights = Chart2016Reader.ReadCT_Copyrights(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoDataEntityQuery = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "entityType":
                instance.entityType = chart_model_1.Charts.ST_EntityType[reader.readContentAsString()];
                break;
            case "entityId":
                instance.entityId = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoDataEntityQueryResult = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "geoDataEntityQuery":
                instance.geoDataEntityQuery = Chart2016Reader.ReadCT_GeoDataEntityQuery(reader);
                break;
            case "geoData":
                instance.geoData = Chart2016Reader.ReadCT_GeoData(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoDataEntityQueryResults = function (reader) {
    var instance = { geoDataEntityQueryResult: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "geoDataEntityQueryResult":
                instance.geoDataEntityQueryResult.push(Chart2016Reader.ReadCT_GeoDataEntityQueryResult(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoDataPointQuery = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "entityType":
                instance.entityType = chart_model_1.Charts.ST_EntityType[reader.readContentAsString()];
                break;
            case "latitude":
                instance.latitude = reader.readContentAsDouble();
                break;
            case "longitude":
                instance.longitude = reader.readContentAsDouble();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoDataPointToEntityQuery = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "entityType":
                instance.entityType = chart_model_1.Charts.ST_EntityType[reader.readContentAsString()];
                break;
            case "entityId":
                instance.entityId = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoDataPointToEntityQueryResult = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "geoDataPointQuery":
                instance.geoDataPointQuery = Chart2016Reader.ReadCT_GeoDataPointQuery(reader);
                break;
            case "geoDataPointToEntityQuery":
                instance.geoDataPointToEntityQuery = Chart2016Reader.ReadCT_GeoDataPointToEntityQuery(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoDataPointToEntityQueryResults = function (reader) {
    var instance = { geoDataPointToEntityQueryResult: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "geoDataPointToEntityQueryResult":
                instance.geoDataPointToEntityQueryResult.push(Chart2016Reader.ReadCT_GeoDataPointToEntityQueryResult(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoChildTypes = function (reader) {
    var instance = { entityType: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "entityType":
                instance.entityType.push(Chart2016Reader.ReadElementContentAsString(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoChildEntitiesQuery = function (reader) {
    var instance = { geoChildTypes: [] };
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "entityId":
                instance.entityId = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "geoChildTypes":
                instance.geoChildTypes = Chart2016Reader.ReadCT_GeoChildTypes(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoHierarchyEntity = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "entityName":
                instance.entityName = reader.readContentAsString();
                break;
            case "entityId":
                instance.entityId = reader.readContentAsString();
                break;
            case "entityType":
                instance.entityType = chart_model_1.Charts.ST_EntityType[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoChildEntities = function (reader) {
    var instance = { geoHierarchyEntity: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "geoHierarchyEntity":
                instance.geoHierarchyEntity.push(Chart2016Reader.ReadCT_GeoHierarchyEntity(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoChildEntitiesQueryResult = function (reader) {
    var instance = { geoChildEntities: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "geoChildEntitiesQuery":
                instance.geoChildEntitiesQuery = Chart2016Reader.ReadCT_GeoChildEntitiesQuery(reader);
                break;
            case "geoChildEntities":
                instance.geoChildEntities.push(Chart2016Reader.ReadCT_GeoHierarchyEntity(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoChildEntitiesQueryResults = function (reader) {
    var instance = { geoChildEntitiesQueryResult: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "geoChildEntitiesQueryResult":
                instance.geoChildEntitiesQueryResult.push(Chart2016Reader.ReadCT_GeoChildEntitiesQueryResult(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Clear = function (reader) {
    var instance = {
        geoChildEntitiesQueryResults: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "geoLocationQueryResults":
                instance.geoLocationQueryResults = Chart2016Reader.ReadCT_GeoLocationQueryResults(reader);
                break;
            case "geoDataEntityQueryResults":
                instance.geoDataEntityQueryResults = Chart2016Reader.ReadCT_GeoDataEntityQueryResults(reader);
                break;
            case "geoDataPointToEntityQueryResults":
                instance.geoDataPointToEntityQueryResults = Chart2016Reader.ReadCT_GeoDataPointToEntityQueryResults(reader);
                break;
            case "geoChildEntitiesQueryResults":
                instance.geoChildEntitiesQueryResults = Chart2016Reader.ReadCT_GeoChildEntitiesQueryResults(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_GeoCache = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "provider":
                instance.provider = reader.readContentAsString();
                break;
            case "binary":
                instance.binary = reader.readContentAsString();
                break;
            case "clear":
                instance.clear = Chart2016Reader.ReadCT_Clear(reader);
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Geography = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "projectionType":
                instance.projectionType = chart_model_1.Charts.ST_GeoProjectionType[reader.readContentAsString()];
                break;
            case "viewedRegionType":
                instance.viewedRegionType = chart_model_1.Charts.ST_GeoMappingLevel[reader.readContentAsString()];
                break;
            case "cultureLanguage":
                instance.cultureLanguage = reader.readContentAsString();
                break;
            case "cultureRegion":
                instance.cultureRegion = reader.readContentAsString();
                break;
            case "attribution":
                instance.attribution = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "geoCache":
                instance.geoCache = Chart2016Reader.ReadCT_GeoCache(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Statistics = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "quartileMethod":
                instance.quartileMethod = chart_model_1.Charts.ST_QuartileMethod[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Subtotals = function (reader) {
    var instance = { idx: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "idx":
                instance.idx.push(parseInt(Chart2016Reader.ReadContentValueAsString(reader), 10));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_SeriesLayoutProperties = function (reader) {
    var instance = { subtotals: [], extLst: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "parentLabelLayout":
                instance.parentLabelLayout = Chart2016Reader.ReadCT_ParentLabelLayout(reader);
                break;
            case "regionLabelLayout":
                instance.regionLabelLayout = Chart2016Reader.ReadCT_RegionLabelLayout(reader);
                break;
            case "visibility":
                instance.visibility = Chart2016Reader.ReadCT_SeriesElementVisibilities(reader);
                break;
            case "geography":
                instance.geography = Chart2016Reader.ReadCT_Geography(reader);
                break;
            case "statistics":
                instance.statistics = Chart2016Reader.ReadCT_Statistics(reader);
                break;
            case "subtotals":
                instance.subtotals = Chart2016Reader.ReadCT_Subtotals(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
            case "aggregation":
                instance.aggregation = Chart2016Reader.ReadCT_Aggregation(reader);
                break;
            case "binning":
                instance.binning = Chart2016Reader.ReadCT_Binning(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_DataPoint = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "idx":
                instance.idx = parseInt(reader.readContentAsString(), 10);
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ExtremeValueColorPosition = function () {
    return {};
};
Chart2016Reader.ReadCT_NumberColorPosition = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "val":
                instance.val = reader.readContentAsDouble();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_PercentageColorPosition = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "val":
                instance.val = reader.readContentAsDouble();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ValueColorEndPosition = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "extremeValue":
                instance.extremeValue = Chart2016Reader.ReadCT_ExtremeValueColorPosition(reader);
                break;
            case "number":
                instance.number = Chart2016Reader.ReadCT_NumberColorPosition(reader);
                break;
            case "percent":
                instance.percent = Chart2016Reader.ReadCT_PercentageColorPosition(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ValueColorMiddlePosition = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "number":
                instance.aggregation = Chart2016Reader.ReadCT_NumberColorPosition(reader);
                break;
            case "percent":
                instance.binning = Chart2016Reader.ReadCT_PercentageColorPosition(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ValueColorPositions = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "count":
                instance.count = reader.readContentAsInt();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "min":
                instance.min = Chart2016Reader.ReadCT_ValueColorEndPosition(reader);
                break;
            case "mid":
                instance.mid = Chart2016Reader.ReadCT_ValueColorMiddlePosition(reader);
                break;
            case "max":
                instance.max = Chart2016Reader.ReadCT_ValueColorEndPosition(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_DataLabelVisibilities = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "seriesName":
                instance.seriesName = reader.readContentAsBoolean();
                break;
            case "categoryName":
                instance.categoryName = reader.readContentAsBoolean();
                break;
            case "value":
                instance.value = reader.readContentAsBoolean();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_DataLabel = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "idx":
                instance.idx = parseInt(reader.readContentAsString(), 10);
                break;
            case "pos":
                instance.pos = chart_model_1.Charts.ST_DataLabelPos[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "numFmt":
                instance.numFmt = Chart2016Reader.ReadCT_NumberFormat(reader);
                break;
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "txPr":
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case "visibility":
                instance.visibility = Chart2016Reader.ReadCT_DataLabelVisibilities(reader);
                break;
            case "separator":
                instance.separator = Chart2016Reader.ReadElementContentAsString(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_DataLabelHidden = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "idx":
                instance.idx = parseInt(reader.readContentAsString(), 10);
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_DataLabels = function (reader) {
    var instance = { dataLabel: [], dataLabelHidden: [], extLst: [] };
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "pos":
                instance.pos = chart_model_1.Charts.ST_DataLabelPos[reader.readContentAsString()];
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "numFmt":
                instance.numFmt = Chart2016Reader.ReadCT_NumberFormat(reader);
                break;
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "txPr":
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case "visibility":
                instance.visibility = Chart2016Reader.ReadCT_DataLabelVisibilities(reader);
                break;
            case "separator":
                instance.separator = Chart2016Reader.ReadElementContentAsString(reader);
                break;
            case "dataLabel":
                instance.dataLabel.push(Chart2016Reader.ReadCT_DataLabel(reader));
                break;
            case "dataLabelHidden":
                instance.dataLabelHidden.push(Chart2016Reader.ReadCT_DataLabelHidden(reader));
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Series = function (reader) {
    var instance = { dataPt: [], axisId: [], extLst: [] };
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "layoutId":
                instance.layoutId = chart_helper_1.ChartHelper.ToCT_ChartType(chart_model_1.Charts.ST_SeriesLayout[reader.readContentAsString()]);
                break;
            case "hidden":
                instance.hidden = reader.readContentAsBoolean();
                break;
            case "ownerIdx":
                instance.ownerIdx = parseInt(reader.readContentAsString(), 10);
                break;
            case "uniqueId":
                instance.uniqueId = reader.readContentAsString();
                break;
            case "formatIdx":
                instance.formatIdx = parseInt(reader.readContentAsString(), 10);
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "tx":
                instance.tx = Chart2016Reader.ReadCT_Text(reader);
                break;
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "valueColors":
                instance.valueColors = Chart2016Reader.ReadCT_ValueColors(reader);
                break;
            case "valueColorPositions":
                instance.valueColorPositions = Chart2016Reader.ReadCT_ValueColorPositions(reader);
                break;
            case "dataPt":
                instance.dataPt.push(Chart2016Reader.ReadCT_DataPoint(reader));
                break;
            case "dataLabels":
                instance.dataLabels = Chart2016Reader.ReadCT_DataLabels(reader);
                break;
            case "dataId":
                instance.dataId = Chart2016Reader.ReadCT_DataId(reader);
                break;
            case "layoutPr":
                instance.layoutPr = Chart2016Reader.ReadCT_SeriesLayoutProperties(reader);
                break;
            case "axisId":
                instance.axisId.push(Chart2016Reader.ReadST_AxisId(reader));
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Legend = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "pos":
                instance.legendPos = chart_model_1.Charts.ST_2016ChartPosLegend[reader.readContentAsString()];
                break;
            case "align":
                instance.align = chart_model_1.Charts.ST_PosAlign[reader.readContentAsString()];
                break;
            case "overlay":
                instance.overlay = reader.readContentAsBoolean();
                break;
            default:
                break;
        }
    }
    if (instance.legendPos === chart_model_1.Charts.ST_2016ChartPosLegend.r
        && instance.align === chart_model_1.Charts.ST_PosAlign.min) {
        instance.legendPos = 5;
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "txPr":
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_PlotSurface = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_PlotAreaRegion = function (reader) {
    var instance = { extLst: [], series: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "plotSurface":
                instance.plotSurface = Chart2016Reader.ReadCT_PlotSurface(reader);
                break;
            case "series":
                instance.series.push(Chart2016Reader.ReadCT_Series(reader));
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_PlotArea = function (reader) {
    var instance = { axes: [], extLst: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "plotAreaRegion":
                instance.plotAreaRegion = Chart2016Reader.ReadCT_PlotAreaRegion(reader);
                break;
            case "axis":
                instance.axes.push(Chart2016Reader.ReadCT_Axis(reader));
                break;
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_Chart = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "title":
                instance.title = Chart2016Reader.ReadCT_ChartTitle(reader);
                break;
            case "plotArea":
                instance.plotArea = Chart2016Reader.ReadCT_PlotArea(reader);
                break;
            case "legend":
                instance.legend = Chart2016Reader.ReadCT_Legend(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_FormatOverride = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "idx":
                instance.idx = parseInt(reader.readContentAsString(), 10);
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_FormatOverrides = function (reader) {
    var instance = { fmtOvr: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "fmtOvr":
                instance.fmtOvr.push(Chart2016Reader.ReadCT_FormatOverride(reader));
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_HeaderFooter = function (reader) {
    var instance = {};
    var elementName;
    while (reader.moveToNextAttribute()) {
        elementName = getAttributeName(reader);
        switch (elementName) {
            case "alignWithMargins":
                instance.alignWithMargins = reader.readContentAsBoolean();
                break;
            case "differentOddEven":
                instance.differentOddEven = reader.readContentAsBoolean();
                break;
            case "differentFirst":
                instance.differentFirst = reader.readContentAsBoolean();
                break;
            default:
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        elementName = getElementName(reader);
        switch (elementName) {
            case "oddHeader":
                instance.oddHeader = Chart2016Reader.ReadElementContentAsString(reader);
                break;
            case "oddFooter":
                instance.oddFooter = Chart2016Reader.ReadElementContentAsString(reader);
                break;
            case "evenHeader":
                instance.evenHeader = Chart2016Reader.ReadElementContentAsString(reader);
                break;
            case "evenFooter":
                instance.evenFooter = Chart2016Reader.ReadElementContentAsString(reader);
                break;
            case "firstHeader":
                instance.firstHeader = Chart2016Reader.ReadElementContentAsString(reader);
                break;
            case "firstFooter":
                instance.firstFooter = Chart2016Reader.ReadElementContentAsString(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_PageMargins = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "l":
                instance.l = reader.readContentAsDouble();
                break;
            case "r":
                instance.r = reader.readContentAsDouble();
                break;
            case "t":
                instance.t = reader.readContentAsDouble();
                break;
            case "b":
                instance.b = reader.readContentAsDouble();
                break;
            case "header":
                instance.header = reader.readContentAsDouble();
                break;
            case "footer":
                instance.footer = reader.readContentAsDouble();
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_PageSetup = function (reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var elementName = getAttributeName(reader);
        switch (elementName) {
            case "paperSize":
                instance.paperSize = parseInt(reader.readContentAsString(), 10);
                break;
            case "firstPageNumber":
                instance.firstPageNumber = parseInt(reader.readContentAsString(), 10);
                break;
            case "orientation":
                instance.orientation = chart_model_1.Charts.ST_PageOrientation[reader.readContentAsString()];
                break;
            case "blackAndWhite":
                instance.blackAndWhite = reader.readContentAsBoolean();
                break;
            case "draft":
                instance.draft = reader.readContentAsBoolean();
                break;
            case "useFirstPageNumber":
                instance.useFirstPageNumber = reader.readContentAsBoolean();
                break;
            case "horizontalDpi":
                instance.horizontalDpi = reader.readContentAsInt();
                break;
            case "verticalDpi":
                instance.verticalDpi = reader.readContentAsInt();
                break;
            case "copies":
                instance.copies = parseInt(reader.readContentAsString(), 10);
                break;
            default:
                break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_PrintSettings = function (reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "headerFooter":
                instance.headerFooter = Chart2016Reader.ReadCT_HeaderFooter(reader);
                break;
            case "pageMargins":
                instance.pageMargins = Chart2016Reader.ReadCT_PageMargins(reader);
                break;
            case "pageSetup":
                instance.pageSetup = Chart2016Reader.ReadCT_PageSetup(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    return instance;
};
Chart2016Reader.ReadCT_ChartSpace = function (reader, drawingInfoDataNames) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= startDepth) {
            break;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "chartData":
                instance.chartData = Chart2016Reader.ReadCT_ChartData(reader);
                break;
            case "chart":
                instance.chart = Chart2016Reader.ReadCT_Chart(reader);
                break;
            case "spPr":
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "txPr":
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case "clrMapOvr":
                instance.clrMapOvr = ReadCT_ColorMapping(reader);
                break;
            case "fmtOvrs":
                instance.fmtOvrs = Chart2016Reader.ReadCT_FormatOverrides(reader);
                break;
            case "printSettings":
                instance.printSettings = Chart2016Reader.ReadCT_PrintSettings(reader);
                break;
            case "extLst":
                instance.extLst = Chart2016Reader.ReadCT_ExtensionList(reader);
                break;
        }
        if (reader.depth <= startDepth) {
            break;
        }
    }
    if (drawingInfoDataNames) {
        Chart2016Reader.TranstateSeriesIDToData(instance.chart.plotArea.plotAreaRegion.series, instance.chartData.data, drawingInfoDataNames);
    }
    return instance;
};
Chart2016Reader.TranstateSeriesIDToData = function (series, chartData, drawingInfoDataNames) {
    var chartDataObj = Chart2016Reader.TranslateChartData(chartData), nameSpaceObj = Chart2016Reader.TranslateNameSpace(drawingInfoDataNames);
    for (var i = 0; i < series.length; i++) {
        var seriesItem = series[i];
        if (!common_1._isNullOrUndefined(seriesItem.dataId)) {
            var serVal = seriesItem.dataId.val;
            var dataId = chartDataObj[serVal];
            if (!common_1._isNullOrUndefined(dataId)) {
                var formulaObj = {}, formula = void 0;
                var numDim = dataId.numDim && dataId.numDim.formula;
                var strDim = dataId.strDim && dataId.strDim.formula;
                if (numDim) {
                    formula = nameSpaceObj[numDim];
                    formulaObj.numDim = formula;
                }
                if (strDim) {
                    formula = nameSpaceObj[strDim];
                    formulaObj.strDim = formula;
                }
                seriesItem.formulaObj = formulaObj;
            }
        }
        var txDataFormula = seriesItem.tx && seriesItem.tx.txData && seriesItem.tx.txData.f && seriesItem.tx.txData.f.formula;
        if (txDataFormula) {
            var sheetFormula = nameSpaceObj[txDataFormula];
            if (sheetFormula) {
                seriesItem.tx.txData.f.formula = sheetFormula;
            }
        }
    }
};
Chart2016Reader.TranslateChartData = function (chartData) {
    var chartDataObj = {};
    for (var i = 0; i < chartData.length; i++) {
        var dataId = chartData[i].id;
        var dataNameSpace = {};
        if (chartData[i].numDim.length > 0) {
            dataNameSpace.numDim = chartData[i].numDim && chartData[i].numDim[0].f;
        }
        if (chartData[i].strDim.length > 0) {
            dataNameSpace.strDim = chartData[i].strDim && chartData[i].strDim[0].f;
        }
        chartDataObj[dataId] = dataNameSpace;
    }
    return chartDataObj;
};
Chart2016Reader.TranslateNameSpace = function (drawingInfoDataNames) {
    var nameSpaceObj = {};
    for (var i = 0; i < drawingInfoDataNames.length; i++) {
        var name_1 = drawingInfoDataNames[i].name, formula = drawingInfoDataNames[i].formula;
        nameSpaceObj[name_1] = formula;
    }
    return nameSpaceObj;
};
exports.DrawingReader.Chart2016Reader = Chart2016Reader;
function ReadCT_ColorScheme(reader) {
    var instance = {};
    instance[CONST_NAME] = readSingleAttributeNode(reader, CONST_NAME);
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var elementArray = ["dk1", "lt1", "dk2", "lt2", "accent1", "accent2", "accent3", "accent4", "accent5", "accent6", "hlink", "folHlink"];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_EXTLST) {
            instance[elementName] = ReadCT_OfficeArtExtensionList(reader);
        }
        else if (elementArray.indexOf(elementName) >= 0) {
            instance[elementName] = ReadCT_Color(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ColorScheme = ReadCT_ColorScheme;
function ReadCT_CustomColor(reader) {
    var instance = {};
    instance[CONST_NAME] = readSingleAttributeNode(reader, CONST_NAME);
    if (reader.elementType === 3) {
        return instance;
    }
    return readSubColorElements(reader, instance);
}
exports.DrawingReader.ReadCT_CustomColor = ReadCT_CustomColor;
function ReadCT_SupplementalFont(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "script" || attrName === "typeface") {
            instance[attrName] = reader.readContentAsString();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_SupplementalFont = ReadCT_SupplementalFont;
function ReadCT_CustomColorList(reader) {
    var instance = { custClr: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "custClr") {
            instance.custClr.push(ReadCT_CustomColor(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_CustomColorList = ReadCT_CustomColorList;
function ReadCT_FontCollection(reader) {
    var instance = { font: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "latin":
                instance.latin = ReadCT_TextFont(reader);
                break;
            case "ea":
                instance.ea = ReadCT_TextFont(reader);
                break;
            case "cs":
                instance.cs = ReadCT_TextFont(reader);
                break;
            case "font":
                instance.font.push(ReadCT_SupplementalFont(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_FontCollection = ReadCT_FontCollection;
function ReadCT_EffectStyleItem(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_EFFECTLST:
                instance.effectLst = ReadCT_EffectList(reader);
                break;
            case CONST_EFFECT_DAG:
                instance.effectDag = ReadCT_EffectContainer(reader);
                break;
            case CONST_SCENE_3D:
                instance.scene3d = ReadCT_Scene3D(reader);
                break;
            case "sp3d":
                instance.sp3d = ReadCT_Shape3D(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_EffectStyleItem = ReadCT_EffectStyleItem;
function ReadCT_FontScheme(reader) {
    var instance = {};
    instance[CONST_NAME] = readSingleAttributeNode(reader, CONST_NAME);
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "majorFont" || elementName === "minorFont") {
            instance[elementName] = ReadCT_FontCollection(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_OfficeArtExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_FontScheme = ReadCT_FontScheme;
function ReadCT_FillStyleList(reader) {
    var instance = {
        items: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    return readFillPropertiesAsArrayItem(reader, instance);
}
exports.DrawingReader.ReadCT_FillStyleList = ReadCT_FillStyleList;
function ReadCT_LineStyleList(reader) {
    var instance = { ln: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "ln") {
            instance.ln.push(exports.DrawingReader.ReadCT_LineProperties(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_LineStyleList = ReadCT_LineStyleList;
function ReadCT_EffectStyleList(reader) {
    var instance = { effectStyle: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "effectStyle") {
            instance.effectStyle.push(ReadCT_EffectStyleItem(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_EffectStyleList = ReadCT_EffectStyleList;
function ReadCT_BackgroundFillStyleList(reader) {
    var instance = {
        items: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    return readFillPropertiesAsArrayItem(reader, instance);
}
exports.DrawingReader.ReadCT_BackgroundFillStyleList = ReadCT_BackgroundFillStyleList;
function ReadCT_StyleMatrix(reader) {
    var instance = {};
    instance[CONST_NAME] = readSingleAttributeNode(reader, CONST_NAME);
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "fillStyleLst":
                instance.fillStyleLst = ReadCT_FillStyleList(reader);
                break;
            case "lnStyleLst":
                instance.lnStyleLst = ReadCT_LineStyleList(reader);
                break;
            case "effectStyleLst":
                instance.effectStyleLst = ReadCT_EffectStyleList(reader);
                break;
            case "bgFillStyleLst":
                instance.bgFillStyleLst = ReadCT_BackgroundFillStyleList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_StyleMatrix = ReadCT_StyleMatrix;
function ReadCT_BaseStyles(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_CLR_SCHEME:
                instance.clrScheme = ReadCT_ColorScheme(reader);
                break;
            case CONST_FONT_SCHEME:
                instance.fontScheme = ReadCT_FontScheme(reader);
                break;
            case CONST_FMT_SCHEME:
                instance.fmtScheme = ReadCT_StyleMatrix(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_BaseStyles = ReadCT_BaseStyles;
var OOXMLFileTypes = {
    hiddenScene3dUri: "{31F19639-BCED-4A60-ADC4-E9642A236FB7}",
    hiddenSp3dUri: "{E45631CC-5BF2-4C18-A39C-3461C7D3F71A}",
    hiddenFillUri: "{909E8E84-426E-40DD-AFC4-6F175D3DCCD1}",
    hiddenFillUri2: "{909E8E84-426E-40dd-AFC4-6F175D3DCCD1}",
    hiddenLineUri: "{91240B29-F687-4F45-9708-019B960494DF}",
    hiddenLineUri2: "{91240B29-F687-4f45-9708-019B960494DF}",
    hiddenASvgBlip: "{96DAC541-7B7A-43D3-8B79-37D633B846F1}",
    hiddenASvgBlip2: "{96DAC541-7B7A-43d3-8B79-37D633B846F1}"
};
function ReadCT_creationId(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        switch (attrName) {
            case "id":
                instance.id = reader.readContentAsString();
                break;
            case "a16":
                instance.name = reader.readContentAsString();
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_creationId = ReadCT_creationId;
function ReadCT_OfficeArtExtension(reader) {
    if (reader.elementType === 3) {
        return { hiddenExtensionType: 4 };
    }
    var instance = { creationId: [] };
    instance.uri = getValidValue(readSingleAttributeNode(reader, "uri"), "");
    var uri = instance.uri, hiddenExtensionType;
    if (uri === OOXMLFileTypes.hiddenScene3dUri) {
        hiddenExtensionType = 0;
    }
    else if (uri === OOXMLFileTypes.hiddenSp3dUri) {
        hiddenExtensionType = 3;
    }
    else if (uri === OOXMLFileTypes.hiddenFillUri || uri === OOXMLFileTypes.hiddenFillUri2) {
        hiddenExtensionType = 1;
    }
    else if (uri === OOXMLFileTypes.hiddenLineUri || uri === OOXMLFileTypes.hiddenLineUri2) {
        hiddenExtensionType = 2;
    }
    else if (uri === OOXMLFileTypes.hiddenASvgBlip || uri === OOXMLFileTypes.hiddenASvgBlip2) {
        hiddenExtensionType = 5;
    }
    else {
        hiddenExtensionType = 4;
    }
    instance.hiddenExtensionType = hiddenExtensionType;
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "hiddenScene3d":
                instance.Scene3d = ReadCT_Scene3D(reader);
                break;
            case "hiddenSp3d":
                instance.Shape3d = ReadCT_Shape3D(reader);
                break;
            case "hiddenFill":
                instance.Fill = ReadCT_FillProperties(reader);
                break;
            case "hiddenLine":
                instance.Line = ReadCT_LineProperties(reader);
                break;
            case "svgBlip":
                instance.svgBlip = ReadCT_SvgBlipProperties(reader);
                break;
            case "creationId":
                instance.creationId.push(ReadCT_creationId(reader));
                break;
            case "cameraTool":
                instance.cameraTool = ReadCT_cameraTool(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_OfficeArtExtension = ReadCT_OfficeArtExtension;
function ReadCT_Angle(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_Angle = ReadCT_Angle;
function ReadCT_cameraTool(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        switch (attrName) {
            case "cellRange":
                instance.cellRange = reader.readContentAsString();
                break;
            case "spid":
                instance.spid = reader.readContentAsString();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return instance;
}
exports.DrawingReader.ReadCT_cameraTool = ReadCT_cameraTool;
function ReadCT_PositiveFixedAngle(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_PositiveFixedAngle = ReadCT_PositiveFixedAngle;
function ReadCT_Percentage(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_Percentage = ReadCT_Percentage;
function ReadCT_PositivePercentage(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_PositivePercentage = ReadCT_PositivePercentage;
function ReadCT_FixedPercentage(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_FixedPercentage = ReadCT_FixedPercentage;
function ReadCT_PositiveFixedPercentage(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_PositiveFixedPercentage = ReadCT_PositiveFixedPercentage;
function ReadCT_Ratio(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "n" || attrName === "d") {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Ratio = ReadCT_Ratio;
function ReadCT_Point2D(reader, needPixel) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "x" || attrName === "y") {
            instance[attrName] = reader.readContentAsInt();
            if (needPixel) {
                instance[attrName] = emuToPixles(instance[attrName], 6);
            }
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Point2D = ReadCT_Point2D;
function ReadCT_PositiveSize2D(reader, needPixel) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "cx" || attrName === "cy") {
            instance[attrName] = reader.readContentAsInt();
            if (needPixel) {
                instance[attrName] = emuToPixles(instance[attrName], 6);
            }
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_PositiveSize2D = ReadCT_PositiveSize2D;
function ReadCT_ComplementTransform() {
    return {};
}
exports.DrawingReader.ReadCT_ComplementTransform = ReadCT_ComplementTransform;
function ReadCT_InverseTransform() {
    return {};
}
exports.DrawingReader.ReadCT_InverseTransform = ReadCT_InverseTransform;
function ReadCT_GrayscaleTransform() {
    return {};
}
exports.DrawingReader.ReadCT_GrayscaleTransform = ReadCT_GrayscaleTransform;
function ReadCT_GammaTransform() {
    return {};
}
exports.DrawingReader.ReadCT_GammaTransform = ReadCT_GammaTransform;
function ReadCT_InverseGammaTransform() {
    return {};
}
exports.DrawingReader.ReadCT_InverseGammaTransform = ReadCT_InverseGammaTransform;
function ReadCT_ScRgbColor(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "r" || attrName === "g" || attrName === 'b') {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return readColorSubElement(reader, instance);
}
exports.DrawingReader.ReadCT_ScRgbColor = ReadCT_ScRgbColor;
function StringToByteArray(hex) {
    var bytes = [];
    if (hex) {
        var charCount = hex.length;
        for (var i = 0; i < charCount; i += 2) {
            bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
        }
    }
    return bytes;
}
exports.DrawingReader.StringToByteArray = StringToByteArray;
function ReadCT_SRgbColor(reader) {
    var instance = {};
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        instance.val = StringToByteArray(val);
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return readColorSubElement(reader, instance);
}
exports.DrawingReader.ReadCT_SRgbColor = ReadCT_SRgbColor;
function ReadCT_HslColor(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "hue" || attrName === "sat" || attrName === "lum") {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return readColorSubElement(reader, instance);
}
exports.DrawingReader.ReadCT_HslColor = ReadCT_HslColor;
function ReadCT_SystemColor(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === CONST_VAL) {
            instance.val = chart_helper_1.ChartHelper.ToKnownColor(chart_model_1.Charts.ST_SystemColorVal[reader.readContentAsString()]);
        }
        else if (attrName === "lastClr") {
            instance.lastClr = StringToByteArray(reader.readContentAsString());
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return readColorSubElement(reader, instance);
}
exports.DrawingReader.ReadCT_SystemColor = ReadCT_SystemColor;
function ReadCT_SchemeColor(reader) {
    var instance = {};
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        instance.val = chart_helper_1.ChartHelper.ToColorSchemeIndex(chart_model_1.Charts.ST_SchemeColorVal[val]);
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return readColorSubElement(reader, instance);
}
exports.DrawingReader.ReadCT_SchemeColor = ReadCT_SchemeColor;
function ReadCT_PresetColor(reader) {
    var instance = {};
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        instance.val = chart_model_1.Charts.ST_PresetColorVal[val];
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return readColorSubElement(reader, instance);
}
exports.DrawingReader.ReadCT_PresetColor = ReadCT_PresetColor;
function ReadCT_StyleColor(reader) {
    var instance = {};
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        instance.val = chart_model_1.Charts.ST_StyleColorVal[val];
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return readColorSubElement(reader, instance);
}
exports.DrawingReader.ReadCT_StyleColor = ReadCT_StyleColor;
function ReadCT_OfficeArtExtensionList(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var ext = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_EXT) {
            ext.push(ReadCT_OfficeArtExtension(reader));
        }
    }
    if (ext.length > 0) {
        instance.ext = ext;
    }
    return instance;
}
exports.DrawingReader.ReadCT_OfficeArtExtensionList = ReadCT_OfficeArtExtensionList;
function ReadCT_Scale2D(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "sx" || elementName === "sy") {
            instance[elementName] = ReadCT_Ratio(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Scale2D = ReadCT_Scale2D;
function ReadCT_Transform2D(reader) {
    var instance = { rot: 0 };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "rot") {
            instance.rot = reader.readContentAsInt();
        }
        else if (attrName === "flipH" || attrName === "flipV") {
            instance[attrName] = reader.readContentAsBoolean();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "off") {
            instance.off = ReadCT_Point2D(reader, true);
        }
        else if (elementName === CONST_EXT) {
            instance.ext = ReadCT_PositiveSize2D(reader, true);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Transform2D = ReadCT_Transform2D;
function ReadCT_GroupTransform2D(reader) {
    var instance = { rot: 0 };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "rot") {
            instance.rot = reader.readContentAsInt();
        }
        else if (attrName === "flipH" || attrName === "flipV") {
            instance[attrName] = reader.readContentAsBoolean();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "off":
                instance.off = ReadCT_Point2D(reader, true);
                break;
            case CONST_EXT:
                instance.ext = ReadCT_PositiveSize2D(reader, true);
                break;
            case "chOff":
                instance.chOff = ReadCT_Point2D(reader, true);
                break;
            case "chExt":
                instance.chExt = ReadCT_PositiveSize2D(reader, true);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_GroupTransform2D = ReadCT_GroupTransform2D;
function ReadCT_Point3D(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "x" || attrName === "y" || attrName === "z") {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Point3D = ReadCT_Point3D;
function ReadCT_Vector3D(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "dx" || attrName === "dy" || attrName === "dz") {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Vector3D = ReadCT_Vector3D;
function ReadCT_SphereCoords(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "lat" || attrName === "lon" || attrName === "rev") {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_SphereCoords = ReadCT_SphereCoords;
function ReadCT_RelativeRect(reader) {
    var instance = { l: 0, r: 0, t: 0, b: 0 };
    var attrNameObj = { l: true, t: true, r: true, b: true };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_RelativeRect = ReadCT_RelativeRect;
function ReadCT_Color(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    return readSubColorElements(reader, instance);
}
exports.DrawingReader.ReadCT_Color = ReadCT_Color;
function ReadCT_ColorMRU(reader) {
    var instance = {
        scrgbClr: [],
        srgbClr: [],
        hslClr: [],
        sysClr: [],
        schemeClr: [],
        prstClr: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_SCRGBCLR:
                instance.scrgbClr.push(ReadCT_ScRgbColor(reader));
                break;
            case CONST_SRGBCLR:
                instance.srgbClr.push(ReadCT_SRgbColor(reader));
                break;
            case CONST_HSLCLR:
                instance.hslClr.push(ReadCT_HslColor(reader));
                break;
            case CONST_SYSCLR:
                instance.sysClr.push(ReadCT_SystemColor(reader));
                break;
            case CONST_SCHEMECLR:
                instance.schemeClr.push(ReadCT_SchemeColor(reader));
                break;
            case CONST_PRSTCLR:
                instance.prstClr.push(ReadCT_PresetColor(reader));
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ColorMRU = ReadCT_ColorMRU;
function ReadCT_EmbeddedWAVAudioFile(reader) {
    var instance = {
        name: '',
        builtIn: false
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "embed" || attrName === CONST_NAME) {
            instance[attrName] = reader.readContentAsString();
        }
        else if (attrName === "builtIn") {
            instance[attrName] = reader.readContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_EmbeddedWAVAudioFile = ReadCT_EmbeddedWAVAudioFile;
function ReadCT_Hyperlink(reader) {
    var instance = {
        invalidUrl: '',
        action: '',
        tgtFrame: '',
        tooltip: '',
        history: true,
        highlightClick: false,
        endSnd: false
    };
    var stringAttrNameObj = { id: true, invalidUrl: true, action: true, tgtFrame: true, tooltip: true }, boolAttrNameObj = { history: true, highlightClick: true, endSnd: true };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "id") {
            var relationFile = reader.relationFiles[reader.readContentAsString()];
            var url = common_1.Util._xmlDecode(relationFile.fileName);
            if (url && url.indexOf('#') === 0) {
                url = url.substr(1);
            }
            var targetMode = common_1.Util._xmlDecode(relationFile.targetMode);
            instance.url = (!targetMode || targetMode === "Internal") ? 'sjs://' + url : url;
        }
        else {
            if (stringAttrNameObj[attrName]) {
                instance[attrName] = reader.readContentAsString();
            }
            else if (boolAttrNameObj[attrName]) {
                instance[attrName] = reader.readContentAsBoolean();
            }
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "snd") {
            instance.snd = ReadCT_EmbeddedWAVAudioFile(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_OfficeArtExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Hyperlink = ReadCT_Hyperlink;
function ReadCT_Boolean(reader) {
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === CONST_VAL) {
            return reader.readContentAsBoolean();
        }
    }
}
exports.DrawingReader.ReadCT_Boolean = ReadCT_Boolean;
function ReadCT_Double(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttrValueOrDefaultOfDoubleType);
}
exports.DrawingReader.ReadCT_Double = ReadCT_Double;
function ReadCT_UnsignedInt(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_UnsignedInt = ReadCT_UnsignedInt;
function ReadCT_Int(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_Int = ReadCT_Int;
function ReadCT_RelId(reader) {
    var instance = {};
    instance.id = readSingleAttributeNode(reader, "id");
    return instance;
}
exports.DrawingReader.ReadCT_RelId = ReadCT_RelId;
function ReadCT_Extension(reader) {
    var instance = {};
    instance.uri = getValidValue(readSingleAttributeNode(reader, "uri"), "{6F2FDCE9-48DA-4B69-8628-5D25D57E5C99}");
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "invertSolidFillFmt") {
            instance.dataObject = ReadCT_InvertSolidFillFmt(reader);
        }
        else if (elementName === "datalabelsRange") {
            instance.dataObject = ReadCT_SeriesDataLabelsRange(reader);
        }
        else if (elementName === 'dataDisplayOptions16') {
            instance.dataObject = ReadCT_DispNaAsBlank(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Extension = ReadCT_Extension;
function ReadCT_ExtensionList(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var ext = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_EXT) {
            ext.push(ReadCT_Extension(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    if (ext.length > 0) {
        instance.ext = ext;
    }
    return instance;
}
exports.DrawingReader.ReadCT_ExtensionList = ReadCT_ExtensionList;
function ReadCT_NumVal(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === CONST_IDX) {
            instance.idx = reader.readContentAsInt();
        }
        else if (attrName === "formatCode") {
            instance.formatCode = reader.readContentAsString();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "v") {
            instance.v = reader.readElementContentAsString();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_NumVal = ReadCT_NumVal;
function ReadCT_NumData(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var pt = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "formatCode":
                instance.formatCode = reader.readElementContentAsString();
                break;
            case "ptCount":
                instance.ptCount = ReadCT_UnsignedInt(reader);
                break;
            case "pt":
                pt.push(ReadCT_NumVal(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    if (pt.length > 0) {
        instance.pt = pt.map(function (item) {
            return item.v;
        });
        var formatCodes = pt.map(function (item) {
            return item.formatCode;
        });
        var canFormatCodes = formatCodes.some(function (item) {
            return !!item;
        });
        if (canFormatCodes) {
            instance.formatCodes = formatCodes;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_NumData = ReadCT_NumData;
function ReadCT_NumRef(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "f":
                instance.f = xmlDecode(reader.readElementContentAsString());
                break;
            case "numCache":
                var numCache = ReadCT_NumData(reader);
                delete numCache.pt;
                delete numCache.ptCount;
                instance.numCache = numCache;
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_NumRef = ReadCT_NumRef;
function ReadCT_NumDataSource(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "numRef") {
            instance.numRef = ReadCT_NumRef(reader);
        }
        else if (elementName === "numLit") {
            instance.numLit = ReadCT_NumData(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_NumDataSource = ReadCT_NumDataSource;
function ReadCT_StrVal(reader) {
    var instance = {};
    instance[CONST_IDX] = readSingleAttributeNode(reader, CONST_IDX, getAttributeValueOrDefaultOfIntType);
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "v") {
            instance.v = xmlDecode(reader.readElementContentAsString());
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_StrVal = ReadCT_StrVal;
function ReadCT_StrData(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var pt = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "ptCount":
                instance.ptCount = ReadCT_UnsignedInt(reader);
                break;
            case "pt":
                pt.push(ReadCT_StrVal(reader).v);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    if (pt.length > 0) {
        instance.pt = pt;
    }
    return instance;
}
exports.DrawingReader.ReadCT_StrData = ReadCT_StrData;
function ReadCT_StrRef(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "f":
                instance.f = xmlDecode(reader.readElementContentAsString());
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_StrRef = ReadCT_StrRef;
function ReadCT_Tx(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "strRef") {
            instance.strRef = ReadCT_StrRef(reader);
        }
        else if (elementName === "rich") {
            instance.rich = ReadCT_TextBody(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Tx = ReadCT_Tx;
function ReadCT_TextLanguageID(reader) {
    return readSingleAttributeNode(reader, CONST_VAL);
}
exports.DrawingReader.ReadCT_TextLanguageID = ReadCT_TextLanguageID;
function ReadCT_Lvl(reader) {
    var instance = { pt: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "pt") {
            instance.pt.push(ReadCT_StrVal(reader));
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Lvl = ReadCT_Lvl;
function ReadCT_MultiLvlStrData(reader) {
    var instance = { lvl: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "ptCount":
                instance.ptCount = ReadCT_UnsignedInt(reader);
                break;
            case "lvl":
                instance.lvl.push(ReadCT_StrData(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_MultiLvlStrData = ReadCT_MultiLvlStrData;
function ReadCT_MultiLvlStrRef(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "f":
                instance.f = xmlDecode(reader.readElementContentAsString());
                break;
            case "multiLvlStrCache":
                instance.multiLvlStrCache = ReadCT_MultiLvlStrData(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_MultiLvlStrRef = ReadCT_MultiLvlStrRef;
function ReadCT_AxDataSource(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "multiLvlStrRef":
                instance.multiLvlStrRef = ReadCT_MultiLvlStrRef(reader);
                break;
            case "numRef":
                instance.numRef = ReadCT_NumRef(reader);
                break;
            case "numLit":
                instance.numLit = ReadCT_NumData(reader);
                break;
            case "strRef":
                instance.strRef = ReadCT_StrRef(reader);
                break;
            case "strLit":
                instance.strLit = ReadCT_StrData(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_AxDataSource = ReadCT_AxDataSource;
function ReadCT_SerTx(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "strRef") {
            instance.strRef = ReadCT_StrRef(reader);
        }
        else if (elementName === "v") {
            instance.v = reader.readElementContentAsString();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_SerTx = ReadCT_SerTx;
function ReadCT_LayoutTarget(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_LayoutTarget[val];
    }
}
exports.DrawingReader.ReadCT_LayoutTarget = ReadCT_LayoutTarget;
function ReadCT_LayoutMode(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_LayoutMode[val];
    }
}
exports.DrawingReader.ReadCT_LayoutMode = ReadCT_LayoutMode;
function ReadCT_ManualLayout(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var modeElementNameObj = { xMode: true, yMode: true, wMode: true, hMode: true }, numberElementNameObj = { x: true, y: true, w: true, h: true };
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (modeElementNameObj[elementName]) {
            instance[elementName] = ReadCT_LayoutMode(reader);
        }
        else if (numberElementNameObj[elementName]) {
            instance[elementName] = ReadCT_Double(reader);
        }
        else if (elementName === "layoutTarget") {
            instance.layoutTarget = ReadCT_LayoutTarget(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_ExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ManualLayout = ReadCT_ManualLayout;
function ReadCT_Layout(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "manualLayout") {
            instance.manualLayout = ReadCT_ManualLayout(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_ExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Layout = ReadCT_Layout;
function ReadCT_Title(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "tx":
                instance.tx = ReadCT_Tx(reader);
                break;
            case CONST_LAYOUT:
                instance.layout = ReadCT_Layout(reader);
                break;
            case "overlay":
                instance.overlay = ReadCT_Boolean(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Title = ReadCT_Title;
function ReadCT_RotX(reader) {
    return getValidValue(readSingleAttributeNode(reader, CONST_VAL), 0);
}
exports.DrawingReader.ReadCT_RotX = ReadCT_RotX;
function ReadCT_HPercent(reader) {
    return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 100);
}
exports.DrawingReader.ReadCT_HPercent = ReadCT_HPercent;
function ReadCT_RotY(reader) {
    return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 0);
}
exports.DrawingReader.ReadCT_RotY = ReadCT_RotY;
function ReadCT_DepthPercent(reader) {
    return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 100);
}
exports.DrawingReader.ReadCT_DepthPercent = ReadCT_DepthPercent;
function ReadCT_Perspective(reader) {
    return getValidValue(readSingleAttributeNode(reader, CONST_VAL), 30);
}
exports.DrawingReader.ReadCT_Perspective = ReadCT_Perspective;
function ReadCT_View3D(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "rotX":
                instance.rotX = ReadCT_RotX(reader);
                break;
            case "hPercent":
                instance.hPercent = ReadCT_HPercent(reader);
                break;
            case "rotY":
                instance.rotY = ReadCT_RotY(reader);
                break;
            case "depthPercent":
                instance.depthPercent = ReadCT_DepthPercent(reader);
                break;
            case "rAngAx":
                instance.rAngAx = ReadCT_Boolean(reader);
                break;
            case "perspective":
                instance.perspective = ReadCT_Perspective(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_View3D = ReadCT_View3D;
function ReadCT_Surface(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "thickness":
                instance.thickness = ReadCT_UnsignedInt(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_PICTURE_OPTIONS:
                instance.pictureOptions = ReadCT_PictureOptions(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Surface = ReadCT_Surface;
function ReadCT_DTable(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var elementNameObj = {
        showHorzBorder: true,
        showVertBorder: true,
        showOutline: true,
        showKeys: true
    };
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementNameObj[elementName]) {
            instance[elementName] = ReadCT_Boolean(reader);
        }
        else if (elementName === CONST_SPPR) {
            instance.spPr = ReadCT_ShapeProperties(reader);
        }
        else if (elementName === CONST_TXPR) {
            instance.txPr = ReadCT_TextBody(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_ExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DTable = ReadCT_DTable;
function ReadCT_GapAmount(reader) {
    return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 150);
}
exports.DrawingReader.ReadCT_GapAmount = ReadCT_GapAmount;
function ReadCT_Overlap(reader) {
    return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 0);
}
exports.DrawingReader.ReadCT_Overlap = ReadCT_Overlap;
function ReadCT_BubbleScale(reader) {
    return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 100);
}
exports.DrawingReader.ReadCT_BubbleScale = ReadCT_BubbleScale;
function ReadCT_SizeRepresents(reader) {
    var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'area');
    return chart_model_1.Charts.ST_SizeRepresents[val];
}
exports.DrawingReader.ReadCT_SizeRepresents = ReadCT_SizeRepresents;
function ReadCT_FirstSliceAng(reader) {
    return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 0);
}
exports.DrawingReader.ReadCT_FirstSliceAng = ReadCT_FirstSliceAng;
function ReadCT_HoleSize(reader) {
    return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 0);
}
exports.DrawingReader.ReadCT_HoleSize = ReadCT_HoleSize;
function ReadCT_SplitType(reader) {
    var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'auto');
    return chart_helper_1.ChartHelper.ToChartSplitType(chart_model_1.Charts.ST_SplitType[val]);
}
exports.DrawingReader.ReadCT_SplitType = ReadCT_SplitType;
function ReadCT_CustSplit(reader) {
    var instance = { secondPiePt: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "secondPiePt") {
            instance.secondPiePt.push(ReadCT_UnsignedInt(reader));
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_CustSplit = ReadCT_CustSplit;
function ReadCT_SecondPieSize(reader) {
    return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 75);
}
exports.DrawingReader.ReadCT_SecondPieSize = ReadCT_SecondPieSize;
function ReadCT_NumFmt(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "formatCode") {
            instance.formatCode = xmlDecode(reader.readContentAsString());
        }
        else if (attrName === "sourceLinked") {
            var sourceLinked = reader.readContentAsBoolean();
            if (!sourceLinked) {
                instance.sourceLinked = false;
            }
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_NumFmt = ReadCT_NumFmt;
function ReadCT_LblAlgn(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_LblAlgn[val];
    }
}
exports.DrawingReader.ReadCT_LblAlgn = ReadCT_LblAlgn;
function ReadCT_DLblPos(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_DLblPos[val];
    }
}
exports.DrawingReader.ReadCT_DLblPos = ReadCT_DLblPos;
function ReadCT_DLbl(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_IDX:
                instance.idx = ReadCT_UnsignedInt(reader);
                break;
            case CONST_DELETE:
                instance.delete = ReadCT_Boolean(reader);
                break;
            case CONST_LAYOUT:
                instance.layout = ReadCT_Layout(reader);
                break;
            case "tx":
                instance.tx = ReadCT_Tx(reader);
                break;
            case CONST_NUMFMT:
                instance.numFmt = ReadCT_NumFmt(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case "dLblPos":
                instance.dLblPos = ReadCT_DLblPos(reader);
                break;
            case "showLegendKey":
                instance.showLegendKey = ReadCT_Boolean(reader);
                break;
            case "showVal":
                instance.showVal = ReadCT_Boolean(reader);
                break;
            case "showCatName":
                instance.showCatName = ReadCT_Boolean(reader);
                break;
            case "showSerName":
                instance.showSerName = ReadCT_Boolean(reader);
                break;
            case "showPercent":
                instance.showPercent = ReadCT_Boolean(reader);
                break;
            case "showBubbleSize":
                instance.showBubbleSize = ReadCT_Boolean(reader);
                break;
            case "separator":
                instance.separator = reader.readElementContentAsString(true);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_DLblExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DLbl = ReadCT_DLbl;
function ReadCT_DLbls(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var dLbl = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "dLbl":
                dLbl.push(ReadCT_DLbl(reader));
                break;
            case CONST_DELETE:
                instance.delete = ReadCT_Boolean(reader);
                break;
            case CONST_NUMFMT:
                instance.numFmt = ReadCT_NumFmt(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case "dLblPos":
                instance.dLblPos = ReadCT_DLblPos(reader);
                break;
            case "showLegendKey":
                instance.showLegendKey = ReadCT_Boolean(reader);
                break;
            case "showVal":
                instance.showVal = ReadCT_Boolean(reader);
                break;
            case "showCatName":
                instance.showCatName = ReadCT_Boolean(reader);
                break;
            case "showSerName":
                instance.showSerName = ReadCT_Boolean(reader);
                break;
            case "showPercent":
                instance.showPercent = ReadCT_Boolean(reader);
                break;
            case "showBubbleSize":
                instance.showBubbleSize = ReadCT_Boolean(reader);
                break;
            case "separator":
                instance.separator = reader.readElementContentAsString(true);
                break;
            case "showLeaderLines":
                instance.showLeaderLines = ReadCT_Boolean(reader);
                break;
            case "leaderLines":
                instance.leaderLines = ReadCT_ChartLines(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_DLblsExtensionList(reader);
                break;
        }
    }
    if (dLbl.length > 0) {
        instance.dLbl = dLbl;
    }
    return instance;
}
exports.DrawingReader.ReadCT_DLbls = ReadCT_DLbls;
function ReadCT_MarkerStyle(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_MarkerStyle[val];
    }
}
exports.DrawingReader.ReadCT_MarkerStyle = ReadCT_MarkerStyle;
function ReadCT_MarkerSize(reader) {
    return excel_style_1.UnitHelper.pointToPixel(getValidValue(readSingleAttributeNode(reader, CONST_VAL), 5));
}
exports.DrawingReader.ReadCT_MarkerSize = ReadCT_MarkerSize;
function ReadCT_Marker(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "symbol":
                instance.symbol = ReadCT_MarkerStyle(reader);
                break;
            case "size":
                instance.size = ReadCT_MarkerSize(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Marker = ReadCT_Marker;
function ReadCT_DPt(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_IDX:
                instance.idx = ReadCT_UnsignedInt(reader);
                break;
            case CONST_INVERT_IF_NEGATIVE:
                instance.invertIfNegative = ReadCT_Boolean(reader);
                break;
            case CONST_MARKER:
                instance.marker = ReadCT_Marker(reader);
                break;
            case CONST_BUBBLE_3D:
                instance.bubble3D = ReadCT_Boolean(reader);
                break;
            case "explosion":
                instance.explosion = ReadCT_UnsignedInt(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_PICTURE_OPTIONS:
                instance.pictureOptions = ReadCT_PictureOptions(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DPt = ReadCT_DPt;
function ReadCT_TrendlineType(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_TrendlineType[val];
    }
}
exports.DrawingReader.ReadCT_TrendlineType = ReadCT_TrendlineType;
function ReadCT_Order(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_Order = ReadCT_Order;
function ReadCT_Period(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_Period = ReadCT_Period;
function ReadCT_TrendlineLbl(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_LAYOUT:
                instance.layout = ReadCT_Layout(reader);
                break;
            case "tx":
                instance.tx = ReadCT_Tx(reader);
                break;
            case CONST_NUMFMT:
                instance.numFmt = ReadCT_NumFmt(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TrendlineLbl = ReadCT_TrendlineLbl;
function ReadCT_Trendline(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_NAME:
                instance.name = reader.readElementContentAsString();
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "trendlineType":
                instance.trendlineType = ReadCT_TrendlineType(reader);
                break;
            case CONST_ORDER:
                instance.order = ReadCT_Order(reader);
                break;
            case "period":
                instance.period = ReadCT_Period(reader);
                break;
            case "forward":
                instance.forward = ReadCT_Double(reader);
                break;
            case "backward":
                instance.backward = ReadCT_Double(reader);
                break;
            case "intercept":
                instance.intercept = ReadCT_Double(reader);
                break;
            case "dispRSqr":
                instance.dispRSqr = ReadCT_Boolean(reader);
                break;
            case "dispEq":
                instance.dispEq = ReadCT_Boolean(reader);
                break;
            case "trendlineLbl":
                instance.trendlineLbl = ReadCT_TrendlineLbl(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Trendline = ReadCT_Trendline;
function ReadCT_ErrDir(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_ErrDir[val];
    }
}
exports.DrawingReader.ReadCT_ErrDir = ReadCT_ErrDir;
function ReadCT_ErrBarType(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_ErrBarType[val];
    }
}
exports.DrawingReader.ReadCT_ErrBarType = ReadCT_ErrBarType;
function ReadCT_ErrValType(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_ErrValType[val];
    }
}
exports.DrawingReader.ReadCT_ErrValType = ReadCT_ErrValType;
function ReadCT_ErrBars(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "errDir":
                instance.errDir = ReadCT_ErrDir(reader);
                break;
            case "errBarType":
                instance.errBarType = ReadCT_ErrBarType(reader);
                break;
            case "errValType":
                instance.errValType = ReadCT_ErrValType(reader);
                break;
            case "noEndCap":
                instance.noEndCap = ReadCT_Boolean(reader);
                break;
            case "plus":
                instance.plus = ReadCT_NumDataSource(reader);
                break;
            case "minus":
                instance.minus = ReadCT_NumDataSource(reader);
                break;
            case CONST_VAL:
                instance.val = ReadCT_Double(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ErrBars = ReadCT_ErrBars;
function ReadCT_UpDownBar(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_SPPR) {
            instance.spPr = ReadCT_ShapeProperties(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_UpDownBar = ReadCT_UpDownBar;
function ReadCT_UpDownBars(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_GAP_WIDTH:
                instance.gapWidth = ReadCT_GapAmount(reader);
                break;
            case "upBars":
                instance.upBars = ReadCT_UpDownBar(reader);
                break;
            case "downBars":
                instance.downBars = ReadCT_UpDownBar(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_UpDownBars = ReadCT_UpDownBars;
function setSerArrayProperties(instance, dPt, trendline, errBars) {
    if (dPt.length > 0) {
        instance.dPt = dPt;
    }
    if (errBars && errBars.length > 0) {
        instance.errBars = errBars;
    }
    if (trendline && trendline.length > 0) {
        instance.trendline = trendline;
    }
}
function ReadCT_LineSer(reader) {
    var instance = {
        seriesType: 2
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var dPt = [], trendline = [], errBars = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_IDX:
                instance.idx = ReadCT_UnsignedInt(reader);
                break;
            case CONST_ORDER:
                instance.order = ReadCT_UnsignedInt(reader);
                break;
            case "tx":
                instance.tx = ReadCT_SerTx(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_MARKER:
                instance.marker = ReadCT_Marker(reader);
                break;
            case "dPt":
                dPt.push(ReadCT_DPt(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_TRENDLINE:
                trendline.push(ReadCT_Trendline(reader));
                break;
            case CONST_ERR_BARS:
                errBars.push(ReadCT_ErrBars(reader));
                break;
            case "cat":
                instance.cat = ReadCT_AxDataSource(reader);
                break;
            case CONST_VAL:
                instance.val = ReadCT_NumDataSource(reader);
                break;
            case "smooth":
                instance.smooth = ReadCT_Boolean(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    setSerArrayProperties(instance, dPt, trendline, errBars);
    return instance;
}
exports.DrawingReader.ReadCT_LineSer = ReadCT_LineSer;
function ReadCT_ScatterSer(reader) {
    var instance = {
        seriesType: 5
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var dPt = [], trendline = [], errBars = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_IDX:
                instance.idx = ReadCT_UnsignedInt(reader);
                break;
            case CONST_ORDER:
                instance.order = ReadCT_UnsignedInt(reader);
                break;
            case "tx":
                instance.tx = ReadCT_SerTx(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_MARKER:
                instance.marker = ReadCT_Marker(reader);
                break;
            case "dPt":
                dPt.push(ReadCT_DPt(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_TRENDLINE:
                trendline.push(ReadCT_Trendline(reader));
                break;
            case CONST_ERR_BARS:
                errBars.push(ReadCT_ErrBars(reader));
                break;
            case "xVal":
                instance.xVal = ReadCT_AxDataSource(reader);
                break;
            case "yVal":
                instance.yVal = ReadCT_NumDataSource(reader);
                break;
            case "smooth":
                instance.smooth = ReadCT_Boolean(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    setSerArrayProperties(instance, dPt, trendline, errBars);
    return instance;
}
exports.DrawingReader.ReadCT_ScatterSer = ReadCT_ScatterSer;
function ReadCT_RadarSer(reader) {
    var instance = {
        seriesType: 4
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var dPt = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_IDX:
                instance.idx = ReadCT_UnsignedInt(reader);
                break;
            case CONST_ORDER:
                instance.order = ReadCT_UnsignedInt(reader);
                break;
            case "tx":
                instance.tx = ReadCT_SerTx(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_MARKER:
                instance.marker = ReadCT_Marker(reader);
                break;
            case "dPt":
                dPt.push(ReadCT_DPt(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case "cat":
                instance.cat = ReadCT_AxDataSource(reader);
                break;
            case CONST_VAL:
                instance.val = ReadCT_NumDataSource(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    setSerArrayProperties(instance, dPt);
    return instance;
}
exports.DrawingReader.ReadCT_RadarSer = ReadCT_RadarSer;
function ReadCT_BarSer(reader) {
    var instance = {
        seriesType: 0
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var dPt = [], trendline = [], errBars = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_IDX:
                instance.idx = ReadCT_UnsignedInt(reader);
                break;
            case CONST_ORDER:
                instance.order = ReadCT_UnsignedInt(reader);
                break;
            case "tx":
                instance.tx = ReadCT_SerTx(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_INVERT_IF_NEGATIVE:
                instance.invertIfNegative = ReadCT_Boolean(reader);
                break;
            case CONST_PICTURE_OPTIONS:
                instance.pictureOptions = ReadCT_PictureOptions(reader);
                break;
            case "dPt":
                dPt.push(ReadCT_DPt(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_TRENDLINE:
                trendline.push(ReadCT_Trendline(reader));
                break;
            case CONST_ERR_BARS:
                errBars.push(ReadCT_ErrBars(reader));
                break;
            case "cat":
                instance.cat = ReadCT_AxDataSource(reader);
                break;
            case CONST_VAL:
                instance.val = ReadCT_NumDataSource(reader);
                break;
            case "shape":
                instance.shape = ReadCT_ShapeBox(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    setSerArrayProperties(instance, dPt, trendline, errBars);
    return instance;
}
exports.DrawingReader.ReadCT_BarSer = ReadCT_BarSer;
function ReadCT_AreaSer(reader) {
    var instance = {
        seriesType: 1
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var dPt = [], trendline = [], errBars = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_IDX:
                instance.idx = ReadCT_UnsignedInt(reader);
                break;
            case CONST_ORDER:
                instance.order = ReadCT_UnsignedInt(reader);
                break;
            case "tx":
                instance.tx = ReadCT_SerTx(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_PICTURE_OPTIONS:
                instance.pictureOptions = ReadCT_PictureOptions(reader);
                break;
            case "dPt":
                dPt.push(ReadCT_DPt(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_TRENDLINE:
                trendline.push(ReadCT_Trendline(reader));
                break;
            case CONST_ERR_BARS:
                errBars.push(ReadCT_ErrBars(reader));
                break;
            case "cat":
                instance.cat = ReadCT_AxDataSource(reader);
                break;
            case CONST_VAL:
                instance.val = ReadCT_NumDataSource(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    setSerArrayProperties(instance, dPt, trendline, errBars);
    return instance;
}
exports.DrawingReader.ReadCT_AreaSer = ReadCT_AreaSer;
function ReadCT_PieSer(reader) {
    var instance = {
        seriesType: 3
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var dPt = [];
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_IDX:
                instance.idx = ReadCT_UnsignedInt(reader);
                break;
            case CONST_ORDER:
                instance.order = ReadCT_UnsignedInt(reader);
                break;
            case "tx":
                instance.tx = ReadCT_SerTx(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "explosion":
                instance.explosion = ReadCT_UnsignedInt(reader);
                break;
            case "dPt":
                dPt.push(ReadCT_DPt(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case "cat":
                instance.cat = ReadCT_AxDataSource(reader);
                break;
            case CONST_VAL:
                instance.val = ReadCT_NumDataSource(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    setSerArrayProperties(instance, dPt);
    return instance;
}
exports.DrawingReader.ReadCT_PieSer = ReadCT_PieSer;
function ReadCT_BubbleSer(reader) {
    var instance = {
        seriesType: 6
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var dPt = [], trendline = [], errBars = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_IDX:
                instance.idx = ReadCT_UnsignedInt(reader);
                break;
            case CONST_ORDER:
                instance.order = ReadCT_UnsignedInt(reader);
                break;
            case "tx":
                instance.tx = ReadCT_SerTx(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_INVERT_IF_NEGATIVE:
                instance.invertIfNegative = ReadCT_Boolean(reader);
                break;
            case "dPt":
                dPt.push(ReadCT_DPt(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_TRENDLINE:
                trendline.push(ReadCT_Trendline(reader));
                break;
            case CONST_ERR_BARS:
                errBars.push(ReadCT_ErrBars(reader));
                break;
            case "xVal":
                instance.xVal = ReadCT_AxDataSource(reader);
                break;
            case "yVal":
                instance.yVal = ReadCT_NumDataSource(reader);
                break;
            case "bubbleSize":
                instance.bubbleSize = ReadCT_NumDataSource(reader);
                break;
            case CONST_BUBBLE_3D:
                instance.bubble3D = ReadCT_Boolean(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    setSerArrayProperties(instance, dPt, trendline, errBars);
    return instance;
}
exports.DrawingReader.ReadCT_BubbleSer = ReadCT_BubbleSer;
function ReadCT_SurfaceSer(reader) {
    var instance = { seriesType: 7 };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_IDX:
                instance.idx = ReadCT_UnsignedInt(reader);
                break;
            case CONST_ORDER:
                instance.order = ReadCT_UnsignedInt(reader);
                break;
            case "tx":
                instance.tx = ReadCT_SerTx(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "cat":
                instance.cat = ReadCT_AxDataSource(reader);
                break;
            case CONST_VAL:
                instance.val = ReadCT_NumDataSource(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_SurfaceSer = ReadCT_SurfaceSer;
function ReadCT_Grouping(reader) {
    var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'standard');
    return chart_model_1.Charts.ST_Grouping[val];
}
exports.DrawingReader.ReadCT_Grouping = ReadCT_Grouping;
function ReadCT_ChartLines(reader) {
    return readSingleSubElementNode(reader, CONST_SPPR, ReadCT_ShapeProperties);
}
exports.DrawingReader.ReadCT_ChartLines = ReadCT_ChartLines;
function ReadCT_LineChart(reader) {
    var instance = {
        chartType: 8,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_GROUPING:
                instance.grouping = ReadCT_Grouping(reader);
                break;
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_LineSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_DROP_LINES:
                instance.dropLines = ReadCT_ChartLines(reader);
                break;
            case "hiLowLines":
                instance.hiLowLines = ReadCT_ChartLines(reader);
                break;
            case "upDownBars":
                instance.upDownBars = ReadCT_UpDownBars(reader);
                break;
            case CONST_MARKER:
                instance.marker = ReadCT_Boolean(reader);
                break;
            case "smooth":
                instance.smooth = ReadCT_Boolean(reader);
                break;
            case CONST_AXID:
                instance.axId.push(ReadCT_Int(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_LineChart = ReadCT_LineChart;
function ReadCT_Line3DChart(reader) {
    var instance = {
        chartType: 9,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_GROUPING:
                instance.grouping = ReadCT_Grouping(reader);
                break;
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_LineSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_DROP_LINES:
                instance.dropLines = ReadCT_ChartLines(reader);
                break;
            case "gapDepth":
                instance.gapDepth = ReadCT_GapAmount(reader);
                break;
            case CONST_AXID:
                instance.axId.push(ReadCT_Int(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Line3DChart = ReadCT_Line3DChart;
function ReadCT_StockChart(reader) {
    var instance = {
        chartType: 0,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_SER:
                instance.ser.push(ReadCT_LineSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_DROP_LINES:
                instance.dropLines = ReadCT_ChartLines(reader);
                break;
            case "hiLowLines":
                instance.hiLowLines = ReadCT_ChartLines(reader);
                break;
            case "upDownBars":
                instance.upDownBars = ReadCT_UpDownBars(reader);
                break;
            case CONST_AXID:
                instance.axId.push(ReadCT_Int(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_StockChart = ReadCT_StockChart;
function ReadCT_ScatterStyle(reader) {
    var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'marker');
    return chart_model_1.Charts.ST_ScatterStyle[val];
}
exports.DrawingReader.ReadCT_ScatterStyle = ReadCT_ScatterStyle;
function ReadCT_ScatterChart(reader) {
    var instance = {
        chartType: 1,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "scatterStyle":
                instance.scatterStyle = ReadCT_ScatterStyle(reader);
                break;
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_ScatterSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_AXID:
                instance.axId.push(ReadCT_Int(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ScatterChart = ReadCT_ScatterChart;
function ReadCT_RadarStyle(reader) {
    var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'standard');
    return chart_model_1.Charts.ST_RadarStyle[val];
}
exports.DrawingReader.ReadCT_RadarStyle = ReadCT_RadarStyle;
function ReadCT_RadarChart(reader) {
    var instance = {
        chartType: 2,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "radarStyle":
                instance.radarStyle = ReadCT_RadarStyle(reader);
                break;
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_RadarSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_AXID:
                instance.axId.push(ReadCT_Int(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_RadarChart = ReadCT_RadarChart;
function ReadCT_BarGrouping(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_BarGrouping[val];
    }
}
exports.DrawingReader.ReadCT_BarGrouping = ReadCT_BarGrouping;
function ReadCT_BarDir(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_BarDir[val];
    }
}
exports.DrawingReader.ReadCT_BarDir = ReadCT_BarDir;
function ReadCT_ShapeBox(reader) {
    var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'box');
    return chart_model_1.Charts.ST_Shape[val];
}
exports.DrawingReader.ReadCT_ShapeBox = ReadCT_ShapeBox;
function ReadCT_BarChart(reader) {
    var instance = {
        chartType: 6,
        ser: [],
        serLines: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "barDir":
                instance.barDir = ReadCT_BarDir(reader);
                break;
            case CONST_GROUPING:
                instance.grouping = ReadCT_BarGrouping(reader);
                break;
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_BarSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_GAP_WIDTH:
                instance.gapWidth = ReadCT_GapAmount(reader);
                break;
            case "overlap":
                instance.overlap = ReadCT_Overlap(reader);
                break;
            case "serLines":
                instance.serLines.push(ReadCT_ChartLines(reader));
                break;
            case CONST_AXID:
                instance.axId.push(ReadCT_Int(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_BarChart = ReadCT_BarChart;
function ReadCT_Bar3DChart(reader) {
    var instance = {
        chartType: 7,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "barDir":
                instance.barDir = ReadCT_BarDir(reader);
                break;
            case CONST_GROUPING:
                instance.grouping = ReadCT_BarGrouping(reader);
                break;
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_BarSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_GAP_WIDTH:
                instance.gapWidth = ReadCT_GapAmount(reader);
                break;
            case "gapDepth":
                instance.gapDepth = ReadCT_GapAmount(reader);
                break;
            case "shape":
                instance.shape = ReadCT_ShapeBox(reader);
                break;
            case CONST_AXID:
                instance.axId.push(ReadCT_Int(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Bar3DChart = ReadCT_Bar3DChart;
function ReadCT_AreaChart(reader) {
    var instance = {
        chartType: 4,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_GROUPING:
                instance.grouping = ReadCT_Grouping(reader);
                break;
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_AreaSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_DROP_LINES:
                instance.dropLines = ReadCT_ChartLines(reader);
                break;
            case CONST_AXID:
                instance.axId.push(ReadCT_Int(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_AreaChart = ReadCT_AreaChart;
function ReadCT_Area3DChart(reader) {
    var instance = {
        chartType: 5,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_GROUPING:
                instance.grouping = ReadCT_Grouping(reader);
                break;
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_AreaSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_DROP_LINES:
                instance.dropLines = ReadCT_ChartLines(reader);
                break;
            case "gapDepth":
                instance.gapDepth = ReadCT_GapAmount(reader);
                break;
            case CONST_AXID:
                instance.axId.push(ReadCT_Int(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Area3DChart = ReadCT_Area3DChart;
function ReadCT_PieChart(reader) {
    var instance = {
        chartType: 10,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_PieSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case "firstSliceAng":
                instance.firstSliceAng = ReadCT_FirstSliceAng(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_PieChart = ReadCT_PieChart;
function ReadCT_Pie3DChart(reader) {
    var instance = {
        chartType: 11,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_PieSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Pie3DChart = ReadCT_Pie3DChart;
function ReadCT_DoughnutChart(reader) {
    var instance = {
        chartType: 12,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_PieSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case "firstSliceAng":
                instance.firstSliceAng = ReadCT_FirstSliceAng(reader);
                break;
            case "holeSize":
                instance.holeSize = ReadCT_HoleSize(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DoughnutChart = ReadCT_DoughnutChart;
function ReadCT_OfPieType(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_OfPieType[val];
    }
}
exports.DrawingReader.ReadCT_OfPieType = ReadCT_OfPieType;
function ReadCT_OfPieChart(reader) {
    var instance = {
        chartType: 13,
        ser: [],
        serLines: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "ofPieType":
                instance.ofPieType = ReadCT_OfPieType(reader);
                break;
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_PieSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_GAP_WIDTH:
                instance.gapWidth = ReadCT_GapAmount(reader);
                break;
            case "splitType":
                instance.splitType = ReadCT_SplitType(reader);
                break;
            case "splitPos":
                instance.splitPos = ReadCT_Double(reader);
                break;
            case "custSplit":
                instance.custSplit = ReadCT_CustSplit(reader);
                break;
            case "secondPieSize":
                instance.secondPieSize = ReadCT_SecondPieSize(reader);
                break;
            case "serLines":
                instance.serLines.push(ReadCT_ChartLines(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_OfPieChart = ReadCT_OfPieChart;
function ReadCT_BubbleChart(reader) {
    var instance = {
        chartType: 3,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_VARY_COLORS:
                instance.varyColors = ReadCT_Boolean(reader);
                break;
            case CONST_SER:
                instance.ser.push(ReadCT_BubbleSer(reader));
                break;
            case COSNT_DLBLS:
                instance.dLbls = ReadCT_DLbls(reader);
                break;
            case CONST_BUBBLE_3D:
                instance.bubble3D = ReadCT_Boolean(reader);
                break;
            case "bubbleScale":
                instance.bubbleScale = ReadCT_BubbleScale(reader);
                break;
            case "showNegBubbles":
                instance.showNegBubbles = ReadCT_Boolean(reader);
                break;
            case "sizeRepresents":
                instance.sizeRepresents = ReadCT_SizeRepresents(reader);
                break;
            case CONST_AXID:
                instance.axId.push(ReadCT_Int(reader));
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_BubbleChart = ReadCT_BubbleChart;
function ReadCT_BandFmt(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_IDX) {
            instance.idx = ReadCT_UnsignedInt(reader);
        }
        else if (elementName === CONST_SPPR) {
            instance.spPr = ReadCT_ShapeProperties(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_BandFmt = ReadCT_BandFmt;
function ReadCT_BandFmts(reader) {
    var instance = { bandFmt: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "bandFmt") {
            instance.bandFmt.push(ReadCT_BandFmt(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_BandFmts = ReadCT_BandFmts;
function ReadCT_SurfaceChart(reader) {
    var instance = {
        chartType: 14,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    return readSurfaceChartSubElement(reader, instance);
}
exports.DrawingReader.ReadCT_SurfaceChart = ReadCT_SurfaceChart;
function ReadCT_Surface3DChart(reader) {
    var instance = {
        chartType: 15,
        ser: [],
        axId: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    return readSurfaceChartSubElement(reader, instance);
}
exports.DrawingReader.ReadCT_Surface3DChart = ReadCT_Surface3DChart;
function ReadCT_AxPos(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_AxPos[val];
    }
}
exports.DrawingReader.ReadCT_AxPos = ReadCT_AxPos;
function ReadCT_Crosses(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_helper_1.ChartHelper.ToAxisCrosses(chart_model_1.Charts.ST_Crosses[val]);
    }
}
exports.DrawingReader.ReadCT_Crosses = ReadCT_Crosses;
function ReadCT_CrossBetween(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_CrossBetween[val];
    }
}
exports.DrawingReader.ReadCT_CrossBetween = ReadCT_CrossBetween;
function ReadCT_TickMark(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_TickMark[val];
    }
}
exports.DrawingReader.ReadCT_TickMark = ReadCT_TickMark;
function ReadCT_TickLblPos(reader) {
    var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'nextTo');
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_TickLblPos[val];
    }
}
exports.DrawingReader.ReadCT_TickLblPos = ReadCT_TickLblPos;
function ReadCT_Skip(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_Skip = ReadCT_Skip;
function ReadCT_TimeUnit(reader) {
    var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'days');
    return chart_model_1.Charts.ST_TimeUnit[val];
}
exports.DrawingReader.ReadCT_TimeUnit = ReadCT_TimeUnit;
function ReadCT_AxisUnit(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttrValueOrDefaultOfDoubleType);
}
exports.DrawingReader.ReadCT_AxisUnit = ReadCT_AxisUnit;
function ReadCT_BuiltInUnit(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_BuiltInUnit[val];
    }
}
exports.DrawingReader.ReadCT_BuiltInUnit = ReadCT_BuiltInUnit;
function ReadCT_PictureFormat(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_PictureFormat[val];
    }
}
exports.DrawingReader.ReadCT_PictureFormat = ReadCT_PictureFormat;
function ReadCT_PictureStackUnit(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttrValueOrDefaultOfDoubleType);
}
exports.DrawingReader.ReadCT_PictureStackUnit = ReadCT_PictureStackUnit;
function ReadCT_PictureOptions(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var elementNameObj = {
        applyToFront: true,
        applyToSides: true,
        applyToEnd: true
    };
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementNameObj[elementName]) {
            instance[elementName] = ReadCT_Boolean(reader);
        }
        else if (elementName === "pictureFormat") {
            instance.pictureFormat = ReadCT_PictureFormat(reader);
        }
        else if (elementName === "pictureStackUnit") {
            instance.pictureStackUnit = ReadCT_PictureStackUnit(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_PictureOptions = ReadCT_PictureOptions;
function ReadCT_DispUnitsLbl(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_LAYOUT:
                instance.layout = ReadCT_Layout(reader);
                break;
            case "tx":
                instance.tx = ReadCT_Tx(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DispUnitsLbl = ReadCT_DispUnitsLbl;
function ReadCT_DispUnits(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "custUnit":
                instance.custUnit = ReadCT_Double(reader);
                break;
            case "builtInUnit":
                instance.builtInUnit = ReadCT_BuiltInUnit(reader);
                break;
            case "dispUnitsLbl":
                instance.dispUnitsLbl = ReadCT_DispUnitsLbl(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DispUnits = ReadCT_DispUnits;
function ReadCT_Orientation(reader) {
    var val = getValidValue(readSingleAttributeNode(reader, CONST_VAL), 'minMax');
    return chart_model_1.Charts.ST_Orientation[val];
}
exports.DrawingReader.ReadCT_Orientation = ReadCT_Orientation;
function ReadCT_LogBase(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttrValueOrDefaultOfDoubleType);
}
exports.DrawingReader.ReadCT_LogBase = ReadCT_LogBase;
function ReadCT_Scaling(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "logBase":
                instance.logBase = ReadCT_LogBase(reader);
                break;
            case "orientation":
                instance.orientation = ReadCT_Orientation(reader);
                break;
            case "max":
                instance.max = ReadCT_Double(reader);
                break;
            case "min":
                instance.min = ReadCT_Double(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Scaling = ReadCT_Scaling;
function ReadCT_LblOffset(reader) {
    return getValidValue(readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType), 100);
}
exports.DrawingReader.ReadCT_LblOffset = ReadCT_LblOffset;
var Default_spPrs = {
    majorGridlines: {
        ln: {
            w: 1,
            cap: 2,
            cmpd: 0,
            algn: 0,
            solidFill: { schemeClr: { val: 1, lumMod: [15000], lumOff: [85000] } },
            round: true
        }, effectLst: {}
    },
    minorGridlines: {
        ln: {
            w: 1,
            cap: 2,
            cmpd: 0,
            algn: 0,
            solidFill: { schemeClr: { val: 1, lumMod: [5000], lumOff: [95000] } },
            round: true
        }, effectLst: {}
    },
    axis: {
        noFill: true,
        ln: {
            w: 1,
            cap: 2,
            cmpd: 0,
            algn: 0,
            solidFill: { schemeClr: { val: 1, lumMod: [15000], lumOff: [85000] } },
            round: true
        },
        effectLst: {}
    },
    plotArea: { noFill: true, ln: { noFill: true }, effectLst: {} }
};
function adjust_spPr(obj, name) {
    if (obj && !obj.spPr) {
        obj.spPr = Default_spPrs[name];
    }
}
function ReadCT_CatAx(reader) {
    var instance = { axisType: 0 };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_AXID:
                instance.axId = ReadCT_Int(reader);
                break;
            case CONST_SCALING:
                instance.scaling = ReadCT_Scaling(reader);
                break;
            case CONST_DELETE:
                instance.delete = ReadCT_Boolean(reader);
                break;
            case CONST_AX_POS:
                instance.axPos = ReadCT_AxPos(reader);
                break;
            case CONST_MAJOR_GRIDLINES:
                instance.majorGridlines = ReadCT_ChartLines(reader);
                adjust_spPr(instance.majorGridlines, "majorGridlines");
                break;
            case CONST_MINOR_GRIDLINES:
                instance.minorGridlines = ReadCT_ChartLines(reader);
                adjust_spPr(instance.minorGridlines, "minorGridlines");
                break;
            case CONST_TITLE:
                instance.title = ReadCT_Title(reader);
                break;
            case CONST_NUMFMT:
                instance.numFmt = ReadCT_NumFmt(reader);
                break;
            case CONST_MAJOR_TICK_MARK:
                instance.majorTickMark = ReadCT_TickMark(reader);
                break;
            case CONST_MINOR_TICK_MARK:
                instance.minorTickMark = ReadCT_TickMark(reader);
                break;
            case CONST_TICK_LBLPOS:
                instance.tickLblPos = ReadCT_TickLblPos(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case CONST_CROSSAX:
                instance.crossAx = ReadCT_Int(reader);
                break;
            case CONST_CROSSES:
                instance.crosses = ReadCT_Crosses(reader);
                break;
            case CONST_CROSSAT:
                instance.crossesAt = ReadCT_Double(reader);
                break;
            case "auto":
                instance.auto = ReadCT_Boolean(reader);
                break;
            case "lblAlgn":
                instance.lblAlgn = ReadCT_LblAlgn(reader);
                break;
            case "lblOffset":
                instance.lblOffset = ReadCT_LblOffset(reader);
                break;
            case "tickLblSkip":
                instance.tickLblSkip = ReadCT_Skip(reader);
                break;
            case "tickMarkSkip":
                instance.tickMarkSkip = ReadCT_Skip(reader);
                break;
            case "noMultiLvlLbl":
                instance.noMultiLvlLbl = ReadCT_Boolean(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    adjust_spPr(instance, "axis");
    return instance;
}
exports.DrawingReader.ReadCT_CatAx = ReadCT_CatAx;
function ReadCT_DateAx(reader) {
    var instance = { axisType: 1 };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_AXID:
                instance.axId = ReadCT_Int(reader);
                break;
            case CONST_SCALING:
                instance.scaling = ReadCT_Scaling(reader);
                break;
            case CONST_DELETE:
                instance.delete = ReadCT_Boolean(reader);
                break;
            case CONST_AX_POS:
                instance.axPos = ReadCT_AxPos(reader);
                break;
            case CONST_MAJOR_GRIDLINES:
                instance.majorGridlines = ReadCT_ChartLines(reader);
                adjust_spPr(instance.majorGridlines, "majorGridlines");
                break;
            case CONST_MINOR_GRIDLINES:
                instance.minorGridlines = ReadCT_ChartLines(reader);
                adjust_spPr(instance.minorGridlines, "minorGridlines");
                break;
            case CONST_TITLE:
                instance.title = ReadCT_Title(reader);
                break;
            case CONST_NUMFMT:
                instance.numFmt = ReadCT_NumFmt(reader);
                break;
            case CONST_MAJOR_TICK_MARK:
                instance.majorTickMark = ReadCT_TickMark(reader);
                break;
            case CONST_MINOR_TICK_MARK:
                instance.minorTickMark = ReadCT_TickMark(reader);
                break;
            case CONST_TICK_LBLPOS:
                instance.tickLblPos = ReadCT_TickLblPos(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case CONST_CROSSAX:
                instance.crossAx = ReadCT_Int(reader);
                break;
            case CONST_CROSSES:
                instance.crosses = ReadCT_Crosses(reader);
                break;
            case CONST_CROSSAT:
                instance.crossesAt = ReadCT_Double(reader);
                break;
            case "auto":
                instance.auto = ReadCT_Boolean(reader);
                break;
            case "lblOffset":
                instance.lblOffset = ReadCT_LblOffset(reader);
                break;
            case "baseTimeUnit":
                instance.baseTimeUnit = ReadCT_TimeUnit(reader);
                break;
            case "majorUnit":
                instance.majorUnit = ReadCT_AxisUnit(reader);
                break;
            case "majorTimeUnit":
                instance.majorTimeUnit = ReadCT_TimeUnit(reader);
                break;
            case "minorUnit":
                instance.minorUnit = ReadCT_AxisUnit(reader);
                break;
            case "minorTimeUnit":
                instance.minorTimeUnit = ReadCT_TimeUnit(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    adjust_spPr(instance, "axis");
    return instance;
}
exports.DrawingReader.ReadCT_DateAx = ReadCT_DateAx;
function ReadCT_SerAx(reader) {
    var instance = { axisType: 2 };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_AXID:
                instance.axId = ReadCT_Int(reader);
                break;
            case CONST_SCALING:
                instance.scaling = ReadCT_Scaling(reader);
                break;
            case CONST_DELETE:
                instance.delete = ReadCT_Boolean(reader);
                break;
            case CONST_AX_POS:
                instance.axPos = ReadCT_AxPos(reader);
                break;
            case CONST_MAJOR_GRIDLINES:
                instance.majorGridlines = ReadCT_ChartLines(reader);
                adjust_spPr(instance.majorGridlines, "majorGridlines");
                break;
            case CONST_MINOR_GRIDLINES:
                instance.minorGridlines = ReadCT_ChartLines(reader);
                adjust_spPr(instance.minorGridlines, "minorGridlines");
                break;
            case CONST_TITLE:
                instance.title = ReadCT_Title(reader);
                break;
            case CONST_NUMFMT:
                instance.numFmt = ReadCT_NumFmt(reader);
                break;
            case CONST_MAJOR_TICK_MARK:
                instance.majorTickMark = ReadCT_TickMark(reader);
                break;
            case CONST_MINOR_TICK_MARK:
                instance.minorTickMark = ReadCT_TickMark(reader);
                break;
            case CONST_TICK_LBLPOS:
                instance.tickLblPos = ReadCT_TickLblPos(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case CONST_CROSSAX:
                instance.crossAx = ReadCT_Int(reader);
                break;
            case CONST_CROSSES:
                instance.crosses = ReadCT_Crosses(reader);
                break;
            case CONST_CROSSAT:
                instance.crossesAt = ReadCT_Double(reader);
                break;
            case "tickLblSkip":
                instance.tickLblSkip = ReadCT_Skip(reader);
                break;
            case "tickMarkSkip":
                instance.tickMarkSkip = ReadCT_Skip(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    adjust_spPr(instance, "axis");
    return instance;
}
exports.DrawingReader.ReadCT_SerAx = ReadCT_SerAx;
function ReadCT_ValAx(reader) {
    var instance = { axisType: 3 };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_AXID:
                instance.axId = ReadCT_Int(reader);
                break;
            case CONST_SCALING:
                instance.scaling = ReadCT_Scaling(reader);
                break;
            case CONST_DELETE:
                instance.delete = ReadCT_Boolean(reader);
                break;
            case CONST_AX_POS:
                instance.axPos = ReadCT_AxPos(reader);
                break;
            case CONST_MAJOR_GRIDLINES:
                instance.majorGridlines = ReadCT_ChartLines(reader);
                adjust_spPr(instance.majorGridlines, "majorGridlines");
                break;
            case CONST_MINOR_GRIDLINES:
                instance.minorGridlines = ReadCT_ChartLines(reader);
                adjust_spPr(instance.minorGridlines, "minorGridlines");
                break;
            case CONST_TITLE:
                instance.title = ReadCT_Title(reader);
                break;
            case CONST_NUMFMT:
                instance.numFmt = ReadCT_NumFmt(reader);
                break;
            case CONST_MAJOR_TICK_MARK:
                instance.majorTickMark = ReadCT_TickMark(reader);
                break;
            case CONST_MINOR_TICK_MARK:
                instance.minorTickMark = ReadCT_TickMark(reader);
                break;
            case CONST_TICK_LBLPOS:
                instance.tickLblPos = ReadCT_TickLblPos(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case CONST_CROSSAX:
                instance.crossAx = ReadCT_Int(reader);
                break;
            case CONST_CROSSES:
                instance.crosses = ReadCT_Crosses(reader);
                break;
            case CONST_CROSSAT:
                instance.crossesAt = ReadCT_Double(reader);
                break;
            case "crossBetween":
                instance.crossBetween = ReadCT_CrossBetween(reader);
                break;
            case "majorUnit":
                instance.majorUnit = ReadCT_AxisUnit(reader);
                break;
            case "minorUnit":
                instance.minorUnit = ReadCT_AxisUnit(reader);
                break;
            case "dispUnits":
                instance.dispUnits = ReadCT_DispUnits(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    adjust_spPr(instance, "axis");
    return instance;
}
exports.DrawingReader.ReadCT_ValAx = ReadCT_ValAx;
function ReadCT_PlotArea(reader) {
    var instance = {
        chartGroups: [],
        axes: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_LAYOUT:
                instance.layout = ReadCT_Layout(reader);
                break;
            case "areaChart":
                instance.chartGroups.push(ReadCT_AreaChart(reader));
                break;
            case "area3DChart":
                instance.chartGroups.push(ReadCT_Area3DChart(reader));
                break;
            case "barChart":
                instance.chartGroups.push(ReadCT_BarChart(reader));
                break;
            case "bar3DChart":
                instance.chartGroups.push(ReadCT_Bar3DChart(reader));
                break;
            case "lineChart":
                instance.chartGroups.push(ReadCT_LineChart(reader));
                break;
            case "line3DChart":
                instance.chartGroups.push(ReadCT_Line3DChart(reader));
                break;
            case "stockChart":
                instance.chartGroups.push(ReadCT_StockChart(reader));
                break;
            case "radarChart":
                instance.chartGroups.push(ReadCT_RadarChart(reader));
                break;
            case "scatterChart":
                instance.chartGroups.push(ReadCT_ScatterChart(reader));
                break;
            case "pieChart":
                instance.chartGroups.push(ReadCT_PieChart(reader));
                break;
            case "pie3DChart":
                instance.chartGroups.push(ReadCT_Pie3DChart(reader));
                break;
            case "doughnutChart":
                instance.chartGroups.push(ReadCT_DoughnutChart(reader));
                break;
            case "ofPieChart":
                instance.chartGroups.push(ReadCT_OfPieChart(reader));
                break;
            case "surfaceChart":
                instance.chartGroups.push(ReadCT_SurfaceChart(reader));
                break;
            case "surface3DChart":
                instance.chartGroups.push(ReadCT_Surface3DChart(reader));
                break;
            case "bubbleChart":
                instance.chartGroups.push(ReadCT_BubbleChart(reader));
                break;
            case "catAx":
                instance.axes.push(ReadCT_CatAx(reader));
                break;
            case "valAx":
                instance.axes.push(ReadCT_ValAx(reader));
                break;
            case "dateAx":
                instance.axes.push(ReadCT_DateAx(reader));
                break;
            case "serAx":
                instance.axes.push(ReadCT_SerAx(reader));
                break;
            case "dTable":
                instance.dTable = ReadCT_DTable(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    adjust_spPr(instance, "plotArea");
    return instance;
}
exports.DrawingReader.ReadCT_PlotArea = ReadCT_PlotArea;
function ReadCT_PivotFmt(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_IDX:
                instance.idx = ReadCT_UnsignedInt(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case CONST_MARKER:
                instance.marker = ReadCT_Marker(reader);
                break;
            case "dLbl":
                instance.dLbl = ReadCT_DLbl(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_PivotFmt = ReadCT_PivotFmt;
function ReadCT_PivotFmts(reader) {
    var instance = { pivotFmt: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "pivotFmt") {
            instance.pivotFmt.push(ReadCT_PivotFmt(reader));
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_PivotFmts = ReadCT_PivotFmts;
function ReadCT_LegendPos(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_helper_1.ChartHelper.ToLegendPosition(chart_model_1.Charts.ST_LegendPos[val]);
    }
}
exports.DrawingReader.ReadCT_LegendPos = ReadCT_LegendPos;
function ReadCT_LegendEntry(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_IDX:
                instance.idx = ReadCT_UnsignedInt(reader);
                break;
            case CONST_DELETE:
                instance.delete = ReadCT_Boolean(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_LegendEntry = ReadCT_LegendEntry;
function ReadCT_Legend(reader) {
    var legendEntry = [];
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "legendPos":
                instance.legendPos = ReadCT_LegendPos(reader);
                break;
            case "legendEntry":
                legendEntry.push(ReadCT_LegendEntry(reader));
                break;
            case CONST_LAYOUT:
                instance.layout = ReadCT_Layout(reader);
                break;
            case "overlay":
                instance.overlay = ReadCT_Boolean(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    if (legendEntry.length > 0) {
        instance.legendEntry = legendEntry;
    }
    return instance;
}
exports.DrawingReader.ReadCT_Legend = ReadCT_Legend;
function ReadCT_DispBlanksAs(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_DispBlanksAs[val];
    }
}
exports.DrawingReader.ReadCT_DispBlanksAs = ReadCT_DispBlanksAs;
function ReadCT_DispNaAsBlank(reader) {
    var instance = { extDataType: 2 };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "dispNaAsBlank") {
            instance.dispNaAsBlank = readSingleAttributeNode(reader, CONST_VAL);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DispNaAsBlank = ReadCT_DispNaAsBlank;
function ReadCT_Chart(reader) {
    var instance = { pivotFmts: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_TITLE:
                instance.title = ReadCT_Title(reader);
                break;
            case "autoTitleDeleted":
                instance.autoTitleDeleted = ReadCT_Boolean(reader);
                break;
            case "pivotFmts":
                instance.pivotFmts.push(ReadCT_PivotFmts(reader));
                break;
            case "view3D":
                instance.view3D = ReadCT_View3D(reader);
                break;
            case "floor":
                instance.floor = ReadCT_Surface(reader);
                break;
            case "sideWall":
                instance.sideWall = ReadCT_Surface(reader);
                break;
            case "backWall":
                instance.backWall = ReadCT_Surface(reader);
                break;
            case "plotArea":
                instance.plotArea = ReadCT_PlotArea(reader);
                break;
            case "legend":
                instance.legend = ReadCT_Legend(reader);
                break;
            case "plotVisOnly":
                instance.plotVisOnly = ReadCT_Boolean(reader);
                break;
            case "dispBlanksAs":
                instance.dispBlanksAs = ReadCT_DispBlanksAs(reader);
                break;
            case "showDLblsOverMax":
                instance.showDLblsOverMax = ReadCT_Boolean(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Chart = ReadCT_Chart;
function ReadCT_Style(reader) {
    return readSingleAttributeNode(reader, CONST_VAL);
}
exports.DrawingReader.ReadCT_Style = ReadCT_Style;
function ReadCT_PivotSource(reader) {
    var instance = { extLst: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_NAME:
                instance.name = reader.readElementContentAsString();
                break;
            case "fmtId":
                instance.fmtId = ReadCT_UnsignedInt(reader);
                break;
            case CONST_EXTLST:
                instance.extLst.push(ReadCT_ExtensionList(reader));
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_PivotSource = ReadCT_PivotSource;
function ReadCT_Protection(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var elementNameObj = {
        chartObject: true,
        data: true,
        formatting: true,
        selection: true,
        userInterface: true
    };
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementNameObj[elementName]) {
            instance[elementName] = ReadCT_Boolean(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Protection = ReadCT_Protection;
function ReadCT_HeaderFooter(reader) {
    var instance = { alignWithMargins: true };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "alignWithMargins" || attrName === "differentOddEven" || attrName === "differentFirst") {
            instance[attrName] = reader.readContentAsBoolean();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var elementNameObj = {
        oddHeader: true,
        oddFooter: true,
        evenHeader: true,
        evenFooter: true,
        firstHeader: true,
        firstFooter: true
    };
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementNameObj[elementName]) {
            instance[elementName] = reader.readElementContentAsString();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_HeaderFooter = ReadCT_HeaderFooter;
function ReadCT_PageMargins(reader) {
    var instance = {};
    var attrNameObj = { l: true, r: true, t: true, b: true, header: true, footer: true };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsDouble();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_PageMargins = ReadCT_PageMargins;
function ReadCT_ExternalData(reader) {
    var instance = {};
    instance.id = readSingleAttributeNode(reader, "id");
    return readSingleSubElementNode(reader, "autoUpdate", ReadCT_Boolean, instance);
}
exports.DrawingReader.ReadCT_ExternalData = ReadCT_ExternalData;
function ReadCT_PageSetup(reader) {
    var instance = {
        paperSize: 1,
        firstPageNumber: 1,
        orientation: 0,
        blackAndWhite: false,
        draft: false,
        useFirstPageNumber: false,
        horizontalDpi: 600,
        verticalDpi: 600,
        copies: 1
    };
    var intAttrNameObj = {
        paperSize: true,
        firstPageNumber: true,
        horizontalDpi: true,
        verticalDpi: true,
        copies: true
    }, boolAttrNameObj = { blackAndWhite: true, draft: true, useFirstPageNumber: true };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (intAttrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsInt();
        }
        else if (boolAttrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsBoolean();
        }
        else if (attrName === "orientation") {
            instance.orientation = chart_model_1.Charts.ST_PageSetupOrientation[reader.readContentAsString()];
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_PageSetup = ReadCT_PageSetup;
function ReadCT_PrintSettings(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "headerFooter":
                instance.headerFooter = ReadCT_HeaderFooter(reader);
                break;
            case "pageMargins":
                instance.pageMargins = ReadCT_PageMargins(reader);
                break;
            case "pageSetup":
                instance.pageSetup = ReadCT_PageSetup(reader);
                break;
            case "legacyDrawingHF":
                instance.legacyDrawingHF = ReadCT_RelId(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_PrintSettings = ReadCT_PrintSettings;
function ReadCT_ChartSpace(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "roundedCorners":
                instance.roundedCorners = ReadCT_Boolean(reader);
                break;
            case CONST_STYLE:
                instance.style = ReadCT_Style(reader);
                break;
            case "clrMapOvr":
                instance.clrMapOvr = ReadCT_ColorMapping(reader);
                break;
            case "pivotSource":
                instance.pivotSource = ReadCT_PivotSource(reader);
                break;
            case "protection":
                instance.protection = ReadCT_Protection(reader);
                break;
            case "chart":
                instance.chart = ReadCT_Chart(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_TXPR:
                instance.txPr = ReadCT_TextBody(reader);
                break;
            case "externalData":
                instance.externalData = ReadCT_ExternalData(reader);
                break;
            case "printSettings":
                instance.printSettings = ReadCT_PrintSettings(reader);
                break;
            case "userShapes":
                instance.userShapes = ReadCT_UserShapes(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_ExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ChartSpace = ReadCT_ChartSpace;
function ReadCT_DLblExtensionList(reader) {
    var instance = { ext: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_EXT) {
            instance.ext.push(ReadCT_DLblExt(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DLblExtensionList = ReadCT_DLblExtensionList;
function ReadCT_DLblExt(reader) {
    var instance = {};
    instance.uri = readSingleAttributeNode(reader, "uri");
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_LAYOUT:
                instance.layout = ReadCT_Layout(reader);
                break;
            case "dlblFieldTable":
                instance.dlblFieldTable = ReadCT_DataLabelFieldTable(reader);
                break;
            case "showDataLabelsRange":
                instance.showDataLabelsRange = ReadCT_Boolean(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DLblExt = ReadCT_DLblExt;
function ReadCT_DLblsExtensionList(reader) {
    var instance = { ext: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_EXT) {
            instance.ext.push(ReadCT_DLblsExt(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DLblsExtensionList = ReadCT_DLblsExtensionList;
function ReadCT_DLblsExt(reader) {
    var instance = {};
    instance.uri = getValidValue(readSingleAttributeNode(reader, "uri"), '{CE6537A1-D6FC-4f65-9D91-7224C49458BB}');
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_LAYOUT:
                instance.layout = ReadCT_Layout(reader);
                break;
            case "showLeaderLines":
                instance.showLeaderLines = ReadCT_Boolean(reader);
                break;
            case "showDataLabelsRange":
                instance.showDataLabelsRange = ReadCT_Boolean(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DLblsExt = ReadCT_DLblsExt;
function ReadCT_UserShapes(reader) {
    var instance = {};
    instance.id = readSingleAttributeNode(reader, "id");
    return readSingleSubElementNode(reader, "userShapes", ReadCT_ChartDrawing, instance);
}
exports.DrawingReader.ReadCT_UserShapes = ReadCT_UserShapes;
function ReadCT_InvertSolidFillFmt(reader) {
    var instance = { extDataType: 0 };
    return readSingleSubElementNode(reader, CONST_SPPR, ReadCT_ShapeProperties, instance);
}
exports.DrawingReader.ReadCT_InvertSolidFillFmt = ReadCT_InvertSolidFillFmt;
function ReadCT_FullRef(reader) {
    return readSubSqrefElement(reader);
}
exports.DrawingReader.ReadCT_FullRef = ReadCT_FullRef;
function ReadCT_LevelRef(reader) {
    return readSubSqrefElement(reader);
}
exports.DrawingReader.ReadCT_LevelRef = ReadCT_LevelRef;
function ReadCT_FormulaRef(reader) {
    return readSubSqrefElement(reader);
}
exports.DrawingReader.ReadCT_FormulaRef = ReadCT_FormulaRef;
function ReadCT_FilteredSeriesTitle(reader) {
    return readSingleSubElementNode(reader, "tx", ReadCT_Tx);
}
exports.DrawingReader.ReadCT_FilteredSeriesTitle = ReadCT_FilteredSeriesTitle;
function ReadCT_FilteredCategoryTitle(reader) {
    return readSingleSubElementNode(reader, "cat", ReadCT_AxDataSource);
}
exports.DrawingReader.ReadCT_FilteredCategoryTitle = ReadCT_FilteredCategoryTitle;
function ReadCT_FilteredBarSer(reader) {
    return readSingleSubElementNode(reader, CONST_SER, ReadCT_BarSer);
}
exports.DrawingReader.ReadCT_FilteredBarSer = ReadCT_FilteredBarSer;
function ReadCT_FilteredLineSer(reader) {
    return readSingleSubElementNode(reader, CONST_SER, ReadCT_LineSer);
}
exports.DrawingReader.ReadCT_FilteredLineSer = ReadCT_FilteredLineSer;
function ReadCT_FilteredScatterSer(reader) {
    return readSingleSubElementNode(reader, CONST_SER, ReadCT_ScatterSer);
}
exports.DrawingReader.ReadCT_FilteredScatterSer = ReadCT_FilteredScatterSer;
function ReadCT_FilteredAreaSer(reader) {
    return readSingleSubElementNode(reader, CONST_SER, ReadCT_AreaSer);
}
exports.DrawingReader.ReadCT_FilteredAreaSer = ReadCT_FilteredAreaSer;
function ReadCT_FilteredPieSer(reader) {
    return readSingleSubElementNode(reader, CONST_SER, ReadCT_PieSer);
}
exports.DrawingReader.ReadCT_FilteredPieSer = ReadCT_FilteredPieSer;
function ReadCT_FilteredBubbleSer(reader) {
    return readSingleSubElementNode(reader, CONST_SER, ReadCT_BubbleSer);
}
exports.DrawingReader.ReadCT_FilteredBubbleSer = ReadCT_FilteredBubbleSer;
function ReadCT_FilteredRadarSer(reader) {
    return readSingleSubElementNode(reader, CONST_SER, ReadCT_RadarSer);
}
exports.DrawingReader.ReadCT_FilteredRadarSer = ReadCT_FilteredRadarSer;
function ReadCT_FilteredSurfaceSer(reader) {
    return readSingleSubElementNode(reader, CONST_SER, ReadCT_SurfaceSer);
}
exports.DrawingReader.ReadCT_FilteredSurfaceSer = ReadCT_FilteredSurfaceSer;
function ReadCT_SeriesDataLabelsRange(reader) {
    var instance = { extDataType: 1 };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "f") {
            instance.f = xmlDecode(reader.readElementContentAsString());
        }
        else if (elementName === "dlblRangeCache") {
            instance.dlblRangeCache = ReadCT_StrData(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_SeriesDataLabelsRange = ReadCT_SeriesDataLabelsRange;
function ReadCT_CategoryFilterException(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_SQREF:
                instance.sqref = reader.readElementContentAsString();
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "explosion":
                instance.explosion = ReadCT_UnsignedInt(reader);
                break;
            case CONST_INVERT_IF_NEGATIVE:
                instance.invertIfNegative = ReadCT_Boolean(reader);
                break;
            case CONST_BUBBLE_3D:
                instance.bubble3D = ReadCT_Boolean(reader);
                break;
            case CONST_MARKER:
                instance.marker = ReadCT_Marker(reader);
                break;
            case "dLbl":
                instance.dLbl = ReadCT_DLbl(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_CategoryFilterException = ReadCT_CategoryFilterException;
function ReadCT_CategoryFilterExceptions(reader) {
    var instance = { categoryFilterException: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "categoryFilterException") {
            instance.categoryFilterException.push(ReadCT_CategoryFilterException(reader));
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_CategoryFilterExceptions = ReadCT_CategoryFilterExceptions;
function ReadCT_DataLabelFieldTableEntry(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "txfldGUID":
                instance.txfldGUID = reader.readElementContentAsString();
                break;
            case "f":
                instance.f = xmlDecode(reader.readElementContentAsString());
                break;
            case "dlblFieldTableCache":
                instance.dlblFieldTableCache = ReadCT_StrData(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DataLabelFieldTableEntry = ReadCT_DataLabelFieldTableEntry;
function ReadCT_DataLabelFieldTable(reader) {
    var instance = { dlblFTEntry: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "dlblFTEntry") {
            instance.dlblFTEntry.push(ReadCT_DataLabelFieldTableEntry(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DataLabelFieldTable = ReadCT_DataLabelFieldTable;
function ReadCT_GraphicFrameNonVisual(reader) {
    return readGraphicFrameNonVisualSubElement(reader);
}
exports.DrawingReader.ReadCT_GraphicFrameNonVisual = ReadCT_GraphicFrameNonVisual;
function ReadCT_CdrPosition(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "x" || elementName === "y") {
            instance[elementName] = reader.readElementContentAsDouble();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_CdrPosition = ReadCT_CdrPosition;
function ReadCT_RelSizeAnchor(reader) {
    var instance = { anchorType: 3 };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "from":
                instance.startPoint = ReadCT_CdrPosition(reader);
                break;
            case "to":
                instance.endPoint = ReadCT_CdrPosition(reader);
                break;
            case "sp":
                instance.sp = ReadCT_Shape(reader);
                break;
            case CONST_GRPSP:
                instance.grpSp = ReadCT_GroupShape(reader);
                break;
            case CONST_GRAPHIC_FRAME:
                instance.graphicFrame = ReadCT_GraphicalObjectFrame(reader);
                break;
            case CONST_CXNSP:
                instance.cxnSp = ReadCT_Connector(reader);
                break;
            case "pic":
                instance.pic = ReadCT_Picture(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_RelSizeAnchor = ReadCT_RelSizeAnchor;
function ReadCT_AbsSizeAnchor(reader) {
    var instance = { anchorType: 4 };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "from":
                instance.startPoint = ReadCT_CdrPosition(reader);
                break;
            case CONST_EXT:
                var extData = ReadCT_PositiveSize2D(reader, true);
                instance.width = extData.cx;
                instance.height = extData.cy;
                break;
            case "sp":
                instance.sp = ReadCT_Shape(reader);
                break;
            case CONST_GRPSP:
                instance.grpSp = ReadCT_GroupShape(reader);
                break;
            case CONST_GRAPHIC_FRAME:
                instance.graphicFrame = ReadCT_GraphicalObjectFrame(reader);
                break;
            case CONST_CXNSP:
                instance.cxnSp = ReadCT_Connector(reader);
                break;
            case "pic":
                instance.pic = ReadCT_Picture(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_AbsSizeAnchor = ReadCT_AbsSizeAnchor;
function ReadCT_ChartDrawing(reader) {
    var instance = {
        relSizeAnchor: [],
        absSizeAnchor: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "relSizeAnchor") {
            instance.relSizeAnchor.push(ReadCT_RelSizeAnchor(reader));
        }
        else if (elementName === "absSizeAnchor") {
            instance.absSizeAnchor.push(ReadCT_AbsSizeAnchor(reader));
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ChartDrawing = ReadCT_ChartDrawing;
function ReadCT_ConnectorLocking(reader) {
    var instance = {
        noGrp: false,
        noSelect: false,
        noRot: false,
        noChangeAspect: false,
        noMove: false,
        noResize: false,
        noEditPoints: false,
        noAdjustHandles: false,
        noChangeArrowheads: false,
        noChangeShapeType: false
    };
    var attrNameObj = {
        noGrp: true,
        noSelect: true,
        noRot: true,
        noChangeAspect: true,
        noMove: true,
        noResize: true,
        noEditPoints: true,
        noAdjustHandles: true,
        noChangeArrowheads: true,
        noChangeShapeType: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsBoolean();
        }
    }
    return readSingleSubElementNode(reader, CONST_EXTLST, ReadCT_OfficeArtExtensionList, instance);
}
exports.DrawingReader.ReadCT_ConnectorLocking = ReadCT_ConnectorLocking;
function ReadCT_ShapeLocking(reader) {
    var instance = {
        noGrp: false,
        noSelect: false,
        noRot: false,
        noChangeAspect: false,
        noMove: false,
        noResize: false,
        noEditPoints: false,
        noAdjustHandles: false,
        noChangeArrowheads: false,
        noChangeShapeType: false,
        noTextEdit: false
    };
    var attrNameObj = {
        noGrp: true,
        noSelect: true,
        noRot: true,
        noChangeAspect: true,
        noMove: true,
        noResize: true,
        noEditPoints: true,
        noAdjustHandles: true,
        noChangeArrowheads: true,
        noChangeShapeType: true,
        noTextEdit: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsBoolean();
        }
    }
    return readSingleSubElementNode(reader, CONST_EXTLST, ReadCT_OfficeArtExtensionList, instance);
}
exports.DrawingReader.ReadCT_ShapeLocking = ReadCT_ShapeLocking;
function ReadCT_PictureLocking(reader) {
    var instance = {};
    var attrNameObj = {
        noGrp: true,
        noSelect: true,
        noRot: true,
        noChangeAspect: true,
        noMove: true,
        noResize: true,
        noEditPoints: true,
        noAdjustHandles: true,
        noChangeArrowheads: true,
        noChangeShapeType: true,
        noCrop: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsBoolean();
        }
    }
    return readSingleSubElementNode(reader, CONST_EXTLST, ReadCT_OfficeArtExtensionList, instance);
}
exports.DrawingReader.ReadCT_PictureLocking = ReadCT_PictureLocking;
function ReadCT_GroupLocking(reader) {
    var instance = {
        noGrp: false,
        noUngrp: false,
        noSelect: false,
        noRot: false,
        noChangeAspect: false,
        noMove: false,
        noResize: false
    };
    var attrNameObj = {
        noGrp: true,
        noUngrp: true,
        noSelect: true,
        noRot: true,
        noChangeAspect: true,
        noMove: true,
        noResize: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsBoolean();
        }
    }
    return readSingleSubElementNode(reader, CONST_EXTLST, ReadCT_OfficeArtExtensionList, instance);
}
exports.DrawingReader.ReadCT_GroupLocking = ReadCT_GroupLocking;
function ReadCT_GraphicalObjectFrameLocking(reader) {
    var instance = {
        noGrp: false,
        noDrilldown: false,
        noSelect: false,
        noChangeAspect: false,
        noMove: false,
        noResize: false
    };
    var attrNameObj = {
        noGrp: true,
        noDrilldown: true,
        noSelect: true,
        noChangeAspect: true,
        noMove: true,
        noResize: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsBoolean();
        }
    }
    return readSingleSubElementNode(reader, CONST_EXTLST, ReadCT_OfficeArtExtensionList, instance);
}
exports.DrawingReader.ReadCT_GraphicalObjectFrameLocking = ReadCT_GraphicalObjectFrameLocking;
function ReadCT_NonVisualDrawingProps(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        switch (attrName) {
            case "id":
                instance.id = reader.readContentAsInt();
                break;
            case CONST_NAME:
                instance.name = xmlDecode(reader.readContentAsString());
                break;
            case CONST_TITLE:
                instance.title = reader.readContentAsString();
                break;
            case "descr":
                instance.descr = reader.readContentAsString();
                break;
            case "hidden":
                instance.hidden = reader.readContentAsBoolean();
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "hlinkClick" || elementName === "hlinkHover") {
            instance[elementName] = ReadCT_Hyperlink(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_OfficeArtExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_NonVisualDrawingProps = ReadCT_NonVisualDrawingProps;
function ReadCT_NonVisualDrawingShapeProps(reader) {
    var instance = {};
    instance.txBox = getValidValue(readSingleAttributeNode(reader, "txBox", getAttrValueOrDefaultOfBooleanType), false);
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "spLocks") {
            instance.spLocks = ReadCT_ShapeLocking(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_OfficeArtExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_NonVisualDrawingShapeProps = ReadCT_NonVisualDrawingShapeProps;
function ReadCT_NonVisualConnectorProperties(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "cxnSpLocks":
                instance.cxnSpLocks = ReadCT_ConnectorLocking(reader);
                break;
            case "stCxn":
                instance.stCxn = ReadCT_Connection(reader);
                break;
            case "endCxn":
                instance.endCxn = ReadCT_Connection(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_NonVisualConnectorProperties = ReadCT_NonVisualConnectorProperties;
function ReadCT_NonVisualPictureProperties(reader) {
    var instance = {};
    instance.preferRelativeResize = readSingleAttributeNode(reader, "preferRelativeResize", getAttrValueOrDefaultOfBooleanType);
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "picLocks") {
            instance.picLocks = ReadCT_PictureLocking(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_OfficeArtExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_NonVisualPictureProperties = ReadCT_NonVisualPictureProperties;
function ReadCT_NonVisualGroupDrawingShapeProps(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "grpSpLocks") {
            instance.grpSpLocks = ReadCT_GroupLocking(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_OfficeArtExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_NonVisualGroupDrawingShapeProps = ReadCT_NonVisualGroupDrawingShapeProps;
function ReadCT_NonVisualGraphicFrameProperties(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "graphicFrameLocks") {
            instance.graphicFrameLocks = ReadCT_GraphicalObjectFrameLocking(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_OfficeArtExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_NonVisualGraphicFrameProperties = ReadCT_NonVisualGraphicFrameProperties;
function ReadCT_GraphicalObjectDataContent(reader) {
    var instance = {};
    instance.id = readSingleAttributeNode(reader, "id");
    return instance;
}
exports.DrawingReader.ReadCT_GraphicalObjectDataContent = ReadCT_GraphicalObjectDataContent;
function ReadCT_GraphicalObjectData(reader) {
    var instance = {};
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "chart") {
            instance.chart = ReadCT_GraphicalObjectDataContent(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_GraphicalObjectData = ReadCT_GraphicalObjectData;
function ReadCT_GraphicalObject(reader) {
    return readSingleSubElementNode(reader, "graphicData", ReadCT_GraphicalObjectData);
}
exports.DrawingReader.ReadCT_GraphicalObject = ReadCT_GraphicalObject;
function NormalizeSignificantWhitespaceFromXml(stringWithSignificantWhitespace) {
    return stringWithSignificantWhitespace.replace(/&#xA/g, '\n').replace(/&#xD/g, '\r');
}
exports.DrawingReader.NormalizeSignificantWhitespaceFromXml = NormalizeSignificantWhitespaceFromXml;
function ReadCT_Slicer(reader) {
    var instance = { name: '' };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_NAME) {
            instance.name = NormalizeSignificantWhitespaceFromXml(reader.readContentAsString());
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Slicer = ReadCT_Slicer;
function ReadCT_Camera(reader) {
    var instance = { zoom: 100000 };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "fov" || attrName === "zoom") {
            instance[attrName] = reader.readContentAsInt();
        }
        else if (attrName === CONST_PRST) {
            instance.prst = chart_model_1.Charts.ST_PresetCameraType[reader.readContentAsString()];
        }
    }
    return readSingleSubElementNode(reader, "rot", ReadCT_SphereCoords, instance);
}
exports.DrawingReader.ReadCT_Camera = ReadCT_Camera;
function ReadCT_LightRig(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "rig") {
            instance.rig = chart_model_1.Charts.ST_LightRigType[reader.readContentAsString()];
        }
        else if (attrName === "dir") {
            instance.dir = chart_model_1.Charts.ST_LightRigDirection[reader.readContentAsString()];
        }
    }
    return readSingleSubElementNode(reader, "rot", ReadCT_SphereCoords, instance);
}
exports.DrawingReader.ReadCT_LightRig = ReadCT_LightRig;
function ReadCT_Scene3D(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "camera":
                instance.camera = ReadCT_Camera(reader);
                break;
            case "lightRig":
                instance.lightRig = ReadCT_LightRig(reader);
                break;
            case "backdrop":
                instance.backdrop = ReadCT_Backdrop(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Scene3D = ReadCT_Scene3D;
function ReadCT_Backdrop(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "anchor":
                instance.anchor = ReadCT_Point3D(reader);
                break;
            case "norm":
                instance.norm = ReadCT_Vector3D(reader);
                break;
            case "up":
                instance.up = ReadCT_Vector3D(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Backdrop = ReadCT_Backdrop;
function ReadCT_Bevel(reader) {
    var instance = { w: 76200, h: 76200, prst: 1 };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "w" || attrName === "h") {
            instance[attrName] = reader.readContentAsInt();
        }
        else if (attrName === CONST_PRST) {
            instance.prst = chart_model_1.Charts.ST_BevelPresetType[reader.readContentAsString()];
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Bevel = ReadCT_Bevel;
function ReadCT_Shape3D(reader) {
    var instance = {};
    var value;
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "z" || attrName === "extrusionH" || attrName === "contourW") {
            value = reader.readContentAsInt();
            instance[attrName] = emuToPixles(value);
        }
        else if (attrName === "prstMaterial") {
            instance.prstMaterial = chart_model_1.Charts.ST_PresetMaterialType[reader.readContentAsString()];
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "bevelT" || elementName === "bevelB") {
            instance[elementName] = ReadCT_Bevel(reader);
        }
        else if (elementName === "extrusionClr" || elementName === "contourClr") {
            instance[elementName] = ReadCT_Color(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_OfficeArtExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Shape3D = ReadCT_Shape3D;
function ReadCT_FlatText(reader) {
    var instance = {};
    instance.z = getValidValue(readSingleAttributeNode(reader, "z", getAttributeValueOrDefaultOfIntType), 0);
    return instance;
}
exports.DrawingReader.ReadCT_FlatText = ReadCT_FlatText;
function ReadCT_AlphaBiLevelEffect(reader) {
    var instance = {};
    instance.thresh = readSingleAttributeNode(reader, "thresh", getAttributeValueOrDefaultOfIntType);
    return instance;
}
exports.DrawingReader.ReadCT_AlphaBiLevelEffect = ReadCT_AlphaBiLevelEffect;
function ReadCT_AlphaCeilingEffect() {
    return {};
}
exports.DrawingReader.ReadCT_AlphaCeilingEffect = ReadCT_AlphaCeilingEffect;
function ReadCT_AlphaFloorEffect() {
    return {};
}
exports.DrawingReader.ReadCT_AlphaFloorEffect = ReadCT_AlphaFloorEffect;
function ReadCT_AlphaInverseEffect(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    return readSubColorElements(reader, instance);
}
exports.DrawingReader.ReadCT_AlphaInverseEffect = ReadCT_AlphaInverseEffect;
function ReadCT_AlphaModulateFixedEffect(reader) {
    var instance = {};
    instance.amt = getValidValue(readSingleAttributeNode(reader, "amt", getAttributeValueOrDefaultOfIntType), 100000);
    return instance;
}
exports.DrawingReader.ReadCT_AlphaModulateFixedEffect = ReadCT_AlphaModulateFixedEffect;
function ReadCT_AlphaOutsetEffect(reader) {
    var instance = {};
    instance.rad = getValidValue(readSingleAttributeNode(reader, "rad", getAttributeValueOrDefaultOfIntType), 0);
    return instance;
}
exports.DrawingReader.ReadCT_AlphaOutsetEffect = ReadCT_AlphaOutsetEffect;
function ReadCT_AlphaReplaceEffect(reader) {
    var instance = {};
    instance.a = readSingleAttributeNode(reader, "a", getAttributeValueOrDefaultOfIntType);
    return instance;
}
exports.DrawingReader.ReadCT_AlphaReplaceEffect = ReadCT_AlphaReplaceEffect;
function ReadCT_BiLevelEffect(reader) {
    var instance = {};
    instance.thresh = readSingleAttributeNode(reader, "thresh", getAttributeValueOrDefaultOfIntType);
    return instance;
}
exports.DrawingReader.ReadCT_BiLevelEffect = ReadCT_BiLevelEffect;
function ReadCT_BlurEffect(reader) {
    var instance = {
        rad: 0,
        grow: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "rad") {
            instance.rad = reader.readContentAsInt();
        }
        else if (attrName === "grow") {
            instance.grow = reader.readContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_BlurEffect = ReadCT_BlurEffect;
function ReadCT_ColorChangeEffect(reader) {
    var instance = {};
    instance.useA = getValidValue(readSingleAttributeNode(reader, "useA", getAttrValueOrDefaultOfBooleanType), true);
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "clrFrom" || elementName === "clrTo") {
            instance[elementName] = ReadCT_Color(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ColorChangeEffect = ReadCT_ColorChangeEffect;
function ReadCT_ColorReplaceEffect(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    return readSubColorElements(reader, instance);
}
exports.DrawingReader.ReadCT_ColorReplaceEffect = ReadCT_ColorReplaceEffect;
function ReadCT_DuotoneEffect(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    return readSubColorElements(reader, instance);
}
exports.DrawingReader.ReadCT_DuotoneEffect = ReadCT_DuotoneEffect;
function ReadCT_GlowEffect(reader) {
    var instance = {};
    instance.rad = getValidValue(readSingleAttributeNode(reader, "rad", getAttributeValueOrDefaultOfIntType), 0);
    if (reader.elementType === 3) {
        return instance;
    }
    return readSubColorElements(reader, instance);
}
exports.DrawingReader.ReadCT_GlowEffect = ReadCT_GlowEffect;
function ReadCT_GrayscaleEffect() {
    return {};
}
exports.DrawingReader.ReadCT_GrayscaleEffect = ReadCT_GrayscaleEffect;
function ReadCT_HSLEffect(reader) {
    var instance = {
        hue: 0,
        sat: 0,
        lum: 0
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "hue" || attrName === "sat" || attrName === "lum") {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_HSLEffect = ReadCT_HSLEffect;
function ReadCT_InnerShadowEffect(reader) {
    var instance = { blurRad: 0, dist: 0, dir: 0 };
    instance.shadowEffectType = 1;
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "blurRad" || attrName === "dist" || attrName === "dir") {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return readSubColorElements(reader, instance);
}
exports.DrawingReader.ReadCT_InnerShadowEffect = ReadCT_InnerShadowEffect;
function ReadCT_LuminanceEffect(reader) {
    var instance = { bright: 0, contrast: 0 };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "bright" || attrName === "contrast") {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_LuminanceEffect = ReadCT_LuminanceEffect;
function ReadCT_OuterShadowEffect(reader) {
    var instance = {
        blurRad: 0,
        dist: 0,
        dir: 0,
        sx: 100000,
        sy: 100000,
        kx: 0,
        ky: 0,
        algn: 7,
        rotWithShape: true
    };
    instance.shadowEffectType = 0;
    var attrNameObj = {
        blurRad: true,
        dist: true,
        dir: true,
        sx: true,
        sy: true,
        kx: true,
        ky: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsInt();
        }
        else if (attrName === "algn") {
            instance.algn = chart_model_1.Charts.ST_RectAlignment[reader.readContentAsString()];
        }
        else if (attrName === CONST_TOT_WITH_SHAPE) {
            instance.rotWithShape = reader.readContentAsBoolean();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return readSubColorElements(reader, instance);
}
exports.DrawingReader.ReadCT_OuterShadowEffect = ReadCT_OuterShadowEffect;
function ReadCT_PresetShadowEffect(reader) {
    var instance = {
        dist: 0,
        dir: 0,
        shadowEffectType: 2
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "dist" || attrName === "dir") {
            instance[attrName] = reader.readContentAsInt();
        }
        else if (attrName === CONST_PRST) {
            instance.prst = chart_model_1.Charts.ST_PresetShadowVal[reader.readContentAsString()];
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return readSubColorElements(reader, instance);
}
exports.DrawingReader.ReadCT_PresetShadowEffect = ReadCT_PresetShadowEffect;
function ReadCT_ReflectionEffect(reader) {
    var instance = {
        blurRad: 0,
        stA: 100000,
        stPos: 0,
        endA: 0,
        endPos: 100000,
        dist: 0,
        dir: 0,
        fadeDir: 5400000,
        sx: 100000,
        sy: 100000,
        kx: 0,
        ky: 0,
        algn: 7,
        rotWithShape: true
    };
    var attrNameObj = {
        blurRad: true,
        stA: true,
        stPos: true,
        endA: true,
        endPos: true,
        dist: true,
        dir: true,
        fadeDir: true,
        sx: true,
        sy: true,
        kx: true,
        ky: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsInt();
        }
        else if (attrName === "algn") {
            instance.algn = chart_model_1.Charts.ST_RectAlignment[reader.readContentAsString()];
        }
        else if (attrName === CONST_TOT_WITH_SHAPE) {
            instance.rotWithShape = reader.readContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ReflectionEffect = ReadCT_ReflectionEffect;
function ReadCT_RelativeOffsetEffect(reader) {
    var instance = {
        tx: 0,
        ty: 0
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "tx" || attrName === "ty") {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_RelativeOffsetEffect = ReadCT_RelativeOffsetEffect;
function ReadCT_SoftEdgesEffect(reader) {
    var instance = {};
    instance.rad = readSingleAttributeNode(reader, "rad", getAttributeValueOrDefaultOfIntType);
    return instance;
}
exports.DrawingReader.ReadCT_SoftEdgesEffect = ReadCT_SoftEdgesEffect;
function ReadCT_TintEffect(reader) {
    var instance = {
        hue: 0,
        amt: 0
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "hue" || attrName === "amt") {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TintEffect = ReadCT_TintEffect;
function ReadCT_TransformEffect(reader) {
    var instance = {
        sx: 100000,
        sy: 100000,
        kx: 0,
        ky: 0,
        tx: 0,
        ty: 0
    };
    var attrNameObj = {
        sx: true,
        sy: true,
        kx: true,
        ky: true,
        tx: true,
        ty: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TransformEffect = ReadCT_TransformEffect;
function ReadCT_NoFillProperties() {
    return true;
}
exports.DrawingReader.ReadCT_NoFillProperties = ReadCT_NoFillProperties;
function ReadCT_SolidColorFillProperties(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    return readSubColorElements(reader, instance);
}
exports.DrawingReader.ReadCT_SolidColorFillProperties = ReadCT_SolidColorFillProperties;
function ReadCT_LinearShadeProperties(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "ang") {
            instance.ang = reader.readContentAsInt();
        }
        else if (attrName === "scaled") {
            instance.scaled = reader.readContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_LinearShadeProperties = ReadCT_LinearShadeProperties;
function ReadCT_PathShadeProperties(reader) {
    var instance = {};
    var path = readSingleAttributeNode(reader, "path");
    if (!common_1._isNullOrUndefined(path)) {
        instance.path = chart_model_1.Charts.ST_PathShadeType[path];
    }
    return readSingleSubElementNode(reader, "fillToRect", ReadCT_RelativeRect, instance);
}
exports.DrawingReader.ReadCT_PathShadeProperties = ReadCT_PathShadeProperties;
function ReadCT_GradientStop(reader) {
    var instance = {};
    instance.pos = readSingleAttributeNode(reader, "pos", getAttributeValueOrDefaultOfIntType);
    if (reader.elementType === 3) {
        return instance;
    }
    return readSubColorElements(reader, instance);
}
exports.DrawingReader.ReadCT_GradientStop = ReadCT_GradientStop;
function ReadCT_GradientStopList(reader) {
    var instance = {
        gs: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "gs") {
            instance.gs.push(ReadCT_GradientStop(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_GradientStopList = ReadCT_GradientStopList;
function ReadCT_GradientFillProperties(reader) {
    var instance = {
        rotWithShape: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "flip") {
            instance.flip = chart_model_1.Charts.ST_TileFlipMode[reader.readContentAsString()];
        }
        else if (attrName === CONST_TOT_WITH_SHAPE) {
            instance.rotWithShape = reader.readContentAsBoolean();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "gsLst":
                instance.gsLst = ReadCT_GradientStopList(reader);
                break;
            case "lin":
                instance.lin = ReadCT_LinearShadeProperties(reader);
                break;
            case "path":
                instance.path = ReadCT_PathShadeProperties(reader);
                break;
            case "tileRect":
                instance.tileRect = ReadCT_RelativeRect(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_GradientFillProperties = ReadCT_GradientFillProperties;
function ReadCT_TileInfoProperties(reader) {
    var instance = {};
    var attrNameObj = {
        tx: true,
        ty: true,
        sx: true,
        sy: true
    };
    var namesInEmu = {
        tx: true,
        ty: true
    };
    var value;
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            value = reader.readContentAsInt();
            if (namesInEmu[attrName]) {
                value = emuToPixles(value);
            }
            instance[attrName] = value;
        }
        else if (attrName === "flip") {
            instance.flip = chart_model_1.Charts.ST_TileFlipMode[reader.readContentAsString()];
        }
        else if (attrName === "algn") {
            instance.algn = chart_model_1.Charts.ST_RectAlignment[reader.readContentAsString()];
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TileInfoProperties = ReadCT_TileInfoProperties;
function ReadCT_StretchInfoProperties(reader) {
    return readSingleSubElementNode(reader, "fillRect", ReadCT_RelativeRect);
}
exports.DrawingReader.ReadCT_StretchInfoProperties = ReadCT_StretchInfoProperties;
function ReadCT_Blip(reader) {
    var instance = { cstate: 4 };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "embed" || attrName === "link") {
            instance[attrName] = reader.readContentAsString();
        }
        else if (attrName === "cstate") {
            instance.cstate = chart_model_1.Charts.ST_BlipCompression[reader.readContentAsString()];
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "alphaBiLevel":
                instance.alphaBiLevel = ReadCT_AlphaBiLevelEffect(reader);
                break;
            case "alphaCeiling":
                instance.alphaCeiling = ReadCT_AlphaCeilingEffect();
                break;
            case "alphaFloor":
                instance.alphaFloor = ReadCT_AlphaFloorEffect();
                break;
            case "alphaInv":
                instance.alphaInv = ReadCT_AlphaInverseEffect(reader);
                break;
            case "alphaMod":
                instance.alphaMod = ReadCT_AlphaModulateEffect(reader);
                break;
            case "alphaModFix":
                instance.alphaModFix = ReadCT_AlphaModulateFixedEffect(reader);
                break;
            case "alphaRepl":
                instance.alphaRepl = ReadCT_AlphaReplaceEffect(reader);
                break;
            case "biLevel":
                instance.biLevel = ReadCT_BiLevelEffect(reader);
                break;
            case "blur":
                instance.blur = ReadCT_BlurEffect(reader);
                break;
            case "clrChange":
                instance.clrChange = ReadCT_ColorChangeEffect(reader);
                break;
            case "clrRepl":
                instance.clrRepl = ReadCT_ColorReplaceEffect(reader);
                break;
            case "duotone":
                instance.duotone = ReadCT_DuotoneEffect(reader);
                break;
            case "fillOverlay":
                instance.fillOverlay = ReadCT_FillOverlayEffect(reader);
                break;
            case "grayscl":
                instance.grayscl = ReadCT_GrayscaleEffect();
                break;
            case "hsl":
                instance.hsl = ReadCT_HSLEffect(reader);
                break;
            case "lum":
                instance.lum = ReadCT_LuminanceEffect(reader);
                break;
            case "tint":
                instance.tint = ReadCT_TintEffect(reader);
                break;
            case "blipBlob":
                instance.blipBlob = ReadCT_BlipBlob(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    var ext = instance.extLst && instance.extLst.ext;
    if (Array.isArray(ext) && instance.embed) {
        var index = -1;
        for (var i = 0; i < ext.length; i++) {
            if (ext[i].hiddenExtensionType === 5) {
                index = i;
                break;
            }
        }
        if (index !== -1) {
            instance.embed = ext[index].svgBlip.embed;
            ext.splice(index, 1);
        }
        if (ext.length === 0) {
            delete instance.extLst.ext;
            if (Object.keys(instance.extLst).length === 0) {
                delete instance.extLst;
            }
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Blip = ReadCT_Blip;
function ReadCT_BlipBlob(reader) {
    var instance = {};
    var type = getValidValue(readSingleAttributeNode(reader, CONST_TYPE), 0);
    if (!common_1._isNullOrUndefined(type)) {
        instance.type = chart_model_1.Charts.ST_BobType[type];
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "blob") {
            instance.blob = reader.readElementContentAsString();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_BlipBlob = ReadCT_BlipBlob;
function ReadCT_BlipFillProperties(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "dpi") {
            instance.dpi = reader.readContentAsInt();
        }
        else if (attrName === CONST_TOT_WITH_SHAPE) {
            instance.rotWithShape = reader.readContentAsBoolean();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "blip":
                instance.blip = ReadCT_Blip(reader);
                break;
            case "srcRect":
                instance.srcRect = ReadCT_RelativeRect(reader);
                break;
            case "tile":
                instance.tile = ReadCT_TileInfoProperties(reader);
                break;
            case "stretch":
                instance.stretch = ReadCT_StretchInfoProperties(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_BlipFillProperties = ReadCT_BlipFillProperties;
function ReadCT_PatternFillProperties(reader) {
    var instance = {};
    var prst = readSingleAttributeNode(reader, CONST_PRST);
    if (!common_1._isNullOrUndefined(prst)) {
        instance.prst = chart_helper_1.ChartHelper.ToPatternType(chart_model_1.Charts.ST_PresetPatternVal[prst]);
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "fgClr" || elementName === "bgClr") {
            instance[elementName] = ReadCT_Color(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_PatternFillProperties = ReadCT_PatternFillProperties;
function ReadCT_GroupFillProperties() {
    return {};
}
exports.DrawingReader.ReadCT_GroupFillProperties = ReadCT_GroupFillProperties;
function ReadCT_FillProperties(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    return readFillProperties(reader, instance);
}
exports.DrawingReader.ReadCT_FillProperties = ReadCT_FillProperties;
function ReadCT_FillEffect(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    return readFillProperties(reader, instance);
}
exports.DrawingReader.ReadCT_FillEffect = ReadCT_FillEffect;
function ReadCT_FillOverlayEffect(reader) {
    var instance = {};
    var blend = readSingleAttributeNode(reader, "blend");
    if (!common_1._isNullOrUndefined(blend)) {
        instance.blend = chart_model_1.Charts.ST_BlendMode[blend];
    }
    if (reader.elementType === 3) {
        return instance;
    }
    return readFillProperties(reader, instance);
}
exports.DrawingReader.ReadCT_FillOverlayEffect = ReadCT_FillOverlayEffect;
function ReadCT_EffectReference(reader) {
    var instance = {};
    instance.ref = readSingleAttributeNode(reader, "ref");
    return instance;
}
exports.DrawingReader.ReadCT_EffectReference = ReadCT_EffectReference;
function ReadCT_EffectContainer(reader) {
    var instance = { type: 0 };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === CONST_TYPE) {
            instance.type = chart_model_1.Charts.ST_EffectContainerType[reader.readContentAsString()];
        }
        else if (attrName === CONST_NAME) {
            instance.name = reader.readContentAsString();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "cont":
                instance.cont = ReadCT_EffectContainer(reader);
                break;
            case "effect":
                instance.effect = ReadCT_EffectReference(reader);
                break;
            case "alphaBiLevel":
                instance.alphaBiLevel = ReadCT_AlphaBiLevelEffect(reader);
                break;
            case "alphaCeiling":
                instance.alphaCeiling = ReadCT_AlphaCeilingEffect();
                break;
            case "alphaFloor":
                instance.alphaFloor = ReadCT_AlphaFloorEffect();
                break;
            case "alphaInv":
                instance.alphaInv = ReadCT_AlphaInverseEffect(reader);
                break;
            case "alphaMod":
                instance.alphaMod = ReadCT_AlphaModulateEffect(reader);
                break;
            case "alphaModFix":
                instance.alphaModFix = ReadCT_AlphaModulateFixedEffect(reader);
                break;
            case "alphaOutset":
                instance.alphaOutset = ReadCT_AlphaOutsetEffect(reader);
                break;
            case "alphaRepl":
                instance.alphaRepl = ReadCT_AlphaReplaceEffect(reader);
                break;
            case "biLevel":
                instance.biLevel = ReadCT_BiLevelEffect(reader);
                break;
            case "blend":
                instance.blend = ReadCT_BlendEffect(reader);
                break;
            case "blur":
                instance.blur = ReadCT_BlurEffect(reader);
                break;
            case "clrChange":
                instance.clrChange = ReadCT_ColorChangeEffect(reader);
                break;
            case "clrRepl":
                instance.clrRepl = ReadCT_ColorReplaceEffect(reader);
                break;
            case "duotone":
                instance.duotone = ReadCT_DuotoneEffect(reader);
                break;
            case "fill":
                instance.fill = ReadCT_FillEffect(reader);
                break;
            case "fillOverlay":
                instance.fillOverlay = ReadCT_FillOverlayEffect(reader);
                break;
            case "glow":
                instance.glow = ReadCT_GlowEffect(reader);
                break;
            case "grayscl":
                instance.grayscl = ReadCT_GrayscaleEffect();
                break;
            case "hsl":
                instance.hsl = ReadCT_HSLEffect(reader);
                break;
            case "innerShdw":
                instance.innerShdw = ReadCT_InnerShadowEffect(reader);
                break;
            case "lum":
                instance.lum = ReadCT_LuminanceEffect(reader);
                break;
            case "outerShdw":
                instance.outerShdw = ReadCT_OuterShadowEffect(reader);
                break;
            case "prstShdw":
                instance.prstShdw = ReadCT_PresetShadowEffect(reader);
                break;
            case "reflection":
                instance.reflection = ReadCT_ReflectionEffect(reader);
                break;
            case "relOff":
                instance.relOff = ReadCT_RelativeOffsetEffect(reader);
                break;
            case "softEdge":
                instance.softEdge = ReadCT_SoftEdgesEffect(reader);
                break;
            case "tint":
                instance.tint = ReadCT_TintEffect(reader);
                break;
            case "xfrm":
                instance.xfrm = ReadCT_TransformEffect(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_EffectContainer = ReadCT_EffectContainer;
function ReadCT_AlphaModulateEffect(reader) {
    return readSingleSubElementNode(reader, "cont", ReadCT_EffectContainer);
}
exports.DrawingReader.ReadCT_AlphaModulateEffect = ReadCT_AlphaModulateEffect;
function ReadCT_BlendEffect(reader) {
    var instance = {};
    var blend = readSingleAttributeNode(reader, "blend");
    if (!common_1._isNullOrUndefined(blend)) {
        instance.blend = chart_model_1.Charts.ST_BlendMode[blend];
    }
    return readSingleSubElementNode(reader, "cont", ReadCT_EffectContainer, instance);
}
exports.DrawingReader.ReadCT_BlendEffect = ReadCT_BlendEffect;
function ReadCT_EffectList(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "blur":
                instance.blur = ReadCT_BlurEffect(reader);
                break;
            case "fillOverlay":
                instance.fillOverlay = ReadCT_FillOverlayEffect(reader);
                break;
            case "glow":
                instance.glow = ReadCT_GlowEffect(reader);
                break;
            case "innerShdw":
                instance.innerShdw = ReadCT_InnerShadowEffect(reader);
                break;
            case "outerShdw":
                instance.outerShdw = ReadCT_OuterShadowEffect(reader);
                break;
            case "prstShdw":
                instance.prstShdw = ReadCT_PresetShadowEffect(reader);
                break;
            case "reflection":
                instance.reflection = ReadCT_ReflectionEffect(reader);
                break;
            case "softEdge":
                instance.softEdge = ReadCT_SoftEdgesEffect(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_EffectList = ReadCT_EffectList;
function ReadCT_EffectProperties(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_EFFECTLST) {
            instance.effectLst = ReadCT_EffectList(reader);
        }
        else if (elementName === CONST_EFFECT_DAG) {
            instance.effectDag = ReadCT_EffectContainer(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_EffectProperties = ReadCT_EffectProperties;
function ReadCT_GeomGuide(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === CONST_NAME || attrName === "fmla") {
            instance[attrName] = reader.readContentAsString();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_GeomGuide = ReadCT_GeomGuide;
function ReadCT_GeomGuideList(reader) {
    var instance = { gd: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "gd") {
            instance.gd.push(ReadCT_GeomGuide(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_GeomGuideList = ReadCT_GeomGuideList;
function ReadCT_AdjPoint2D(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "x" || attrName === "y") {
            instance[attrName] = reader.readContentAsString();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_AdjPoint2D = ReadCT_AdjPoint2D;
function ReadCT_GeomRect(reader) {
    var instance = {};
    var attrNameObj = {
        l: true,
        t: true,
        r: true,
        b: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsString();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_GeomRect = ReadCT_GeomRect;
function ReadCT_XYAdjustHandle(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "gdRefX" || attrName === "gdRefY") {
            instance[attrName] = reader.readContentAsString();
        }
    }
    return readSingleSubElementNode(reader, "pos", ReadCT_AdjPoint2D, instance);
}
exports.DrawingReader.ReadCT_XYAdjustHandle = ReadCT_XYAdjustHandle;
function ReadCT_PolarAdjustHandle(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "gdRefR" || attrName === "gdRefAng") {
            instance[attrName] = reader.readContentAsString();
        }
    }
    return readSingleSubElementNode(reader, "pos", ReadCT_AdjPoint2D, instance);
}
exports.DrawingReader.ReadCT_PolarAdjustHandle = ReadCT_PolarAdjustHandle;
function ReadCT_ConnectionSite(reader) {
    var instance = {};
    instance.ang = readSingleAttributeNode(reader, "ang");
    return readSingleSubElementNode(reader, "pos", ReadCT_AdjPoint2D, instance);
}
exports.DrawingReader.ReadCT_ConnectionSite = ReadCT_ConnectionSite;
function ReadCT_AdjustHandleList(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "ahXY") {
            instance.ahXY = ReadCT_XYAdjustHandle(reader);
        }
        else if (elementName === "ahPolar") {
            instance.ahPolar = ReadCT_PolarAdjustHandle(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_AdjustHandleList = ReadCT_AdjustHandleList;
function ReadCT_ConnectionSiteList(reader) {
    var instance = { cxn: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "cxn") {
            instance.cxn.push(ReadCT_ConnectionSite(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ConnectionSiteList = ReadCT_ConnectionSiteList;
function ReadCT_Connection(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "id" || attrName === CONST_IDX) {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Connection = ReadCT_Connection;
function ReadCT_PathToList(reader, pathToType) {
    var instance = { PtList: [], typeName: chart_model_1.Charts.CT_PathType.CT_PathToList };
    instance.pathToType = pathToType;
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "pt") {
            instance.PtList.push(ReadCT_AdjPoint2D(reader));
        }
    }
    return instance;
}
function ReadCT_Path2DArcTo() {
    return {
        typeName: chart_model_1.Charts.CT_PathType.CT_Path2DArcTo
    };
}
exports.DrawingReader.ReadCT_Path2DArcTo = ReadCT_Path2DArcTo;
function ReadCT_Path2DClose() {
    return {
        typeName: chart_model_1.Charts.CT_PathType.CT_Path2DClose
    };
}
exports.DrawingReader.ReadCT_Path2DClose = ReadCT_Path2DClose;
function ReadCT_Path2D(reader) {
    var instance = {
        quadBezTo: [],
        cubicBezTo: [],
        w: 0,
        h: 0,
        fill: 1,
        stroke: true,
        extrusionOk: true,
        pathToList: []
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "w" || attrName === "h") {
            instance[attrName] = reader.readContentAsInt();
        }
        else if (attrName === "stroke" || attrName === "extrusionOk") {
            instance[attrName] = reader.readContentAsBoolean();
        }
        else if (attrName === "fill") {
            instance.fill = chart_model_1.Charts.ST_PathFillMode[reader.readContentAsString()];
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "close":
                instance.pathToList.push(ReadCT_Path2DClose());
                break;
            case "moveTo":
                instance.pathToList.push(ReadCT_PathToList(reader, 1));
                break;
            case "lnTo":
                instance.pathToList.push(ReadCT_PathToList(reader, 0));
                break;
            case "arcTo":
                instance.pathToList.push(ReadCT_Path2DArcTo());
                break;
            case "quadBezTo":
                instance.pathToList.push(ReadCT_PathToList(reader, 2));
                break;
            case "cubicBezTo":
                instance.pathToList.push(ReadCT_PathToList(reader, 3));
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Path2D = ReadCT_Path2D;
function ReadCT_Path2DList(reader) {
    var instance = [];
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "path") {
            instance.push(ReadCT_Path2D(reader));
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Path2DList = ReadCT_Path2DList;
function ReadCT_PresetGeometry2D(reader) {
    var instance = {};
    var prst = readSingleAttributeNode(reader, CONST_PRST);
    if (!common_1._isNullOrUndefined(prst)) {
        instance.prst = chart_model_1.Charts.ST_ShapeType[prst];
    }
    return readSingleSubElementNode(reader, "avLst", ReadCT_GeomGuideList, instance);
}
exports.DrawingReader.ReadCT_PresetGeometry2D = ReadCT_PresetGeometry2D;
function ReadCT_PresetTextShape(reader) {
    var instance = {};
    var prst = readSingleAttributeNode(reader, CONST_PRST);
    if (!common_1._isNullOrUndefined(prst)) {
        instance.prst = chart_model_1.Charts.ST_TextShapeType[prst];
    }
    return readSingleSubElementNode(reader, "avLst", ReadCT_GeomGuideList, instance);
}
exports.DrawingReader.ReadCT_PresetTextShape = ReadCT_PresetTextShape;
function ReadCT_CustomGeometry2D(reader) {
    var instance = { pathLst: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "avLst":
                instance.avLst = ReadCT_GeomGuideList(reader);
                break;
            case "gdLst":
                instance.gdLst = ReadCT_GeomGuideList(reader);
                break;
            case "ahLst":
                instance.ahLst = ReadCT_AdjustHandleList(reader);
                break;
            case "cxnLst":
                instance.cxnLst = ReadCT_ConnectionSiteList(reader);
                break;
            case "rect":
                instance.rect = ReadCT_GeomRect(reader);
                break;
            case "pathLst":
                instance.pathLst = ReadCT_Path2DList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_CustomGeometry2D = ReadCT_CustomGeometry2D;
function ReadCT_LineEndProperties(reader) {
    var instance = {
        w: 1,
        len: 1
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        switch (attrName) {
            case CONST_TYPE:
                instance.type = chart_model_1.Charts.ST_LineEndType[reader.readContentAsString()];
                break;
            case "w":
                instance.w = chart_model_1.Charts.ST_LineEndWidth[reader.readContentAsString()];
                break;
            case "len":
                instance.len = chart_model_1.Charts.ST_LineEndLength[reader.readContentAsString()];
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_LineEndProperties = ReadCT_LineEndProperties;
function ReadCT_LineJoinBevel() {
    return {};
}
exports.DrawingReader.ReadCT_LineJoinBevel = ReadCT_LineJoinBevel;
function ReadCT_LineJoinRound() {
    return true;
}
exports.DrawingReader.ReadCT_LineJoinRound = ReadCT_LineJoinRound;
function ReadCT_LineJoinMiterProperties(reader) {
    var instance = {};
    instance.lim = readSingleAttributeNode(reader, "lim", getAttributeValueOrDefaultOfIntType);
    return instance;
}
exports.DrawingReader.ReadCT_LineJoinMiterProperties = ReadCT_LineJoinMiterProperties;
function ReadCT_PresetLineDashProperties(reader) {
    var val = readSingleAttributeNode(reader, CONST_VAL);
    if (!common_1._isNullOrUndefined(val)) {
        return chart_model_1.Charts.ST_PresetLineDashVal[val];
    }
}
exports.DrawingReader.ReadCT_PresetLineDashProperties = ReadCT_PresetLineDashProperties;
function ReadCT_DashStop(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "d" || attrName === "sp") {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DashStop = ReadCT_DashStop;
function ReadCT_DashStopList(reader) {
    var instance = { ds: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "ds") {
            instance.ds.push(ReadCT_DashStop(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DashStopList = ReadCT_DashStopList;
function ReadCT_LineProperties(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        switch (attrName) {
            case "w":
                instance.w = emuToPixles(reader.readContentAsInt());
                break;
            case "cap":
                instance.cap = chart_model_1.Charts.ST_LineCap[reader.readContentAsString()];
                break;
            case "cmpd":
                instance.cmpd = chart_model_1.Charts.ST_CompoundLine[reader.readContentAsString()];
                break;
            case "algn":
                instance.algn = chart_model_1.Charts.ST_PenAlignment[reader.readContentAsString()];
                break;
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_NO_FILL:
                instance.noFill = ReadCT_NoFillProperties();
                break;
            case CONST_SOLID_FILL:
                instance.solidFill = ReadCT_SolidColorFillProperties(reader);
                break;
            case CONST_GRAD_FILL:
                instance.gradFill = ReadCT_GradientFillProperties(reader);
                break;
            case CONST_PATT_FILL:
                instance.pattFill = ReadCT_PatternFillProperties(reader);
                break;
            case "prstDash":
                instance.prstDash = ReadCT_PresetLineDashProperties(reader);
                break;
            case "custDash":
                instance.custDash = ReadCT_DashStopList(reader);
                break;
            case "round":
                instance.round = ReadCT_LineJoinRound();
                break;
            case "bevel":
                instance.bevel = ReadCT_LineJoinBevel();
                break;
            case "miter":
                instance.miter = ReadCT_LineJoinMiterProperties(reader);
                break;
            case "headEnd":
                instance.headEnd = ReadCT_LineEndProperties(reader);
                break;
            case "tailEnd":
                instance.tailEnd = ReadCT_LineEndProperties(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    if (instance.w === 0 && !instance.noFill) {
        instance.w = 1;
    }
    return instance;
}
exports.DrawingReader.ReadCT_LineProperties = ReadCT_LineProperties;
function ReadCT_SvgBlipProperties(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        switch (attrName) {
            case "asvg":
                instance.asvg = reader.readContentAsString();
                break;
            case "embed":
                instance.embed = reader.readContentAsString();
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_SvgBlip = ReadCT_SvgBlipProperties;
function ReadCT_ShapeProperties(reader) {
    var instance = {};
    var bwMode = readSingleAttributeNode(reader, "bwMode");
    if (!common_1._isNullOrUndefined(bwMode)) {
        instance.bwMode = chart_model_1.Charts.ST_BlackWhiteMode[bwMode];
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "xfrm":
                instance.xfrm = ReadCT_Transform2D(reader);
                break;
            case "custGeom":
                instance.custGeom = ReadCT_CustomGeometry2D(reader);
                break;
            case "prstGeom":
                instance.prstGeom = ReadCT_PresetGeometry2D(reader);
                break;
            case CONST_NO_FILL:
                instance.noFill = ReadCT_NoFillProperties();
                break;
            case CONST_SOLID_FILL:
                instance.solidFill = ReadCT_SolidColorFillProperties(reader);
                break;
            case CONST_GRAD_FILL:
                instance.gradFill = ReadCT_GradientFillProperties(reader);
                break;
            case CONST_BLIP_FILL:
                instance.blipFill = ReadCT_BlipFillProperties(reader);
                break;
            case CONST_PATT_FILL:
                instance.pattFill = ReadCT_PatternFillProperties(reader);
                break;
            case CONST_GRP_FILL:
                instance.grpFill = ReadCT_GroupFillProperties();
                break;
            case "ln":
                instance.ln = ReadCT_LineProperties(reader);
                break;
            case CONST_EFFECTLST:
                instance.effectLst = ReadCT_EffectList(reader);
                break;
            case CONST_EFFECT_DAG:
                instance.effectDag = ReadCT_EffectContainer(reader);
                break;
            case CONST_SCENE_3D:
                instance.scene3d = ReadCT_Scene3D(reader);
                break;
            case "sp3d":
                instance.sp3d = ReadCT_Shape3D(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ShapeProperties = ReadCT_ShapeProperties;
function ReadCT_GroupShapeProperties(reader) {
    var instance = {};
    var bwMode = readSingleAttributeNode(reader, "bwMode");
    if (!common_1._isNullOrUndefined(bwMode)) {
        instance.bwMode = chart_model_1.Charts.ST_BlackWhiteMode[bwMode];
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "xfrm":
                instance.xfrm = ReadCT_GroupTransform2D(reader);
                break;
            case CONST_NO_FILL:
                instance.noFill = ReadCT_NoFillProperties();
                break;
            case CONST_SOLID_FILL:
                instance.solidFill = ReadCT_SolidColorFillProperties(reader);
                break;
            case CONST_GRAD_FILL:
                instance.gradFill = ReadCT_GradientFillProperties(reader);
                break;
            case CONST_BLIP_FILL:
                instance.blipFill = ReadCT_BlipFillProperties(reader);
                break;
            case CONST_PATT_FILL:
                instance.pattFill = ReadCT_PatternFillProperties(reader);
                break;
            case CONST_GRP_FILL:
                instance.grpFill = ReadCT_GroupFillProperties();
                break;
            case CONST_EFFECTLST:
                instance.effectLst = ReadCT_EffectList(reader);
                break;
            case CONST_EFFECT_DAG:
                instance.effectDag = ReadCT_EffectContainer(reader);
                break;
            case CONST_SCENE_3D:
                instance.scene3d = ReadCT_Scene3D(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_GroupShapeProperties = ReadCT_GroupShapeProperties;
function ReadCT_StyleMatrixReference(reader) {
    var instance = { ColorProp: {} };
    instance[CONST_IDX] = readSingleAttributeNode(reader, CONST_IDX, getAttributeValueOrDefaultOfIntType);
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_SCRGBCLR:
                instance.ColorProp.scrgbClr = ReadCT_ScRgbColor(reader);
                break;
            case CONST_SRGBCLR:
                instance.ColorProp.srgbClr = ReadCT_SRgbColor(reader);
                break;
            case CONST_HSLCLR:
                instance.ColorProp.hslClr = ReadCT_HslColor(reader);
                break;
            case CONST_SYSCLR:
                instance.ColorProp.sysClr = ReadCT_SystemColor(reader);
                break;
            case CONST_SCHEMECLR:
                instance.ColorProp.schemeClr = ReadCT_SchemeColor(reader);
                break;
            case CONST_PRSTCLR:
                instance.ColorProp.prstClr = ReadCT_PresetColor(reader);
                break;
            case CONST_STYLECLR:
                instance.ColorProp.styleClr = ReadCT_StyleColor(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_StyleMatrixReference = ReadCT_StyleMatrixReference;
function ReadCT_FontReference(reader) {
    var instance = { TextCharacterProperties: {} };
    instance[CONST_IDX] = readSingleAttributeNode(reader, CONST_IDX);
    if (instance.idx) {
        instance.idx = chart_model_1.Charts.ST_FontCollectionIndex[instance.idx];
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var solidFill = instance.TextCharacterProperties.solidFill = {};
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_SCRGBCLR:
                solidFill.scrgbClr = ReadCT_ScRgbColor(reader);
                break;
            case CONST_SRGBCLR:
                solidFill.srgbClr = ReadCT_SRgbColor(reader);
                break;
            case CONST_HSLCLR:
                solidFill.hslClr = ReadCT_HslColor(reader);
                break;
            case CONST_SYSCLR:
                solidFill.sysClr = ReadCT_SystemColor(reader);
                break;
            case CONST_SCHEMECLR:
                solidFill.schemeClr = ReadCT_SchemeColor(reader);
                break;
            case CONST_PRSTCLR:
                solidFill.prstClr = ReadCT_PresetColor(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_FontReference = ReadCT_FontReference;
function ReadCT_ShapeStyle(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "lnRef" || elementName === "fillRef" || elementName === "effectRef") {
            instance[elementName] = ReadCT_StyleMatrixReference(reader);
        }
        else if (elementName === "fontRef") {
            instance.fontRef = ReadCT_FontReference(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ShapeStyle = ReadCT_ShapeStyle;
function ReadCT_AnchorClientData(reader) {
    var instance = { fLocksWithSheet: true, fPrintsWithSheet: true };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "fLocksWithSheet" || attrName === "fPrintsWithSheet") {
            instance[attrName] = reader.readContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_AnchorClientData = ReadCT_AnchorClientData;
function ReadCT_ShapeNonVisual(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_CNVPR) {
            instance.cNvPr = ReadCT_NonVisualDrawingProps(reader);
        }
        else if (elementName === "cNvSpPr") {
            instance.cNvSpPr = ReadCT_NonVisualDrawingShapeProps(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ShapeNonVisual = ReadCT_ShapeNonVisual;
function ReadCT_Shape(reader) {
    var instance = { shapeType: 5 };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === CONST_MACRO || attrName === "textlink") {
            instance[attrName] = reader.readContentAsString();
        }
        else if (attrName === "fLocksText" || attrName === CONST_FPUBLISHED) {
            instance[attrName] = reader.readContentAsBoolean();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "nvSpPr":
                instance.nvSpPr = ReadCT_ShapeNonVisual(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_STYLE:
                instance.style = ReadCT_ShapeStyle(reader);
                break;
            case "txBody":
                instance.txBody = ReadCT_TextBody(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Shape = ReadCT_Shape;
function ReadCT_ConnectorNonVisual(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_CNVPR) {
            instance.cNvPr = ReadCT_NonVisualDrawingProps(reader);
        }
        else if (elementName === "cNvCxnSpPr") {
            instance.cNvCxnSpPr = ReadCT_NonVisualConnectorProperties(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ConnectorNonVisual = ReadCT_ConnectorNonVisual;
function ReadCT_Connector(reader) {
    var instance = { shapeType: 4 };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === CONST_MACRO) {
            instance.macro = reader.readContentAsString();
        }
        else if (attrName === CONST_FPUBLISHED) {
            instance.fPublished = reader.readContentAsBoolean();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "nvCxnSpPr":
                instance.nvCxnSpPr = ReadCT_ConnectorNonVisual(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_STYLE:
                instance.style = ReadCT_ShapeStyle(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Connector = ReadCT_Connector;
function ReadCT_PictureNonVisual(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_CNVPR) {
            instance.cNvPr = ReadCT_NonVisualDrawingProps(reader);
        }
        else if (elementName === "cNvPicPr") {
            instance.cNvPicPr = ReadCT_NonVisualPictureProperties(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_PictureNonVisual = ReadCT_PictureNonVisual;
function ReadCT_Picture(reader) {
    var instance = { shapeType: 1 };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === CONST_MACRO) {
            instance.macro = reader.readContentAsString();
        }
        else if (attrName === CONST_FPUBLISHED) {
            instance.fPublished = reader.readContentAsBoolean();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "nvPicPr":
                instance.nvPicPr = ReadCT_PictureNonVisual(reader);
                break;
            case CONST_BLIP_FILL:
                instance.blipFill = ReadCT_BlipFillProperties(reader);
                break;
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case CONST_STYLE:
                instance.style = ReadCT_ShapeStyle(reader);
                break;
        }
    }
    if (IsCameraTool(instance)) {
        instance.cameraTool = true;
    }
    return instance;
}
exports.DrawingReader.ReadCT_Picture = ReadCT_Picture;
function ReadCT_GraphicalObjectFrameNonVisual(reader) {
    return readGraphicFrameNonVisualSubElement(reader);
}
exports.DrawingReader.ReadCT_GraphicalObjectFrameNonVisual = ReadCT_GraphicalObjectFrameNonVisual;
function ReadCT_GraphicalObjectFrame(reader) {
    var instance = { shapeType: 2 };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === CONST_MACRO) {
            instance.macro = reader.readContentAsString();
        }
        else if (attrName === CONST_FPUBLISHED) {
            instance.fPublished = reader.readContentAsBoolean();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "nvGraphicFramePr":
                instance.nvGraphicFramePr = ReadCT_GraphicalObjectFrameNonVisual(reader);
                break;
            case "xfrm":
                instance.xfrm = ReadCT_Transform2D(reader);
                break;
            case "graphic":
                instance.graphic = ReadCT_GraphicalObject(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_GraphicalObjectFrame = ReadCT_GraphicalObjectFrame;
function ReadCT_GroupShapeNonVisual(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_CNVPR) {
            instance.cNvPr = ReadCT_NonVisualDrawingProps(reader);
        }
        else if (elementName === "cNvGrpSpPr") {
            instance.cNvGrpSpPr = ReadCT_NonVisualGroupDrawingShapeProps(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_GroupShapeNonVisual = ReadCT_GroupShapeNonVisual;
function ReadCT_GroupShape(reader) {
    var instance = {
        shapeType: 3,
        sp: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var notNeedRead = false;
    while (notNeedRead || reader.read()) {
        notNeedRead = false;
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "nvGrpSpPr":
                instance.nvGrpSpPr = ReadCT_GroupShapeNonVisual(reader);
                break;
            case "grpSpPr":
                instance.grpSpPr = ReadCT_GroupShapeProperties(reader);
                break;
            case "sp":
                instance.sp.push(ReadCT_Shape(reader));
                break;
            case CONST_GRPSP:
                instance.sp.push(ReadCT_GroupShape(reader));
                break;
            case CONST_GRAPHIC_FRAME:
                instance.sp.push(ReadCT_GraphicalObjectFrame(reader));
                break;
            case CONST_CXNSP:
                instance.sp.push(ReadCT_Connector(reader));
                break;
            case "pic":
                instance.sp.push(ReadCT_Picture(reader));
                break;
            case "AlternateContent":
                var content = ReadCT_AlternateContent(reader);
                if (IsSlicer(content)) {
                    instance.sp.push(content);
                }
                else if (content && content.Choice && content.Choice.pic && IsCameraTool(content.Choice.pic)) {
                    instance.sp.push(content.Choice.pic);
                }
                notNeedRead = true;
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_GroupShape = ReadCT_GroupShape;
function IsSlicer(content) {
    return !!(content && content.Choice && content.Choice.GraphicalObjectFrame &&
        content.Choice.GraphicalObjectFrame.graphic &&
        content.Choice.GraphicalObjectFrame.graphic.graphicData &&
        content.Choice.GraphicalObjectFrame.graphic.graphicData.slicer);
}
function IsCameraTool(pic) {
    return !!(pic &&
        pic.nvPicPr &&
        pic.nvPicPr.cNvPicPr &&
        pic.nvPicPr.cNvPicPr.extLst &&
        pic.nvPicPr.cNvPicPr.extLst.ext &&
        pic.nvPicPr.cNvPicPr.extLst.ext[0] &&
        pic.nvPicPr.cNvPicPr.extLst.ext[0].cameraTool);
}
exports.DrawingReader.IsCameraTool = IsCameraTool;
function ReadCT_Position(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var elementNameObj = {
        col: true,
        row: true
    };
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementNameObj[elementName]) {
            instance[elementName] = reader.readElementContentAsInt();
        }
        else if (elementName === "rowOff") {
            instance.rowOffset = emuToPixles(reader.readElementContentAsInt());
        }
        else if (elementName === "colOff") {
            instance.colOffset = emuToPixles(reader.readElementContentAsInt());
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Position = ReadCT_Position;
function ReadCT_TwoCellAnchor(reader) {
    var instance = { anchorType: 0 };
    var editAs = readSingleAttributeNode(reader, "editAs");
    if (!common_1._isNullOrUndefined(editAs)) {
        instance.editAs = chart_model_1.Charts.ST_EditAs[editAs];
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var notNeedRead = false;
    while (notNeedRead || reader.read()) {
        notNeedRead = false;
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "from":
                instance.startPoint = ReadCT_Position(reader);
                break;
            case "to":
                instance.endPoint = ReadCT_Position(reader);
                break;
            case "sp":
                instance.sp = ReadCT_Shape(reader);
                break;
            case CONST_GRPSP:
                instance.grpSp = ReadCT_GroupShape(reader);
                break;
            case CONST_GRAPHIC_FRAME:
                instance.graphicFrame = ReadCT_GraphicalObjectFrame(reader);
                break;
            case CONST_CXNSP:
                instance.cxnSp = ReadCT_Connector(reader);
                break;
            case "pic":
                instance.pic = ReadCT_Picture(reader);
                break;
            case "AlternateContent":
                instance.AlternateContent = ReadCT_AlternateContent(reader);
                notNeedRead = true;
                break;
            case "clientData":
                instance.clientData = ReadCT_AnchorClientData(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TwoCellAnchor = ReadCT_TwoCellAnchor;
function NormalizeSignificantWhitespaceToXml(stringWithSignificantWhitespace) {
    return stringWithSignificantWhitespace.replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
}
function ReadCT_AlternateContent(reader) {
    var instance = { shapeType: 0 };
    while (reader.moveToNextAttribute()) {
        instance.AlternateContent = NormalizeSignificantWhitespaceToXml(reader.readContentAsString());
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "Choice") {
            instance.Choice = ReadCT_Choice(reader);
        }
        else if (elementName === "Fallback") {
            instance.Fallback = {};
            instance.Fallback.Shape = ReadCT_Shape(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_AlternateContent = ReadCT_AlternateContent;
function ReadCT_Choice(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === CONST_REQUIRES) {
            var requires = reader.readContentAsString();
            if (requires !== 0 && requires !== 1) {
                instance.Requires = requires;
            }
            else {
                instance.Requires = getAttrValueOrDefaultOfBooleanType(requires);
            }
        }
        else {
            instance.cx = reader.readContentAsString();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_GRAPHIC_FRAME) {
            instance.GraphicalObjectFrame = ReadCT_GraphicalObjectFrame(reader);
        }
        else if (elementName === "sp") {
            instance.sp = ReadCT_Shape(reader);
        }
        else if (elementName === CONST_GRPSP) {
            instance.grpSp = ReadCT_GroupShape(reader);
        }
        else if (elementName === CONST_CXNSP) {
            instance.cxnSp = ReadCT_Connector(reader);
        }
        else if (elementName === 'twoCellAnchor') {
            instance.twoCellAnchor = ReadCT_TwoCellAnchor(reader);
        }
        else if (elementName === 'pic') {
            instance.pic = ReadCT_Picture(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Choice = ReadCT_Choice;
function ReadCT_OneCellAnchor(reader) {
    var instance = { anchorType: 1 };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var notNeedRead = false;
    while (notNeedRead || reader.read()) {
        notNeedRead = false;
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "from":
                instance.startPoint = ReadCT_Position(reader);
                break;
            case CONST_EXT:
                var extData = ReadCT_PositiveSize2D(reader, true);
                instance.width = extData.cx;
                instance.height = extData.cy;
                break;
            case "sp":
                instance.sp = ReadCT_Shape(reader);
                break;
            case CONST_GRPSP:
                instance.grpSp = ReadCT_GroupShape(reader);
                break;
            case CONST_GRAPHIC_FRAME:
                instance.graphicFrame = ReadCT_GraphicalObjectFrame(reader);
                break;
            case CONST_CXNSP:
                instance.cxnSp = ReadCT_Connector(reader);
                break;
            case "pic":
                instance.pic = ReadCT_Picture(reader);
                break;
            case "AlternateContent":
                instance.AlternateContent = ReadCT_AlternateContent(reader);
                notNeedRead = true;
                break;
            case "clientData":
                instance.clientData = ReadCT_AnchorClientData(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_OneCellAnchor = ReadCT_OneCellAnchor;
function ReadCT_AbsoluteAnchor(reader) {
    var instance = { anchorType: 2 };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var notNeedRead = false;
    while (notNeedRead || reader.read()) {
        notNeedRead = false;
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "pos":
                var posData = ReadCT_Point2D(reader, true);
                instance.x = posData.x;
                instance.y = posData.y;
                break;
            case CONST_EXT:
                var extData = ReadCT_PositiveSize2D(reader, true);
                instance.width = extData.cx;
                instance.height = extData.cy;
                break;
            case "sp":
                instance.sp = ReadCT_Shape(reader);
                break;
            case CONST_GRPSP:
                instance.grpSp = ReadCT_GroupShape(reader);
                break;
            case CONST_GRAPHIC_FRAME:
                instance.graphicFrame = ReadCT_GraphicalObjectFrame(reader);
                break;
            case CONST_CXNSP:
                instance.cxnSp = ReadCT_Connector(reader);
                break;
            case "pic":
                instance.pic = ReadCT_Picture(reader);
                break;
            case "AlternateContent":
                instance.AlternateContent = ReadCT_AlternateContent(reader);
                notNeedRead = true;
                break;
            case "clientData":
                instance.clientData = ReadCT_AnchorClientData(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_AbsoluteAnchor = ReadCT_AbsoluteAnchor;
function ReadCT_Drawing(reader) {
    var instance = {
        twoCellAnchor: [],
        oneCellAnchor: [],
        absoluteAnchor: [],
        AnchorBaseList: []
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        var anchorBase = keyword_null;
        var alternateContent = keyword_null;
        switch (elementName) {
            case "twoCellAnchor":
                anchorBase = ReadCT_TwoCellAnchor(reader);
                break;
            case "oneCellAnchor":
                anchorBase = ReadCT_OneCellAnchor(reader);
                break;
            case "absoluteAnchor":
                anchorBase = ReadCT_AbsoluteAnchor(reader);
                break;
            case "AlternateContent":
                alternateContent = ReadCT_AlternateContent(reader);
        }
        if (anchorBase && (anchorBase.sp || IsSupportShape(anchorBase))) {
            var Is2016Chart = common_1.Util._is2016Chart(anchorBase.AlternateContent);
            instance.AnchorBaseList.push(anchorBase);
            if (anchorBase.AlternateContent && !Is2016Chart) {
                delete anchorBase.AlternateContent;
            }
        }
        if (anchorBase && anchorBase.AlternateContent && anchorBase.AlternateContent.Choice && (anchorBase.AlternateContent.Choice.sp || anchorBase.AlternateContent.Choice.grpSp || anchorBase.AlternateContent.Choice.cxnSp)) {
            if (anchorBase.AlternateContent.Choice.sp) {
                anchorBase.sp = anchorBase.AlternateContent.Choice.sp;
            }
            if (anchorBase.AlternateContent.Choice.grpSp) {
                anchorBase.grpSp = anchorBase.AlternateContent.Choice.grpSp;
            }
            if (anchorBase.AlternateContent.Choice.cxnSp) {
                anchorBase.cxnSp = anchorBase.AlternateContent.Choice.cxnSp;
            }
            instance.AnchorBaseList.push(anchorBase);
        }
        if (alternateContent && alternateContent.Choice && alternateContent.Choice.twoCellAnchor) {
            instance.AnchorBaseList.push(alternateContent.Choice.twoCellAnchor);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_Drawing = ReadCT_Drawing;
function IsSupportShape(anchorBase) {
    var alternateContent = anchorBase.AlternateContent;
    var Is2016Chart = common_1.Util._is2016Chart(alternateContent);
    if (alternateContent && !IsSlicer(alternateContent) && !Is2016Chart) {
        return false;
    }
    if (!Is2016Chart) {
        var graphicFrame = anchorBase.graphicFrame;
        var graphicData = graphicFrame && graphicFrame.graphic && graphicFrame.graphic.graphicData;
        if (graphicData && !graphicData.chart && !graphicData.slicer) {
            return false;
        }
    }
    return true;
}
function ReadCT_DefaultShapeDefinition(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_SPPR:
                instance.spPr = ReadCT_ShapeProperties(reader);
                break;
            case "bodyPr":
                instance.bodyPr = ReadCT_TextBodyProperties(reader);
                break;
            case "lstStyle":
                instance.lstStyle = ReadCT_TextListStyle(reader);
                break;
            case CONST_STYLE:
                instance.style = ReadCT_ShapeStyle(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_DefaultShapeDefinition = ReadCT_DefaultShapeDefinition;
function ReadCT_ObjectStyleDefaults(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "spDef" || elementName === "lnDef" || elementName === "txDef") {
            instance[elementName] = ReadCT_DefaultShapeDefinition(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_OfficeArtExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ObjectStyleDefaults = ReadCT_ObjectStyleDefaults;
function ReadCT_EmptyElement() {
    return {};
}
exports.DrawingReader.ReadCT_EmptyElement = ReadCT_EmptyElement;
function ReadCT_ColorMapping(reader) {
    var instance = {};
    var attrNameObj = {
        bg1: true,
        tx1: true,
        bg2: true,
        tx2: true,
        accent1: true,
        accent2: true,
        accent3: true,
        accent4: true,
        accent5: true,
        accent6: true,
        hlink: true,
        folHlink: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = chart_model_1.Charts.ST_ColorSchemeIndex[reader.readContentAsString()];
        }
    }
    return readSingleSubElementNode(reader, CONST_EXTLST, ReadCT_OfficeArtExtensionList, instance);
}
exports.DrawingReader.ReadCT_ColorMapping = ReadCT_ColorMapping;
function ReadCT_ColorMappingOverride(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "masterClrMapping") {
            instance.masterClrMapping = ReadCT_EmptyElement();
        }
        else if (elementName === "overrideClrMapping") {
            instance.overrideClrMapping = ReadCT_ColorMapping(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ColorMappingOverride = ReadCT_ColorMappingOverride;
function ReadCT_ColorSchemeAndMapping(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === CONST_CLR_SCHEME) {
            instance.clrScheme = ReadCT_ColorScheme(reader);
        }
        else if (elementName === "clrMap") {
            instance.clrMap = ReadCT_ColorMapping(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ColorSchemeAndMapping = ReadCT_ColorSchemeAndMapping;
function ReadCT_ColorSchemeList(reader) {
    var instance = { extraClrScheme: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "extraClrScheme") {
            instance.extraClrScheme.push(ReadCT_ColorSchemeAndMapping(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ColorSchemeList = ReadCT_ColorSchemeList;
function ReadCT_OfficeStyleSheet(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "theme":
                instance[CONST_NAME] = readSingleAttributeNode(reader, CONST_NAME);
                break;
            case "themeElements":
                instance.themeElements = ReadCT_BaseStyles(reader);
                break;
            case "objectDefaults":
                instance.objectDefaults = ReadCT_ObjectStyleDefaults(reader);
                break;
            case "extraClrSchemeLst":
                instance.extraClrSchemeLst = ReadCT_ColorSchemeList(reader);
                break;
            case "custClrLst":
                instance.custClrLst = ReadCT_CustomColorList(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_OfficeStyleSheet = ReadCT_OfficeStyleSheet;
function ReadCT_BaseStylesOverride(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case CONST_CLR_SCHEME:
                instance.clrScheme = ReadCT_ColorScheme(reader);
                break;
            case CONST_FONT_SCHEME:
                instance.fontScheme = ReadCT_FontScheme(reader);
                break;
            case CONST_FMT_SCHEME:
                instance.fmtScheme = ReadCT_StyleMatrix(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_BaseStylesOverride = ReadCT_BaseStylesOverride;
function ReadCT_ClipboardStyleSheet(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "themeElements") {
            instance.themeElements = ReadCT_BaseStyles(reader);
        }
        else if (elementName === "clrMap") {
            instance.clrMap = ReadCT_ColorMapping(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_ClipboardStyleSheet = ReadCT_ClipboardStyleSheet;
function ReadCT_TextParagraph(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var elements = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "pPr":
                instance.pPr = ReadCT_TextParagraphProperties(reader);
                break;
            case "r":
                elements.push(exports.DrawingReader.ReadCT_RegularTextRun(reader));
                break;
            case "br":
                elements.push(exports.DrawingReader.ReadCT_TextLineBreak(reader));
                break;
            case "fld":
                elements.push(exports.DrawingReader.ReadCT_TextField(reader));
                break;
            case "endParaRPr":
                instance.endParaRPr = ReadCT_TextCharacterProperties(reader);
                break;
        }
    }
    if (elements.length > 0) {
        instance.elements = elements;
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextParagraph = ReadCT_TextParagraph;
function ReadCT_TextListStyle(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var elementNameObj = {
        defPPr: true,
        lvl1pPr: true,
        lvl2pPr: true,
        lvl3pPr: true,
        lvl4pPr: true,
        lvl5pPr: true,
        lvl6pPr: true,
        lvl7pPr: true,
        lvl8pPr: true,
        lvl9pPr: true
    };
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementNameObj[elementName]) {
            instance[elementName] = ReadCT_TextParagraphProperties(reader);
        }
        else if (elementName === CONST_EXTLST) {
            instance.extLst = ReadCT_OfficeArtExtensionList(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextListStyle = ReadCT_TextListStyle;
function ReadCT_TextNormalAutofit(reader) {
    var instance = {
        fontScale: 100000,
        lnSpcReduction: 0
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "fontScale" || attrName === "lnSpcReduction") {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextNormalAutofit = ReadCT_TextNormalAutofit;
function ReadCT_TextShapeAutofit() {
    return true;
}
exports.DrawingReader.ReadCT_TextShapeAutofit = ReadCT_TextShapeAutofit;
function ReadCT_TextNoAutofit() {
    return {};
}
exports.DrawingReader.ReadCT_TextNoAutofit = ReadCT_TextNoAutofit;
function getRotationDegree(rotation) {
    return rotation / 60000;
}
exports.DrawingReader.getRotationDegree = getRotationDegree;
function ReadCT_TextBodyProperties(reader) {
    var instance = {};
    var intAttrNameObj = {
        lIns: true,
        tIns: true,
        rIns: true,
        bIns: true,
        numCol: true,
        spcCol: true
    };
    var booleanAttrNameObj = {
        spcFirstLastPara: true,
        rtlCol: true,
        fromWordArt: true,
        anchorCtr: true,
        forceAA: true,
        upright: true,
        compatLnSpc: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (intAttrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsInt();
        }
        else if (booleanAttrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsBoolean();
        }
        else if (attrName === "rot") {
            var rotValue = reader.readContentAsInt();
            if (!common_1._isNullOrUndefined(rotValue) && rotValue !== -60000000) {
                instance.rot = getRotationDegree(rotValue);
            }
        }
        else if (attrName === "vertOverflow") {
            instance.vertOverflow = chart_model_1.Charts.ST_TextVertOverflowType[reader.readContentAsString()];
        }
        else if (attrName === "horzOverflow") {
            instance.horzOverflow = chart_model_1.Charts.ST_TextHorzOverflowType[reader.readContentAsString()];
        }
        else if (attrName === "vert") {
            instance.vert = chart_model_1.Charts.ST_TextVerticalType[reader.readContentAsString()];
        }
        else if (attrName === "wrap") {
            instance.wrap = chart_model_1.Charts.ST_TextWrappingType[reader.readContentAsString()];
        }
        else if (attrName === "anchor") {
            instance.anchor = chart_model_1.Charts.ST_TextAnchoringType[reader.readContentAsString()];
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "prstTxWarp":
                instance.prstTxWarp = ReadCT_PresetTextShape(reader);
                break;
            case "noAutofit":
                instance.noAutofit = ReadCT_TextNoAutofit();
                break;
            case "normAutofit":
                instance.normAutofit = ReadCT_TextNormalAutofit(reader);
                break;
            case "spAutoFit":
                instance.spAutoFit = ReadCT_TextShapeAutofit();
                break;
            case CONST_SCENE_3D:
                instance.scene3d = ReadCT_Scene3D(reader);
                break;
            case "sp3d":
                instance.sp3d = ReadCT_Shape3D(reader);
                break;
            case "flatTx":
                instance.flatTx = ReadCT_FlatText(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextBodyProperties = ReadCT_TextBodyProperties;
function ReadCT_TextBody(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    var p = [];
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "bodyPr":
                instance.bodyPr = ReadCT_TextBodyProperties(reader);
                break;
            case "lstStyle":
                instance.lstStyle = ReadCT_TextListStyle(reader);
                break;
            case "p":
                p.push(ReadCT_TextParagraph(reader));
                break;
        }
    }
    if (p.length > 0) {
        instance.p = p;
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextBody = ReadCT_TextBody;
function ReadCT_TextBulletColorFollowText() {
    return {};
}
exports.DrawingReader.ReadCT_TextBulletColorFollowText = ReadCT_TextBulletColorFollowText;
function ReadCT_TextBulletSizeFollowText() {
    return {};
}
exports.DrawingReader.ReadCT_TextBulletSizeFollowText = ReadCT_TextBulletSizeFollowText;
function ReadCT_TextBulletSizePercent(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_TextBulletSizePercent = ReadCT_TextBulletSizePercent;
function ReadCT_TextBulletSizePoint(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_TextBulletSizePoint = ReadCT_TextBulletSizePoint;
function ReadCT_TextBulletTypefaceFollowText() {
    return {};
}
exports.DrawingReader.ReadCT_TextBulletTypefaceFollowText = ReadCT_TextBulletTypefaceFollowText;
function ReadCT_TextAutonumberBullet(reader) {
    var instance = {
        startAt: 1
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === CONST_TYPE) {
            instance.type = chart_model_1.Charts.ST_TextAutonumberScheme[reader.readContentAsString()];
        }
        else if (attrName === "startAt") {
            instance.startAt = reader.readContentAsInt();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextAutonumberBullet = ReadCT_TextAutonumberBullet;
function ReadCT_TextCharBullet(reader) {
    var instance = {};
    instance.char = readSingleAttributeNode(reader, "char");
    return instance;
}
exports.DrawingReader.ReadCT_TextCharBullet = ReadCT_TextCharBullet;
function ReadCT_TextBlipBullet(reader) {
    return readSingleSubElementNode(reader, "blip", ReadCT_Blip);
}
exports.DrawingReader.ReadCT_TextBlipBullet = ReadCT_TextBlipBullet;
function ReadCT_TextNoBullet() {
    return {};
}
exports.DrawingReader.ReadCT_TextNoBullet = ReadCT_TextNoBullet;
function ReadCT_TextFont(reader) {
    var instance = {
        pitchFamily: 0,
        charset: 1
    };
    var attrNameObj = {
        typeface: true,
        panose: true,
        pitchFamily: true,
        charset: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsString();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextFont = ReadCT_TextFont;
function ReadCT_TextUnderlineLineFollowText() {
    return {};
}
exports.DrawingReader.ReadCT_TextUnderlineLineFollowText = ReadCT_TextUnderlineLineFollowText;
function ReadCT_TextUnderlineFillFollowText() {
    return {};
}
exports.DrawingReader.ReadCT_TextUnderlineFillFollowText = ReadCT_TextUnderlineFillFollowText;
function ReadCT_TextUnderlineFillGroupWrapper(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    return readFillProperties(reader, instance);
}
exports.DrawingReader.ReadCT_TextUnderlineFillGroupWrapper = ReadCT_TextUnderlineFillGroupWrapper;
function ReadCT_TextCharacterProperties(reader) {
    var instance = {};
    var intAttrNameObj = {
        kern: true,
        spc: true,
        baseline: true,
        smtId: true
    };
    var booleanAttrNameObj = {
        kumimoji: true,
        normalizeH: true,
        noProof: true,
        dirty: true,
        err: true,
        smtClean: true
    };
    var stringAttrNameObj = {
        altLang: true,
        bmk: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (intAttrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsInt();
        }
        else if (booleanAttrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsBoolean();
        }
        else if (stringAttrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsString();
        }
        else if (attrName === "sz") {
            instance.sz = excel_style_1.UnitHelper.pointToPixel(reader.readContentAsInt() / 100);
        }
        else if (attrName === "b") {
            instance.b = reader.readContentAsBoolean();
        }
        else if (attrName === "i") {
            instance.i = reader.readContentAsBoolean();
        }
        else if (attrName === "u") {
            instance.u = chart_model_1.Charts.ST_TextUnderlineType[reader.readContentAsString()];
        }
        else if (attrName === "strike") {
            instance.strike = chart_model_1.Charts.ST_TextStrikeType[reader.readContentAsString()];
        }
        else if (attrName === "cap") {
            instance.cap = chart_model_1.Charts.ST_TextCapsType[reader.readContentAsString()];
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "ln":
                instance.ln = ReadCT_LineProperties(reader);
                break;
            case CONST_NO_FILL:
                instance.noFill = ReadCT_NoFillProperties();
                break;
            case CONST_SOLID_FILL:
                instance.solidFill = ReadCT_SolidColorFillProperties(reader);
                break;
            case CONST_GRAD_FILL:
                instance.gradFill = ReadCT_GradientFillProperties(reader);
                break;
            case CONST_BLIP_FILL:
                instance.blipFill = ReadCT_BlipFillProperties(reader);
                break;
            case CONST_PATT_FILL:
                instance.pattFill = ReadCT_PatternFillProperties(reader);
                break;
            case CONST_GRP_FILL:
                instance.grpFill = ReadCT_GroupFillProperties();
                break;
            case CONST_EFFECTLST:
                instance.effectLst = ReadCT_EffectList(reader);
                break;
            case CONST_EFFECT_DAG:
                instance.effectDag = ReadCT_EffectContainer(reader);
                break;
            case "highlight":
                instance.highlight = ReadCT_Color(reader);
                break;
            case "uLnTx":
                instance.uLnTx = ReadCT_TextUnderlineLineFollowText();
                break;
            case "uLn":
                instance.uLn = ReadCT_LineProperties(reader);
                break;
            case "uFillTx":
                instance.uFillTx = ReadCT_TextUnderlineFillFollowText();
                break;
            case "uFill":
                instance.uFill = ReadCT_TextUnderlineFillGroupWrapper(reader);
                break;
            case "latin":
                instance.latin = ReadCT_TextFont(reader);
                break;
            case "ea":
                instance.ea = ReadCT_TextFont(reader);
                break;
            case "cs":
                instance.cs = ReadCT_TextFont(reader);
                break;
            case "sym":
                instance.sym = ReadCT_TextFont(reader);
                break;
            case "hlinkClick":
                instance.hlinkClick = ReadCT_Hyperlink(reader);
                break;
            case "hlinkMouseOver":
                instance.hlinkMouseOver = ReadCT_Hyperlink(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextCharacterProperties = ReadCT_TextCharacterProperties;
function ReadCT_TextSpacingPercent(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_TextSpacingPercent = ReadCT_TextSpacingPercent;
function ReadCT_TextSpacingPoint(reader) {
    return readSingleAttributeNode(reader, CONST_VAL, getAttributeValueOrDefaultOfIntType);
}
exports.DrawingReader.ReadCT_TextSpacingPoint = ReadCT_TextSpacingPoint;
function ReadCT_TextTabStop(reader) {
    var instance = {};
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "pos") {
            instance.pos = reader.readContentAsInt();
        }
        else if (attrName === "algn") {
            instance.algn = chart_model_1.Charts.ST_TextTabAlignType[reader.readContentAsString()];
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextTabStop = ReadCT_TextTabStop;
function ReadCT_TextTabStopList(reader) {
    var instance = { tab: [] };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "tab") {
            instance.tab.push(ReadCT_TextTabStop(reader));
        }
        else if (elementName === CONST_DUMY) {
            instance.dumy = reader.readElementContentAsBoolean();
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextTabStopList = ReadCT_TextTabStopList;
function ReadCT_TextLineBreak(reader) {
    var instance = {
        elementType: 1
    };
    return readSingleSubElementNode(reader, "rPr", ReadCT_TextCharacterProperties, instance);
}
exports.DrawingReader.ReadCT_TextLineBreak = ReadCT_TextLineBreak;
function ReadCT_TextSpacing(reader) {
    var instance = {};
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "spcPct") {
            instance.spcPct = ReadCT_TextSpacingPercent(reader);
        }
        else if (elementName === "spcPts") {
            instance.spcPts = ReadCT_TextSpacingPoint(reader);
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextSpacing = ReadCT_TextSpacing;
function ReadCT_TextParagraphProperties(reader) {
    var instance = {};
    var intAttrNameObj = {
        marL: true,
        marR: true,
        lvl: true,
        indent: true,
        defTabSz: true
    };
    var booleanAttrNameObj = {
        rtl: true,
        eaLnBrk: true,
        latinLnBrk: true,
        hangingPunct: true
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (intAttrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsInt();
        }
        else if (booleanAttrNameObj[attrName]) {
            instance[attrName] = reader.readContentAsBoolean();
        }
        else if (attrName === "fontAlgn") {
            instance.fontAlgn = chart_model_1.Charts.ST_TextFontAlignType[reader.readContentAsString()];
        }
        else if (attrName === "algn") {
            instance.algn = chart_model_1.Charts.ST_TextAlignType[reader.readContentAsString()];
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "lnSpc":
                instance.lnSpc = ReadCT_TextSpacing(reader);
                break;
            case "spcBef":
                instance.spcBef = ReadCT_TextSpacing(reader);
                break;
            case "spcAft":
                instance.spcAft = ReadCT_TextSpacing(reader);
                break;
            case "buClrTx":
                instance.buClrTx = ReadCT_TextBulletColorFollowText();
                break;
            case "buClr":
                instance.buClr = ReadCT_Color(reader);
                break;
            case "buSzTx":
                instance.buSzTx = ReadCT_TextBulletSizeFollowText();
                break;
            case "buSzPct":
                instance.buSzPct = ReadCT_TextBulletSizePercent(reader);
                break;
            case "buSzPts":
                instance.buSzPts = ReadCT_TextBulletSizePoint(reader);
                break;
            case "buFontTx":
                instance.buFontTx = ReadCT_TextBulletTypefaceFollowText();
                break;
            case "buFont":
                instance.buFont = ReadCT_TextFont(reader);
                break;
            case "buNone":
                instance.buNone = ReadCT_TextNoBullet();
                break;
            case "buAutoNum":
                instance.buAutoNum = ReadCT_TextAutonumberBullet(reader);
                break;
            case "buChar":
                instance.buChar = ReadCT_TextCharBullet(reader);
                break;
            case "buBlip":
                instance.buBlip = ReadCT_TextBlipBullet(reader);
                break;
            case "tabLst":
                instance.tabLst = ReadCT_TextTabStopList(reader);
                break;
            case "defRPr":
                instance.defRPr = ReadCT_TextCharacterProperties(reader);
                break;
            case CONST_EXTLST:
                instance.extLst = ReadCT_OfficeArtExtensionList(reader);
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextParagraphProperties = ReadCT_TextParagraphProperties;
function ReadCT_TextField(reader) {
    var instance = {
        elementType: 2
    };
    while (reader.moveToNextAttribute()) {
        var attrName = getAttributeName(reader);
        if (attrName === "id" || attrName === CONST_TYPE) {
            instance[attrName] = reader.readContentAsInt();
        }
    }
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        switch (elementName) {
            case "rPr":
                instance.rPr = ReadCT_TextCharacterProperties(reader);
                break;
            case "pPr":
                instance.pPr = ReadCT_TextParagraphProperties(reader);
                break;
            case "t":
                instance.t = reader.readElementContentAsString();
                break;
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_TextField = ReadCT_TextField;
function ReadCT_RegularTextRun(reader) {
    var instance = {
        elementType: 0
    };
    if (reader.elementType === 3) {
        return instance;
    }
    var startDepth = reader.depth;
    while (reader.read()) {
        var currentDepth = reader.depth, elementType = reader.elementType;
        if (currentDepth === startDepth && elementType === 2) {
            break;
        }
        if (currentDepth > startDepth + 1 || elementType === 2) {
            continue;
        }
        var elementName = getElementName(reader);
        if (elementName === "rPr") {
            instance.rPr = ReadCT_TextCharacterProperties(reader);
        }
        else if (elementName === "t") {
            instance.t = xmlDecode(reader.readElementContentAsString());
        }
    }
    return instance;
}
exports.DrawingReader.ReadCT_RegularTextRun = ReadCT_RegularTextRun;


/***/ }),

/***/ "./src/xlsx-io/reader/comment-reader.ts":
/*!**********************************************!*\
  !*** ./src/xlsx-io/reader/comment-reader.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var node_helper_1 = __webpack_require__(/*! ./../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var color_reader_1 = __webpack_require__(/*! ./../common/color-reader */ "./src/xlsx-io/common/color-reader.ts");
var getAsArray = node_helper_1.XmlNodeHelper._getAsArray;
var getValueFromObject = node_helper_1.XmlNodeHelper._getValueFromObject;
var xmlDecode = common_1.Util._xmlDecode;
function readComments(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData) {
    if (relationFiles) {
        var commentFile = void 0, commentShapeFile = void 0;
        for (var key in relationFiles) {
            if (key !== 'count') {
                var relationFile = relationFiles[key];
                if (relationFile) {
                    var fileType = relationFile.fileType;
                    if (fileType === excel_types_1.RelationshipConstants._relationshipCommentType) {
                        commentFile = relationFile;
                    }
                    else if (fileType === excel_types_1.RelationshipConstants._relationshipVMLDrawingType) {
                        commentShapeFile = relationFile;
                    }
                    if (commentFile && commentShapeFile) {
                        break;
                    }
                }
            }
        }
        if (commentFile && commentShapeFile) {
            var comments = readCommentsFromFile(commentFile, commentShapeFile, getFileDataAndCleanData);
            readerDataModel._setComments(comments, sheetName);
        }
    }
}
exports.readComments = readComments;
function readCommentsFromFile(commentFile, commentShapeFile, getFileDataAndCleanData) {
    var comments = [];
    var dataString = getFileDataAndCleanData(commentFile.fileName);
    if (dataString) {
        readComment(dataString, comments, xml_parser_1.parseXmlToObject);
        dataString = getFileDataAndCleanData(commentShapeFile.fileName);
        readCommentShape(dataString, comments, xml_parser_1.parseXmlToObject);
    }
    return comments;
}
exports.readCommentsFromFile = readCommentsFromFile;
function getComment(comments, row, col) {
    function isMatch(comment) {
        return comment.row === row && comment.col === col;
    }
    return comments.filter(isMatch)[0];
}
function readCommentShape(dataString, comments, parseXmlFn) {
    var obj = parseXmlFn(dataString, true), root = obj.xml, shapes = getAsArray(root['v:shape']);
    if (shapes) {
        shapes.forEach(function (shape) {
            var clientdata = shape['x:ClientData'], row, col, comment, value;
            if (clientdata) {
                row = parseInt(getValueFromObject(clientdata, 'x:Row'), 10);
                col = parseInt(getValueFromObject(clientdata, 'x:Column'), 10);
                if (isNaN(row) || isNaN(col)) {
                    return;
                }
                comment = getComment(comments, row, col);
                if (!comment) {
                    return;
                }
                var shapeAttr = shape._attr;
                value = shapeAttr.fillcolor;
                if (value) {
                    comment.backColor = value;
                }
                value = shapeAttr.strokecolor;
                if (value) {
                    comment.borderColor = value;
                }
                value = shapeAttr.strokeweight;
                if (value) {
                    comment.borderWidth = value;
                }
                value = shapeAttr.style;
                if (value) {
                    readCommentStyle(comment, value);
                }
                value = shape['v:fill'];
                if (value) {
                    var opacity = value._attr.opacity;
                    if (opacity) {
                        if (opacity.substr(-1) === 'f') {
                            comment.opacity = parseFloat(opacity.substr(0, opacity.length - 1)) / 65535;
                        }
                        else {
                            comment.opacity = parseFloat(opacity);
                        }
                    }
                }
                value = shape['v:stroke'];
                if (value) {
                    comment.dashStyle = value._attr.dashstyle;
                    comment.lineStyle = value._attr.linestyle;
                }
                value = shape['v:textbox'];
                if (value) {
                    var textboxStyle = value._attr.style;
                    if (textboxStyle && textboxStyle.indexOf('mso-fit-shape-to-text:t') !== -1) {
                        comment.autoSize = true;
                    }
                    comment.inset = value._attr.inset;
                }
                if (clientdata['x:SizeWithCells']) {
                    comment.dynamicSize = false;
                }
                if (clientdata['x:MoveWithCells']) {
                    comment.dynamicMove = false;
                }
                value = getValueFromObject(clientdata, 'x:Anchor');
                if (value) {
                    var anchorItems = value.split(',').map((function (s) {
                        return parseInt(s, 10);
                    }));
                    comment.anchor = anchorItems;
                }
                value = getValueFromObject(clientdata, 'x:Locked');
                if (value) {
                    comment.locked = convertToBoolean(value, true);
                }
                value = getValueFromObject(clientdata, 'x:LockText');
                if (value) {
                    comment.lockText = convertToBoolean(value, true);
                }
                value = getValueFromObject(clientdata, 'x:TextHAlign');
                if (value) {
                    comment.hAlign = value.toLowerCase();
                }
                if (clientdata['x:Visible']) {
                    comment.displayMode = 1;
                }
            }
        });
    }
    function convertToBoolean(str, defaultValue) {
        if (str) {
            var value = str.trim().toLowerCase();
            if (['false'].indexOf(value) !== -1) {
                return false;
            }
            else if (['true'].indexOf(value) !== -1) {
                return true;
            }
        }
        return defaultValue;
    }
    function getKeyValuePair(value, separator) {
        var pair = (value || '').trim().split(separator);
        return { key: pair[0], value: pair[1] };
    }
    function readCommentStyle(comment, styleString) {
        var styles = styleString.split(';');
        styles.forEach(function (style) {
            var pair = getKeyValuePair(style, ':'), key = pair.key, value = pair.value;
            if (!common_1._isNullOrUndefined(value)) {
                switch (key) {
                    case 'margin-left':
                        comment.marginLeft = convertUnitToPT(value);
                        break;
                    case 'margin-top':
                        comment.marginTop = convertUnitToPT(value);
                        break;
                    case 'width':
                        comment.width = value;
                        break;
                    case 'height':
                        comment.height = value;
                        break;
                    case 'z-index':
                        comment.zIndex = parseInt(value, 10);
                        break;
                }
            }
        });
    }
}
function convertUnitToPT(value) {
    var dpi = 96, pointPerInch = 72, cm = 37.7952755905512;
    try {
        if (value.indexOf("pt") !== -1) {
            return parseFloat(value.replace("pt", ""));
        }
        else if (value.indexOf("in") !== -1) {
            return parseFloat(value.replace("in", "")) * pointPerInch;
        }
        else if (value.indexOf("cm") !== -1) {
            return parseFloat(value.replace("cm", "")) * cm * pointPerInch / dpi;
        }
        return parseFloat(value);
    }
    catch (e) {
        return 0;
    }
}
function readComment(dataString, comments, parseXmlFn) {
    var obj = parseXmlFn(dataString), list = obj.comments && obj.comments.commentList;
    if (list) {
        var items = getAsArray(list.comment);
        items.forEach(function (item) {
            var comment = {}, ref = item._attr.ref;
            comment.row = common_1.IndexHelper._getRowIndexInNumber(ref);
            comment.col = common_1.IndexHelper._getColumnIndexInNumber(ref);
            readCommentText(comment, item.text);
            comments.push(comment);
        });
    }
}
function readCommentText(comment, text) {
    if (text) {
        var items = void 0;
        if (text.r) {
            items = getAsArray(text.r);
        }
        else {
            items = getAsArray([{ t: text.t }]);
        }
        var needReadFont_1 = items.length === 1;
        var segments_1 = [];
        items.forEach(function (item) {
            var rPr = item.rPr, value;
            if (rPr && needReadFont_1) {
                value = rPr.rFont && rPr.rFont._attr.val;
                if (value) {
                    comment.fontFamily = value;
                }
                var textDecoration = 0;
                if (rPr.u) {
                    var underLineValue = rPr.u && rPr.u._attr.val, underLineStyle = 1;
                    if (underLineValue) {
                        underLineStyle = excel_style_1.UnderLineStyle[underLineValue];
                    }
                    if (underLineStyle === 2) {
                        textDecoration |= 8;
                    }
                    else {
                        textDecoration |= 1;
                    }
                }
                if (rPr.strike) {
                    textDecoration |= 2;
                }
                if (textDecoration) {
                    comment.textDecoration = textDecoration;
                }
                if (rPr.b) {
                    comment.fontWeight = 'bold';
                }
                if (rPr.i) {
                    comment.fontStyle = 'italic';
                }
                value = rPr.color;
                if (value) {
                    var foreColor = color_reader_1.readColor(value);
                    if (!(foreColor.colorType() === 1 && foreColor.value() === 81)) {
                        comment.foreColor = foreColor;
                    }
                }
                value = rPr.sz && rPr.sz._attr.val;
                if (value) {
                    comment.fontSize = value + 'pt';
                }
            }
            segments_1.push(getValueFromObject(item, 't'));
        });
        comment.text = xmlDecode(segments_1.join(''));
    }
}


/***/ }),

/***/ "./src/xlsx-io/reader/conditionalformat-reader.ts":
/*!********************************************************!*\
  !*** ./src/xlsx-io/reader/conditionalformat-reader.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var range_parser_1 = __webpack_require__(/*! ./../../common/range-parser */ "./src/common/range-parser.ts");
var color_reader_1 = __webpack_require__(/*! ./../common/color-reader */ "./src/xlsx-io/common/color-reader.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var node_helper_1 = __webpack_require__(/*! ./../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var style_reader_1 = __webpack_require__(/*! ./style-reader */ "./src/xlsx-io/reader/style-reader.ts");
var xml_reader_1 = __webpack_require__(/*! ./../../xml-io/xml-reader */ "./src/xml-io/xml-reader.ts");
var getAsArray = node_helper_1.XmlNodeHelper._getAsArray;
var getValueFromObject = node_helper_1.XmlNodeHelper._getValueFromObject;
var convertDxfToStyle = excel_style_1.ConverterHelper.convertDxfToStyle;
function getNodeValue(obj, key, subkey) {
    return common_1.Util._xmlDecode(getValueFromObject(obj, key, subkey));
}
function validFormulas(formulaArr) {
    return formulaArr.filter(function (value) {
        return value && value.formula;
    });
}
function readConditionalFormatting(reader, sheetName, readerDataModel) {
    if (reader.elementType === 3) {
        return;
    }
    var oneConditionalFormat = xml_parser_1.parseXmlToObject(reader.readFullElement()).conditionalFormatting;
    var conditionalFormat = { rules: [] };
    var ranges = [];
    if (oneConditionalFormat._attr.sqref) {
        ranges = range_parser_1.getRangesFromString(oneConditionalFormat._attr.sqref);
    }
    var cfRule = oneConditionalFormat.cfRule;
    if (cfRule && cfRule.formula && Array.isArray(cfRule.formula)) {
        oneConditionalFormat.cfRule.formula = validFormulas(cfRule.formula);
    }
    if (ranges.length === 0) {
        return;
    }
    var isPivot = false;
    if (oneConditionalFormat._attr.pivot) {
        isPivot = true;
    }
    var excelRules = getAsArray(oneConditionalFormat.cfRule);
    for (var j = 0; j < excelRules.length; j++) {
        var rule = readRule(excelRules[j], ranges, isPivot);
        if (rule) {
            conditionalFormat.rules.push(rule);
        }
    }
    readerDataModel._addConditionalFormatting(sheetName, conditionalFormat);
}
exports.readConditionalFormatting = readConditionalFormatting;
var NormalRuleTypes = {
    beginsWith: 2,
    endsWith: 2,
    notContainsText: 2,
    containsText: 2,
    expression: 3,
    containsBlanks: 3,
    notContainsBlanks: 3,
    containsErrors: 3,
    notContainsErrors: 3,
    timePeriod: 4,
    today: 4,
    tomorrow: 4,
    yesterday: 4,
    last7Days: 4,
    lastMonth: 4,
    nextMonth: 4,
    thisWeek: 4,
    nextWeek: 4,
    lastWeek: 4,
    thisMonth: 4,
    top10: 5,
    uniqueValues: 6,
    duplicateValues: 7,
    aboveAverage: 8,
    belowAverage: 8,
    aboveOrEqualToAverage: 8,
    belowOrEqualToAverage: 8
};
var ScaleValueType = {
    num: 0,
    min: 1,
    max: 2,
    percent: 3,
    percentile: 4,
    stddev: 0,
    formula: 6,
    autoMin: 5,
    autoMax: 7
};
var IconSetTypes = {
    $3Arrows: 0,
    $3ArrowsGray: 1,
    $3Flags: 4,
    $3TrafficLights1: 5,
    $3TrafficLights2: 6,
    $3Signs: 7,
    $3Symbols: 8,
    $3Symbols2: 9,
    $4Arrows: 10,
    $4ArrowsGray: 11,
    $4RedToBlack: 12,
    $4Rating: 13,
    $4TrafficLights: 14,
    $5Arrows: 15,
    $5ArrowsGray: 16,
    $5Rating: 17,
    $5Quarters: 18,
    $3Stars: 3,
    $3Triangles: 2,
    $5Boxes: 19,
    $NoIcons: 20
};
var IconValueTypes = {
    num: 1,
    percent: 4,
    formula: 7,
    percentile: 5
};
var ComparisonOperators = {
    equal: 0,
    notEqual: 1,
    greaterThan: 2,
    greaterThanOrEqual: 3,
    lessThan: 4,
    lessThanOrEqual: 5,
    between: 6,
    notBetween: 7
};
function addEqualSign(val) {
    if (val && val.charAt(0) !== '=') {
        return '=' + val;
    }
    return val;
}
function readRule(cfRule, ranges, isPivot) {
    var rule = { priority: 0, ranges: ranges, pivot: isPivot }, ruleType;
    var ruleAttributes = cfRule._attr;
    if (!common_1._isNullOrUndefined(ruleAttributes.type)) {
        ruleType = ruleAttributes.type;
    }
    if (!common_1._isNullOrUndefined(ruleAttributes.priority)) {
        rule.priority = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(ruleAttributes.priority, 0);
    }
    var ruleChildNodes;
    switch (ruleType) {
        case 'colorScale':
            ruleChildNodes = readRuleChilds(cfRule.colorScale);
            rule.minType = ScaleValueType[ruleChildNodes._cfvoArray[0].type];
            rule.minValue = addEqualSign(ruleChildNodes._cfvoArray[0].val);
            rule.minColor = ruleChildNodes._colorArray[0];
            if (ruleChildNodes._cfvoArray.length === 3) {
                rule.ruleType = 11;
                rule.midType = ScaleValueType[ruleChildNodes._cfvoArray[1].type];
                rule.midValue = addEqualSign(ruleChildNodes._cfvoArray[1].val);
                rule.midColor = ruleChildNodes._colorArray[1];
                rule.maxType = ScaleValueType[ruleChildNodes._cfvoArray[2].type];
                rule.maxValue = addEqualSign(ruleChildNodes._cfvoArray[2].val);
                rule.maxColor = ruleChildNodes._colorArray[2];
            }
            else {
                rule.ruleType = 10;
                rule.maxType = ScaleValueType[ruleChildNodes._cfvoArray[1].type];
                rule.maxValue = addEqualSign(ruleChildNodes._cfvoArray[1].val);
                rule.maxColor = ruleChildNodes._colorArray[1];
            }
            break;
        case 'dataBar':
            rule.ruleType = 12;
            var dataBar = cfRule.dataBar;
            if (!common_1._isNullOrUndefined(dataBar._attr.showValue)) {
                rule.showBarOnly = !node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(dataBar._attr.showValue, true);
            }
            ruleChildNodes = readRuleChilds(dataBar);
            rule.minType = ScaleValueType[ruleChildNodes._cfvoArray[0].type];
            rule.minValue = addEqualSign(ruleChildNodes._cfvoArray[0].val);
            rule.maxType = ScaleValueType[ruleChildNodes._cfvoArray[1].type];
            rule.maxValue = addEqualSign(ruleChildNodes._cfvoArray[1].val);
            rule.color = ruleChildNodes._colorArray[0];
            break;
        case 'iconSet':
            rule.ruleType = 13;
            rule.iconSetType = IconSetTypes.$3TrafficLights1;
            var iconSet = cfRule.iconSet;
            var iconSetAttributes = iconSet._attr;
            if (!common_1._isNullOrUndefined(iconSetAttributes.iconSet)) {
                rule.iconSetType = IconSetTypes['$' + iconSetAttributes.iconSet];
            }
            if (!common_1._isNullOrUndefined(iconSetAttributes.showValue)) {
                rule.showIconOnly = !node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(iconSetAttributes.showValue, true);
            }
            if (!common_1._isNullOrUndefined(iconSetAttributes.reverse)) {
                rule.reverseIconOrder = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(iconSetAttributes.reverse, false);
            }
            rule.iconCriteria = readCriteria(iconSet);
            break;
        case 'cellIs':
            rule.ruleType = 1;
            var cellIsAttributes = cfRule._attr;
            if (!common_1._isNullOrUndefined(cellIsAttributes.stopIfTrue)) {
                rule.stopIfTrue = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cellIsAttributes.stopIfTrue, false);
            }
            if (!common_1._isNullOrUndefined(cellIsAttributes.dxfId)) {
                rule.dxfId = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(cellIsAttributes.dxfId, -1);
            }
            if (!common_1._isNullOrUndefined(cellIsAttributes.operator)) {
                rule.operator = ComparisonOperators[cellIsAttributes.operator];
            }
            var formulas = getAsArray(cfRule.formula);
            rule.value1 = '=' + common_1.Util._xmlDecode(formulas[0].formula);
            if (formulas.length === 2) {
                rule.value2 = '=' + common_1.Util._xmlDecode(formulas[1].formula);
            }
            break;
        default:
            rule.ruleType = NormalRuleTypes[ruleType];
            if (!common_1._isNullOrUndefined(ruleAttributes.dxfId)) {
                rule.dxfId = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(ruleAttributes.dxfId, -1);
            }
            if (!common_1._isNullOrUndefined(ruleAttributes.aboveAverage)) {
                rule.aboveAverage = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(ruleAttributes.aboveAverage, true);
                if (!rule.aboveAverage && ruleType === 'aboveAverage') {
                    ruleType = 'belowAverage';
                }
            }
            if (!common_1._isNullOrUndefined(ruleAttributes.bottom)) {
                rule.bottom = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(ruleAttributes.bottom, false);
            }
            if (!common_1._isNullOrUndefined(ruleAttributes.equalAverage)) {
                var equalAverage = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(ruleAttributes.equalAverage, false);
                if (equalAverage) {
                    if (ruleType === 'aboveAverage') {
                        ruleType = 'aboveOrEqualToAverage';
                    }
                    if (ruleType === 'belowAverage') {
                        ruleType = 'belowOrEqualToAverage';
                    }
                }
            }
            if (!common_1._isNullOrUndefined(ruleAttributes.operator)) {
                rule.operator = ruleAttributes.operator;
            }
            if (!common_1._isNullOrUndefined(ruleAttributes.percent)) {
                rule.percent = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(ruleAttributes.percent, false);
            }
            if (!common_1._isNullOrUndefined(ruleAttributes.rank)) {
                rule.rank = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(ruleAttributes.rank, 0);
            }
            if (!common_1._isNullOrUndefined(ruleAttributes.stdDev)) {
                rule.stdDev = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(ruleAttributes.stdDev, 0);
            }
            if (!common_1._isNullOrUndefined(ruleAttributes.stopIfTrue)) {
                rule.stopIfTrue = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(ruleAttributes.stopIfTrue, false);
            }
            if (!common_1._isNullOrUndefined(ruleAttributes.text)) {
                rule.text = common_1.Util._xmlDecode(ruleAttributes.text);
            }
            if (!common_1._isNullOrUndefined(ruleAttributes.timePeriod)) {
                ruleType = ruleAttributes.timePeriod;
            }
            var cfRuleFormula = cfRule.formula;
            if (!common_1._isNullOrUndefined(cfRuleFormula)) {
                if (Array.isArray(cfRuleFormula)) {
                    cfRule.formula = cfRuleFormula[0];
                }
                rule.formula = getNodeValue(cfRule, 'formula');
            }
            rule = convertNormalRuleToSpreadJSRule(rule, ruleType);
            break;
    }
    if (cfRule.extLst && cfRule.extLst.ext && cfRule.extLst.ext['x14:id']) {
        rule.id = getNodeValue(cfRule.extLst.ext, 'x14:id');
    }
    return rule;
}
function convertNormalRuleToSpreadJSRule(rule, ruleType) {
    switch (ruleType) {
        case 'expression':
        case 'containsBlanks':
        case 'notContainsBlanks':
        case 'containsErrors':
        case 'notContainsErrors':
            return rule;
        case 'top10':
            var range = rule.ranges[0];
            var top10Rule = {
                ruleType: rule.ruleType,
                dxfId: rule.dxfId,
                rank: rule.rank,
                stopIfTrue: rule.stopIfTrue,
                priority: rule.priority,
                ranges: rule.ranges,
                pivot: rule.pivot
            };
            top10Rule.type = 0;
            if (rule.bottom) {
                top10Rule.type = 1;
            }
            if (rule.percent) {
                var rank = Math.floor((range.rowCount * range.colCount) * rule.rank / 100);
                if (rank === 0) {
                    rank = 1;
                }
                top10Rule.rank = rank;
            }
            return top10Rule;
        case 'uniqueValues':
        case 'duplicateValues':
            return rule;
        case 'containsText':
            rule.operator = 0;
            return rule;
        case 'aboveAverage':
        case 'belowAverage':
        case 'aboveOrEqualToAverage':
        case 'belowOrEqualToAverage':
            var averageType = 0, above = true;
            if (ruleType === 'belowAverage') {
                above = false;
                averageType = 1;
            }
            if (ruleType === 'belowOrEqualToAverage') {
                above = false;
                averageType = 3;
            }
            if (ruleType === 'aboveOrEqualToAverage') {
                averageType = 2;
            }
            if (!common_1._isNullOrUndefined(rule.stdDev)) {
                var stdDev = rule.stdDev;
                if (above) {
                    if (stdDev === 1) {
                        averageType = 4;
                    }
                    else if (stdDev === 2) {
                        averageType = 6;
                    }
                    else if (stdDev === 3) {
                        averageType = 8;
                    }
                }
                else if (stdDev === 1) {
                    averageType = 5;
                }
                else if (stdDev === 2) {
                    averageType = 7;
                }
                else if (stdDev === 3) {
                    averageType = 9;
                }
            }
            rule.type = averageType;
            return rule;
        case 'beginsWith':
            rule.operator = 2;
            return rule;
        case 'endsWith':
            rule.operator = 3;
            return rule;
        case 'notContainsText':
            rule.operator = 1;
            return rule;
        case 'timePeriod':
        case 'today':
        case 'tomorrow':
        case 'yesterday':
        case 'last7Days':
        case 'lastMonth':
        case 'nextMonth':
        case 'thisWeek':
        case 'nextWeek':
        case 'lastWeek':
        case 'thisMonth':
            var DateOccurringType = {
                today: 0,
                yesterday: 1,
                tomorrow: 2,
                last7Days: 3,
                thisMonth: 4,
                lastMonth: 5,
                nextMonth: 6,
                thisWeek: 7,
                lastWeek: 8,
                nextWeek: 9
            };
            rule.type = 0;
            if (DateOccurringType[ruleType]) {
                rule.type = DateOccurringType[ruleType];
            }
            return rule;
        default:
            return rule;
    }
}
function readCriteria(node) {
    var iconCriteria = [];
    var ruleChildNodes = readRuleChilds(node);
    for (var i = 1; i < ruleChildNodes._cfvoArray.length; i++) {
        var criteria = { isGreaterThanOrEqualTo: true };
        if (ruleChildNodes._cfvoArray[i].gte === false) {
            criteria.isGreaterThanOrEqualTo = ruleChildNodes._cfvoArray[i].gte;
        }
        criteria.iconValueType = IconValueTypes[ruleChildNodes._cfvoArray[i].type];
        criteria.iconValue = addEqualSign(ruleChildNodes._cfvoArray[i].val);
        iconCriteria.push(criteria);
    }
    return iconCriteria;
}
function readIcons(node) {
    var iconInfos = [];
    var ruleChildNodes = readRuleChilds(node);
    for (var i = 0; i < ruleChildNodes._cfIconArray.length; i++) {
        var iconInfo = {};
        iconInfo.iconSetType = ruleChildNodes._cfIconArray[i].iconSetType;
        iconInfo.iconIndex = ruleChildNodes._cfIconArray[i].iconIndex;
        iconInfos.push(iconInfo);
    }
    return iconInfos;
}
function readCfvo(cfvoNode) {
    var cfvo = {};
    if (!common_1._isNullOrUndefined(cfvoNode._attr.type)) {
        cfvo.type = cfvoNode._attr.type;
    }
    if (!common_1._isNullOrUndefined(cfvoNode._attr.val)) {
        cfvo.val = cfvoNode._attr.val;
    }
    if (!common_1._isNullOrUndefined(cfvoNode._attr.gte)) {
        cfvo.gte = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cfvoNode._attr.gte, true);
    }
    if (cfvoNode['xm:f']) {
        cfvo.val = getNodeValue(cfvoNode, 'xm:f');
    }
    return cfvo;
}
function readCfIcon(cfIconNode) {
    var cfIcon = {};
    if (!common_1._isNullOrUndefined(cfIconNode._attr.iconSet)) {
        cfIcon.iconSetType = IconSetTypes['$' + cfIconNode._attr.iconSet];
    }
    if (!common_1._isNullOrUndefined(cfIconNode._attr.iconId)) {
        cfIcon.iconIndex = parseInt(cfIconNode._attr.iconId, 10);
    }
    return cfIcon;
}
function readRuleChilds(ruleNode) {
    var ruleChildNodes = { _cfvoArray: [], _colorArray: [], _cfIconArray: [] };
    var cfvos = getAsArray(ruleNode.cfvo || ruleNode['x14:cfvo']);
    var cfIcons = getAsArray(ruleNode['x14:cfIcon']);
    for (var i = 0; i < cfvos.length; i++) {
        var cfvo = readCfvo(cfvos[i]);
        ruleChildNodes._cfvoArray.push(cfvo);
    }
    var cfIcon;
    for (var i = 0; i < cfIcons.length; i++) {
        cfIcon = readCfIcon(cfIcons[i]);
        ruleChildNodes._cfIconArray.push(cfIcon);
    }
    if (ruleNode.color) {
        var colors = getAsArray(ruleNode.color || ruleNode['x14:color']);
        for (var j = 0; j < colors.length; j++) {
            ruleChildNodes._colorArray.push(excel_style_1.ColorHelper.toRGBColor(color_reader_1.readColor(colors[j])));
        }
    }
    return ruleChildNodes;
}
function readExtensionConditionalFormating(reader, sheetName, readerDataModel) {
    var ext = xml_parser_1.parseXmlToObject(reader.readFullElement()).ext;
    var type, id;
    if (ext['x14:conditionalFormattings'] && ext['x14:conditionalFormattings']['x14:conditionalFormatting']) {
        var conditionalFormatings = getAsArray(ext['x14:conditionalFormattings']['x14:conditionalFormatting']);
        for (var i = 0; i < conditionalFormatings.length; i++) {
            var oneConditionalFormat = conditionalFormatings[i];
            var cfRules = getAsArray(oneConditionalFormat['x14:cfRule']);
            for (var j = 0; j < cfRules.length; j++) {
                var cfRule = cfRules[j];
                var cfRuleAttributes = cfRule._attr;
                if (!common_1._isNullOrUndefined(cfRuleAttributes.type)) {
                    type = cfRuleAttributes.type;
                }
                id = cfRuleAttributes.id;
                var rule = getRuleById(readerDataModel, sheetName, id);
                if (cfRuleAttributes.priority) {
                    rule.priority = +cfRuleAttributes.priority;
                }
                if (type === 'dataBar') {
                    rule.ruleType = 12;
                    readExtensionDataBarRule(cfRule['x14:dataBar'], rule);
                }
                else if (type === 'iconSet') {
                    rule.ruleType = 13;
                    readExtensionIconSetRule(cfRule['x14:iconSet'], rule);
                }
                else if (type === 'expression') {
                    rule.ruleType = 3;
                    readExtensionFormulaRule(cfRule, rule, readerDataModel);
                }
                else if (type === "cellIs") {
                    rule.ruleType = 1;
                    readCellValueRule(cfRule, rule, readerDataModel);
                }
                if (oneConditionalFormat['xm:sqref']) {
                    var ranges = range_parser_1.getRangesFromString(getNodeValue(oneConditionalFormat, 'xm:sqref'));
                    if (rule) {
                        rule.ranges = ranges;
                    }
                }
            }
        }
    }
}
exports.readExtensionConditionalFormating = readExtensionConditionalFormating;
function getRuleById(readerDataModel, sheetName, id) {
    var conditionalFormatting = readerDataModel._getConditionalFormatting(sheetName);
    if (!conditionalFormatting) {
        conditionalFormatting = { rules: [] };
    }
    if (!common_1._isNullOrUndefined(id)) {
        var rules = conditionalFormatting.rules;
        if (rules && rules.length > 0) {
            for (var i = 0; i < rules.length; i++) {
                if (rules[i].id === id) {
                    return rules[i];
                }
            }
        }
    }
    var newRule = {};
    readerDataModel._addConditionalFormatting(sheetName, { rules: [newRule] });
    return newRule;
}
var DataBarAxisPositions = {
    automatic: 0,
    middle: 1,
    none: 2
};
function readCellValueRule(cfRule, rule, readerDataModel) {
    var cellIsAttributes = cfRule._attr;
    if (!common_1._isNullOrUndefined(cellIsAttributes.stopIfTrue)) {
        rule.stopIfTrue = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cellIsAttributes.stopIfTrue, false);
    }
    if (!common_1._isNullOrUndefined(cellIsAttributes.operator)) {
        rule.operator = ComparisonOperators[cellIsAttributes.operator];
    }
    var formulas = getAsArray(cfRule["xm:f"]);
    rule.value1 = '=' + common_1.Util._xmlDecode(formulas[0]["xm:f"]);
    if (formulas.length === 2) {
        rule.value2 = '=' + common_1.Util._xmlDecode(formulas[1]["xm:f"]);
    }
    var dxfXml = xml_parser_1.convertObjectToXml(cfRule['x14:dxf'], 'x14:dxf');
    var reader = new xml_reader_1.XmlReader();
    reader.setXml(dxfXml);
    reader.read();
    var dxf = style_reader_1.readDifferentialFormattingRecord(reader);
    rule.style = convertDxfToStyle(dxf, readerDataModel._headingFont, readerDataModel._bodyFont);
}
function readExtensionFormulaRule(cfRule, rule, readerDataModel) {
    rule.formula = addEqualSign(getNodeValue(cfRule, 'xm:f'));
    var dxfXml = xml_parser_1.convertObjectToXml(cfRule['x14:dxf'], 'x14:dxf');
    var reader = new xml_reader_1.XmlReader();
    reader.setXml(dxfXml);
    reader.read();
    var dxf = style_reader_1.readDifferentialFormattingRecord(reader);
    rule.style = convertDxfToStyle(dxf, readerDataModel._headingFont, readerDataModel._bodyFont);
}
function readExtensionDataBarRule(dataBar, rule) {
    var cfRuleAttributes = dataBar._attr;
    if (!common_1._isNullOrUndefined(cfRuleAttributes.showValue)) {
        rule.showBarOnly = !node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cfRuleAttributes.showValue, true);
    }
    if (!common_1._isNullOrUndefined(cfRuleAttributes.border)) {
        rule.showBorder = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cfRuleAttributes.border, false);
    }
    if (!common_1._isNullOrUndefined(cfRuleAttributes.gradient)) {
        rule.gradient = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cfRuleAttributes.gradient, true);
    }
    if (!common_1._isNullOrUndefined(cfRuleAttributes.direction)) {
        rule.dataBarDirection = cfRuleAttributes.direction === 'rightToLeft' ? 1 : 0;
    }
    if (!common_1._isNullOrUndefined(cfRuleAttributes.axisPosition)) {
        rule.axisPosition = DataBarAxisPositions[cfRuleAttributes.axisPosition];
    }
    if (!common_1._isNullOrUndefined(cfRuleAttributes.negativeBarColorSameAsPositive)) {
        rule.useNegativeFillColor = !node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cfRuleAttributes.negativeBarColorSameAsPositive, false);
    }
    if (!common_1._isNullOrUndefined(cfRuleAttributes.negativeBarBorderColorSameAsPositive)) {
        rule.useNegativeBorderColor = !node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cfRuleAttributes.negativeBarBorderColorSameAsPositive, true);
    }
    var cfvoList = [];
    if (dataBar['x14:cfvo']) {
        getAsArray(dataBar['x14:cfvo']).forEach(function (value) {
            cfvoList.push(readCfvo(value));
        });
    }
    if (dataBar['x14:fillColor']) {
        rule.color = excel_style_1.ColorHelper.toRGBColor(color_reader_1.readColor(dataBar['x14:fillColor']));
    }
    if (dataBar['x14:borderColor']) {
        rule.borderColor = excel_style_1.ColorHelper.toRGBColor(color_reader_1.readColor(dataBar['x14:borderColor']));
    }
    if (dataBar['x14:negativeFillColor']) {
        rule.negativeFillColor = excel_style_1.ColorHelper.toRGBColor(color_reader_1.readColor(dataBar['x14:negativeFillColor']));
    }
    if (dataBar['x14:negativeBorderColor']) {
        rule.negativeBorderColor = excel_style_1.ColorHelper.toRGBColor(color_reader_1.readColor(dataBar['x14:negativeBorderColor']));
    }
    if (dataBar['x14:axisColor']) {
        rule.axisColor = excel_style_1.ColorHelper.toRGBColor(color_reader_1.readColor(dataBar['x14:axisColor']));
    }
    if (cfvoList.length === 2) {
        rule.minType = ScaleValueType[cfvoList[0].type];
        rule.minValue = addEqualSign(cfvoList[0].val);
        rule.maxType = ScaleValueType[cfvoList[1].type];
        rule.maxValue = addEqualSign(cfvoList[1].val);
    }
}
exports.readExtensionDataBarRule = readExtensionDataBarRule;
function readExtensionIconSetRule(iconSet, rule) {
    var iconSetAttributes = iconSet._attr;
    if (!common_1._isNullOrUndefined(iconSetAttributes.iconSet)) {
        rule.iconSetType = IconSetTypes['$' + iconSetAttributes.iconSet];
    }
    if (!common_1._isNullOrUndefined(iconSetAttributes.showValue)) {
        rule.showIconOnly = !node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(iconSetAttributes.showValue, true);
    }
    if (!common_1._isNullOrUndefined(iconSetAttributes.reverse)) {
        rule.reverseIconOrder = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(iconSetAttributes.reverse, false);
    }
    rule.iconCriteria = readCriteria(iconSet);
    rule.icons = readIcons(iconSet);
}
exports.readExtensionIconSetRule = readExtensionIconSetRule;


/***/ }),

/***/ "./src/xlsx-io/reader/datavalidation-reader.ts":
/*!*****************************************************!*\
  !*** ./src/xlsx-io/reader/datavalidation-reader.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var node_helper_1 = __webpack_require__(/*! ./../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var range_parser_1 = __webpack_require__(/*! ./../../common/range-parser */ "./src/common/range-parser.ts");
var getAttrValueOrDefaultOfBooleanType = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType;
var xmlDecode = common_1.Util._xmlDecode;
function getNodeValue(obj, key, subkey) {
    return xmlDecode(node_helper_1.XmlNodeHelper._getValueFromObject(obj, key, subkey));
}
var ExcelDataValidationType = {
    none: 0,
    whole: 1,
    decimal: 2,
    list: 3,
    date: 4,
    time: 5,
    textLength: 6,
    custom: 7
};
var ExcelDataValidationErrorStyle = {
    stop: 0,
    warning: 1,
    information: 2
};
var ExcelDataValidationOperator = {
    between: 6,
    notBetween: 7,
    equal: 0,
    notEqual: 1,
    greaterThan: 2,
    lessThan: 4,
    greaterThanOrEqual: 3,
    lessThanOrEqual: 5
};
function updateSheetRowColCount(sheetName, readerDataModel, ranges) {
    var spread = readerDataModel._spread, sheet = spread.sheets && spread.sheets[sheetName];
    for (var i = 0, len = ranges.length; i < len; i++) {
        var range = ranges[i], sheetRowCount = sheet.rowCount, sheetColCount = sheet.columnCount;
        if (range.row + range.rowCount > sheetRowCount) {
            sheet.rowCount = range.row + range.rowCount;
        }
        if (range.col + range.colCount > sheetColCount) {
            sheet.columnCount = range.col + range.colCount;
        }
    }
}
function readDataValidation(dataValidationNode, sheetName, readerDataModel, isExtensionRecord) {
    if (common_1.isNullOrUndefined(dataValidationNode) || common_1.isNullOrUndefined(sheetName)) {
        return;
    }
    var attr = dataValidationNode._attr;
    var dataValidation = {
        type: ExcelDataValidationType[attr.type] || 0,
        errorType: ExcelDataValidationErrorStyle[attr.errorStyle] || 0,
        compareOperator: common_1.isNullOrUndefined(ExcelDataValidationOperator[attr.operator]) ? 6 : ExcelDataValidationOperator[attr.operator],
        allowBlank: getAttrValueOrDefaultOfBooleanType(attr.allowBlank, false),
        showPromptBox: !getAttrValueOrDefaultOfBooleanType(attr.showDropDown, false),
        showInputMessage: getAttrValueOrDefaultOfBooleanType(attr.showInputMessage, false),
        showErrorMessage: getAttrValueOrDefaultOfBooleanType(attr.showErrorMessage, false),
        errorTitle: xmlDecode(attr.errorTitle),
        error: xmlDecode(attr.error),
        promptTitle: xmlDecode(attr.promptTitle),
        prompt: xmlDecode(attr.prompt)
    };
    dataValidation.error = common_1.Util._decodeSpecialCharacterFromXML(dataValidation.error);
    dataValidation.prompt = common_1.Util._decodeSpecialCharacterFromXML(dataValidation.prompt);
    var rangeString, firstFormula, secondFormula;
    if (isExtensionRecord) {
        rangeString = getNodeValue(dataValidationNode, 'xm:sqref');
        var firstFormulaElement = dataValidationNode['x14:formula1'];
        var secondFormulaElement = dataValidationNode['x14:formula2'];
        if (firstFormulaElement) {
            firstFormula = getNodeValue(firstFormulaElement, 'xm:f');
        }
        if (secondFormulaElement) {
            secondFormula = getNodeValue(secondFormulaElement, 'xm:f');
        }
    }
    else {
        rangeString = attr.sqref;
        firstFormula = getNodeValue(dataValidationNode, 'formula1');
        secondFormula = getNodeValue(dataValidationNode, 'formula2');
    }
    var ranges = range_parser_1.getRangesFromString(rangeString);
    dataValidation.firstFormula = firstFormula;
    dataValidation.secondFormula = secondFormula;
    dataValidation.ranges = ranges;
    updateSheetRowColCount(sheetName, readerDataModel, ranges);
    readerDataModel._setDataValidation(sheetName, dataValidation);
}
function readDataValidations(reader, sheetName, readerDataModel) {
    var dataValidationsNode = xml_parser_1.parseXmlToObject(reader.readFullElement()).dataValidations;
    var dataValidationArrayNode = node_helper_1.XmlNodeHelper._getAsArray(dataValidationsNode.dataValidation);
    for (var index = dataValidationArrayNode.length - 1; index >= 0; index--) {
        var dataValidationNode = dataValidationArrayNode[index];
        readDataValidation(dataValidationNode, sheetName, readerDataModel);
    }
}
exports.readDataValidations = readDataValidations;
function readExtensionDataValidation(reader, sheetName, readerDataModel) {
    var ext = xml_parser_1.parseXmlToObject(reader.readFullElement()).ext;
    var dataValidationsNode = ext['x14:dataValidations'];
    var dataValidationArrayNode = node_helper_1.XmlNodeHelper._getAsArray(dataValidationsNode['x14:dataValidation']);
    for (var index = dataValidationArrayNode.length - 1; index >= 0; index--) {
        var dataValidationNode = dataValidationArrayNode[index];
        readDataValidation(dataValidationNode, sheetName, readerDataModel, true);
    }
}
exports.readExtensionDataValidation = readExtensionDataValidation;


/***/ }),

/***/ "./src/xlsx-io/reader/docpropsapp-reader.ts":
/*!**************************************************!*\
  !*** ./src/xlsx-io/reader/docpropsapp-reader.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_reader_1 = __webpack_require__(/*! ./../../xml-io/xml-reader */ "./src/xml-io/xml-reader.ts");
function readDocPropsAppFile(dataString, readerDataModel) {
    var reader = new xml_reader_1.XmlReader();
    reader.setXml(dataString);
    while (reader.read()) {
        if (reader.depth !== 1 || reader.elementType === 2) {
            continue;
        }
        var nodeName = reader.name();
        switch (nodeName) {
            case "HeadingPairs":
                readHeadingPairs(reader, readerDataModel, nodeName);
                break;
            case "TitlesOfParts":
                readTitlesOfParts(reader, readerDataModel, nodeName);
                break;
            default:
                readNodeWithoutAttr(reader, readerDataModel, nodeName);
                break;
        }
    }
}
exports.readDocPropsAppFile = readDocPropsAppFile;
function readNodeWithoutAttr(reader, readerDataModel, nodeName) {
    if (reader.nodeType() === 1) {
        var value = reader.readElementContentAsString(true);
        readerDataModel._setDocPropsApp(nodeName, value);
    }
}
function readHeadingPairs(reader, readerDataModel, nodeName) {
    if (reader.elementType === 3) {
        return;
    }
    var headingPairsObj = {}, workbookInfoArray = [];
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1 && reader.name() === 'vt:vector') {
            readVectorAttr(reader, headingPairsObj);
            if (reader.elementType === 3) {
                continue;
            }
            var vectorDepth = reader.depth;
            while (reader.read()) {
                if (reader.depth <= vectorDepth) {
                    break;
                }
                if (reader.nodeType() === 1) {
                    if (reader.elementType === 3) {
                        continue;
                    }
                    var variantDepth = reader.depth;
                    while (reader.read()) {
                        if (reader.depth <= variantDepth) {
                            break;
                        }
                        if (reader.nodeType() === 1) {
                            var workbookInfoItem = {};
                            workbookInfoItem.elementType = reader.name();
                            workbookInfoItem.value = reader.readElementContentAsString(true);
                            workbookInfoArray.push(workbookInfoItem);
                        }
                    }
                    headingPairsObj.workbookInfoArray = workbookInfoArray;
                }
            }
        }
    }
    readerDataModel._setDocPropsApp(nodeName, headingPairsObj);
}
function readTitlesOfParts(reader, readerDataModel, nodeName) {
    if (reader.elementType === 3) {
        return;
    }
    var titlesOfPartsObj = {};
    var sheetsNameArray = [];
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1 && reader.name() === 'vt:vector') {
            readVectorAttr(reader, titlesOfPartsObj);
            if (reader.elementType === 3) {
                continue;
            }
            var vectorDepth = reader.depth;
            while (reader.read()) {
                if (reader.depth <= vectorDepth) {
                    break;
                }
                if (reader.nodeType() === 1) {
                    var value = reader.readElementContentAsString(true);
                    sheetsNameArray.push(value);
                }
            }
            titlesOfPartsObj.sheetsNameArray = sheetsNameArray;
        }
    }
    readerDataModel._setDocPropsApp(nodeName, titlesOfPartsObj);
}
function readVectorAttr(reader, titlesOfPartsObj) {
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case 'size':
                titlesOfPartsObj.size = reader.readContentAsInt(1);
                break;
            case 'baseType':
                titlesOfPartsObj.baseType = reader.readContentAsString();
                break;
            default:
                break;
        }
    }
}


/***/ }),

/***/ "./src/xlsx-io/reader/docpropscore-reader.ts":
/*!***************************************************!*\
  !*** ./src/xlsx-io/reader/docpropscore-reader.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_reader_1 = __webpack_require__(/*! ./../../xml-io/xml-reader */ "./src/xml-io/xml-reader.ts");
function readDocPropsCoreFile(dataString, readerDataModel) {
    var reader = new xml_reader_1.XmlReader();
    reader.setXml(dataString);
    while (reader.read()) {
        if (reader.depth !== 1 || reader.elementType === 2) {
            continue;
        }
        var nodeName = reader.name();
        if (nodeName.indexOf(":") !== -1) {
            nodeName = reader.name().split(':')[1];
        }
        readNodeWithoutAttr(reader, readerDataModel, nodeName);
    }
}
exports.readDocPropsCoreFile = readDocPropsCoreFile;
function readNodeWithoutAttr(reader, readerDataModel, nodeName) {
    if (reader.nodeType() === 1) {
        var value = reader.readElementContentAsString(true);
        readerDataModel._setDocPropsCore(nodeName, value);
    }
}


/***/ }),

/***/ "./src/xlsx-io/reader/docpropscustom-reader.ts":
/*!*****************************************************!*\
  !*** ./src/xlsx-io/reader/docpropscustom-reader.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_reader_1 = __webpack_require__(/*! ./../../xml-io/xml-reader */ "./src/xml-io/xml-reader.ts");
function readDocPropsCustomFile(dataString, readerDataModel) {
    var reader = new xml_reader_1.XmlReader();
    reader.setXml(dataString);
    var customPropertyItemArray = [];
    while (reader.read()) {
        if (reader.depth !== 1 || reader.elementType === 2) {
            continue;
        }
        readPropertyOfCustom(reader, customPropertyItemArray);
    }
    readerDataModel._setDocPropsCustom(customPropertyItemArray);
}
exports.readDocPropsCustomFile = readDocPropsCustomFile;
function readPropertyOfCustom(reader, customPropertyItemArray) {
    if (reader.elementType === 3) {
        return;
    }
    if (reader.nodeType() === 1 && reader.name() === 'property') {
        var customPropertyItem = {};
        while (reader.moveToNextAttribute()) {
            var key = reader.readAttributeNameAsString();
            var value = reader.readContentAsString();
            customPropertyItem[key] = value;
        }
        var vectorDepth = reader.depth;
        while (reader.read()) {
            if (reader.depth <= vectorDepth) {
                break;
            }
            if (reader.nodeType() === 1) {
                var propertyItemChildElement = {};
                var key = reader.name();
                var value = reader.readElementContentAsString(true);
                propertyItemChildElement[key] = value;
                customPropertyItem.propertyItemChildElement = propertyItemChildElement;
            }
        }
        customPropertyItemArray.push(customPropertyItem);
    }
}


/***/ }),

/***/ "./src/xlsx-io/reader/drawing-reader.ts":
/*!**********************************************!*\
  !*** ./src/xlsx-io/reader/drawing-reader.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var node_helper_1 = __webpack_require__(/*! ./../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var excel_helper_1 = __webpack_require__(/*! ./../../datamodel/excel-helper */ "./src/datamodel/excel-helper.ts");
var xml_reader_1 = __webpack_require__(/*! ./../../xml-io/xml-reader */ "./src/xml-io/xml-reader.ts");
var chart_reader_1 = __webpack_require__(/*! ./chart-reader */ "./src/xlsx-io/reader/chart-reader.ts");
var getAsArray = node_helper_1.XmlNodeHelper._getAsArray;
var readXY = node_helper_1.XmlNodeHelper._readXY;
var readSize = node_helper_1.XmlNodeHelper._readSize;
var readAnchorPoint = node_helper_1.XmlNodeHelper._readAnchorPoint;
var _is2016Chart = common_1.Util._is2016Chart;
var chart_model_1 = __webpack_require__(/*! ./../../datamodel/chart-model */ "./src/datamodel/chart-model.ts");
function readDrawings(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData) {
    if (relationFiles) {
        var drawingFiles = [];
        for (var key in relationFiles) {
            if (key !== 'count') {
                var relationFile = relationFiles[key];
                if (relationFile) {
                    var fileType = relationFile.fileType;
                    if (fileType === excel_types_1.RelationshipConstants._relationshipDrawingType || fileType === excel_types_1.RelationshipConstants._relationshipDrawingType2) {
                        drawingFiles.push(relationFile);
                    }
                }
            }
        }
        if (drawingFiles.length) {
            var drawingInfoData = { names: readerDataModel._spread.names || [] };
            var drawingInfo = readDrawingInfoFromFile(drawingFiles, getFileDataAndCleanData, drawingInfoData);
            readerDataModel._addDrawingObjects(drawingInfo, sheetName);
        }
    }
}
exports.readDrawings = readDrawings;
function readDrawingInfoFromFile(drawingFiles, getFileDataAndCleanData, drawingInfoData) {
    var drawingRelationFiles = {}, drawingInfo;
    drawingFiles.forEach(function (file) {
        var relationFiles = file.relationFiles;
        if (relationFiles) {
            for (var key in relationFiles) {
                if (key !== 'count') {
                    var relationFile = relationFiles[key];
                    if (relationFile) {
                        var fileType = relationFile.fileType;
                        if (fileType === excel_types_1.RelationshipConstants._relationshipImageType ||
                            fileType === excel_types_1.RelationshipConstants._relationshipImageType2 ||
                            fileType === excel_types_1.RelationshipConstants._relationshipChartType ||
                            fileType === excel_types_1.RelationshipConstants._relationshipNewChartType ||
                            fileType === excel_types_1.RelationshipConstants._relationshipPurlChartType ||
                            fileType === excel_types_1.RelationshipConstants._relationshipHyperlinkType) {
                            drawingRelationFiles[key] = relationFile;
                        }
                    }
                }
            }
        }
        var dataString = getFileDataAndCleanData(file.fileName, true);
        if (dataString) {
            drawingInfo = readDrawing(dataString, drawingRelationFiles, getFileDataAndCleanData, drawingInfoData);
        }
    });
    return drawingInfo;
}
function setImageStringToBlipBlob(blipFillContainer, chartRelationFileMap, getFileDataAndCleanData) {
    var embedImageId = blipFillContainer && blipFillContainer.blipFill && blipFillContainer.blipFill.blip &&
        blipFillContainer.blipFill.blip.embed;
    if (!embedImageId) {
        return;
    }
    var imageFile = chartRelationFileMap[embedImageId];
    if (imageFile) {
        var fileName = imageFile.fileName;
        var pos = fileName.lastIndexOf('.');
        if (pos >= 0) {
            var imageFileString = excel_helper_1.getImageContent(fileName, getFileDataAndCleanData);
            if (imageFileString) {
                var blipBlob = blipFillContainer.blipFill.blip.blipBlob = {};
                blipBlob.blob = imageFileString;
                blipBlob.type = fileName.substr(pos + 1);
            }
        }
    }
}
var xfrmRect = /** @class */ (function () {
    function xfrmRect(xfrm) {
        var off = xfrm.off, ext = xfrm.ext;
        var width = ext.cx;
        var height = ext.cy;
        this.left = off.x;
        this.top = off.y;
        this.right = this.left + width;
        this.bottom = this.top + height;
    }
    return xfrmRect;
}());
function xfrmCache() {
    this.cache = {};
    this.get = function (key, xfrm) {
        var item = this.cache[key];
        if (!item && xfrm) {
            item = this.cache[key] = new xfrmRect(xfrm);
        }
        return item;
    };
}
function isContainsBy(xfrmCompare, xfrmCompareTo) {
    return xfrmCompare.left >= xfrmCompareTo.left && xfrmCompare.top >= xfrmCompareTo.top &&
        xfrmCompare.right <= xfrmCompareTo.right && xfrmCompare.bottom <= xfrmCompareTo.bottom;
}
function markHiddenShape(items, index, cache) {
    var xfrmCompareTo = cache.get(index, items[index].pic.spPr.xfrm);
    if (!xfrmCompareTo) {
        return;
    }
    for (var i = 0; i < index; i++) {
        var item = items[i];
        if (!item.pic && !item.hidden) {
            var xfrm = excel_helper_1.getXFrm(item);
            if (xfrm) {
                var xfrmCompare = cache.get(i, xfrm);
                if (xfrmCompare && isContainsBy(xfrmCompare, xfrmCompareTo)) {
                    item.hidden = true;
                }
            }
        }
    }
}
function readDrawing(dataString, drawingRelationFiles, getFileDataAndCleanData, drawingInfoData) {
    var obj = xml_parser_1.parseXmlToObject(dataString, true), root = obj['xdr:wsDr'];
    var drawingResult = {};
    if (root) {
        var pictures = readPictureDrawing(root, drawingRelationFiles, getFileDataAndCleanData);
        if (pictures.length > 0) {
            drawingResult.pictures = pictures;
        }
        var drawingObj = readChartDrawingNode(dataString, drawingRelationFiles);
        var anchorBaseList_1 = drawingObj && drawingObj.AnchorBaseList;
        var charts = readChartDrawing(anchorBaseList_1, drawingRelationFiles, getFileDataAndCleanData, drawingInfoData);
        if (charts.length > 0) {
            drawingResult.charts = charts;
        }
        var shapes = readShapeDrawing(anchorBaseList_1, drawingRelationFiles, getFileDataAndCleanData);
        if (shapes.length > 0) {
            drawingResult.shapes = shapes;
        }
        var cache_1 = new xfrmCache();
        anchorBaseList_1.forEach(function (item, index) {
            var pic = item.pic;
            if (pic && !pic.nvPicPr.cNvPr.hidden) {
                markHiddenShape(anchorBaseList_1, index, cache_1);
            }
        });
    }
    return drawingResult;
}
function readPicture(pictures, anchor, drawingRelationFiles, getFileDataAndCleanData) {
    var picture = {};
    readPictureFrame(drawingRelationFiles, anchor['xdr:pic'], picture, getFileDataAndCleanData);
    readLocked(anchor['xdr:clientData'], picture);
    if (picture.src) {
        pictures.push(picture);
    }
    return picture;
}
function readPictureDrawing(wsDrNodeObj, drawingRelationFiles, getFileDataAndCleanData) {
    if (!wsDrNodeObj) {
        return [];
    }
    var pictures = [];
    var picture;
    var anchors = getAsArray(wsDrNodeObj['xdr:oneCellAnchor']);
    anchors.forEach(function (anchor) {
        if (anchor && anchor['xdr:pic']) {
            var oneCellAnchor = { startPoint: readAnchorPoint(anchor['xdr:from']) };
            readSize(anchor['xdr:ext'], oneCellAnchor);
            picture = readPicture(pictures, anchor, drawingRelationFiles, getFileDataAndCleanData);
            oneCellAnchor.anchorType = 1;
            picture.anchor = oneCellAnchor;
        }
    });
    anchors = getAsArray(wsDrNodeObj['xdr:twoCellAnchor']);
    anchors.forEach(function (anchor) {
        if (anchor && anchor['xdr:pic']) {
            var twoCellAnchor = {
                startPoint: readAnchorPoint(anchor['xdr:from']),
                endPoint: readAnchorPoint(anchor['xdr:to'])
            };
            var editAs = anchor._attr.editAs;
            if (editAs) {
                twoCellAnchor.editAs = chart_model_1.Charts.ST_EditAs[editAs];
            }
            picture = readPicture(pictures, anchor, drawingRelationFiles, getFileDataAndCleanData);
            twoCellAnchor.anchorType = 0;
            picture.anchor = twoCellAnchor;
        }
    });
    anchors = getAsArray(wsDrNodeObj['xdr:absoluteAnchor']);
    anchors.forEach(function (anchor) {
        if (anchor && anchor['xdr:pic']) {
            var absoluteAnchor = {};
            readXY(anchor['xdr:pos'], absoluteAnchor);
            readSize(anchor['xdr:ext'], absoluteAnchor);
            picture = readPicture(pictures, anchor, drawingRelationFiles, getFileDataAndCleanData);
            absoluteAnchor.anchorType = 2;
            picture.anchor = absoluteAnchor;
        }
    });
    return pictures;
}
function readChartDrawing(anchorBaseList, drawingRelationFiles, getFileDataAndCleanData, drawingInfoData) {
    var charts = [];
    if (anchorBaseList && anchorBaseList.length > 0) {
        anchorBaseList.forEach(function (item) {
            var graphicFrame, AlternateContent = item.AlternateContent;
            if (_is2016Chart(AlternateContent)) {
                graphicFrame = AlternateContent.Choice.GraphicalObjectFrame;
            }
            else {
                graphicFrame = item.graphicFrame;
            }
            var chartFileId = graphicFrame && graphicFrame.graphic && graphicFrame.graphic.graphicData
                && graphicFrame.graphic.graphicData.chart && graphicFrame.graphic.graphicData.chart.id;
            if (chartFileId) {
                var chartFile = drawingRelationFiles[chartFileId];
                var chartSpace = readChartSpace(chartFile, getFileDataAndCleanData, drawingInfoData);
                if (chartSpace) {
                    var chartRelationFileMap = {};
                    var relationFiles = chartFile.relationFiles;
                    for (var key in relationFiles) {
                        if (key !== 'count') {
                            var relationFile = relationFiles[key];
                            if (relationFile) {
                                var fileType = relationFile.fileType;
                                if (fileType === excel_types_1.RelationshipConstants._realationshipChartUserShapes ||
                                    fileType === excel_types_1.RelationshipConstants._relationshipImageType) {
                                    chartRelationFileMap[key] = relationFile;
                                }
                            }
                        }
                    }
                    var userShapes = readChartUserShapes(chartSpace.userShapes, chartRelationFileMap, getFileDataAndCleanData);
                    if (userShapes) {
                        chartSpace.userShapes = userShapes;
                    }
                    readChartEmbededImage(chartSpace, chartRelationFileMap, getFileDataAndCleanData);
                    item.chartSpace = chartSpace;
                    charts.push(item);
                }
            }
        });
    }
    return charts;
}
function readShapeDrawing(anchorBaseList, drawingRelationFiles, getFileDataAndCleanData) {
    var shapes = [];
    if (anchorBaseList && anchorBaseList.length > 0) {
        anchorBaseList.forEach(function (item) {
            if (item.sp || item.cxnSp || item.grpSp || (item.pic && chart_reader_1.DrawingReader.IsCameraTool(item.pic))) {
                readShapeEmbededImage(item, drawingRelationFiles, getFileDataAndCleanData);
                shapes.push(item);
            }
        });
    }
    return shapes;
}
function readChartDrawingNode(dataString, relationFiles) {
    var reader = new xml_reader_1.XmlReader();
    reader.relationFiles = relationFiles;
    reader.reset();
    reader.setXml(dataString);
    reader.keepRootNamespace = true;
    while (reader.read()) {
        if (reader.depth !== 0 || reader.elementType === 2) {
            continue;
        }
        if (reader.name() === 'xdr:wsDr') {
            return chart_reader_1.DrawingReader.ReadCT_Drawing(reader);
        }
    }
    return null;
}
function readChartSpace(chartFile, getFileDataAndCleanData, drawingInfoData) {
    if (!chartFile) {
        return null;
    }
    var fileName = chartFile.fileName;
    var chartFileString = getFileDataAndCleanData(fileName, true);
    var reader = new xml_reader_1.XmlReader();
    reader.reset();
    reader.setXml(chartFileString);
    reader.keepRootNamespace = true;
    var chart, is2016Chart;
    while (reader.read()) {
        if (reader.depth !== 0 || reader.elementType === 2) {
            continue;
        }
        if (reader.name() === 'c:chartSpace') {
            chart = chart_reader_1.DrawingReader.ReadCT_ChartSpace(reader);
            is2016Chart = false;
            break;
        }
        else if (reader.name() === 'cx:chartSpace') {
            var drawingInfoDataName = (drawingInfoData && drawingInfoData.names) ? drawingInfoData.names : [];
            chart = chart_reader_1.DrawingReader.Chart2016Reader.ReadCT_ChartSpace(reader, drawingInfoDataName);
            is2016Chart = true;
            break;
        }
    }
    if (is2016Chart) {
        var relationFiles = chartFile.relationFiles;
        for (var key in relationFiles) {
            if (key !== 'count') {
                var file = relationFiles[key];
                var fileType = file && file.fileType;
                if (fileType === excel_types_1.RelationshipConstants._realationshipChartStyle) {
                    chart.style = read2016ChartStyle(file, getFileDataAndCleanData);
                }
                else if (fileType === excel_types_1.RelationshipConstants._realationshipChartColorStyle) {
                    chart.colors = read2016ChartColors(file, getFileDataAndCleanData);
                }
            }
        }
    }
    return chart;
}
function read2016ChartStyle(relationFiles, getFileDataAndCleanData) {
    var chartFileString = getFileDataAndCleanData(relationFiles.fileName, true);
    var reader = new xml_reader_1.XmlReader();
    reader.reset();
    reader.setXml(chartFileString);
    while (reader.read()) {
        if (reader.depth !== 0 || reader.elementType === 2) {
            continue;
        }
        return chart_reader_1.DrawingReader.Chart2016Reader.ReadCT_ChartStyle(reader);
    }
}
function read2016ChartColors(relationFiles, getFileDataAndCleanData) {
    var chartFileString = getFileDataAndCleanData(relationFiles.fileName, true);
    var reader = new xml_reader_1.XmlReader();
    reader.reset();
    reader.setXml(chartFileString);
    while (reader.read()) {
        if (reader.depth !== 0 || reader.elementType === 2) {
            continue;
        }
        return chart_reader_1.DrawingReader.Chart2016Reader.ReadCT_chartColors(reader);
    }
}
function readChartUserShapes(userShapes, chartRelationFileMap, getFileDataAndCleanData) {
    if (!userShapes || !userShapes.id) {
        return null;
    }
    var drawingFile = chartRelationFileMap[userShapes.id];
    var userShapeRelationFileMap = {}, userShapeRelationFiles = drawingFile.relationFiles;
    var key, relationFile, fileType;
    for (key in userShapeRelationFiles) {
        if (key !== 'count') {
            relationFile = userShapeRelationFiles[key];
            if (relationFile) {
                fileType = relationFile.fileType;
                if (fileType === excel_types_1.RelationshipConstants._relationshipImageType ||
                    fileType === excel_types_1.RelationshipConstants._relationshipChartType) {
                    userShapeRelationFileMap[key] = relationFile;
                }
            }
        }
    }
    var chartUserShapesAnchors = readChartUserShapesNode(drawingFile, getFileDataAndCleanData);
    if (chartUserShapesAnchors && chartUserShapesAnchors.length > 0) {
        return chartUserShapesAnchors.map(function (anchorItem) {
            if (anchorItem.pic) {
                readPictureInChart(anchorItem, userShapeRelationFileMap, getFileDataAndCleanData);
            }
            else if (anchorItem.graphicFrame) {
                readChartInChart(anchorItem, userShapeRelationFileMap, getFileDataAndCleanData);
            }
            return anchorItem;
        });
    }
}
function getChartPictureStyle(pictureNode) {
    var userShapes = pictureNode && pictureNode['c:userShapes'];
    if (userShapes) {
        var absSizeAnchor = userShapes['cdr:absSizeAnchor'], relSizeAnchor = userShapes['cdr:relSizeAnchor'];
        if (absSizeAnchor) {
            return absSizeAnchor['cdr:pic'] && absSizeAnchor['cdr:pic']['cdr:spPr'];
        }
        else if (relSizeAnchor) {
            return relSizeAnchor['cdr:pic'] && relSizeAnchor['cdr:pic']['cdr:spPr'];
        }
    }
    return null;
}
function readChartUserShapesNode(drawingFile, getFileDataAndCleanData) {
    if (!drawingFile) {
        return null;
    }
    var fileName = drawingFile.fileName;
    var drawingFileString = getFileDataAndCleanData(fileName, true);
    var reader = new xml_reader_1.XmlReader();
    reader.reset();
    reader.setXml(drawingFileString);
    reader.keepRootNamespace = true;
    while (reader.read()) {
        if (reader.depth !== 0 || reader.elementType === 2) {
            continue;
        }
        if (reader.name() === 'c:userShapes') {
            var drawingObj = chart_reader_1.DrawingReader.ReadCT_ChartDrawing(reader);
            if (drawingObj) {
                var drawingAnchor = drawingObj.relSizeAnchor.concat(drawingObj.absSizeAnchor);
                drawingAnchor.forEach(function (anchor) {
                    if (anchor.pic) {
                        var pictureNode = xml_parser_1.parseXmlToObject(drawingFileString);
                        anchor.pictureStyleInfo = getChartPictureStyle(pictureNode);
                    }
                });
                return drawingAnchor;
            }
        }
    }
    return null;
}
function readChartInChart(anchorItem, userShapeRelationFileMap, getFileDataAndCleanData) {
    var innerChartId = anchorItem.graphicFrame.graphic && anchorItem.graphicFrame.graphic.graphicData &&
        anchorItem.graphicFrame.graphic.graphicData.chart && anchorItem.graphicFrame.graphic.graphicData.chart.id;
    var innerChartFile = userShapeRelationFileMap[innerChartId];
    if (innerChartFile) {
        anchorItem.chartSpace = readChartSpace(innerChartFile, getFileDataAndCleanData);
    }
}
function readPictureInChart(anchorItem, userShapeRelationFileMap, getFileDataAndCleanData) {
    setImageStringToBlipBlob(anchorItem.pic, userShapeRelationFileMap, getFileDataAndCleanData);
    var pictureStyleInfo = anchorItem.pictureStyleInfo;
    if (pictureStyleInfo) {
        anchorItem.pictureFormat = readImageFormat(pictureStyleInfo);
        delete anchorItem.pictureStyleInfo;
    }
}
function readChartEmbededImage(chartSpace, chartRelationFileMap, getFileDataAndCleanData) {
    var plotArea = chartSpace.chart.plotArea;
    if (plotArea && plotArea.chartGroups) {
        plotArea.chartGroups.forEach(function (chart) {
            if (chart && chart.ser) {
                chart.ser.forEach(function (serItem) {
                    if (serItem.spPr) {
                        setImageStringToBlipBlob(serItem.spPr, chartRelationFileMap, getFileDataAndCleanData);
                    }
                    if (serItem.dLbls && serItem.dLbls.spPr) {
                        setImageStringToBlipBlob(serItem.dLbls.spPr, chartRelationFileMap, getFileDataAndCleanData);
                    }
                });
            }
        });
    }
    if (plotArea && plotArea.spPr) {
        setImageStringToBlipBlob(plotArea.spPr, chartRelationFileMap, getFileDataAndCleanData);
    }
    if (chartSpace.spPr) {
        setImageStringToBlipBlob(chartSpace.spPr, chartRelationFileMap, getFileDataAndCleanData);
    }
}
function readShapeEmbededImage(item, drawingRelationFiles, getFileDataAndCleanData) {
    var bilpFill = (item.sp && item.sp.spPr) || (item.pic);
    if (bilpFill) {
        setImageStringToBlipBlob(bilpFill, drawingRelationFiles, getFileDataAndCleanData);
    }
    else if (item.grpSp) {
        if (item.grpSp.sp) {
            item.grpSp.sp.forEach(function (shape) {
                if (shape.spPr) {
                    setImageStringToBlipBlob(shape.spPr, drawingRelationFiles, getFileDataAndCleanData);
                }
            });
        }
        if (item.grpSp.grpSpPr) {
            setImageStringToBlipBlob(item.grpSp.grpSpPr, drawingRelationFiles, getFileDataAndCleanData);
        }
    }
}
function changeTinitToShapeLineFill(spPr) {
    var ln = spPr.ln;
    if (ln && ln.solidFill && ln.solidFill.schemeClr && ln.solidFill.schemeClr.tint === undefined) {
    }
}
function adjustTintToShapeLineFill(item) {
    if (item.sp && item.sp.spPr) {
        changeTinitToShapeLineFill(item.sp.spPr);
    }
    else if (item.grpSp) {
        if (item.grpSp.sp) {
            item.grpSp.sp.forEach(function (shape) {
                if (shape.spPr) {
                    changeTinitToShapeLineFill(shape.spPr);
                }
            });
        }
        if (item.grpSp.grpSpPr) {
            changeTinitToShapeLineFill(item.grpSp.grpSpPr);
        }
    }
}
function readLocked(item, picture) {
    if (item) {
        picture.locked = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(item._attr.fLocksWithSheet, true);
    }
}
function readPictureFrame(imageFiles, pic, picture, getFileDataAndCleanData) {
    if (pic) {
        var item = pic['xdr:nvPicPr'];
        if (item) {
            var cNvPr = item['xdr:cNvPr'];
            picture.name = cNvPr && cNvPr._attr.name;
            picture.descr = cNvPr && cNvPr._attr.descr;
            picture.isVisible = !(node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(cNvPr && cNvPr._attr.hidden, false));
        }
        item = pic['xdr:blipFill'];
        if (item) {
            var blip = item['a:blip'];
            var rid = blip && blip._attr['r:embed'];
            var ext = blip && blip["a:extLst"] && blip["a:extLst"]["a:ext"];
            if (!(ext instanceof Array)) {
                ext = [ext];
            }
            for (var i in ext) {
                if (ext.hasOwnProperty(i)) {
                    var svgBlip = ext[i] && ext[i]["asvg:svgBlip"];
                    if (svgBlip) {
                        rid = svgBlip._attr['r:embed'];
                    }
                }
            }
            if (rid) {
                var imageFile = imageFiles[rid];
                if (imageFile) {
                    var imageContent = excel_helper_1.getImageContent(imageFile.fileName, getFileDataAndCleanData);
                    if (imageContent) {
                        picture.src = imageContent;
                    }
                }
            }
            var srcRectNode = item['a:srcRect'], srcRect = srcRectNode && srcRectNode._attr;
            if (srcRect) {
                var l = +srcRect.l || 0, t = +srcRect.t || 0, r = +srcRect.r || 0, b = +srcRect.b || 0;
                if (l || t || r || b) {
                    picture.srcRect = { l: l, t: t, r: r, b: b };
                }
            }
        }
        item = pic['xdr:spPr'];
        if (item) {
            picture.pictureFormat = readImageFormat(item);
            var xfrm = item['a:xfrm'];
            if (xfrm) {
                var rotValue = parseInt(xfrm._attr.rot, 10);
                if (rotValue) {
                    picture.rot = chart_reader_1.DrawingReader.getRotationDegree(rotValue);
                }
            }
        }
    }
}
function readLineFormat(node) {
    if (node) {
        var lineFormat = {};
        var attr = node._attr, width = parseInt(attr.w || '0', 10);
        lineFormat.width = excel_style_1.UnitHelper.emuToPixles(width);
        lineFormat.compoundLineType = attr.compd || 'sng';
        lineFormat.lineEndingCap = attr.cap || 'sq';
        lineFormat.penAlignment = attr.align || 'ctr';
        lineFormat.fillFormat = readFillFormat(node);
        lineFormat.headLineEndStyle = readLineEndStyle(node['a:headEnd']);
        lineFormat.tailLineEndStyle = readLineEndStyle(node['a:tailEnd']);
        if (node['a:bevel']) {
            lineFormat.joinType = 'bevel';
        }
        if (node['a:miter']) {
            lineFormat.joinType = 'miter';
        }
        if (node['a:round']) {
            lineFormat.joinType = 'round';
        }
        var item = node['a:prstDash'];
        lineFormat.lineDashType = item && item._attr.val || 'solid';
        return lineFormat;
    }
}
function readFillFormat(node) {
    var item = node['a:solidFill'];
    if (item) {
        return readSolidFillFormat(item);
    }
    item = node['a:pattFill'];
    if (item) {
        return readPatternFillFormat(item);
    }
    item = node['a:noFill'];
    if (item) {
        return readNoFillFormat();
    }
    item = node['a:gradFill'];
    if (item) {
        return readGradientFillFormat(item);
    }
    item = node['a:blipFill'];
    if (item) {
        return readBlipFillFormat(item);
    }
}
function readSolidFillFormat(node) {
    var drawingColorSettings = {}, color = readColor(node, drawingColorSettings);
    return {
        fillFormatType: 1,
        color: color,
        drawingColorSettings: drawingColorSettings
    };
}
function setDrawingColorSetting(drawingColorSettings, item, keys) {
    keys.forEach(function (key) {
        var node = item['a:' + key];
        if (node) {
            drawingColorSettings[key] = parseInt(node._attr.val || '0', 10);
        }
    });
}
function readColor(node, drawingColorSettings) {
    var value, clr, attr, item = node['a:schemeClr'];
    if (item) {
        value = (item._attr.val || '').toUpperCase();
        setDrawingColorSetting(drawingColorSettings, item, ['alpha', 'shade', 'tint', 'hue', 'hueOff', 'hueMod', 'sat', 'satOff', 'satMod', 'lum', 'lumOff', 'lumMod']);
        if (value) {
            return new excel_style_1.ExcelColor(3, excel_style_1.ColorHelper.toColorSchemeIndex(value), 0);
        }
    }
    item = node['a:hslClr'];
    if (item) {
        attr = item._attr;
        var h = parseInt(attr.hue || '0', 10), s = parseInt(attr.sat || '0', 10), l = parseInt(attr.lum || '0', 10);
        setDrawingColorSetting(drawingColorSettings, item, ['alpha', 'shade', 'tint']);
        return excel_style_1.ColorHelper.fromColorToExcelColor(excel_style_1.ColorHelper.convertHLSToRGB(h, l, s));
    }
    item = node['a:prstClr'];
    if (item) {
        value = (item._attr.val || '');
        setDrawingColorSetting(drawingColorSettings, item, ['alpha', 'shade', 'tint']);
        if (value) {
            return excel_style_1.ColorHelper.fromColorToExcelColor(excel_style_1.ColorHelper.fromPresetColorVal(value));
        }
    }
    item = node['a:scrgbClr'];
    if (item) {
        attr = item._attr;
        var r = parseInt(attr.r || '0', 10), g = parseInt(attr.g || '0', 10), b = parseInt(attr.b || '0', 10);
        setDrawingColorSetting(drawingColorSettings, item, ['alpha', 'shade', 'tint']);
        return excel_style_1.ColorHelper.fromColorToExcelColor(new excel_style_1._Color(255, excel_style_1.ColorHelper.scRgbTosRgb(r), excel_style_1.ColorHelper.scRgbTosRgb(g), excel_style_1.ColorHelper.scRgbTosRgb(b)));
    }
    item = node['a:srgbClr'];
    if (item) {
        clr = item._attr.val;
        setDrawingColorSetting(drawingColorSettings, item, ['alpha', 'shade', 'tint']);
        if (clr) {
            value = parseInt(clr, 16);
            if (!isNaN(value)) {
                return new excel_style_1.ExcelColor(2, value, 0);
            }
        }
    }
    item = node['a:sysClr'];
    if (item) {
        var name_1 = item._attr.val;
        var color = excel_style_1.ExcelSystemColor.getSystemColor(name_1);
        setDrawingColorSetting(drawingColorSettings, item, ['alpha', 'shade', 'tint', 'lumMode']);
        if (color) {
            return excel_style_1.ColorHelper.fromColorToExcelColor(color);
        }
    }
    return null;
}
function readLineEndStyle(node) {
    if (node) {
        var attr = node._attr;
        return {
            length: attr.len || 'lg',
            type: attr.type || 'none',
            width: attr.w || 'lg'
        };
    }
}
function readPatternFillFormat(node) {
    var style = node._attr.prst || 'pct5';
    var bgDrawingColorSettings, bgColor, fgDrawingColorSettings, fgColor;
    var item = node['a:bgClr'];
    if (item) {
        bgDrawingColorSettings = {};
        bgColor = readColor(item, bgDrawingColorSettings);
    }
    item = node['a:fgClr'];
    if (item) {
        fgDrawingColorSettings = {};
        fgColor = readColor(item, fgDrawingColorSettings);
    }
    return {
        fillFormatType: 4,
        fillPattern: style,
        backgroundDrawingColorSettings: bgDrawingColorSettings,
        backgroundColor: bgColor,
        foregroundDrawingColorSettings: fgDrawingColorSettings,
        foregroundColor: fgColor
    };
}
function readNoFillFormat() {
    return {
        fillFormatType: 0
    };
}
function readGradientFillFormat(node) {
    var gradientStops = [], attr = node._attr;
    var result = {
        fillFomatType: 2,
        gradientStops: gradientStops
    };
    result.flipMode = attr.flip || 'none';
    result.rotateWithShape = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.rotWithShape, false);
    var item = node['a:gsLst'];
    if (item) {
        getAsArray(item['a:gs']).forEach(function (n) {
            gradientStops.push(readGradientStop(n));
        });
    }
    item = node['a:lin'];
    if (item) {
        result.gradientFillType = 'linear';
        result.angle = parseFloat(item._attr.ang || '0') / 60000;
        result.scaled = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(item._attr.scaled, false);
    }
    item = node['a:path'];
    if (item) {
        result.gradientFillType = item._attr.path || 'shape';
        result.fillToRect = readRelativeRect(item['a:fillToRect']);
    }
    result.tileRect = readRelativeRect(node['a:tileRect']);
    return result;
}
function readGradientStop(node) {
    var drawingColorSettings = {}, color = readColor(node, drawingColorSettings);
    var position = parseFloat(node._attr.pos || '100000') / 100000;
    return {
        position: position,
        color: color,
        drawingColorSettings: drawingColorSettings
    };
}
function readBlipFillFormat(node) {
    var result = { transparency: 1 };
    result.rotateWithShape = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(node._attr.rotWithShape, false);
    var item = node['a:blip'];
    if (item) {
        result.imageID = item._attr['r:embed'];
        var alpha = item['a:alphaModFix'];
        if (alpha) {
            result.transparency = 1 - parseFloat(alpha._attr.amt || '0') / 100000;
        }
    }
    item = node['a:tile'];
    if (item) {
        result.tile = readTile(item);
    }
    item = node['a:stretch'];
    if (item) {
        result.stretch = readRelativeRect(item['a:fillRect']);
    }
    return result;
}
function readTile(node) {
    var attr = node._attr, sx = attr.sx, sy = attr.sy, tx = attr.tx, ty = attr.ty;
    return {
        alignment: attr.algn || 'tl',
        flipping: attr.flip || 'none',
        horizontalRatio: (sx && (parseFloat(sx) / 100000)) || 1,
        verticalRatio: (sy && (parseFloat(sy) / 100000)) || 1,
        horizontalOffset: (tx && (parseFloat(tx) / 100000)) || 0,
        verticalOffset: (ty && (parseFloat(ty) / 100000)) || 0
    };
}
function readRelativeRect(node) {
    if (node) {
        var attr = node._attr;
        return [attr.l, attr.t, attr.r, attr.b].map(function (sValue) {
            return parseFloat(sValue || '0') / 100000;
        });
    }
}
function readImageFormat(node) {
    var drawingFormat = {};
    drawingFormat.lineFormat = readLineFormat(node['a:ln']);
    var fillFormat = readFillFormat(node);
    if (fillFormat) {
        drawingFormat.fillFormat = fillFormat;
    }
    return drawingFormat;
}


/***/ }),

/***/ "./src/xlsx-io/reader/metadata-reader.ts":
/*!***********************************************!*\
  !*** ./src/xlsx-io/reader/metadata-reader.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var node_helper_1 = __webpack_require__(/*! ./../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var getAsArray = node_helper_1.XmlNodeHelper._getAsArray;
function getNameAttribute(item) {
    return item._attr.name;
}
function readSheetMetadata(dataString, readerDataModel) {
    var obj = xml_parser_1.parseXmlToObject(dataString);
    var root = obj.metadata;
    if (root) {
        var typeNames = getAsArray(root.metadataTypes.metadataType).map(getNameAttribute);
        root.typeNames = typeNames;
        readerDataModel._setSheetMetadata(root);
    }
}
exports.readSheetMetadata = readSheetMetadata;


/***/ }),

/***/ "./src/xlsx-io/reader/pivot-reader.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/reader/pivot-reader.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var xml_reader_1 = __webpack_require__(/*! ./../../xml-io/xml-reader */ "./src/xml-io/xml-reader.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var datetime_helper_1 = __webpack_require__(/*! ./../../datamodel/datetime-helper */ "./src/datamodel/datetime-helper.ts");
var xml_parser_1 = __webpack_require__(/*! ../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var autofilter_reader_1 = __webpack_require__(/*! ./autofilter-reader */ "./src/xlsx-io/reader/autofilter-reader.ts");
var excel_style_1 = __webpack_require__(/*! ../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var node_helper_1 = __webpack_require__(/*! ../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var captionCompareTypeExcel = {
    captionEqual: 0,
    captionNotEqual: 1,
    captionBeginsWith: 2,
    captionNotBeginsWith: 3,
    captionEndsWith: 4,
    captionNotEndsWith: 5,
    captionContains: 6,
    captionNotContains: 7,
    captionGreaterThan: 8,
    captionGreaterThanOrEqual: 9,
    captionLessThan: 10,
    captionLessThanOrEqual: 11,
    captionBetween: 12,
    captionNotBetween: 13
};
var valueCompareTypeExcel = {
    valueEqual: 0,
    valueNotEqual: 1,
    valueGreaterThan: 2,
    valueGreaterThanOrEqual: 3,
    valueLessThan: 4,
    valueLessThanOrEqual: 5,
    valueBetween: 6,
    valueNotBetween: 7
};
var dateCompareTypeExcel = {
    dateEqual: 0,
    dateNotEqual: 1,
    dateOlderThan: 2,
    dateOlderThanOrEqual: 3,
    dateNewerThan: 4,
    dateNewerThanOrEqual: 5,
    dateBetween: 6,
    dateNotBetween: 7,
    tomorrow: 10,
    today: 8,
    yesterday: 9,
    nextWeek: 17,
    thisWeek: 15,
    lastWeek: 16,
    nextMonth: 14,
    thisMonth: 12,
    lastMonth: 13,
    nextQuarter: 18,
    thisQuarter: 19,
    lastQuarter: 20,
    nextYear: 21,
    thisYear: 22,
    lastYear: 23,
    yearToDate: 40,
    Q1: 24,
    Q2: 25,
    Q3: 26,
    Q4: 27,
    M1: 28,
    M2: 29,
    M3: 30,
    M4: 31,
    M5: 32,
    M6: 33,
    M7: 34,
    M8: 35,
    M9: 36,
    M10: 37,
    M11: 38,
    M12: 39,
};
var top10CompareTypeExcel = {
    count: 0,
    percent: 1,
    sum: 2,
};
var keyword_undefined = void 0;
var xmlDecode = common_1.Util._xmlDecode;
function readPivotCacheDefinitions(dataString, readerDataModel, pivotCache) {
    var reader = new xml_reader_1.XmlReader();
    reader.setXml(dataString);
    while (reader.read()) {
        if (reader.depth !== 0 || reader.elementType === 2) {
            continue;
        }
        switch (reader.name()) {
            case 'pivotCacheDefinition':
                readPivotCacheDefinitionAttributes(reader, pivotCache);
                readPivotCacheDefinitionContents(reader, pivotCache);
                break;
        }
    }
}
exports.readPivotCacheDefinitions = readPivotCacheDefinitions;
function readPivotCacheDefinitionContents(reader, pivotCacheDefinition) {
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        switch (reader.name()) {
            case "cacheSource":
                readPivotCacheSource(reader, pivotCacheDefinition);
                break;
            case "cacheFields":
                readPivotCacheField(reader, pivotCacheDefinition);
                break;
            case "cacheHierarchy":
                readPivotCacheHierarchy(reader, pivotCacheDefinition);
                break;
            case "kpi":
                readPivotCachePCDKPI(reader, pivotCacheDefinition);
                break;
            case "tupleCache":
                readPivotCacheTupleCache(reader, pivotCacheDefinition);
                break;
            case "calculatedItem":
                readCalculatedItem(reader, pivotCacheDefinition);
                break;
            case "calculatedMember":
                readCalculatedMember(reader, pivotCacheDefinition);
                break;
            case "dimension":
                readPivotCacheDimension(reader, pivotCacheDefinition);
                break;
            case "measureGroup":
                readPivotCacheMeasureGroup(reader, pivotCacheDefinition);
                break;
            case "map":
                readPivotCacheMeasureDimensionMap(reader, pivotCacheDefinition);
                break;
            case "extLst":
                readPivotCacheDefinitionExtension(reader, pivotCacheDefinition);
                break;
        }
    }
}
function readPivotCacheDefinitionAttributes(reader, pivotCacheDefinition) {
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "backgroundQuery":
                pivotCacheDefinition.backgroundQuery = reader.readContentAsBoolean();
                break;
            case "createdVersion":
                pivotCacheDefinition.createdVersion = reader.readContentAsInt();
                break;
            case "enableRefresh":
                pivotCacheDefinition.enableRefresh = reader.readContentAsBoolean();
                break;
            case "r:id":
                pivotCacheDefinition.rid = reader.readContentAsString();
                break;
            case "invalid":
                pivotCacheDefinition.invalid = reader.readContentAsBoolean();
                break;
            case "minRefreshableVersion":
                pivotCacheDefinition.minRefreshableVersion = reader.readContentAsInt();
                break;
            case "missingItemsLimit":
                pivotCacheDefinition.missingItemsLimit = reader.readContentAsInt();
                break;
            case "recordCount":
                pivotCacheDefinition.recordCount = reader.readContentAsInt();
                break;
            case "optimizeMemory":
                pivotCacheDefinition.optimizeMemory = reader.readContentAsBoolean();
                break;
            case "refreshedBy":
                pivotCacheDefinition.refreshedBy = reader.readContentAsString();
                break;
            case "refreshedDate":
                pivotCacheDefinition.refreshedDate = datetime_helper_1.DateTimeHelper._fromOADate(reader.readContentAsDouble());
                break;
            case "refreshedVersion":
                pivotCacheDefinition.refreshedVersion = reader.readContentAsInt();
                break;
            case "refreshOnLoad":
                pivotCacheDefinition.refreshOnLoad = reader.readContentAsBoolean();
                break;
            case "saveData":
                pivotCacheDefinition.saveData = reader.readContentAsBoolean();
                break;
            case "supportAdvancedDrill":
                pivotCacheDefinition.supportAdvancedDrill = reader.readContentAsBoolean();
                break;
            case "supportSubquery":
                pivotCacheDefinition.supportSubquery = reader.readContentAsBoolean();
                break;
            case "tupleCache":
                pivotCacheDefinition.tupleCache = reader.readContentAsBoolean();
                break;
            case "upgradeOnRefresh":
                pivotCacheDefinition.upgradeOnRefresh = reader.readContentAsBoolean();
                break;
        }
    }
}
function readPivotCacheSource(reader, pivotCacheDefinition) {
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "type":
                pivotCacheDefinition.sourceType = reader.readContentAsString();
                break;
            case "connectionId":
                pivotCacheDefinition.sourceConnectionId = reader.readContentAsInt();
                break;
        }
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        switch (reader.name()) {
            case "worksheetSource":
                while (reader.moveToNextAttribute()) {
                    var attrName = reader.readAttributeNameAsString();
                    switch (attrName) {
                        case "ref":
                            pivotCacheDefinition.ref = reader.readContentAsString();
                            break;
                        case "sheet":
                            pivotCacheDefinition.sheet = reader.readContentAsString();
                            break;
                        case "name":
                            pivotCacheDefinition.sourceName = reader.readContentAsString();
                            break;
                        default:
                            break;
                    }
                }
                break;
        }
    }
}
function readPivotCacheField(reader, pivotCacheDefinition) {
    pivotCacheDefinition.fields = [];
    var fieldsDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= fieldsDepth) {
            break;
        }
        var field = {};
        while (reader.moveToNextAttribute()) {
            switch (reader.readAttributeNameAsString()) {
                case "caption":
                    field.caption = reader.readContentAsString();
                    break;
                case "databaseField":
                    field.databaseField = reader.readContentAsBoolean();
                    break;
                case "formula":
                    field.formula = reader.readContentAsString();
                    break;
                case "hierarchy":
                    field.hierarchy = reader.readContentAsInt();
                    break;
                case "level":
                    field.level = reader.readContentAsInt();
                    break;
                case "mappingCount":
                    field.mappingCount = reader.readContentAsInt();
                    break;
                case "memberPropertyField":
                    field.memberPropertyField = reader.readContentAsBoolean();
                    break;
                case "name":
                    field.name = xmlDecode(reader.readContentAsString());
                    break;
                case "numFmtId":
                    field.numFmtId = reader.readContentAsInt();
                    break;
                case "propertyName":
                    field.propertyName = reader.readContentAsString();
                    break;
                case "serverField":
                    field.serverField = reader.readContentAsBoolean();
                    break;
                case "sqlType":
                    field.sqlType = reader.readContentAsInt();
                    break;
                case "uniqueList":
                    field.uniqueList = reader.readContentAsBoolean();
                    break;
            }
        }
        if (reader.elementType !== 3) {
            var fieldDepth = reader.depth;
            while (reader.read()) {
                if (reader.depth <= fieldDepth) {
                    break;
                }
                switch (reader.name()) {
                    case "sharedItems":
                        readSharedItemAttributes(reader, field);
                        readSharedItemContents(reader, field);
                        break;
                    case "fieldGroup":
                        var fieldGroup = {};
                        readFieldGroupAttributes(reader, fieldGroup);
                        if (!common_1.isNullOrUndefined(fieldGroup.base)) {
                            readFieldGroupContents(reader, fieldGroup);
                        }
                        field.fieldGroup = fieldGroup;
                        break;
                    case "mpMap":
                        field.mpMap = [];
                        while (reader.moveToNextAttribute()) {
                            if (reader.readAttributeNameAsString() === 'v') {
                                field.mpMap.push(reader.readContentAsInt());
                            }
                        }
                        break;
                }
            }
        }
        pivotCacheDefinition.fields.push(field);
    }
}
function readFieldGroupAttributes(reader, fieldGroup) {
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "par":
                fieldGroup.parent = reader.readContentAsInt();
                break;
            case "base":
                fieldGroup.base = reader.readContentAsInt();
                break;
        }
    }
}
function readFieldGroupContents(reader, fieldGroup) {
    var fieldGroupDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= fieldGroupDepth) {
            break;
        }
        switch (reader.name()) {
            case "rangePr":
                fieldGroup.hasRangeGroup = true;
                while (reader.moveToNextAttribute()) {
                    switch (reader.readAttributeNameAsString()) {
                        case "autoStart":
                            fieldGroup.autoStart = reader.readContentAsBoolean();
                            break;
                        case "autoEnd":
                            fieldGroup.autoEnd = reader.readContentAsBoolean();
                            break;
                        case "groupBy":
                            fieldGroup.groupBy = reader.readContentAsString();
                            break;
                        case "startNum":
                            fieldGroup.startNum = reader.readContentAsDouble();
                            break;
                        case "endNum":
                            fieldGroup.endNum = reader.readContentAsDouble();
                            break;
                        case "startDate":
                            fieldGroup.startDate = Date.parse(reader.readContentAsString());
                            break;
                        case "endDate":
                            fieldGroup.endDate = Date.parse(reader.readContentAsString());
                            break;
                        case "groupInterval":
                            fieldGroup.groupInterval = reader.readContentAsDouble();
                            break;
                    }
                }
                break;
            case "discretePr":
                fieldGroup.discreteGroup = [];
                var discretePrDepth = reader.depth;
                while (reader.read()) {
                    if (reader.depth <= discretePrDepth) {
                        break;
                    }
                    if (reader.name() === 'x') {
                        while (reader.moveToNextAttribute()) {
                            if (reader.readAttributeNameAsString() === 'v') {
                                fieldGroup.discreteGroup.push(reader.readContentAsInt());
                            }
                        }
                    }
                }
                break;
            case "groupItems":
                fieldGroup.groupItems = [];
                var groupItemsDepth = reader.depth;
                while (reader.read()) {
                    if (reader.depth <= groupItemsDepth) {
                        break;
                    }
                    fieldGroup.groupItems.push(readPivotEntityItem(reader));
                }
                break;
        }
    }
}
function readSharedItemAttributes(reader, field) {
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "containsBlank":
                field.containsBlank = reader.readContentAsBoolean();
                break;
            case "containsDate":
                field.containsDate = reader.readContentAsBoolean();
                break;
            case "containsInteger":
                field.containsInteger = reader.readContentAsBoolean();
                break;
            case "containsMixedTypes":
                field.containsMixedTypes = reader.readContentAsBoolean();
                break;
            case "containsNonDate":
                field.containsNonDate = reader.readContentAsBoolean();
                break;
            case "containsNumber":
                field.containsNumber = reader.readContentAsBoolean();
                break;
            case "containsSemiMixedTypes":
                field.containsSemiMixedTypes = reader.readContentAsBoolean();
                break;
            case "containsString":
                field.containsString = reader.readContentAsBoolean();
                break;
            case "longText":
                field.longText = reader.readContentAsBoolean();
                break;
            case "maxDate":
                field.maxDate = Date.parse(reader.readContentAsString());
                break;
            case "maxValue":
                field.maxValue = reader.readContentAsDouble();
                break;
            case "minDate":
                field.minDate = Date.parse(reader.readContentAsString());
                break;
            case "minValue":
                field.minValue = reader.readContentAsDouble();
                break;
        }
    }
}
function readSharedItemContents(reader, field) {
    field.entities = [];
    var sharedItemsDepth = reader.depth;
    if (reader.elementType === 3) {
        return;
    }
    while (reader.read()) {
        if (reader.depth <= sharedItemsDepth) {
            break;
        }
        field.entities.push(readPivotEntityItem(reader));
    }
}
function readPivotEntityItem(reader) {
    var pivotEntityItem = {};
    var type = reader.name();
    switch (type) {
        case "b":
            pivotEntityItem.type = 'b';
            break;
        case "d":
            pivotEntityItem.type = 'd';
            break;
        case "e":
            pivotEntityItem.type = 'e';
            break;
        case "m":
            pivotEntityItem.type = 'm';
            break;
        case "n":
            pivotEntityItem.type = 'n';
            break;
        case "s":
            pivotEntityItem.type = 's';
            break;
    }
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "c":
                pivotEntityItem.caption = reader.readContentAsString();
                break;
            case "cp":
                pivotEntityItem.propertyCount = reader.readContentAsInt();
                break;
            case "f":
                pivotEntityItem.isCalculatedItem = reader.readContentAsBoolean();
                break;
            case "u":
                pivotEntityItem.isUnusedItem = reader.readContentAsBoolean();
                break;
            case "b":
                pivotEntityItem.isBold = reader.readContentAsBoolean();
                break;
            case "bc":
                pivotEntityItem.backgroundColor = reader.readContentAsInt();
                break;
            case "fc":
                pivotEntityItem.foregroundColor = reader.readContentAsInt();
                break;
            case "i":
                pivotEntityItem.isItalic = reader.readContentAsBoolean();
                break;
            case "in":
                pivotEntityItem.formatIndex = reader.readContentAsInt();
                break;
            case "st":
                pivotEntityItem.isStrikethrough = reader.readContentAsBoolean();
                break;
            case "un":
                pivotEntityItem.isUnderline = reader.readContentAsBoolean();
                break;
            case "v":
                switch (type) {
                    case "b":
                        pivotEntityItem.value = reader.readContentAsBoolean();
                        break;
                    case "d":
                        pivotEntityItem.value = common_1.Util._decodeSpecialCharacterFromXML(reader.readContentAsString());
                        break;
                    case "e":
                        pivotEntityItem.value = reader.readContentAsError();
                        break;
                    case "n":
                        pivotEntityItem.value = reader.readContentAsDouble();
                        break;
                    case "s":
                        pivotEntityItem.value = reader.readContentAsString();
                        break;
                    case "x":
                        pivotEntityItem.value = reader.readContentAsString();
                        break;
                }
                break;
        }
    }
    return pivotEntityItem;
}
function readPivotCacheHierarchy(reader, pivotCacheDefinition) {
    pivotCacheDefinition.cacheHierarchies = [];
    while (reader.read()) {
        var hierarchy = {
            fieldsUsages: [],
            groupLevels: []
        };
        while (reader.moveToNextAttribute()) {
            switch (reader.readAttributeNameAsString()) {
                case "uniqueName":
                    hierarchy.uniqueName = reader.readContentAsString();
                    break;
                case "caption":
                    hierarchy.caption = reader.readContentAsString();
                    break;
                case "measure":
                    hierarchy.measure = reader.readContentAsBoolean();
                    break;
                case "set":
                    hierarchy.set = reader.readContentAsBoolean();
                    break;
                case "parentSet":
                    hierarchy.parentSet = reader.readContentAsInt();
                    break;
                case "iconSet":
                    hierarchy.iconSet = reader.readContentAsInt();
                    break;
                case "attribute":
                    hierarchy.attribute = reader.readContentAsBoolean();
                    break;
                case "time":
                    hierarchy.time = reader.readContentAsBoolean();
                    break;
                case "keyAttribute":
                    hierarchy.keyAttribute = reader.readContentAsBoolean();
                    break;
                case "defaultMemberUniqueName":
                    hierarchy.defaultMemberUniqueName = reader.readContentAsString();
                    break;
                case "allUniqueName":
                    hierarchy.allUniqueName = reader.readContentAsString();
                    break;
                case "allCaption":
                    hierarchy.allCaption = reader.readContentAsString();
                    break;
                case "dimensionUniqueName":
                    hierarchy.dimensionUniqueName = reader.readContentAsString();
                    break;
                case "displayFolder":
                    hierarchy.displayFolder = reader.readContentAsString();
                    break;
                case "measureGroup":
                    hierarchy.measureGroup = reader.readContentAsString();
                    break;
                case "measures":
                    hierarchy.measures = reader.readContentAsBoolean();
                    break;
                case "count":
                    hierarchy.count = reader.readContentAsInt();
                    break;
                case "oneField":
                    hierarchy.oneField = reader.readContentAsBoolean();
                    break;
                case "memberValueDatatype":
                    hierarchy.memberValueDatatype = reader.readContentAsInt();
                    break;
                case "unbalanced":
                    hierarchy.unbalanced = reader.readContentAsBoolean();
                    break;
                case "unbalancedGroup":
                    hierarchy.unbalancedGroup = reader.readContentAsBoolean();
                    break;
                case "hidden":
                    hierarchy.hidden = reader.readContentAsBoolean();
                    break;
            }
        }
        var depth = reader.depth;
        while (reader.read()) {
            if (reader.depth <= depth) {
                break;
            }
            switch (reader.name()) {
                case "fieldUsage":
                    hierarchy.fieldsUsages.push(reader.readContentAsInt());
                    break;
                case "groupLevel":
                    hierarchy.groupLevels.push(readPivotCacheGroupLevel(reader));
                    break;
            }
        }
        pivotCacheDefinition.cacheHierarchies.push(hierarchy);
    }
}
function readPivotCacheGroupLevel(reader) {
    var groupLevel = {};
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "uniqueName":
                groupLevel.uniqueName = reader.readContentAsString();
                break;
            case "caption":
                groupLevel.caption = reader.readContentAsString();
                break;
            case "user":
                groupLevel.user = reader.readContentAsBoolean();
                break;
            case "customRollUp":
                groupLevel.customRollUp = reader.readContentAsBoolean();
                break;
        }
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.name()) {
            groupLevel.groups.push(readPivotCacheLevelGroup(reader));
        }
    }
    return groupLevel;
}
function readPivotCacheLevelGroup(reader) {
    var levelGroup = {
        groupMembers: []
    };
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "name":
                levelGroup.Name = reader.readContentAsString();
                break;
            case "uniqueName":
                levelGroup.UniqueName = reader.readContentAsString();
                break;
            case "caption":
                levelGroup.Caption = reader.readContentAsString();
                break;
            case "uniqueParent":
                levelGroup.UniqueParent = reader.readContentAsString();
                break;
            case "id":
                levelGroup.Id = reader.readContentAsInt();
                break;
        }
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.name() === 'groupMember') {
            var groupMember = {};
            while (reader.moveToNextAttribute()) {
                switch (reader.name()) {
                    case "uniqueName":
                        groupMember.uniqueName = reader.readContentAsString();
                        break;
                    case "group":
                        groupMember.group = reader.readContentAsBoolean();
                        break;
                }
            }
            levelGroup.groupMembers.push(groupMember);
        }
    }
    return levelGroup;
}
function readPivotCachePCDKPI(reader, pivotCacheDefinition) {
    pivotCacheDefinition.KPIs = [];
    while (reader.moveToNextAttribute()) {
        var kpi = {};
        switch (reader.readAttributeNameAsString()) {
            case "uniqueName":
                kpi.uniqueName = reader.readContentAsString();
                break;
            case "caption":
                kpi.caption = reader.readContentAsString();
                break;
            case "displayFolder":
                kpi.displayFolder = reader.readContentAsString();
                break;
            case "measureGroup":
                kpi.measureGroup = reader.readContentAsString();
                break;
            case "parent":
                kpi.parent = reader.readContentAsString();
                break;
            case "value":
                kpi.value = reader.readContentAsString();
                break;
            case "goal":
                kpi.goal = reader.readContentAsString();
                break;
            case "status":
                kpi.status = reader.readContentAsString();
                break;
            case "trend":
                kpi.trend = reader.readContentAsString();
                break;
            case "weight":
                kpi.weight = reader.readContentAsString();
                break;
            case "time":
                kpi.time = reader.readContentAsString();
                break;
        }
        pivotCacheDefinition.KPIs.push(kpi);
    }
}
var PivotReader = /** @class */ (function () {
    function PivotReader() {
    }
    PivotReader.readPivotCacheSet = function (reader) {
    };
    PivotReader.readPivotCacheQuery = function (reader) {
    };
    PivotReader.readPivotCacheServerFormat = function (reader) {
    };
    return PivotReader;
}());
function readPivotCacheTupleCache(reader, pivotCacheDefinition) {
    var pivotCacheTupleCache = {
        entries: []
    };
    while (reader.read()) {
        switch (reader.name()) {
            case "entries":
                var depth = reader.depth;
                while (reader.read() && (reader.depth > depth)) {
                    pivotCacheTupleCache.entries.push(readPivotEntityItem(reader));
                }
                break;
            case "set":
                break;
            case "query":
                break;
            case "serverFormats":
                break;
        }
    }
    pivotCacheDefinition.pivotCacheTupleCache = pivotCacheTupleCache;
}
function readCalculatedItem(reader, pivotCacheDefinition) {
    var pivotCalculatedItem = {};
    pivotCacheDefinition.calculatedItems = [];
    while (reader.moveToNextAttribute()) {
        switch (reader.name()) {
            case "field":
                pivotCalculatedItem.field = reader.readContentAsInt();
                break;
            case "formula":
                pivotCalculatedItem.formula = reader.readContentAsString();
                break;
        }
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.name() === "pivotArea") {
            pivotCalculatedItem.pivotArea = readPivotArea(reader);
        }
    }
    pivotCacheDefinition.calculatedItems.push(pivotCalculatedItem);
}
function readCalculatedMember(reader, pivotCacheDefinition) {
    var pivotCalculatedMember = {};
    while (reader.moveToNextAttribute()) {
        switch (reader.name()) {
            case "name":
                pivotCalculatedMember.name = xmlDecode(reader.readContentAsString());
                break;
            case "mdx":
                pivotCalculatedMember.mdx = reader.readContentAsString();
                break;
            case "memberName":
                pivotCalculatedMember.memberName = reader.readContentAsString();
                break;
            case "hierarchy":
                pivotCalculatedMember.hierarchy = reader.readContentAsString();
                break;
            case "parent":
                pivotCalculatedMember.parent = reader.readContentAsString();
                break;
            case "solveOrder":
                pivotCalculatedMember.solveOrder = reader.readContentAsInt();
                break;
            case "set":
                pivotCalculatedMember.set = reader.readContentAsBoolean();
                break;
        }
    }
    pivotCacheDefinition.calculatedMembers.push(pivotCalculatedMember);
}
function readPivotCacheDimension(reader, pivotCacheDefinition) {
    var pivotCacheDimension = {};
    while (reader.moveToNextAttribute()) {
        switch (reader.name()) {
            case "name":
            case "measure":
                pivotCacheDimension.measure = reader.readContentAsBoolean();
                break;
            case "name":
                pivotCacheDimension.name = xmlDecode(reader.readContentAsString());
                break;
            case "uniqueName":
                pivotCacheDimension.uniqueName = reader.readContentAsString();
                break;
            case "caption":
                pivotCacheDimension.caption = reader.readContentAsString();
                break;
        }
    }
    pivotCacheDefinition.dimensions.push(pivotCacheDimension);
}
function readPivotCacheMeasureGroup(reader, pivotCacheDefinition) {
    var pivotCacheMeasureGroup = {};
    while (reader.moveToNextAttribute()) {
        switch (reader.name()) {
            case "name":
                pivotCacheMeasureGroup.name = xmlDecode(reader.readContentAsString());
                break;
            case "caption":
                pivotCacheMeasureGroup.caption = reader.readContentAsString();
                break;
        }
    }
    pivotCacheDefinition.measureGroups.push(pivotCacheMeasureGroup);
}
function readPivotCacheMeasureDimensionMap(reader, pivotCacheDefinition) {
    var pivotCacheMeasureDimensionMap = {};
    while (reader.moveToNextAttribute()) {
        switch (reader.name()) {
            case "measureGroup":
                pivotCacheMeasureDimensionMap.name = reader.readContentAsInt();
                break;
            case "dimension":
                pivotCacheMeasureDimensionMap.caption = reader.readContentAsInt();
                break;
        }
    }
    pivotCacheDefinition.measureDimensionMap.push(pivotCacheMeasureDimensionMap);
}
function readPivotCacheDefinitionExtension(reader, pivotCacheDefinition) {
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.name() === 'ext') {
            var extDepth = reader.depth;
            while (reader.read()) {
                if (reader.depth <= extDepth) {
                    break;
                }
                if (reader.name() === "x14:pivotCacheDefinition") {
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === "pivotCacheId") {
                            pivotCacheDefinition._pivotCacheId = reader.readContentAsInt();
                        }
                    }
                }
            }
        }
    }
}
function readPivotCacheRecords(dataString, pivotCache) {
    var reader = new xml_reader_1.XmlReader();
    reader.setXml(dataString);
    var result = [];
    while (reader.read()) {
        if (reader.depth !== 0 || reader.elementType === 2) {
            continue;
        }
        if (reader.name() === 'pivotCacheRecords') {
            var depth = reader.depth;
            while (reader.read()) {
                if (reader.depth <= depth) {
                    break;
                }
                if (reader.name() === 'r') {
                    var row = [];
                    var rDepth = reader.depth;
                    while (reader.read()) {
                        if (reader.depth <= rDepth) {
                            break;
                        }
                        var elementName = reader.name();
                        var pivotEntityItem = {};
                        while (reader.moveToNextAttribute()) {
                            switch (reader.readAttributeNameAsString()) {
                                case 'v':
                                    switch (elementName) {
                                        case 'b':
                                            pivotEntityItem.type = excel_types_1.PivotSharedItemType.B;
                                            pivotEntityItem.value = reader.readContentAsBoolean();
                                            break;
                                        case 'd':
                                            pivotEntityItem.type = excel_types_1.PivotSharedItemType.D;
                                            pivotEntityItem.value = common_1.Util._decodeSpecialCharacterFromXML(reader.readContentAsString());
                                            break;
                                        case 'e':
                                            pivotEntityItem.type = excel_types_1.PivotSharedItemType.E;
                                            pivotEntityItem.value = reader.readContentAsError();
                                            break;
                                        case 'm':
                                            pivotEntityItem.type = excel_types_1.PivotSharedItemType.M;
                                            pivotEntityItem.value = null;
                                            break;
                                        case 'n':
                                            pivotEntityItem.type = excel_types_1.PivotSharedItemType.N;
                                            pivotEntityItem.value = reader.readContentAsDouble();
                                            break;
                                        case 's':
                                            pivotEntityItem.type = excel_types_1.PivotSharedItemType.S;
                                            pivotEntityItem.value = common_1.Util._decodeSpecialCharacterFromXML(reader.readContentAsString());
                                            break;
                                        case 'x':
                                            pivotEntityItem.type = excel_types_1.PivotSharedItemType.X;
                                            pivotEntityItem.value = reader.readContentAsInt();
                                            break;
                                    }
                                    break;
                                case "c":
                                    pivotEntityItem.caption = reader.readContentAsString();
                                    break;
                                case "cp":
                                    pivotEntityItem.propertyCount = reader.readContentAsInt();
                                    break;
                                case "f":
                                    pivotEntityItem.isCalculatedItem = reader.readContentAsBoolean();
                                    break;
                                case "u":
                                    pivotEntityItem.isUnusedItem = reader.readContentAsBoolean();
                                    break;
                                case "b":
                                    pivotEntityItem.isBold = reader.readContentAsBoolean();
                                    break;
                                case "bc":
                                    pivotEntityItem.backgroundColor = reader.readContentAsInt();
                                    break;
                                case "fc":
                                    pivotEntityItem.foregroundColor = reader.readContentAsInt();
                                    break;
                                case "i":
                                    pivotEntityItem.isItalic = reader.readContentAsBoolean();
                                    break;
                                case "in":
                                    pivotEntityItem.formatIndex = reader.readContentAsInt();
                                    break;
                                case "st":
                                    pivotEntityItem.isStrikethrough = reader.readContentAsBoolean();
                                    break;
                                case "un":
                                    pivotEntityItem.isUnderline = reader.readContentAsBoolean();
                                    break;
                            }
                        }
                        row.push(pivotEntityItem);
                    }
                    result.push(row);
                }
            }
        }
    }
    pivotCache.pivotCacheRecords = result;
}
exports.readPivotCacheRecords = readPivotCacheRecords;
function readPivotTableDefinition(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData) {
    var pivotTableFiles = [], pivotTables = [];
    if (relationFiles) {
        for (var key in relationFiles) {
            if (key !== 'count') {
                var relationFile = relationFiles[key];
                if (relationFile) {
                    var fileType = relationFile.fileType;
                    if (fileType === excel_types_1.RelationshipConstants._relationshipPivotTableType) {
                        pivotTableFiles.push(relationFile);
                    }
                }
            }
        }
    }
    for (var i = 0; i < pivotTableFiles.length; i++) {
        var dataString = getFileDataAndCleanData(pivotTableFiles[i].fileName);
        if (dataString) {
            try {
                pivotTables.push(_readPivotTableDefinition(dataString, readerDataModel, readerDataModel._spread.sheets[sheetName]));
            }
            catch (e) {
            }
        }
    }
    readerDataModel._setPivotTables(pivotTables, sheetName);
}
exports.readPivotTableDefinition = readPivotTableDefinition;
function _readPivotTableDefinition(dataString, readerDataModel, sheet, pivotCaches, rules) {
    var reader = new xml_reader_1.XmlReader();
    reader.setXml(dataString);
    var pivotTable = {
        fields: [],
        chartFormats: [],
        pivotFilters: [],
        formats: [],
        rowFields: [],
        rowItems: [],
        columnFields: [],
        columnItems: [],
        pageFields: [],
        dataFields: [],
        pivotHierarchies: []
    };
    pivotTable.hideValuesRow = false;
    if (readerDataModel && readerDataModel._pivotNamesForIO === undefined) {
        readerDataModel._pivotNamesForIO = [];
    }
    while (reader.read()) {
        if (reader.depth !== 0 || reader.elementType === 2) {
            continue;
        }
        if (reader.name() === "pivotTableDefinition") {
            readPivotTableDefinitionAttributes(reader, pivotTable, readerDataModel);
            readPivotTableDefinitionContents(reader, pivotTable, readerDataModel, sheet);
        }
    }
    return pivotTable;
}
function _getUniqueName(name, arr) {
    var nameSeparator = "_";
    var names = name.split(nameSeparator);
    if (isNaN(parseInt(names[names.length - 1], 10))) {
        name += nameSeparator + "1";
    }
    else {
        var index = names[names.length - 1];
        names.splice(names.length - 1, 1, nameSeparator + (parseInt(index, 10) + 1));
        name = names.join("");
    }
    if (arr.indexOf(name) !== -1) {
        name = _getUniqueName(name, arr);
    }
    return name;
}
function readPivotTableDefinitionAttributes(reader, pivotTable, readerDataModel) {
    pivotTable.outline = false;
    pivotTable.outlineData = false;
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "applyAlignmentFormats":
                pivotTable.applyAlignmentFormats = reader.readContentAsBoolean();
                break;
            case "applyBorderFormats":
                pivotTable.applyBorderFormats = reader.readContentAsBoolean();
                break;
            case "applyFontFormats":
                pivotTable.applyFontFormats = reader.readContentAsBoolean();
                break;
            case "applyNumberFormats":
                pivotTable.applyNumberFormats = reader.readContentAsBoolean();
                break;
            case "applyPatternFormats":
                pivotTable.applyPatternFormats = reader.readContentAsBoolean();
                break;
            case "applyWidthHeightFormats":
                pivotTable.applyWidthHeightFormats = reader.readContentAsBoolean();
                break;
            case "asteriskTotals":
                pivotTable.asteriskTotals = reader.readContentAsBoolean();
                break;
            case "autoFormatId":
                pivotTable.autoFormatId = reader.readContentAsInt();
                break;
            case "cacheId":
                pivotTable.cacheId = reader.readContentAsInt();
                break;
            case "chartFormat":
                pivotTable.chartFormat = reader.readContentAsInt();
                break;
            case "colGrandTotals":
                pivotTable.colGrandTotals = reader.readContentAsBoolean();
                break;
            case "colHeaderCaption":
                pivotTable.colHeaderCaption = reader.readContentAsString();
                break;
            case "compact":
                pivotTable.compact = reader.readContentAsBoolean();
                break;
            case "compactData":
                pivotTable.compactData = reader.readContentAsBoolean();
                break;
            case "createdVersion":
                pivotTable.createdVersion = reader.readContentAsInt();
                break;
            case "customListSort":
                pivotTable.customListSort = reader.readContentAsBoolean();
                break;
            case "dataCaption":
                pivotTable.dataCaption = reader.readContentAsString();
                break;
            case "disableFieldList":
                pivotTable.disableFieldList = reader.readContentAsBoolean();
                break;
            case "editData":
                pivotTable.editData = reader.readContentAsBoolean();
                break;
            case "enableDrill":
                pivotTable.enableDrill = reader.readContentAsBoolean();
                break;
            case "enableFieldProperties":
                pivotTable.enableFieldProperties = reader.readContentAsBoolean();
                break;
            case "enableWizard":
                pivotTable.enableWizard = reader.readContentAsBoolean();
                break;
            case "errorCaption":
                pivotTable.errorCaption = reader.readContentAsString();
                break;
            case "fieldListSortAscending":
                pivotTable.fieldListSortAscending = reader.readContentAsBoolean();
                break;
            case "fieldPrintTitles":
                pivotTable.fieldPrintTitles = reader.readContentAsBoolean();
                break;
            case "grandTotalCaption":
                pivotTable.grandTotalCaption = reader.readContentAsString();
                break;
            case "gridDropZones":
                pivotTable.gridDropZones = reader.readContentAsBoolean();
                break;
            case "immersive":
                pivotTable.immersive = reader.readContentAsBoolean();
                break;
            case "indent":
                pivotTable.indent = reader.readContentAsInt();
                break;
            case "itemPrintTitles":
                pivotTable.itemPrintTitles = reader.readContentAsBoolean();
                break;
            case "mdxSubqueries":
                pivotTable.mdxSubqueries = reader.readContentAsBoolean();
                break;
            case "mergeItem":
                pivotTable.mergeItem = reader.readContentAsBoolean();
                break;
            case "minRefreshableVersion":
                pivotTable.minRefreshableVersion = reader.readContentAsInt();
                break;
            case "missingCaption":
                pivotTable.missingCaption = reader.readContentAsString();
                break;
            case "multipleFieldFilters":
                pivotTable.multipleFieldFilters = reader.readContentAsBoolean();
                break;
            case "name":
                var name_1 = xmlDecode(reader.readContentAsString());
                var pivotNames = readerDataModel && readerDataModel._pivotNamesForIO;
                if (pivotNames && pivotNames.indexOf(name_1) !== -1) {
                    name_1 = _getUniqueName(name_1, pivotNames);
                }
                pivotTable.name = name_1;
                pivotNames.push(name_1);
                break;
            case "outline":
                pivotTable.outline = reader.readContentAsBoolean();
                break;
            case "outlineData":
                pivotTable.outlineData = reader.readContentAsBoolean();
                break;
            case "pageOverThenDown":
                pivotTable.pageOverThenDown = reader.readContentAsBoolean();
                break;
            case "pageStyle":
                pivotTable.pageStyle = reader.readContentAsString();
                break;
            case "pageWrap":
                pivotTable.pageWrap = reader.readContentAsInt();
                break;
            case "pivotTableStyle":
                pivotTable.pivotTableStyle = reader.readContentAsString();
                break;
            case "preserveFormatting":
                pivotTable.preserveFormatting = reader.readContentAsBoolean();
                break;
            case "printDrill":
                pivotTable.printDrill = reader.readContentAsBoolean();
                break;
            case "published":
                pivotTable.published = reader.readContentAsBoolean();
                break;
            case "rowGrandTotals":
                pivotTable.rowGrandTotals = reader.readContentAsBoolean();
                break;
            case "rowHeaderCaption":
                pivotTable.rowHeaderCaption = reader.readContentAsString();
                break;
            case "showCalcMbrs":
                pivotTable.showCalcMbrs = reader.readContentAsBoolean();
                break;
            case "showDataDropDown":
                pivotTable.showDataDropDown = reader.readContentAsBoolean();
                break;
            case "showDataTips":
                pivotTable.showDataTips = reader.readContentAsBoolean();
                break;
            case "showDrill":
                pivotTable.showDrill = reader.readContentAsBoolean();
                break;
            case "showDropZones":
                pivotTable.showDropZones = reader.readContentAsBoolean();
                break;
            case "showEmptyCol":
                pivotTable.showEmptyCol = reader.readContentAsBoolean();
                break;
            case "showEmptyRow":
                pivotTable.showEmptyRow = reader.readContentAsBoolean();
                break;
            case "showError":
                pivotTable.showError = reader.readContentAsBoolean();
                break;
            case "showHeaders":
                pivotTable.showHeaders = reader.readContentAsBoolean();
                break;
            case "showItems":
                pivotTable.showItems = reader.readContentAsBoolean();
                break;
            case "showMemberPropertyTips":
                pivotTable.showMemberPropertyTips = reader.readContentAsBoolean();
                break;
            case "showMissing":
                pivotTable.showMissing = reader.readContentAsBoolean();
                break;
            case "showMultipleLabel":
                pivotTable.showMultipleLabel = reader.readContentAsBoolean();
                break;
            case "subtotalHiddenItems":
                pivotTable.subtotalHiddenItems = reader.readContentAsBoolean();
                break;
            case "tag":
                pivotTable.tag = reader.readContentAsString();
                break;
            case "updatedVersion":
                pivotTable.updatedVersion = reader.readContentAsInt();
                break;
            case "useAutoFormatting":
                pivotTable.useAutoFormatting = reader.readContentAsBoolean();
                break;
            case "vacatedStyle":
                pivotTable.vacatedStyle = reader.readContentAsString();
                break;
            case "visualTotals":
                pivotTable.visualTotals = reader.readContentAsBoolean();
                break;
        }
    }
}
function readPivotTableDefinitionContents(reader, pivotTable, readerDataModel, sheet) {
    var depth = reader.depth, rules = sheet && sheet.conditionalFormats && sheet.conditionalFormats.rules;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        switch (reader.name()) {
            case "pivotTableDefinition":
                readPivotTableDefinitionAttributes(reader, pivotTable);
                break;
            case "location":
                readPivotTableLocation(reader, pivotTable);
                break;
            case "pivotFields":
                var pivotFieldsDepth = reader.depth;
                while (reader.read()) {
                    if (reader.depth <= pivotFieldsDepth) {
                        break;
                    }
                    pivotTable.fields.push(readPivotField(reader, readerDataModel));
                }
                break;
            case "formats":
                readPivotTableFormats(reader, pivotTable, readerDataModel);
                break;
            case "conditionalFormats":
                readPivotTableConditionalFormats(reader, pivotTable, rules);
                break;
            case "chartFormat":
                readPivotTableChartFormat(reader, pivotTable);
                break;
            case "filter":
                readPivotFilterData(reader, pivotTable, readerDataModel);
                break;
            case "pivotTableStyleInfo":
                readPivotStyle(reader, pivotTable, readerDataModel);
                break;
            case "rowFields":
                pivotTable.rowFields = readFields(reader);
                break;
            case "rowItems":
                pivotTable.rowItems = readItems(reader);
                break;
            case "colFields":
                pivotTable.columnFields = readFields(reader);
                break;
            case "colItems":
                pivotTable.columnItems = readItems(reader);
                break;
            case "pageFields":
                readPageFields(reader, pivotTable);
                break;
            case "dataFields":
                readDataFields(reader, pivotTable, readerDataModel);
                break;
            case "pivotHierarchies":
                readPivotHierarchies(reader, pivotTable);
                break;
            case "rowHierarchiesUsage":
                pivotTable.rowHierarchyUsage = readHierarchyUsage(reader);
                break;
            case "colHierarchiesUsage":
                pivotTable.columnHierarchyUsage = readHierarchyUsage(reader);
                break;
            case "extLst":
                readPivotTableExtList(reader, pivotTable);
                break;
        }
    }
}
function readPivotTableExtList(reader, pivotTable) {
    var outerDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= outerDepth) {
            break;
        }
        var extListDepth = reader.depth;
        while (reader.read()) {
            if (reader.depth <= extListDepth) {
                break;
            }
            if (reader.name() === "x14:pivotTableDefinition") {
                while (reader.moveToNextAttribute()) {
                    if (reader.readAttributeNameAsString() === 'hideValuesRow') {
                        pivotTable.hideValuesRow = reader.readContentAsBoolean();
                    }
                    if (reader.readAttributeNameAsString() === 'altText') {
                        pivotTable.altText = reader.readContentAsString();
                    }
                    if (reader.readAttributeNameAsString() === 'fillDownLabelsDefault') {
                        pivotTable.fillDownLabels = reader.readContentAsBoolean();
                    }
                    if (reader.readAttributeNameAsString() === 'altTextSummary') {
                        pivotTable.altTextSummary = reader.readContentAsString();
                    }
                }
            }
            if (reader.name() === "xpdl:pivotTableDefinition16") {
                while (reader.moveToNextAttribute()) {
                    if (reader.readAttributeNameAsString() === 'SubtotalsOnTopDefault') {
                        pivotTable.subtotalsOnTopDefault = reader.readContentAsBoolean();
                    }
                }
            }
        }
    }
}
function readHierarchyUsage(reader) {
    var hierarchies = [];
    var outerDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= outerDepth) {
            break;
        }
        while (reader.moveToNextAttribute()) {
            if (reader.readAttributeNameAsString() === "hierarchyUsage") {
                hierarchies.push(reader.readContentAsInt());
            }
        }
    }
    return hierarchies;
}
function readPivotHierarchies(reader, pivotTable) {
    var outerDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= outerDepth) {
            break;
        }
        var pivotHierarchy = {
            memberProperties: [],
            members: []
        };
        while (reader.moveToNextAttribute()) {
            switch (reader.readAttributeNameAsString()) {
                case "caption":
                    pivotHierarchy.caption = reader.readContentAsString();
                    break;
                case "dragOff":
                    pivotHierarchy.dragOff = reader.readContentAsBoolean();
                    break;
                case "dragToCol":
                    pivotHierarchy.dragToCol = reader.readContentAsBoolean();
                    break;
                case "dragToData":
                    pivotHierarchy.dragToData = reader.readContentAsBoolean();
                    break;
                case "dragToPage":
                    pivotHierarchy.dragToPage = reader.readContentAsBoolean();
                    break;
                case "dragToRow":
                    pivotHierarchy.dragToRow = reader.readContentAsBoolean();
                    break;
                case "includeNewItemsInFilter":
                    pivotHierarchy.includeNewItemsInFilter = reader.readContentAsBoolean();
                    break;
                case "multipleItemSelectionAllowed":
                    pivotHierarchy.multipleItemSelectionAllowed = reader.readContentAsBoolean();
                    break;
                case "outline":
                    pivotHierarchy.outline = reader.readContentAsBoolean();
                    break;
                case "showInFieldList":
                    pivotHierarchy.showInFieldList = reader.readContentAsBoolean();
                    break;
                case "subtotalTop":
                    pivotHierarchy.subtotalTop = reader.readContentAsBoolean();
                    break;
            }
        }
        var phDepth = reader.depth;
        while (reader.read()) {
            if (reader.depth <= phDepth) {
                break;
            }
            switch (reader.name()) {
                case "sh:mps":
                    var mpsDepth = reader.depth;
                    while (reader.read()) {
                        var pivotMemberProperty = {};
                        if (reader.depth <= mpsDepth) {
                            break;
                        }
                        if (reader.name() === 'sh:mp') {
                            while (reader.moveToNextAttribute()) {
                                switch (reader.readAttributeNameAsString()) {
                                    case "name":
                                        pivotMemberProperty.name = xmlDecode(reader.readContentAsString());
                                        break;
                                    case "showCell":
                                        pivotMemberProperty.showCell = reader.readContentAsBoolean();
                                        break;
                                    case "showTip":
                                        pivotMemberProperty.showTip = reader.readContentAsBoolean();
                                        break;
                                    case "showAsCaption":
                                        pivotMemberProperty.showAsCaption = reader.readContentAsBoolean();
                                        break;
                                    case "nameLen":
                                        pivotMemberProperty.nameLen = reader.readContentAsInt();
                                        break;
                                    case "pPos":
                                        pivotMemberProperty.pPos = reader.readContentAsInt();
                                        break;
                                    case "pLen":
                                        pivotMemberProperty.pLen = reader.readContentAsInt();
                                        break;
                                    case "level":
                                        pivotMemberProperty.level = reader.readContentAsInt();
                                        break;
                                    case "field":
                                        pivotMemberProperty.field = reader.readContentAsInt();
                                        break;
                                }
                            }
                        }
                        pivotHierarchy.memberProperties.push(pivotMemberProperty);
                    }
                    break;
                case "members":
                    var pivotMembers = {
                        members: []
                    };
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'level') {
                            pivotMembers.level = reader.readContentAsInt();
                        }
                    }
                    var membersDepth = reader.depth;
                    while (reader.read()) {
                        if (reader.depth <= membersDepth) {
                            break;
                        }
                        while (reader.moveToNextAttribute()) {
                            if (reader.readAttributeNameAsString() === 'name') {
                                pivotMembers.members.push(reader.readContentAsString());
                            }
                        }
                    }
                    break;
            }
        }
        pivotTable.pivotHierarchies.push(pivotHierarchy);
    }
}
function readDataFields(reader, pivotTable, readerDataModel) {
    var outerDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= outerDepth) {
            break;
        }
        var pivotLayoutDataField = {};
        pivotLayoutDataField.isOnRead = true;
        while (reader.moveToNextAttribute()) {
            switch (reader.readAttributeNameAsString()) {
                case "baseField":
                    pivotLayoutDataField.baseField = reader.readContentAsInt();
                    break;
                case "baseItem":
                    pivotLayoutDataField.baseItem = reader.readContentAsInt();
                    break;
                case "fld":
                    pivotLayoutDataField.fld = reader.readContentAsInt();
                    break;
                case "name":
                    pivotLayoutDataField.name = xmlDecode(reader.readContentAsString());
                    break;
                case "numFmtId":
                    var formatId = reader.readContentAsInt();
                    var buildInFormat = excel_style_1.ExtendedNumberFormatHelper.builtInNumberFomrat();
                    if (readerDataModel._numberFormats && readerDataModel._numberFormats[formatId]) {
                        pivotLayoutDataField.numberFormat = excel_style_1.ExtendedNumberFormatHelper.getFormatCode({
                            numberFormat: readerDataModel._numberFormats[formatId]
                        });
                    }
                    else if (buildInFormat[formatId]) {
                        pivotLayoutDataField.numberFormat = buildInFormat[formatId];
                    }
                    break;
                case "showDataAs":
                    pivotLayoutDataField.showDataAs = reader.readContentAsString();
                    break;
                case "subtotal":
                    pivotLayoutDataField.subtotal = reader.readContentAsString();
                    break;
            }
        }
        readPivotTableDataFieldExtList(reader, pivotLayoutDataField);
        pivotLayoutDataField.isOnRead = false;
        pivotTable.dataFields.push(pivotLayoutDataField);
    }
}
function readPivotTableDataFieldExtList(reader, pivotLayoutDataField) {
    if (reader.elementType === 3) {
        return;
    }
    var pivotFilterDataDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= pivotFilterDataDepth) {
            break;
        }
        if (reader.name() === "extLst") {
            var extLstDepth = reader.depth;
            while (reader.read()) {
                if (reader.depth <= extLstDepth) {
                    break;
                }
                if (reader.name() === "ext") {
                    var extDepth = reader.depth;
                    while (reader.read()) {
                        if (reader.depth <= extDepth) {
                            break;
                        }
                        if (reader.name() === "x14:dataField") {
                            while (reader.moveToNextAttribute()) {
                                if (reader.readAttributeNameAsString() === "pivotShowAs") {
                                    pivotLayoutDataField.showDataAs = reader.readContentAsString();
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
function readPageFields(reader, pivotTable) {
    var outerDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= outerDepth) {
            break;
        }
        var pivotLayoutPageField = {};
        while (reader.moveToNextAttribute()) {
            switch (reader.readAttributeNameAsString()) {
                case "cap":
                    pivotLayoutPageField.cap = reader.readContentAsString();
                    break;
                case "fld":
                    pivotLayoutPageField.fld = reader.readContentAsInt();
                    break;
                case "hier":
                    pivotLayoutPageField.hier = reader.readContentAsInt();
                    break;
                case "item":
                    pivotLayoutPageField.item = reader.readContentAsInt();
                    break;
                case "name":
                    pivotLayoutPageField.name = xmlDecode(reader.readContentAsString());
                    break;
            }
        }
        pivotTable.pageFields.push(pivotLayoutPageField);
    }
}
function readPivotFilterData(reader, pivotTable, readerDataModel) {
    var pivotFilterData = {};
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "fld":
                pivotFilterData.fld = reader.readContentAsInt();
                break;
            case "mpFld":
                pivotFilterData.mpFld = reader.readContentAsInt();
                break;
            case "type":
                pivotFilterData.type = reader.readContentAsString();
                break;
            case "evalOrder":
                pivotFilterData.evalOrder = reader.readContentAsInt();
                break;
            case "id":
                pivotFilterData.id = reader.readContentAsInt();
                break;
            case "iMeasureHier":
                pivotFilterData.iMeasureHier = reader.readContentAsInt();
                break;
            case "iMeasureFld":
                pivotFilterData.iMeasureFld = reader.readContentAsInt();
                break;
            case "name":
                pivotFilterData.name = xmlDecode(reader.readContentAsString());
                break;
            case "description":
                pivotFilterData.description = reader.readContentAsString();
                break;
            case "stringValue1":
                pivotFilterData.stringValue1 = reader.readContentAsString();
                break;
            case "stringValue2":
                pivotFilterData.stringValue2 = reader.readContentAsString();
                break;
        }
    }
    var pivotFilterDataDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= pivotFilterDataDepth) {
            break;
        }
        if (reader.name() === "autoFilter") {
            var autoFilterNode = xml_parser_1.parseXmlToObject(reader.readFullElement()).autoFilter;
            var autoFilter = autofilter_reader_1.readAutoFilter(autoFilterNode);
            var typeInfos = void 0;
            if (autoFilterNode.sortState) {
                autoFilter.sortInfo = autofilter_reader_1.readSortInfo(autoFilterNode.sortState);
            }
            if (!common_1.isNullOrUndefined(pivotFilterData.type)) {
                typeInfos = getPivotCompareTypeByXml(pivotFilterData.type);
            }
            pivotFilterData.conType = typeInfos && typeInfos.conType;
            pivotFilterData.autoFilter = readerDataModel._convertPivotAutoFilterToJSON(autoFilter, typeInfos);
        }
    }
    pivotTable.pivotFilters.push(pivotFilterData);
}
function getPivotCompareTypeByXml(compareStr) {
    if (compareStr.indexOf("caption") > -1 && !common_1.isNullOrUndefined(captionCompareTypeExcel[compareStr])) {
        return {
            conType: 0, compareType: captionCompareTypeExcel[compareStr]
        };
    }
    else if (compareStr.indexOf("value") > -1 && !common_1.isNullOrUndefined(valueCompareTypeExcel[compareStr])) {
        return {
            conType: 2, compareType: valueCompareTypeExcel[compareStr]
        };
    }
    else if (!common_1.isNullOrUndefined(dateCompareTypeExcel[compareStr])) {
        return {
            conType: 1, compareType: dateCompareTypeExcel[compareStr]
        };
    }
    else if (!common_1.isNullOrUndefined(top10CompareTypeExcel[compareStr])) {
        return {
            conType: 3, compareType: top10CompareTypeExcel[compareStr]
        };
    }
}
function readPivotTableConditionalFormats(reader, pivotTable, rules) {
    var depth = reader.depth;
    if (common_1.isNullOrUndefined(rules)) {
        rules = [];
    }
    pivotTable.pivotTableConditionFormats = [];
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        switch (reader.name()) {
            case "conditionalFormat":
                readPivotTableConditionalFormat(reader, pivotTable, rules);
                break;
        }
    }
}
function readPivotTableConditionalFormat(reader, pivotTable, rules) {
    var pivotTableConditionFormat = {
        pivotAreas: []
    };
    var _loop_1 = function () {
        switch (reader.readAttributeNameAsString()) {
            case "scope":
                pivotTableConditionFormat.scope = reader.readContentAsString();
                break;
            case "type":
                pivotTableConditionFormat.type = reader.readContentAsString();
                break;
            case "priority":
                var priority_1 = reader.readContentAsInt();
                rules.forEach(function (rule) {
                    if (rule.priority === priority_1) {
                        pivotTableConditionFormat.rule = rule;
                    }
                });
                break;
        }
    };
    while (reader.moveToNextAttribute()) {
        _loop_1();
    }
    var pivotTableConditionFormatDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= pivotTableConditionFormatDepth) {
            break;
        }
        if (reader.name() === "pivotArea") {
            pivotTableConditionFormat.pivotAreas.push(readPivotArea(reader));
        }
    }
    pivotTable.pivotTableConditionFormats.push(pivotTableConditionFormat);
}
function readPivotTableChartFormat(reader, pivotTable) {
    var pivotTableChartFormat = {};
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "chart":
                pivotTableChartFormat.chart = reader.readContentAsInt();
                break;
            case "format":
                pivotTableChartFormat.format = reader.readContentAsInt();
                break;
            case "series":
                pivotTableChartFormat.series = reader.readContentAsBoolean();
                break;
        }
    }
    var pivotTableChartFormatDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= pivotTableChartFormatDepth) {
            break;
        }
        if (reader.name() === "pivotArea") {
            pivotTableChartFormat.pivotArea = readPivotArea(reader);
        }
    }
    pivotTable.chartFormats.push(pivotTableChartFormat);
}
function readPivotTableLocation(reader, pivotTable) {
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "ref":
                pivotTable.ref = reader.readContentAsString();
                break;
            case "firstHeaderRow":
                pivotTable.firstHeaderRow = reader.readContentAsInt();
                break;
            case "firstDataRow":
                pivotTable.firstDataRow = reader.readContentAsInt();
                break;
            case "firstDataCol":
                pivotTable.firstDataCol = reader.readContentAsInt();
                break;
            case "rowPageCount":
                pivotTable.rowPageCount = reader.readContentAsInt();
                break;
            case "colPageCount":
                pivotTable.colPageCount = reader.readContentAsInt();
                break;
        }
    }
}
function readPivotField(reader, readerDataModel) {
    var pivotField = {
        items: []
    };
    pivotField.isOnRead = true;
    pivotField.showAll = true;
    pivotField.defaultSubtotal = true;
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "allDrilled":
                pivotField.allDrilled = reader.readContentAsBoolean();
                break;
            case "autoShow":
                pivotField.autoShow = reader.readContentAsBoolean();
                break;
            case "avgSubtotal":
                pivotField.avgSubtotal = reader.readContentAsBoolean();
                break;
            case "axis":
                pivotField.axis = reader.readContentAsString();
                break;
            case "compact":
                pivotField.compact = reader.readContentAsBoolean();
                break;
            case "countASubtotal":
                pivotField.countASubtotal = reader.readContentAsBoolean();
                break;
            case "countSubtotal":
                pivotField.countSubtotal = reader.readContentAsBoolean();
                break;
            case "dataField":
                pivotField.dataField = reader.readContentAsBoolean();
                break;
            case "dataSourceSort":
                pivotField.dataSourceSort = reader.readContentAsBoolean();
                break;
            case "defaultAttributeDrillState":
                pivotField.defaultAttributeDrillState = reader.readContentAsBoolean();
                break;
            case "defaultSubtotal":
                pivotField.defaultSubtotal = reader.readContentAsBoolean();
                break;
            case "dragOff":
                pivotField.dragOff = reader.readContentAsBoolean();
                break;
            case "dragToCol":
                pivotField.dragToCol = reader.readContentAsBoolean();
                break;
            case "dragToData":
                pivotField.dragToData = reader.readContentAsBoolean();
                break;
            case "dragToPage":
                pivotField.dragToPage = reader.readContentAsBoolean();
                break;
            case "dragToRow":
                pivotField.dragToRow = reader.readContentAsBoolean();
                break;
            case "hiddenLevel":
                pivotField.hiddenLevel = reader.readContentAsBoolean();
                break;
            case "hideNewItems":
                pivotField.hideNewItems = reader.readContentAsBoolean();
                break;
            case "includeNewItemsInFilter":
                pivotField.includeNewItemsInFilter = reader.readContentAsBoolean();
                break;
            case "insertBlankRow":
                pivotField.insertBlankRow = reader.readContentAsBoolean();
                break;
            case "insertPageBreak":
                pivotField.insertPageBreak = reader.readContentAsBoolean();
                break;
            case "itemPageCount":
                pivotField.itemPageCount = reader.readContentAsInt();
                break;
            case "maxSubtotal":
                pivotField.maxSubtotal = reader.readContentAsBoolean();
                break;
            case "measureFilter":
                pivotField.measureFilter = reader.readContentAsBoolean();
                break;
            case "minSubtotal":
                pivotField.minSubtotal = reader.readContentAsBoolean();
                break;
            case "multipleItemSelectionAllowed":
                pivotField.multipleItemSelectionAllowed = reader.readContentAsBoolean();
                break;
            case "name":
                pivotField.name = xmlDecode(reader.readContentAsString());
                break;
            case "nonAutoSortDefault":
                pivotField.nonAutoSortDefault = reader.readContentAsBoolean();
                break;
            case "numFmtId":
                var formatId = reader.readContentAsInt();
                var buildInFormat = excel_style_1.ExtendedNumberFormatHelper.builtInNumberFomrat();
                if (readerDataModel._numberFormats && readerDataModel._numberFormats[formatId]) {
                    pivotField.numberFormat = excel_style_1.ExtendedNumberFormatHelper.getFormatCode({
                        numberFormat: readerDataModel._numberFormats[formatId]
                    });
                }
                else if (buildInFormat[formatId]) {
                    pivotField.numberFormat = buildInFormat[formatId];
                }
                break;
            case "outline":
                pivotField.outline = reader.readContentAsBoolean();
                break;
            case "productSubtotal":
                pivotField.productSubtotal = reader.readContentAsBoolean();
                break;
            case "rankBy":
                pivotField.rankBy = reader.readContentAsInt();
                break;
            case "serverField":
                pivotField.serverField = reader.readContentAsBoolean();
                break;
            case "showAll":
                pivotField.showAll = reader.readContentAsBoolean();
                break;
            case "showDropDowns":
                pivotField.showDropDowns = reader.readContentAsBoolean();
                break;
            case "showPropAsCaption":
                pivotField.showPropAsCaption = reader.readContentAsBoolean();
                break;
            case "showPropCell":
                pivotField.showPropCell = reader.readContentAsBoolean();
                break;
            case "showPropTip":
                pivotField.showPropTip = reader.readContentAsBoolean();
                break;
            case "sortType":
                pivotField.sortType = reader.readContentAsString();
                break;
            case "stdDevPSubtotal":
                pivotField.stdDevPSubtotal = reader.readContentAsBoolean();
                break;
            case "stdDevSubtotal":
                pivotField.stdDevSubtotal = reader.readContentAsBoolean();
                break;
            case "subtotalCaption":
                pivotField.subtotalCaption = reader.readContentAsString();
                break;
            case "subtotalTop":
                pivotField.subtotalTop = reader.readContentAsBoolean();
                break;
            case "sumSubtotal":
                pivotField.sumSubtotal = reader.readContentAsBoolean();
                break;
            case "topAutoShow":
                pivotField.topAutoShow = reader.readContentAsBoolean();
                break;
            case "uniqueMemberProperty":
                pivotField.uniqueMemberProperty = reader.readContentAsString();
                break;
            case "varPSubtotal":
                pivotField.varPSubtotal = reader.readContentAsBoolean();
                break;
            case "varSubtotal":
                pivotField.varSubtotal = reader.readContentAsBoolean();
                break;
        }
    }
    if (reader.elementType === 3) {
        pivotField.isOnRead = false;
        return pivotField;
    }
    var fieldDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= fieldDepth) {
            break;
        }
        switch (reader.name()) {
            case "items":
                var itemsDepth = reader.depth;
                while (reader.read()) {
                    if (reader.depth <= itemsDepth) {
                        break;
                    }
                    var pivotItem = {};
                    while (reader.moveToNextAttribute()) {
                        switch (reader.readAttributeNameAsString()) {
                            case "c":
                                pivotItem.childItems = reader.readContentAsBoolean();
                                break;
                            case "d":
                                pivotItem.expanded = reader.readContentAsBoolean();
                                break;
                            case "e":
                                pivotItem.drillAcross = reader.readContentAsBoolean();
                                break;
                            case "f":
                                pivotItem.calculatedMember = reader.readContentAsBoolean();
                                break;
                            case "h":
                                pivotItem.hidden = reader.readContentAsBoolean();
                                break;
                            case "m":
                                pivotItem.missing = reader.readContentAsBoolean();
                                break;
                            case "n":
                                pivotItem.caption = reader.readContentAsString();
                                break;
                            case "s":
                                pivotItem.character = reader.readContentAsBoolean();
                                break;
                            case "sd":
                                pivotItem.collapse = !reader.readContentAsBoolean();
                                break;
                            case "t":
                                pivotItem.type = reader.readContentAsString();
                                break;
                            case "x":
                                pivotItem.indexValue = reader.readContentAsInt();
                                break;
                        }
                    }
                    pivotField.items.push(pivotItem);
                }
                if (pivotField.items.length > 0) {
                    pivotField.isShared = true;
                }
                break;
            case "autoSortScope":
                var autoSortScopeDepth = reader.depth;
                while (reader.read()) {
                    if (reader.depth <= autoSortScopeDepth) {
                        break;
                    }
                    if (reader.name() === "pivotArea") {
                        pivotField.autoSortScope = readPivotArea(reader);
                    }
                }
                break;
        }
    }
    pivotField.isOnRead = false;
    return pivotField;
}
function readPivotArea(reader) {
    var pivotArea = {
        references: []
    };
    pivotArea.outline = false;
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "axis":
                pivotArea.axis = reader.readContentAsString();
                break;
            case "cacheIndex":
                pivotArea.cacheIndex = reader.readContentAsBoolean();
                break;
            case "collapsedLevelsAreSubtotals":
                pivotArea.collapsedLevelsAreSubtotals = reader.readContentAsBoolean();
                break;
            case "dataOnly":
                pivotArea.dataOnly = reader.readContentAsBoolean();
                break;
            case "field":
                pivotArea.field = reader.readContentAsInt();
                break;
            case "fieldPosition":
                pivotArea.fieldPosition = reader.readContentAsInt();
                break;
            case "grandCol":
                pivotArea.grandCol = reader.readContentAsBoolean();
                break;
            case "grandRow":
                pivotArea.grandRow = reader.readContentAsBoolean();
                break;
            case "labelOnly":
                pivotArea.labelOnly = reader.readContentAsBoolean();
                break;
            case "offset":
                pivotArea.offset = reader.readContentAsString();
                break;
            case "outline":
                pivotArea.outline = reader.readContentAsBoolean();
                break;
            case "type":
                pivotArea.type = reader.readContentAsString();
                break;
        }
    }
    if (reader.elementType === 3) {
        return pivotArea;
    }
    var pivotAreaDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= pivotAreaDepth) {
            break;
        }
        if (reader.name() === "reference") {
            var pivotAreaReference = {
                indexes: []
            };
            while (reader.moveToNextAttribute()) {
                switch (reader.readAttributeNameAsString()) {
                    case "avgSubtotal":
                        pivotAreaReference.avgSubtotal = reader.readContentAsBoolean();
                        break;
                    case "byPosition":
                        pivotAreaReference.byPosition = reader.readContentAsBoolean();
                        break;
                    case "countASubtotal":
                        pivotAreaReference.countASubtotal = reader.readContentAsBoolean();
                        break;
                    case "countSubtotal":
                        pivotAreaReference.countSubtotal = reader.readContentAsBoolean();
                        break;
                    case "defaultSubtotal":
                        pivotAreaReference.defaultSubtotal = reader.readContentAsBoolean();
                        break;
                    case "field":
                        pivotAreaReference.field = reader.readContentAsDouble();
                        break;
                    case "maxSubtotal":
                        pivotAreaReference.maxSubtotal = reader.readContentAsBoolean();
                        break;
                    case "minSubtotal":
                        pivotAreaReference.minSubtotal = reader.readContentAsBoolean();
                        break;
                    case "productSubtotal":
                        pivotAreaReference.productSubtotal = reader.readContentAsBoolean();
                        break;
                    case "relative":
                        pivotAreaReference.relative = reader.readContentAsBoolean();
                        break;
                    case "selected":
                        pivotAreaReference.selected = reader.readContentAsBoolean();
                        break;
                    case "stdDevPSubtotal":
                        pivotAreaReference.stdDevPSubtotal = reader.readContentAsBoolean();
                        break;
                    case "stdDevSubtotal":
                        pivotAreaReference.stdDevSubtotal = reader.readContentAsBoolean();
                        break;
                    case "sumSubtotal":
                        pivotAreaReference.sumSubtotal = reader.readContentAsBoolean();
                        break;
                    case "varPSubtotal":
                        pivotAreaReference.varPSubtotal = reader.readContentAsBoolean();
                        break;
                    case "varSubtotal":
                        pivotAreaReference.varSubtotal = reader.readContentAsBoolean();
                        break;
                }
            }
            if (reader.elementType === 3) {
                pivotArea.references.push(pivotAreaReference);
                continue;
            }
            var rDepth = reader.depth;
            while (reader.read()) {
                if (reader.depth <= rDepth) {
                    break;
                }
                if (reader.name() === "x") {
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === "v") {
                            pivotAreaReference.indexes.push(reader.readContentAsInt());
                        }
                    }
                }
            }
            pivotArea.references.push(pivotAreaReference);
        }
    }
    return pivotArea;
}
function isSameReference(reference1, reference2) {
    if (!reference1 || !reference2) {
        return false;
    }
    if (reference1.field === reference2.field
        && reference1.defaultSubtotal === reference2.defaultSubtotal) {
        if (!reference1.indexes && !reference2.indexes) {
            return true;
        }
        if (!reference1.indexes || !reference2.indexes) {
            return false;
        }
        if (reference1.indexes.length === reference2.indexes.length) {
            reference1.indexes.sort();
            reference2.indexes.sort();
            for (var i = 0; i < reference1.indexes.length; i++) {
                if (reference1.indexes[i] !== reference2.indexes[i]) {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}
function getSpecifiedReferenceByFieldName(field, references) {
    for (var i = 0, len = references.length; i < len; i++) {
        if (references[i] && references[i].field === field) {
            return references[i];
        }
    }
}
function isSamePivotArea(pivotArea1, pivotArea2) {
    if (common_1.isNullOrUndefined(pivotArea1) || common_1.isNullOrUndefined(pivotArea2)) {
        return false;
    }
    if (pivotArea1.type !== pivotArea2.type
        || pivotArea1.cacheIndex !== pivotArea2.cacheIndex
        || pivotArea1.collapsedLevelsAreSubtotals !== pivotArea2.collapsedLevelsAreSubtotals
        || pivotArea1.field !== pivotArea2.field
        || pivotArea1.labelOnly !== pivotArea2.labelOnly
        || pivotArea1.grandRow !== pivotArea2.grandRow
        || pivotArea1.grandCol !== pivotArea2.grandCol
        || pivotArea1.dataOnly !== pivotArea2.dataOnly
        || pivotArea1.field !== pivotArea2.field
        || pivotArea1.fieldPosition !== pivotArea2.fieldPosition
        || pivotArea1.offset !== pivotArea2.offset
        || pivotArea1.outline !== pivotArea2.outline
        || pivotArea1.axis !== pivotArea2.axis) {
        return false;
    }
    if ((pivotArea1.references === keyword_undefined && pivotArea2.references !== keyword_undefined)
        || (pivotArea1.references !== keyword_undefined && pivotArea2.references === keyword_undefined)) {
        return false;
    }
    else if (pivotArea1.references !== keyword_undefined && pivotArea2.references !== keyword_undefined) {
        if (pivotArea1.references.length !== pivotArea2.references.length) {
            return false;
        }
        var pivotAreaInStyleModelReferences = pivotArea2.references, pivotAreaReferences = pivotArea1.references;
        for (var i = 0, len = pivotAreaReferences.length; i < len; i++) {
            var pivotAreaReference = pivotAreaReferences[i];
            var fieldName = pivotAreaReference.field;
            var pivotAreaInStyleModelReference = getSpecifiedReferenceByFieldName(fieldName, pivotAreaInStyleModelReferences);
            if (!isSameReference(pivotAreaReference, pivotAreaInStyleModelReference)) {
                return false;
            }
        }
    }
    return true;
}
function mergeDxf(dxf1, dxf2) {
    if (dxf2.font) {
        if (dxf1.font) {
            dxf2.font.compose(dxf1.font);
        }
        dxf1.font = dxf2.font;
    }
    if (dxf2.border) {
        if (dxf1.border) {
            dxf2.border.compose(dxf1.border);
        }
        dxf1.border = dxf2.border;
    }
    if (dxf2.fill) {
        if (dxf1.fill) {
            dxf2.fill.compose(dxf1.fill);
        }
        dxf1.fill = dxf2.fill;
    }
    if (dxf2.numberFormat) {
        if (dxf1.numberFormat) {
            dxf2.numberFormat.compose(dxf1.numberFormat);
        }
        dxf1.numberFormat = dxf2.numberFormat;
    }
    return dxf1;
}
function cloneDxf(dxf) {
    if (dxf) {
        var result = {};
        if (dxf.font) {
            result.font = dxf.font.clone();
        }
        if (dxf.border) {
            result.border = dxf.border.clone();
        }
        if (dxf.fill) {
            result.fill = dxf.fill.clone();
        }
        if (dxf.numberFormat) {
            result.numberFormat = dxf.numberFormat.clone();
        }
        return result;
    }
}
function rebuildPivotFormats(pivotFormats, readerDataModel) {
    if (!pivotFormats || pivotFormats.length < 1) {
        return [];
    }
    var result = [];
    if (pivotFormats.length > 1) {
        for (var i = 0, len = pivotFormats.length; i < len - 1; i++) {
            var pivotFormat = pivotFormats[i];
            if (!pivotFormat || !pivotFormat.dxf) {
                continue;
            }
            for (var j = i + 1; j < len; j++) {
                var otherPivotFormat = pivotFormats[j];
                if (otherPivotFormat && otherPivotFormat.dxf && isSamePivotArea(pivotFormat.pivotArea, otherPivotFormat.pivotArea)) {
                    pivotFormat.dxf = mergeDxf(pivotFormat.dxf, otherPivotFormat.dxf);
                    pivotFormats[j] = keyword_undefined;
                }
            }
            result.push(pivotFormat);
        }
        if (pivotFormats[pivotFormats.length - 1]) {
            result.push(pivotFormats[pivotFormats.length - 1]);
        }
    }
    else {
        result = pivotFormats;
    }
    for (var i = 0; i < result.length; i++) {
        result[i].style = readerDataModel._getStyleByDxf(result[i].dxf);
    }
    return result;
}
function readPivotTableFormats(reader, pivotTable, readerDataModel) {
    var depth = reader.depth;
    pivotTable.formats = [];
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        switch (reader.name()) {
            case "format":
                readPivotTableFormat(reader, pivotTable, readerDataModel);
                break;
        }
    }
    pivotTable.formats = rebuildPivotFormats(pivotTable.formats, readerDataModel);
}
function readPivotTableFormat(reader, pivotTable, readerDataModel) {
    var pivotTableFormat = {};
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "action":
                pivotTableFormat.action = reader.readContentAsString();
                break;
            case "dxfId":
                var dxfId = reader.readContentAsInt();
                if (!common_1.isNullOrUndefined(dxfId) && dxfId > -1) {
                    pivotTableFormat.dxf = cloneDxf(readerDataModel._dxfRecords[dxfId]);
                }
                break;
        }
    }
    var formatDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= formatDepth) {
            break;
        }
        if (reader.name() === "pivotArea") {
            pivotTableFormat.pivotArea = readPivotArea(reader);
        }
    }
    pivotTable.formats.push(pivotTableFormat);
}
function generatePivotTableTheme() {
    var retValue = {};
    for (var i = 1; i <= 28; i++) {
        retValue['PIVOTSTYLELIGHT' + i] = true;
        retValue['PIVOTSTYLEMEDIUM' + i] = true;
        retValue['PIVOTSTYLEDARK' + i] = true;
    }
    return retValue;
}
var BuiltInPivotTableThemeNames = generatePivotTableTheme();
function readPivotStyle(reader, pivotTable, readerDataModel) {
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "name":
                pivotTable.styleName = reader.readContentAsString();
                break;
            case "showColHeaders":
                pivotTable.showColHeaders = reader.readContentAsBoolean();
                break;
            case "showColStripes":
                pivotTable.showColStripes = reader.readContentAsBoolean();
                break;
            case "showLastColumn":
                pivotTable.showLastColumn = reader.readContentAsBoolean();
                break;
            case "showRowHeaders":
                pivotTable.showRowHeaders = reader.readContentAsBoolean();
                break;
            case "showRowStripes":
                pivotTable.showRowStripes = reader.readContentAsBoolean();
                break;
        }
    }
    if (common_1.isNullOrUndefined(pivotTable.styleName)) {
        pivotTable.styleName = "PivotStyleLight0";
    }
    else {
        var isBuildInPivotTableStyle = BuiltInPivotTableThemeNames[pivotTable.styleName.toUpperCase()];
        if (!isBuildInPivotTableStyle) {
            var pivotTableStylesObj = readerDataModel.tableStylesObj;
            var name_2 = pivotTable.styleName;
            if (!common_1.isNullOrUndefined(pivotTableStylesObj)) {
                var attr = pivotTableStylesObj._attr;
                if (!common_1.isNullOrUndefined(attr)) {
                    var tableStyleCount = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(attr.count, 0);
                    var styleNode = void 0;
                    if (tableStyleCount > 0) {
                        var tableStylesArray = node_helper_1.XmlNodeHelper._getAsArray(pivotTableStylesObj.tableStyle);
                        if (!common_1.isNullOrUndefined(tableStylesArray)) {
                            for (var i = 0; i < tableStylesArray.length; i++) {
                                var styleName = tableStylesArray[i]._attr.name;
                                if (name_2 === styleName) {
                                    styleNode = tableStylesArray[i];
                                    break;
                                }
                            }
                        }
                    }
                    var pivotTableTheme = {};
                    readCustomTheme(pivotTable, pivotTableTheme, styleNode, readerDataModel);
                }
            }
        }
    }
}
function readCustomTheme(sheetTable, tableTheme, styleNode, readerDataModel) {
    var customerStyleNode = styleNode;
    var attr = customerStyleNode._attr;
    tableTheme.name = attr.name;
    if (attr.count && attr.count > 0) {
        readPivotTableStyleElement(sheetTable, tableTheme, styleNode, readerDataModel);
    }
}
var ExcelPivotTableThemeType2SpreadJSThemeType = {
    wholeTable: 'wholeTableStyle',
    pageFieldLabels: 'reportFilterLabelsStyle',
    pageFieldValues: 'reportFilterValuesStyle',
    firstRowStripe: 'firstRowStripeStyle',
    secondRowStripe: 'secondRowStripeStyle',
    firstColumnStripe: 'firstColumnStripeStyle',
    secondColumnStripe: 'secondColumnStripeStyle',
    firstColumn: 'firstColumnStyle',
    headerRow: 'headerRowStyle',
    firstHeaderCell: 'firstHeaderCellStyle',
    firstSubtotalColumn: 'subtotalColumn1Style',
    secondSubtotalColumn: 'subtotalColumn2Style',
    thirdSubtotalColumn: 'subtotalColumn3Style',
    blankRow: 'blankRowStyle',
    firstSubtotalRow: 'subtotalRow1Style',
    secondSubtotalRow: 'subtotalRow2Style',
    thirdSubtotalRow: 'subtotalRow3Style',
    firstColumnSubheading: 'columnSubheading1Style',
    secondColumnSubheading: 'columnSubheading2Style',
    thirdColumnSubheading: 'columnSubheading3Style',
    firstRowSubheading: 'rowSubheading1Style',
    secondRowSubheading: 'rowSubheading2Style',
    thirdRowSubheading: 'rowSubheading3Style',
    lastColumn: 'grandTotalColumnStyle',
    totalRow: 'grandTotalRowStyle'
};
function readPivotTableStyleElement(pivotTable, tableTheme, styleNode, readerDataModel) {
    var styleElementArray = node_helper_1.XmlNodeHelper._getAsArray(styleNode.tableStyleElement);
    if (!common_1.isNullOrUndefined(styleElementArray)) {
        styleElementArray.forEach(function (styleElementNode) {
            var elementAttr = styleElementNode._attr;
            if (!common_1.isNullOrUndefined(elementAttr)) {
                var elementType = elementAttr.type || 'wholePivotTable';
                var dxfid = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(elementAttr.dxfId) || 0;
                var stripSize = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(elementAttr.size) || 1;
                var style = readerDataModel._getStyleByDxfId(dxfid);
                tableTheme[ExcelPivotTableThemeType2SpreadJSThemeType[elementType]] = style;
                if (elementType === 'firstRowStripe' || elementType === 'secondRowStripe' || elementType === 'firstColumnStripe' || elementType === 'secondColumnStripe') {
                    tableTheme[elementType.substr(0, elementType.length - 1) + 'Size'] = stripSize;
                }
            }
        });
    }
    pivotTable.style = tableTheme;
}
function readFields(reader) {
    var fields = [];
    var outerDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= outerDepth) {
            break;
        }
        if (reader.name() === 'field') {
            while (reader.moveToNextAttribute()) {
                if (reader.readAttributeNameAsString() === 'x') {
                    fields.push(reader.readContentAsInt());
                }
            }
        }
    }
    return fields;
}
function readItems(reader) {
    var items = [];
    var outerDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= outerDepth) {
            break;
        }
        items.push(readPivotLayoutItem(reader));
    }
    return items;
}
function readPivotLayoutItem(reader) {
    var pivotLayoutItem = {
        pivotItemIndexes: []
    };
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case "t":
                pivotLayoutItem.type = reader.readContentAsString();
                break;
            case "r":
                pivotLayoutItem.repeatCount = reader.readContentAsInt();
                break;
            case "i":
                pivotLayoutItem.dataFieldIndex = reader.readContentAsInt();
                break;
        }
    }
    if (reader.elementType === 3) {
        return pivotLayoutItem;
    }
    var outerDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= outerDepth) {
            break;
        }
        if (reader.name() === 'x') {
            if (reader.moveToNextAttribute()) {
                if (reader.readAttributeNameAsString() === 'v') {
                    pivotLayoutItem.pivotItemIndexes.push(reader.readContentAsInt());
                    continue;
                }
            }
            else {
                pivotLayoutItem.pivotItemIndexes.push(0);
                continue;
            }
            while (reader.moveToNextAttribute()) {
                if (reader.readAttributeNameAsString() === 'v') {
                    pivotLayoutItem.pivotItemIndexes.push(reader.readContentAsInt());
                    break;
                }
            }
        }
    }
    return pivotLayoutItem;
}


/***/ }),

/***/ "./src/xlsx-io/reader/print-reader.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/reader/print-reader.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var node_helper_1 = __webpack_require__(/*! ./../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var excel_helper_1 = __webpack_require__(/*! ./../../datamodel/excel-helper */ "./src/datamodel/excel-helper.ts");
var getAttrValueOrDefaultOfBooleanType = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType, getAttributeValueOrDefaultOfIntType = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType, getValueFromObject = node_helper_1.XmlNodeHelper._getValueFromObject, getAsArray = node_helper_1.XmlNodeHelper._getAsArray;
var xmlDecode = common_1.Util._xmlDecode;
var parseFloatFunc = parseFloat;
var ExcelPrintPageOrder = {
    auto: 0,
    downThenOver: 1,
    overThenDown: 2
};
var ExcelPrintOrientation = {
    auto: 0,
    portrait: 1,
    landscape: 2
};
var PrintHFImage = {
    LH: 0,
    CH: 1,
    RH: 2,
    LF: 3,
    CF: 4,
    RF: 5
};
function readPageMargins(reader, sheetName, readerDataModel) {
    var pageMarginsNode = xml_parser_1.parseXmlToObject(reader.readFullElement()).pageMargins;
    if (pageMarginsNode) {
        var attr = pageMarginsNode._attr;
        readerDataModel._setPrintPageMargin(sheetName, {
            left: parseFloatFunc(attr.left),
            right: parseFloatFunc(attr.right),
            top: parseFloatFunc(attr.top),
            bottom: parseFloatFunc(attr.bottom),
            header: parseFloatFunc(attr.header),
            footer: parseFloatFunc(attr.footer)
        });
    }
}
exports.readPageMargins = readPageMargins;
function readPrintOptions(reader, sheetName, readerDataModel) {
    var printOptionsNode = xml_parser_1.parseXmlToObject(reader.readFullElement()).printOptions;
    if (printOptionsNode) {
        var attr = printOptionsNode._attr;
        readerDataModel._setPrintOption(sheetName, {
            printGridLine: getAttrValueOrDefaultOfBooleanType(attr.gridLines, false) && getAttrValueOrDefaultOfBooleanType(attr.gridLinesSet, true),
            horizontalCentered: getAttrValueOrDefaultOfBooleanType(attr.horizontalCentered, false),
            verticalCentered: getAttrValueOrDefaultOfBooleanType(attr.verticalCentered, false),
            printRowColumnsHeaders: getAttrValueOrDefaultOfBooleanType(attr.headings, false)
        });
    }
}
exports.readPrintOptions = readPrintOptions;
function readPageSetup(reader, readerDataModel) {
    var pageSetupNode = xml_parser_1.parseXmlToObject(reader.readFullElement()).pageSetup;
    if (pageSetupNode) {
        var attr = pageSetupNode._attr;
        var excelPrintPageSetting = readerDataModel._excelPrintPageSetting;
        var paperSize = void 0;
        if (attr.paperSize !== undefined) {
            paperSize = parseInt(attr.paperSize, 10);
        }
        excelPrintPageSetting.showColor = !getAttrValueOrDefaultOfBooleanType(attr.blackAndWhite, false);
        excelPrintPageSetting.copies = getAttributeValueOrDefaultOfIntType(attr.copies, 1);
        excelPrintPageSetting.draft = getAttrValueOrDefaultOfBooleanType(attr.draft, false);
        excelPrintPageSetting.useCustomStartingPage = getAttrValueOrDefaultOfBooleanType(attr.useFirstPageNumber, false);
        excelPrintPageSetting.firstPageNumber = getAttributeValueOrDefaultOfIntType(attr.firstPageNumber, 1);
        excelPrintPageSetting.smartPrintPagesHeight = getAttributeValueOrDefaultOfIntType(attr.fitToHeight, 1);
        excelPrintPageSetting.smartPrintPagesWidth = getAttributeValueOrDefaultOfIntType(attr.fitToWidth, 1);
        excelPrintPageSetting.pageOrder = ExcelPrintPageOrder[attr.pageOrder] || 0;
        excelPrintPageSetting.paperSizeIndex = typeof paperSize === 'number' ? paperSize : 1;
        excelPrintPageSetting.zoomFactor = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfDoubleType(attr.scale, 100) / 100;
        excelPrintPageSetting.orientation = ExcelPrintOrientation[attr.orientation] || 0;
    }
}
exports.readPageSetup = readPageSetup;
function readPageSetupAdditionalProperty(reader, readerDataModel) {
    var pageSetUpPrNode = xml_parser_1.parseXmlToObject(reader.readFullElement()).pageSetUpPr;
    if (pageSetUpPrNode) {
        readerDataModel._excelPrintPageSetting.useSmartPrint = getAttrValueOrDefaultOfBooleanType(pageSetUpPrNode._attr.fitToPage, false);
    }
}
exports.readPageSetupAdditionalProperty = readPageSetupAdditionalProperty;
function readHeaderFooter(reader, readerDataModel) {
    var headerFooterNode = xml_parser_1.parseXmlToObject(reader.readFullElement()).headerFooter;
    if (headerFooterNode) {
        var attr = headerFooterNode._attr;
        var advancedHeadFooterSetting = readerDataModel._excelPrintPageSetting.advancedHeadFooterSetting = {
            headerFooterAlignWithPageMargin: getAttrValueOrDefaultOfBooleanType(attr.alignWithMargins, true),
            headerFooterDifferentFirstPage: getAttrValueOrDefaultOfBooleanType(attr.differentFirst, false)
        };
        if (advancedHeadFooterSetting.headerFooterDifferentFirstPage) {
            advancedHeadFooterSetting.headerFirstPage = headerFooterNode.firstHeader;
            advancedHeadFooterSetting.footerFirstPage = headerFooterNode.firstFooter;
        }
        var headerFooterDifferentOddEvenPages = advancedHeadFooterSetting.headerFooterDifferentOddEvenPages = getAttrValueOrDefaultOfBooleanType(attr.differentOddEven, false);
        var oddHeader = xmlDecode(getValueFromObject(headerFooterNode, 'oddHeader')), oddFooter = xmlDecode(getValueFromObject(headerFooterNode, 'oddFooter'));
        advancedHeadFooterSetting.headerEvenPage = headerFooterDifferentOddEvenPages ? xmlDecode(getValueFromObject(headerFooterNode, 'evenHeader')) : oddHeader;
        advancedHeadFooterSetting.footerEvenPage = headerFooterDifferentOddEvenPages ? xmlDecode(getValueFromObject(headerFooterNode, 'evenFooter')) : oddFooter;
        advancedHeadFooterSetting.headerOddPage = oddHeader;
        advancedHeadFooterSetting.footerOddPage = oddFooter;
        advancedHeadFooterSetting.headerFooterScalesWithDocument = getAttrValueOrDefaultOfBooleanType("scaleWithDoc", true);
    }
}
exports.readHeaderFooter = readHeaderFooter;
function readRowColumnBreaks(reader, readerDataModel, isRowBreaks) {
    var nodeObject = xml_parser_1.parseXmlToObject(reader.readFullElement());
    var breaksNode = isRowBreaks ? nodeObject.rowBreaks : nodeObject.colBreaks;
    var breaksArray = [];
    var brkNodeArray = getAsArray(breaksNode.brk);
    brkNodeArray.forEach(function (brkNode) {
        if (brkNode) {
            var brk = getAttributeValueOrDefaultOfIntType(brkNode._attr.id, 0);
            if (brk > 0) {
                breaksArray.push(brk);
            }
        }
    });
    if (isRowBreaks) {
        readerDataModel._excelPrintPageSetting.rowBreakLines = breaksArray;
    }
    else {
        readerDataModel._excelPrintPageSetting.columnBreakLines = breaksArray;
    }
}
exports.readRowColumnBreaks = readRowColumnBreaks;
function readLegacyDrawingHF(reader, readerDataModel) {
    var legacyDrawingHF = xml_parser_1.parseXmlToObject(reader.readFullElement()).legacyDrawingHF;
    if (legacyDrawingHF) {
        readerDataModel._legacyDrawingHFId = legacyDrawingHF._attr['r:id'];
    }
}
exports.readLegacyDrawingHF = readLegacyDrawingHF;
function readVMLDrawingRelatedImage(relationFiles) {
    var imageFileNames = {}, rid;
    for (rid in relationFiles) {
        if (relationFiles.hasOwnProperty(rid)) {
            var relationFile = relationFiles[rid], fileType = relationFile.fileType;
            if (fileType === excel_types_1.RelationshipConstants._relationshipImageType || fileType === excel_types_1.RelationshipConstants._relationshipImageType2) {
                imageFileNames[rid] = relationFile.fileName;
            }
        }
    }
    return imageFileNames;
}
function readHeaderFooterImage(readerDataModel, hfPos, imageString) {
    if (!imageString) {
        return;
    }
    var excelPrintPageSetting = readerDataModel._excelPrintPageSetting;
    if (!excelPrintPageSetting.advancedHeadFooterSetting) {
        excelPrintPageSetting.advancedHeadFooterSetting = {};
    }
    var advancedHeadFooterSetting = excelPrintPageSetting.advancedHeadFooterSetting;
    switch (hfPos) {
        case PrintHFImage.CH:
            advancedHeadFooterSetting.headerCenterImage = imageString;
            break;
        case PrintHFImage.RH:
            advancedHeadFooterSetting.headerRightImage = imageString;
            break;
        case PrintHFImage.LF:
            advancedHeadFooterSetting.footerLeftImage = imageString;
            break;
        case PrintHFImage.CF:
            advancedHeadFooterSetting.footerCenterImage = imageString;
            break;
        case PrintHFImage.RF:
            advancedHeadFooterSetting.footerRightImage = imageString;
            break;
        case PrintHFImage.LH:
        default:
            advancedHeadFooterSetting.headerLeftImage = imageString;
            break;
    }
}
exports.readHeaderFooterImage = readHeaderFooterImage;
function readVmlDrawing(relationFiles, readerDataModel, getFileDataAndCleanData) {
    if (relationFiles && readerDataModel._legacyDrawingHFId) {
        var relationFile = relationFiles[readerDataModel._legacyDrawingHFId];
        if (relationFile && relationFile.fileType === excel_types_1.RelationshipConstants._relationshipVMLDrawingType) {
            var imagesArray_1 = readVMLDrawingRelatedImage(relationFile.relationFiles);
            var vmlDrawingFileString = getFileDataAndCleanData(relationFile.fileName);
            var root = xml_parser_1.parseXmlToObject(vmlDrawingFileString).xml;
            var shapeArray = getAsArray(root['v:shape']);
            shapeArray.forEach(function (item) {
                var hfPos = item._attr.id, imageId = item['v:imagedata']._attr['o:relid'];
                var imageFileName = imagesArray_1[imageId];
                if (imageFileName) {
                    var imageString = excel_helper_1.getImageContent(imageFileName, getFileDataAndCleanData);
                    if (imageString) {
                        readHeaderFooterImage(readerDataModel, PrintHFImage[hfPos], imageString);
                    }
                }
            });
        }
        readerDataModel._legacyDrawingHFId = '';
    }
}
exports.readVmlDrawing = readVmlDrawing;


/***/ }),

/***/ "./src/xlsx-io/reader/sharedstring-reader.ts":
/*!***************************************************!*\
  !*** ./src/xlsx-io/reader/sharedstring-reader.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_reader_1 = __webpack_require__(/*! ./../../xml-io/xml-reader */ "./src/xml-io/xml-reader.ts");
var style_reader_1 = __webpack_require__(/*! ./style-reader */ "./src/xlsx-io/reader/style-reader.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
function readSharedString(dataString) {
    var reader = new xml_reader_1.XmlReader();
    reader.setXml(dataString);
    var result = [];
    while (reader.read()) {
        if (reader.depth !== 1 || reader.elementType === 2) {
            continue;
        }
        if (reader.name() === 'si') {
            var depth = reader.depth, text = '', richText = [];
            while (reader.read()) {
                if (reader.depth <= depth) {
                    break;
                }
                if (reader.nodeType() === 1) {
                    var name_1 = reader.name();
                    if (name_1 === 't' && reader.elementType === 1 && reader.depth === depth + 1) {
                        text = common_1.Util._decodeSpecialCharacterFromXML(reader.readElementContentAsString());
                    }
                    else if (name_1 === 'r') {
                        var rDepth = reader.depth;
                        var richTextInfo = {};
                        while (reader.read()) {
                            if (reader.depth <= rDepth) {
                                break;
                            }
                            if (reader.elementType === 1 && reader.name() === 't') {
                                richTextInfo.text = common_1.Util._xmlDecode(common_1.Util._decodeSpecialCharacterFromXML(reader.readElementContentAsString(true)));
                                text += richTextInfo.text;
                            }
                            else if (reader.elementType === 1 && reader.name() === 'rPr') {
                                richTextInfo.style = style_reader_1.readRichTextFont(reader);
                            }
                        }
                        richText.push(richTextInfo);
                    }
                }
            }
            if (richText.length === 0) {
                richText = void 0;
            }
            result.push({
                value: common_1.Util._xmlDecode(text),
                richText: richText
            });
        }
    }
    return result;
}
exports.readSharedString = readSharedString;


/***/ }),

/***/ "./src/xlsx-io/reader/slicer-reader.ts":
/*!*********************************************!*\
  !*** ./src/xlsx-io/reader/slicer-reader.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var node_helper_1 = __webpack_require__(/*! ./../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var getAsArray = node_helper_1.XmlNodeHelper._getAsArray;
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var emuToPixles = excel_style_1.UnitHelper.emuToPixles;
var readAnchorPoint = node_helper_1.XmlNodeHelper._readAnchorPoint;
var excel_helper_1 = __webpack_require__(/*! ./../../datamodel/excel-helper */ "./src/datamodel/excel-helper.ts");
var SlicerStyleName = {
    selectedItemWithData: "selectedItemWithDataStyle",
    selectedItemWithNoData: "selectedItemWithNoDataStyle",
    unselectedItemWithData: "unSelectedItemWithDataStyle",
    unselectedItemWithNoData: "unSelectedItemWithNoDataStyle",
    hoveredSelectedItemWithData: "hoveredSelectedItemWithDataStyle",
    hoveredSelectedItemWithNoData: "hoveredSelectedItemWithNoDataStyle",
    hoveredUnselectedItemWithData: "hoveredUnSelectedItemWithDataStyle",
    hoveredUnselectedItemWithNoData: "hoveredUnSelectedItemWithNoDataStyle",
    wholeTable: "wholeSlicerStyle",
    headerRow: "headerStyle"
};
var LineBorderWidth = {
    9: 1,
    1: 1,
    3: 1,
    4: 1,
    7: 1,
    11: 1,
    2: 2,
    10: 2,
    12: 2,
    8: 2,
    13: 2,
    5: 3,
    6: 3
};
function getWebBorderStyle(style) {
    switch (style) {
        case 6: return "double";
        case 9:
        case 11:
        case 4:
        case 13:
        case 10:
        case 12: return "dotted";
        case 2:
        case 3:
        case 8: return "dashed";
        default:
            return "solid";
    }
}
function getSlicerBorderStyle(borderStyle) {
    if (!borderStyle) {
        return;
    }
    var style = {};
    if (borderStyle.style) {
        style.borderWidth = LineBorderWidth[borderStyle.style] || 1;
        style.borderStyle = getWebBorderStyle(borderStyle.style);
    }
    if (borderStyle.color) {
        style.borderColor = borderStyle.color;
    }
    return style;
}
function getConvertedSlicerStyle(slicerStyle) {
    if (!slicerStyle) {
        return;
    }
    for (var prop in slicerStyle) {
        if (slicerStyle.hasOwnProperty(prop) && prop.indexOf('border') >= 0) {
            var borderStyle = slicerStyle[prop];
            if (borderStyle) {
                slicerStyle[prop] = getSlicerBorderStyle(borderStyle);
            }
            else if (borderStyle === null) {
                slicerStyle[prop] = void 0;
            }
        }
    }
    return slicerStyle;
}
function readSlicers(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData, workbookFile) {
    if (relationFiles) {
        var slicerFiles = [];
        var slicerDrawingFiles = [];
        for (var key in relationFiles) {
            if (key !== 'count') {
                var relationFile = relationFiles[key];
                if (relationFile) {
                    var fileType = relationFile.fileType;
                    if (fileType === excel_types_1.RelationshipConstants._relationshipSlicerType) {
                        slicerFiles.push(relationFile);
                    }
                    else if (fileType === excel_types_1.RelationshipConstants._relationshipDrawingType
                        || fileType === excel_types_1.RelationshipConstants._relationshipDrawingType2) {
                        slicerDrawingFiles.push(relationFile);
                    }
                }
            }
        }
        var slicerStylesFile = readSlicerStyleFile(workbookFile);
        var slicerCacheFiles = readSlicerCacheFiles(workbookFile);
        if (slicerFiles.length) {
            var slicers = readSlicersFromFile(slicerFiles, getFileDataAndCleanData);
            var sheet = readerDataModel._spread.sheets[sheetName];
            readSlicerCachesFromFile(slicers, slicerCacheFiles, getFileDataAndCleanData);
            readSlicerDrawingsFromFile(slicers, slicerDrawingFiles, getFileDataAndCleanData, sheet);
            readSlicerStyleFromFile(slicers, slicerStylesFile, getFileDataAndCleanData, readerDataModel);
            readerDataModel._addSlicers(slicers, sheetName);
        }
    }
}
exports.readSlicers = readSlicers;
function readSlicer(dataString, slicers) {
    var obj = xml_parser_1.parseXmlToObject(dataString);
    var root = obj.slicers;
    if (root) {
        var slicerArray = getAsArray(root.slicer);
        if (!common_1.isNullOrUndefined(slicerArray)) {
            slicerArray.forEach(function (slicerNode) {
                var slicerInfo = {};
                var attr = slicerNode._attr;
                if (!common_1.isNullOrUndefined(attr)) {
                    if (!common_1.isNullOrUndefined(attr.name)) {
                        slicerInfo.name = common_1.Util._xmlDecode(common_1.Util._replaceAll(attr.name, '_x000a_', '\n'));
                    }
                    if (!common_1.isNullOrUndefined(attr.cache)) {
                        slicerInfo.nameInFormula = attr.cache;
                    }
                    if (!common_1.isNullOrUndefined(attr.caption)) {
                        slicerInfo.captionName = attr.caption;
                    }
                    if (!common_1.isNullOrUndefined(attr.columnCount)) {
                        slicerInfo.columnCount = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(attr.columnCount, 1);
                    }
                    if (!common_1.isNullOrUndefined(attr.showCaption)) {
                        slicerInfo.showHeader = attr.showCaption !== '0';
                    }
                    slicerInfo.style = { name: attr.style };
                    if (!common_1.isNullOrUndefined(attr.lockedPosition)) {
                        slicerInfo.disableResizingAndMoving = attr.lockedPosition === '1';
                    }
                    if (!common_1.isNullOrUndefined(attr.rowHeight)) {
                        slicerInfo.itemHeight = emuToPixles(parseInt(attr.rowHeight, 10));
                    }
                }
                slicers.push(slicerInfo);
            });
        }
    }
}
function readSlicersFromFile(slicerFiles, getFileDataAndCleanData) {
    var slicers = [];
    slicerFiles.forEach(function (file) {
        var dataString = getFileDataAndCleanData(file.fileName);
        if (dataString) {
            readSlicer(dataString, slicers);
        }
    });
    return slicers;
}
exports.readSlicersFromFile = readSlicersFromFile;
function readSlicerCache(slicers, dataString) {
    var obj = xml_parser_1.parseXmlToObject(dataString);
    var root = obj.slicerCacheDefinition;
    if (root) {
        var attr = root._attr;
        var name_1 = attr.name;
        var associateSlicers_1 = [];
        slicers.forEach(function (slicer) {
            if (slicer.nameInFormula === name_1) {
                associateSlicers_1.push(slicer);
            }
        });
        if (!associateSlicers_1.length) {
            return;
        }
        var sourceName_1 = attr.sourceName;
        var tableId_1 = null, columnId_1 = null;
        var sortState_1 = null;
        var showNoDataItems_1 = true, visuallyNoDataItems_1 = true, showNoDataItemsInLast_1 = true;
        var extLstNode = root.extLst;
        if (extLstNode) {
            var extNodes = getAsArray(extLstNode['x:ext']);
            extNodes.forEach(function (extNode) {
                var extNodeAttr = extNode._attr;
                var uri = extNodeAttr.uri;
                var crossFilter = null;
                switch (uri) {
                    case "{03082B11-2C62-411c-B77F-237D8FCFBE4C}":
                        break;
                    case "{2F2917AC-EB37-4324-AD4E-5DD8C200BD13}":
                        var tableSlicerCaches = getAsArray(extNode['x15:tableSlicerCache']);
                        tableSlicerCaches.forEach(function (tableSlicerCache) {
                            var tableSlicerCacheAttr = tableSlicerCache._attr;
                            tableId_1 = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(tableSlicerCacheAttr.tableId, 0);
                            columnId_1 = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(tableSlicerCacheAttr.column, 0);
                            sortState_1 = tableSlicerCacheAttr.sortOrder;
                            crossFilter = tableSlicerCacheAttr.crossFilter;
                        });
                        break;
                    case "{470722E0-AACD-4C17-9CDC-17EF765DBC7E}":
                        var slicerHideItemsWithNoDataCaches = getAsArray(extNode['x15:slicerCacheHideItemsWithNoData']);
                        if (slicerHideItemsWithNoDataCaches && slicerHideItemsWithNoDataCaches.length > 0) {
                            showNoDataItems_1 = false;
                        }
                        break;
                }
                switch (crossFilter) {
                    case "none":
                        visuallyNoDataItems_1 = false;
                        break;
                    case "showItemsWithNoData":
                        showNoDataItemsInLast_1 = false;
                        break;
                }
            });
        }
        associateSlicers_1.forEach(function (slicer) {
            slicer.sourceName = sourceName_1;
            slicer.tableId = tableId_1;
            slicer.columnId = columnId_1;
            if (sortState_1 === 'descending') {
                slicer.sortState = 2;
            }
            slicer.showNoDataItems = showNoDataItems_1;
            slicer.visuallyNoDataItems = visuallyNoDataItems_1;
            slicer.showNoDataItemsInLast = showNoDataItemsInLast_1;
        });
    }
}
function readSlicerCachesFromFile(slicers, slicerCacheFiles, getFileDataAndCleanData) {
    slicerCacheFiles.forEach(function (slicerCacheFile) {
        var dataString = getFileDataAndCleanData(slicerCacheFile.fileName, true);
        if (dataString) {
            readSlicerCache(slicers, dataString);
        }
    });
}
function readSlicerStyleFromFile(slicers, slicerStylesFile, getFileDataAndCleanData, readerDataModel) {
    var dataString = getFileDataAndCleanData(slicerStylesFile.fileName, true);
    if (dataString) {
        var obj = xml_parser_1.parseXmlToObject(dataString);
        var root = obj.styleSheet;
        var slicerStyles_1 = {};
        var slicerStylesNode = readerDataModel._slicerStylesNode;
        if (!common_1.isNullOrUndefined(slicerStylesNode)) {
            var slicerStyleNodes = getAsArray(slicerStylesNode['x14:slicerStyle']);
            slicerStyleNodes.forEach(function (slicerStyleNode) {
                var slicerStyleNodeAttr = slicerStyleNode._attr;
                var name = slicerStyleNodeAttr.name;
                var slicerStyle = { name: name };
                var slicerStyleElementsNodes = getAsArray(slicerStyleNode['x14:slicerStyleElements']);
                slicerStyleElementsNodes.forEach(function (slicerStyleElementsNode) {
                    var slicerStyleElementNodes = getAsArray(slicerStyleElementsNode['x14:slicerStyleElement']);
                    slicerStyleElementNodes.forEach(function (slicerStyleElementNode) {
                        var slicerStyleElementNodeAttr = slicerStyleElementNode._attr;
                        var type = slicerStyleElementNodeAttr.type;
                        var dxfId = slicerStyleElementNodeAttr.dxfId;
                        var styleName = SlicerStyleName[type];
                        if (!common_1.isNullOrUndefined(dxfId) && styleName) {
                            var styleInfo = readerDataModel._getExtStyleByDxfId(dxfId);
                            slicerStyle[styleName] = getConvertedSlicerStyle(styleInfo);
                        }
                    });
                });
                slicerStyles_1[name] = slicerStyle;
            });
        }
        var tableStylesNode = root.tableStyles;
        if (!common_1.isNullOrUndefined(tableStylesNode)) {
            var tableStyleNodes = getAsArray(tableStylesNode.tableStyle);
            tableStyleNodes.forEach(function (tableStyleNode) {
                var tableStyleNodeAttr = tableStyleNode._attr;
                var name = tableStyleNodeAttr.name;
                var slicerStyle = slicerStyles_1[name];
                if (!slicerStyle) {
                    return;
                }
                var tableStyleElementNodes = getAsArray(tableStyleNode.tableStyleElement);
                tableStyleElementNodes.forEach(function (tableStyleElementNode) {
                    var tableStyleElementNodeAttr = tableStyleElementNode._attr;
                    var type = tableStyleElementNodeAttr.type;
                    var dxfId = tableStyleElementNodeAttr.dxfId;
                    var styleInfo = readerDataModel._getStyleByDxfId(dxfId);
                    var styleName = SlicerStyleName[type];
                    if (!common_1.isNullOrUndefined(dxfId) && styleName) {
                        slicerStyle[styleName] = getConvertedSlicerStyle(styleInfo);
                    }
                });
            });
        }
        var defaultSlicerStyleName_1 = slicerStylesNode._attr.defaultSlicerStyle;
        slicers.forEach(function (slicer) {
            var styleName = slicer.style.name;
            if (!styleName) {
                slicer.style.name = defaultSlicerStyleName_1;
                styleName = defaultSlicerStyleName_1;
            }
            if (slicerStyles_1[styleName]) {
                slicer.style = slicerStyles_1[styleName];
            }
        });
    }
}
function getSlicer(slicers, slicerName) {
    var result = null;
    slicers.forEach(function (slicer) {
        if (slicer.name === slicerName) {
            result = slicer;
        }
    });
    return result;
}
function readSlicerDrawing(slicers, dataString, sheet) {
    var obj = xml_parser_1.parseXmlToObject(dataString, true);
    var root = obj['xdr:wsDr'];
    var slicerDrawingNodes = getSlicerDrawingNodes(getAsArray(root['xdr:twoCellAnchor']));
    slicerDrawingNodes.forEach(function (slicerDrawingNode) {
        var slicerDrawingNodeAttr = slicerDrawingNode._attr;
        var dynamicMove = true, dynamicSize = true;
        var moveResizeProperty = slicerDrawingNodeAttr.editAs;
        if (moveResizeProperty === "absolute") {
            dynamicMove = false;
            dynamicSize = false;
        }
        else if (moveResizeProperty === "oneCell") {
            dynamicMove = true;
            dynamicSize = false;
        }
        var isLocked = true;
        var clientDataNode = slicerDrawingNode.clientData;
        var startPoint = readAnchorPoint(slicerDrawingNode['xdr:from']);
        var endPoint = readAnchorPoint(slicerDrawingNode['xdr:to']);
        var bounds = excel_helper_1.getBounds(sheet, startPoint, endPoint);
        if (clientDataNode) {
            var fLocksWithSheet = clientDataNode._attr.fLocksWithSheet;
            if (fLocksWithSheet === "0") {
                isLocked = false;
            }
        }
        var slicerName = common_1.Util._xmlDecode(common_1.Util._replaceAll(slicerDrawingNode.slicerName, '&#xA;', '\n'));
        var excelSlicer = getSlicer(slicers, slicerName);
        if (!common_1.isNullOrUndefined(excelSlicer)) {
            excelSlicer.dynamicMove = dynamicMove;
            excelSlicer.dynamicSize = dynamicSize;
            excelSlicer.x = bounds.x;
            excelSlicer.y = bounds.y;
            excelSlicer.width = bounds.width;
            excelSlicer.height = bounds.height;
            excelSlicer.isLocked = isLocked;
            excelSlicer.endPoint = endPoint;
        }
    });
}
function readSlicerDrawingsFromFile(slicers, slicerDrawingFiles, getFileDataAndCleanData, sheet) {
    slicerDrawingFiles.forEach(function (slicerDrawingFile) {
        var dataString = getFileDataAndCleanData(slicerDrawingFile.fileName, true);
        if (dataString) {
            readSlicerDrawing(slicers, dataString, sheet);
        }
    });
}
function readSlicerCacheFiles(workbookFile) {
    var relationFiles = workbookFile.relationFiles;
    var slicerCacheFiles = [];
    for (var key in relationFiles) {
        if (key !== 'count') {
            var relationFile = relationFiles[key];
            if (relationFile) {
                var fileType = relationFile.fileType;
                if (fileType === excel_types_1.RelationshipConstants._relationshipSlicerCacheType) {
                    slicerCacheFiles.push(relationFile);
                }
            }
        }
    }
    return slicerCacheFiles;
}
function readSlicerStyleFile(workbookFile) {
    var slicerStylesFile = workbookFile._getFileByType(excel_types_1.RelationshipConstants._relationshipStylesType);
    if (!slicerStylesFile) {
        slicerStylesFile = workbookFile._getFileByType(excel_types_1.RelationshipConstants._relationshipStylesType2);
    }
    if (!slicerStylesFile) {
        return;
    }
    return slicerStylesFile;
}
function getSlicerDrawingNodes(nodes) {
    var path = ["mc:AlternateContent", "mc:Choice", "xdr:graphicFrame", "a:graphic", "a:graphicData"];
    var slicerDrawingNodes = [];
    nodes.forEach(function (node) {
        var currentNode = node;
        var find;
        for (var i = 0; i < path.length; i++) {
            find = false;
            if (currentNode && currentNode[path[i]]) {
                find = true;
                currentNode = currentNode[path[i]];
            }
        }
        if (find) {
            var graphicDatanNode = currentNode;
            var uri = graphicDatanNode._attr.uri;
            if (uri === "http://schemas.microsoft.com/office/drawing/2010/slicer") {
                var sleSlicers = getAsArray(graphicDatanNode['sle:slicer']);
                sleSlicers.forEach(function (sleSlicer) {
                    var sleSlicerAttr = sleSlicer._attr;
                    var slicerName = sleSlicerAttr.name;
                    node.slicerName = slicerName;
                    slicerDrawingNodes.push(node);
                });
            }
        }
    });
    return slicerDrawingNodes;
}


/***/ }),

/***/ "./src/xlsx-io/reader/sparkline-reader.ts":
/*!************************************************!*\
  !*** ./src/xlsx-io/reader/sparkline-reader.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var node_helper_1 = __webpack_require__(/*! ./../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var color_reader_1 = __webpack_require__(/*! ./../common/color-reader */ "./src/xlsx-io/common/color-reader.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var range_parser_1 = __webpack_require__(/*! ./../../common/range-parser */ "./src/common/range-parser.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var getAsArray = node_helper_1.XmlNodeHelper._getAsArray;
function readSparklineGroups(reader, sheetName, readerDataModel) {
    if (reader.elementType === 3) {
        return;
    }
    var sparklineGroups = [];
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1 && reader.name() === 'x14:sparklineGroup') {
            var sparklineGroup = readSparklineGroup(xml_parser_1.parseXmlToObject(reader.readFullElement(), true)[reader.name()], sheetName);
            if (sparklineGroup.sparklines && sparklineGroup.sparklines.length > 0) {
                sparklineGroups.push(sparklineGroup);
            }
        }
    }
    readerDataModel._setSparkLineGroups(sparklineGroups, sheetName);
}
exports.readSparklineGroups = readSparklineGroups;
var ExcelSparklineEmptyCellDisplayAs = {
    span: 2,
    gap: 0,
    zero: 1
};
var ExcelSparklineType = {
    line: 0,
    column: 1,
    stacked: 2
};
var ExcelSparklineAxisMinMax = {
    individual: 0,
    group: 1,
    custom: 2
};
function readSparklineGroup(node, sheetName) {
    if (common_1.isNullOrUndefined(node)) {
        return;
    }
    var sparklineGroup = { setting: {} };
    sparklineGroup.sparklineType = 0;
    var attr = node._attr;
    if (!common_1.isNullOrUndefined(attr)) {
        if (!common_1.isNullOrUndefined(attr.manualMax)) {
            sparklineGroup.setting.manualMax = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfDoubleType(attr.manualMax, 0.0);
        }
        if (!common_1.isNullOrUndefined(attr.manualMin)) {
            sparklineGroup.setting.manualMin = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfDoubleType(attr.manualMin, 0.0);
        }
        if (!common_1.isNullOrUndefined(attr.lineWeight)) {
            sparklineGroup.setting.lineWeight = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfDoubleType(attr.lineWeight, 1) * 4 / 3.0;
        }
        if (!common_1.isNullOrUndefined(attr.type)) {
            sparklineGroup.sparklineType = ExcelSparklineType[attr.type] || 0;
        }
        if (!common_1.isNullOrUndefined(attr.dateAxis)) {
            sparklineGroup.displayDateAxis = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.dateAxis, false);
        }
        if (!common_1.isNullOrUndefined(attr.displayEmptyCellsAs)) {
            sparklineGroup.setting.displayEmptyCellsAs = ExcelSparklineEmptyCellDisplayAs[attr.displayEmptyCellsAs] || 0;
        }
        if (!common_1.isNullOrUndefined(attr.markers)) {
            sparklineGroup.setting.showMarkers = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.markers, false);
        }
        if (!common_1.isNullOrUndefined(attr.high)) {
            sparklineGroup.setting.showHigh = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.high, false);
        }
        if (!common_1.isNullOrUndefined(attr.low)) {
            sparklineGroup.setting.showLow = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.low, false);
        }
        if (!common_1.isNullOrUndefined(attr.first)) {
            sparklineGroup.setting.showFirst = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.first, false);
        }
        if (!common_1.isNullOrUndefined(attr.last)) {
            sparklineGroup.setting.showLast = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.last, false);
        }
        if (!common_1.isNullOrUndefined(attr.negative)) {
            sparklineGroup.setting.showNegative = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.negative, false);
        }
        if (!common_1.isNullOrUndefined(attr.displayXAxis)) {
            sparklineGroup.setting.displayXAxis = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.displayXAxis, false);
        }
        if (!common_1.isNullOrUndefined(attr.displayHidden)) {
            sparklineGroup.setting.displayHidden = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.displayHidden, false);
        }
        if (!common_1.isNullOrUndefined(attr.rightToLeft)) {
            sparklineGroup.setting.rightToLeft = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.rightToLeft, false);
        }
        if (!common_1.isNullOrUndefined(attr.minAxisType)) {
            sparklineGroup.setting.minAxisType = ExcelSparklineAxisMinMax[attr.minAxisType] || 0;
        }
        if (!common_1.isNullOrUndefined(attr.maxAxisType)) {
            sparklineGroup.setting.maxAxisType = ExcelSparklineAxisMinMax[attr.maxAxisType] || 0;
        }
    }
    if (!common_1.isNullOrUndefined(node['x14:colorSeries'])) {
        sparklineGroup.setting.seriesColor = convertColor(color_reader_1.readColor(node['x14:colorSeries'])) || "rgba(36,64,98,255)";
    }
    if (!common_1.isNullOrUndefined(node['x14:colorNegative'])) {
        sparklineGroup.setting.negativeColor = convertColor(color_reader_1.readColor(node['x14:colorNegative'])) || "Brown";
    }
    if (!common_1.isNullOrUndefined(node['x14:colorAxis'])) {
        sparklineGroup.setting.axisColor = convertColor(color_reader_1.readColor(node['x14:colorAxis'])) || "Black";
    }
    if (!common_1.isNullOrUndefined(node['x14:colorMarkers'])) {
        sparklineGroup.setting.markersColor = convertColor(color_reader_1.readColor(node['x14:colorMarkers'])) || "rgba(36,64,98,255)";
    }
    if (!common_1.isNullOrUndefined(node['x14:colorFirst'])) {
        sparklineGroup.setting.firstMarkerColor = convertColor(color_reader_1.readColor(node['x14:colorFirst'])) || "rgba(149,179,215,255)";
    }
    if (!common_1.isNullOrUndefined(node['x14:colorLast'])) {
        sparklineGroup.setting.lastMarkerColor = convertColor(color_reader_1.readColor(node['x14:colorLast'])) || "rgba(149,179,215,255)";
    }
    if (!common_1.isNullOrUndefined(node['x14:colorHigh'])) {
        sparklineGroup.setting.highMarkerColor = convertColor(color_reader_1.readColor(node['x14:colorHigh'])) || "Blue";
    }
    if (!common_1.isNullOrUndefined(node['x14:colorLow'])) {
        sparklineGroup.setting.lowMarkerColor = convertColor(color_reader_1.readColor(node['x14:colorLow'])) || "Blue";
    }
    if (!common_1.isNullOrUndefined(node['xm:f'])) {
        var xmfObj = node['xm:f'];
        var rangeStringArray = xmfObj['xm:f'].split('!');
        sparklineGroup.axisReference = range_parser_1.getRangesFromString(rangeStringArray[1])[0] || null;
        if (rangeStringArray[0] !== sheetName) {
            sparklineGroup.axisReference.sheetName = rangeStringArray[0];
        }
    }
    if (!common_1.isNullOrUndefined(node['x14:sparklines'])) {
        sparklineGroup.sparklines = readSparklines(node['x14:sparklines'], sheetName);
    }
    var axisReference = sparklineGroup.axisReference;
    if (sparklineGroup.displayDateAxis && axisReference) {
        sparklineGroup.axisOrientation = axisReference.rowCount === 1 ? 1 : 0;
    }
    return sparklineGroup;
}
function readSparklines(sparklinesNode, sheetName) {
    var sparklines = [];
    var node = sparklinesNode && sparklinesNode['x14:sparkline'];
    var sparklineArray = getAsArray(node);
    sparklineArray.forEach(function (sparklineObj) {
        var dataRange, location, rangeStringArray;
        if (!common_1.isNullOrUndefined(sparklineObj['xm:f'])) {
            var xmfObj = sparklineObj['xm:f'];
            rangeStringArray = xmfObj['xm:f'].split('!');
            dataRange = range_parser_1.getRangesFromString(rangeStringArray[1])[0] || null;
        }
        if (!common_1.isNullOrUndefined(sparklineObj['xm:sqref'])) {
            var xmsqrefObj = sparklineObj['xm:sqref'];
            location = range_parser_1.getRangesFromString(xmsqrefObj['xm:sqref'])[0] || null;
        }
        if (!common_1.isNullOrUndefined(dataRange) && !common_1.isNullOrUndefined(location)) {
            var sparkline = {};
            sparkline.row = location.row;
            sparkline.col = location.col;
            sparkline.orientation = dataRange.rowCount === 1 ? 1 : 0;
            sparkline.data = dataRange;
            if (rangeStringArray && rangeStringArray[0] !== sheetName) {
                sparkline.data.sheetName = rangeStringArray[0];
            }
            sparklines.push(sparkline);
        }
    });
    return sparklines;
}
function convertColor(excelColor) {
    var color;
    if (excelColor.isThemeColor()) {
        color = excel_style_1.ColorHelper.getThemeColorName(excelColor);
    }
    else {
        color = excel_style_1.ColorHelper.toRGBColor(excelColor);
    }
    return color;
}


/***/ }),

/***/ "./src/xlsx-io/reader/style-reader.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/reader/style-reader.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var xml_reader_1 = __webpack_require__(/*! ./../../xml-io/xml-reader */ "./src/xml-io/xml-reader.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var excelStyle = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var color_reader_1 = __webpack_require__(/*! ./../common/color-reader */ "./src/xlsx-io/common/color-reader.ts");
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
function readStyle(dataString, readerDataModel) {
    var reader = new xml_reader_1.XmlReader();
    reader.setXml(dataString);
    var styleCellStyleXfs = [];
    var styleFonts = [], numberFormats = {}, styleFills = [], styleBorders = [], styleCellXfs = [];
    while (reader.read()) {
        if (reader.depth !== 1 || reader.elementType === 2) {
            continue;
        }
        switch (reader.name()) {
            case 'numFmts':
                readNumberFormats(reader, numberFormats);
                break;
            case 'fonts':
                var bodyFont = readerDataModel._bodyFont, headingFont = readerDataModel._headingFont;
                readFonts(reader, styleFonts, bodyFont, headingFont);
                break;
            case 'fills':
                readFills(reader, styleFills);
                break;
            case 'borders':
                readBorders(reader, styleBorders);
                break;
            case 'cellStyleXfs':
                readXFs(reader, styleCellStyleXfs, styleFonts, styleBorders, numberFormats, styleFills, true);
                break;
            case 'cellXfs':
                readXFs(reader, styleCellXfs, styleFonts, styleBorders, numberFormats, styleFills, false);
                break;
            case 'cellStyles':
                readCellStyles(reader, readerDataModel, styleCellStyleXfs);
                break;
            case 'colors':
                readColors(reader, readerDataModel);
                break;
            case 'dxfs':
                readDxfs(reader, readerDataModel);
                break;
            case 'tableStyles':
                readTableStyles(reader, readerDataModel);
                break;
            case 'extLst':
                readExtLst(reader, readerDataModel);
                break;
            default:
                break;
        }
    }
    readerDataModel._numberFormats = numberFormats;
    var cellStyleXfsLength = styleCellStyleXfs.length;
    if (cellStyleXfsLength > 0) {
        readerDataModel._setExcelDefaultCellFormat(styleCellStyleXfs[0]);
        for (var i = 0, len = cellStyleXfsLength; i < len; i++) {
            readerDataModel._setExcelCellFormat(styleCellStyleXfs[i], i);
        }
        for (var i = 0, len = styleCellXfs.length; i < len; i++) {
            readerDataModel._setExcelCellFormat(styleCellXfs[i], i);
        }
    }
    else {
        readerDataModel._normalStyleInfo = {
            foreColor: "Text 1 0",
            themeFont: "Body",
            font: "normal normal 14.7px Calibri",
            locked: true,
            textIndent: 0,
            wordWrap: false,
            vAlign: 2,
            hAlign: 3
        };
    }
    return cellStyleXfsLength;
}
exports.readStyle = readStyle;
function readNumberFormats(reader, numberFormats) {
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            return;
        }
        if (reader.nodeType() === 1 && reader.name() === 'numFmt') {
            var numberFormat = readNumberFormat(reader);
            if (numberFormat && numberFormat.numberFormatId > 0) {
                numberFormats[numberFormat.numberFormatId] = numberFormat;
            }
        }
    }
}
exports.readNumberFormats = readNumberFormats;
function readNumberFormat(reader) {
    var formatId = -1, formatCode = '', formatCode16 = '';
    while (reader.moveToNextAttribute()) {
        var value = reader.readAttributeNameAsString();
        if (value === 'numFmtId') {
            formatId = reader.readContentAsInt(-1);
        }
        else if (value === 'formatCode') {
            formatCode = reader.readContentAsString();
        }
        else if (value.indexOf("formatCode16") > -1) {
            formatCode16 = reader.readContentAsString();
            if (formatCode16.indexOf("[$-ja-JP-x-gannen]") > -1) {
                formatCode = formatCode16;
            }
        }
    }
    formatCode = common_1.Util._xmlDecode(common_1.Util._replaceAll(formatCode, "_x000a_", "\n"));
    return new excelStyle.ExcelNumerFormat(formatId, formatCode);
}
function readFonts(reader, styleFonts, bodyFont, headingFont) {
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            return;
        }
        if (reader.nodeType() === 1 && reader.name() === 'font') {
            styleFonts.push(readFont(reader, false, bodyFont, headingFont));
        }
    }
}
exports.readFonts = readFonts;
function readFont(reader, isDxfFont, bodyFont, headingFont) {
    if (reader.elementType === 3) {
        return;
    }
    var styleFont = new excelStyle.ExcelFont();
    var fontDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= fontDepth) {
            break;
        }
        if (reader.nodeType() === 1) {
            switch (reader.name()) {
                case 'b':
                    styleFont.isBold = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.isBold = reader.readContentAsBoolean(-1);
                        }
                    }
                    break;
                case 'charset':
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.charSetIndex = reader.readContentAsInt(-1);
                        }
                    }
                    break;
                case 'family':
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.fontFamily = reader.readContentAsInt(0);
                        }
                    }
                    break;
                case 'name':
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.fontName = reader.readContentAsString();
                        }
                    }
                    break;
                case 'scheme':
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            var scheme = reader.readContentAsString();
                            if (!common_1.StringEx._isNullOrWhiteSpace(scheme) && excel_style_1.FontSchemeCategory[scheme.toLocaleLowerCase()] !== undefined) {
                                styleFont.fontScheme = excel_style_1.FontSchemeCategory[scheme.toLocaleLowerCase()];
                            }
                        }
                    }
                    break;
                case 'u':
                    var underLineStyle = 1;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            var u = reader.readContentAsString();
                            if (!common_1.StringEx._isNullOrWhiteSpace(u) && excelStyle.UnderLineStyle[u] !== undefined) {
                                underLineStyle = excelStyle.UnderLineStyle[u];
                            }
                        }
                    }
                    styleFont.underLineStyle = underLineStyle;
                    break;
                case 'i':
                    styleFont.isItalic = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.isItalic = reader.readContentAsBoolean(-1);
                        }
                    }
                    break;
                case 'outline':
                    styleFont.isOutlineStyle = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.isOutlineStyle = reader.readContentAsBoolean(-1);
                        }
                    }
                    break;
                case 'shadow':
                    styleFont.isShadowStyle = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.isShadowStyle = reader.readContentAsBoolean(-1);
                        }
                    }
                    break;
                case 'strike':
                    styleFont.isStrikeOut = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.isStrikeOut = reader.readContentAsBoolean(-1);
                        }
                    }
                    break;
                case 'sz':
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.fontSize = reader.readContentAsDouble(0);
                        }
                    }
                    break;
                case 'vertAlign':
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            var vertAlign = reader.readContentAsString();
                            if (vertAlign && excelStyle.VertAlign[vertAlign.toLocaleLowerCase()] !== undefined) {
                                styleFont.vertAlign = excelStyle.VertAlign[vertAlign.toLocaleLowerCase()];
                            }
                        }
                    }
                    break;
                case 'color':
                    var color = color_reader_1.readColor(reader);
                    if (color !== excel_style_1.ExcelColor.EmptyColor) {
                        styleFont.fontColor = color;
                    }
                    break;
                default:
                    break;
            }
        }
    }
    var fontScheme = styleFont.fontScheme;
    if ((fontScheme === 1 && bodyFont) || (fontScheme === 2 && headingFont)) {
        var fallbackFontName = getFallbackThemeFont(fontScheme, bodyFont, headingFont);
        styleFont.fontName = fallbackFontName;
    }
    return styleFont;
}
function getFallbackThemeFont(fontScheme, bodyFont, headingFont) {
    var fontName;
    if (fontScheme === 1) {
        fontName = headingFont;
    }
    else if (fontScheme === 2) {
        fontName = bodyFont;
    }
    return fontName;
}
function readRichTextFont(reader) {
    var styleFont = new excelStyle.ExcelFont();
    var fontDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= fontDepth) {
            break;
        }
        if (reader.nodeType() === 1) {
            switch (reader.name()) {
                case 'b':
                    styleFont.isBold = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.isBold = reader.readContentAsBoolean(-1);
                        }
                    }
                    break;
                case 'charset':
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.charSetIndex = reader.readContentAsInt(-1);
                        }
                    }
                    break;
                case 'color':
                    var color = color_reader_1.readColor(reader);
                    if (color !== excel_style_1.ExcelColor.EmptyColor) {
                        styleFont.fontColor = color;
                    }
                    break;
                case 'condense':
                    styleFont.isCondense = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.isCondense = reader.readContentAsBoolean(-1);
                        }
                    }
                    break;
                case 'extend':
                    styleFont.isExtend = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.isExtend = reader.readContentAsBoolean(-1);
                        }
                    }
                    break;
                case 'family':
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.fontFamily = reader.readContentAsInt(0);
                        }
                    }
                    break;
                case 'i':
                    styleFont.isItalic = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.isItalic = reader.readContentAsBoolean(-1);
                        }
                    }
                    break;
                case 'outline':
                    styleFont.isOutlineStyle = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.isOutlineStyle = reader.readContentAsBoolean(-1);
                        }
                    }
                    break;
                case 'rFont':
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.fontName = reader.readContentAsString();
                        }
                    }
                    break;
                case 'scheme':
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            var scheme = reader.readContentAsString();
                            if (!common_1.StringEx._isNullOrWhiteSpace(scheme) && excel_style_1.FontSchemeCategory[scheme.toLocaleLowerCase()] !== undefined) {
                                styleFont.fontScheme = excel_style_1.FontSchemeCategory[scheme.toLocaleLowerCase()];
                            }
                        }
                    }
                    break;
                case 'shadow':
                    styleFont.isShadowStyle = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.isShadowStyle = reader.readContentAsBoolean(-1);
                        }
                    }
                    break;
                case 'strike':
                    styleFont.isStrikeOut = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.isStrikeOut = reader.readContentAsBoolean(-1);
                        }
                    }
                    break;
                case 'sz':
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            styleFont.fontSize = reader.readContentAsDouble(0);
                        }
                    }
                    break;
                case 'u':
                    var underLineStyle = 1;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            var u = reader.readContentAsString();
                            if (!common_1.StringEx._isNullOrWhiteSpace(u) && excelStyle.UnderLineStyle[u] !== undefined) {
                                underLineStyle = excelStyle.UnderLineStyle[u];
                            }
                        }
                    }
                    styleFont.underLineStyle = underLineStyle;
                    break;
                case 'vertAlign':
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'val') {
                            var vertAlign = reader.readContentAsString();
                            if (vertAlign && excelStyle.VertAlign[vertAlign.toLocaleLowerCase()] !== undefined) {
                                styleFont.vertAlign = excelStyle.VertAlign[vertAlign.toLocaleLowerCase()];
                            }
                        }
                    }
                    break;
                default:
                    break;
            }
        }
    }
    return styleFont;
}
exports.readRichTextFont = readRichTextFont;
function readFills(reader, styleFills) {
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            return;
        }
        if (reader.nodeType() === 1 && reader.name() === 'fill') {
            styleFills.push(readFill(reader));
            if (styleFills.length === 0) {
                styleFills.push({
                    patternType: 0,
                    fgColor: excel_style_1.ExcelColor.EmptyColor,
                    bgColor: excel_style_1.ExcelColor.EmptyColor
                });
            }
        }
    }
}
exports.readFills = readFills;
function readFill(reader) {
    var fill = new excelStyle.ExcelFill();
    var fillDepth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= fillDepth) {
            break;
        }
        if (reader.nodeType() === 1 && reader.name() === 'patternFill') {
            while (reader.moveToNextAttribute()) {
                if (reader.readAttributeNameAsString() === 'patternType') {
                    var patternTypeStr = reader.readContentAsString();
                    if (patternTypeStr && excelStyle.FillPatternType[patternTypeStr] !== undefined) {
                        fill.patternType = excelStyle.FillPatternType[patternTypeStr];
                    }
                }
            }
            if (reader.elementType === 3) {
                break;
            }
            var patternFillDepth = reader.depth;
            while (reader.read()) {
                if (reader.depth <= patternFillDepth) {
                    break;
                }
                if (reader.nodeType() === 1) {
                    if (reader.name() === 'fgColor') {
                        fill.fgColor = color_reader_1.readColor(reader);
                    }
                    else if (reader.name() === 'bgColor') {
                        fill.bgColor = color_reader_1.readColor(reader);
                    }
                }
            }
        }
        else if (reader.nodeType() === 1 && reader.name() === 'gradientFill') {
            fill.stops = [];
            while (reader.moveToNextAttribute()) {
                var attr = reader.readAttributeNameAsString();
                if (attr === "type") {
                    fill[attr] = reader.readContentAsString();
                }
                else if (attr === "degree") {
                    fill[attr] = reader.readContentAsInt();
                }
                else {
                    fill[attr] = reader.readContentAsDouble();
                }
            }
            if (reader.elementType === 3) {
                break;
            }
            var patternFillDepth = reader.depth;
            while (reader.read()) {
                if (reader.depth <= patternFillDepth) {
                    break;
                }
                if (reader.name() === "stop") {
                    var stop_1 = {};
                    if (reader.moveToNextAttribute() && reader.readAttributeNameAsString() === 'position') {
                        stop_1.position = reader.readContentAsDouble();
                    }
                    var stopDepth = reader.depth;
                    while (reader.read()) {
                        if (reader.depth <= stopDepth) {
                            break;
                        }
                        stop_1.color = color_reader_1.readColor(reader);
                    }
                    fill.stops.push(stop_1);
                }
            }
        }
    }
    return fill;
}
function readBorders(reader, styleBorders) {
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            return;
        }
        if (reader.nodeType() === 1 && reader.name() === 'border') {
            styleBorders.push(readBorder(reader));
        }
    }
}
exports.readBorders = readBorders;
function readBorder(reader) {
    var borderDepth = reader.depth, border = new excelStyle.ExcelBorder();
    var haveDiagonalUp = false;
    var haveDiagonalDown = false;
    while (reader.moveToNextAttribute()) {
        var attributeName = reader.readAttributeNameAsString();
        if (attributeName === 'diagonalUp') {
            haveDiagonalUp = true;
        }
        else if (attributeName === 'diagonalDown') {
            haveDiagonalDown = true;
        }
    }
    if (reader.elementType === 3 && !haveDiagonalUp && !haveDiagonalDown) {
        return border;
    }
    border.top = undefined;
    border.right = undefined;
    border.bottom = undefined;
    border.left = undefined;
    while (reader.read()) {
        if (reader.depth <= borderDepth) {
            break;
        }
        if (reader.nodeType() === 1) {
            switch (reader.name()) {
                case 'top':
                    border.top = readOneBorder(reader);
                    break;
                case 'right':
                case 'end':
                    border.right = readOneBorder(reader);
                    break;
                case 'bottom':
                    border.bottom = readOneBorder(reader);
                    break;
                case 'left':
                case 'start':
                    border.left = readOneBorder(reader);
                    break;
                case 'vertical':
                    border.vertical = readOneBorder(reader);
                    break;
                case 'horizontal':
                    border.horizontal = readOneBorder(reader);
                    break;
                case 'diagonal':
                    var tempBorder = readOneBorder(reader);
                    if (haveDiagonalUp) {
                        border.diagonalUp = tempBorder;
                    }
                    if (haveDiagonalDown) {
                        border.diagonalDown = tempBorder;
                    }
                    break;
                default:
                    break;
            }
        }
    }
    return border;
}
function readOneBorder(reader) {
    var borderside = new excelStyle.ExcelBorderSide();
    borderside.lineStyle = 0;
    while (reader.moveToNextAttribute()) {
        if (reader.readAttributeNameAsString() === 'style') {
            var style = reader.readContentAsString();
            if (style && excelStyle.ExcelBorderStyle[style] !== undefined) {
                borderside.lineStyle = excelStyle.ExcelBorderStyle[style];
            }
        }
    }
    if (reader.elementType === 3) {
        return borderside;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1 && reader.name() === 'color') {
            borderside.color = color_reader_1.readColor(reader);
        }
    }
    return borderside;
}
function readXFs(reader, result, styleFonts, styleBorders, numberFormats, styleFills, isStyleXf) {
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            return;
        }
        if (reader.nodeType() === 1 && reader.name() === 'xf') {
            var style = new excelStyle.ExtendedFormat();
            style.isStyleFormat = isStyleXf;
            readXFAttr(reader, style, styleFonts, styleBorders, numberFormats, styleFills);
            result.push(style);
            if (reader.elementType === 3) {
                continue;
            }
            var styleDepth = reader.depth;
            while (reader.read()) {
                if (reader.depth <= styleDepth) {
                    break;
                }
                if (reader.nodeType() === 1) {
                    if (reader.name() === 'alignment') {
                        readAlignment(reader, style);
                    }
                    else if (reader.name() === 'protection') {
                        readProtection(reader, style);
                    }
                }
            }
        }
    }
}
exports.readXFs = readXFs;
function readXFAttr(reader, style, styleFonts, styleBorders, numberFormats, styleFills) {
    var formatId = 0, fontId = 0, fillId = 0, borderId = 0;
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case 'numFmtId':
                formatId = reader.readContentAsInt(0);
                break;
            case 'fontId':
                fontId = reader.readContentAsInt(0);
                break;
            case 'fillId':
                fillId = reader.readContentAsInt(0);
                break;
            case 'borderId':
                borderId = reader.readContentAsInt(0);
                break;
            case 'applyAlignment':
                var applyAlignment = reader.readContentAsInt(-1);
                if (applyAlignment === 0 || applyAlignment === 1) {
                    style.applyAlignment = (applyAlignment === 1);
                }
                break;
            case 'applyBorder':
                var applyBorder = reader.readContentAsInt(-1);
                if (applyBorder === 0 || applyBorder === 1) {
                    style.applyBorder = (applyBorder === 1);
                }
                break;
            case 'applyFill':
                var applyFill = reader.readContentAsInt(-1);
                if (applyFill === 0 || applyFill === 1) {
                    style.applyFill = (applyFill === 1);
                }
                break;
            case 'applyFont':
                var applyFont = reader.readContentAsInt(-1);
                if (applyFont === 0 || applyFont === 1) {
                    style.applyFont = (applyFont === 1);
                }
                break;
            case 'applyProtection':
                var applyProtection = reader.readContentAsInt(-1);
                if (applyProtection === 0 || applyProtection === 1) {
                    style.applyProtection = (applyProtection === 1);
                }
                break;
            case 'applyNumberFormat':
                var applyNumberFormat = reader.readContentAsInt(-1);
                if (applyNumberFormat === 0 || applyNumberFormat === 1) {
                    style.applyNumberFormat = (applyNumberFormat === 1);
                }
                break;
            case 'xfId':
                var parentXfID = reader.readContentAsInt(-1);
                if (parentXfID >= 0) {
                    style.parentFormatID = parentXfID;
                }
                break;
            case 'quotePrefix':
                var quotePrefix = reader.readContentAsBoolean();
                style.quotePrefix = quotePrefix;
                break;
            default:
                break;
        }
    }
    style.font = styleFonts[fontId];
    style.border = styleBorders[borderId];
    if (numberFormats[formatId]) {
        style.numberFormat = numberFormats[formatId];
    }
    else {
        style.numberFormatIndex = formatId;
    }
    var fill = styleFills[fillId];
    if (fill) {
        style.fill = fill;
    }
    style.isLocked = true;
    style.isHidden = false;
    style.horizontalAlign = 0;
    style.verticalAlign = 2;
}
function readAlignment(reader, style) {
    var hAlign = null, vAlign = null, justifyLastLine = false, isShrinkToFit = false, isWordWrap = false;
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case 'horizontal':
                hAlign = reader.readContentAsString();
                break;
            case 'vertical':
                vAlign = reader.readContentAsString();
                break;
            case 'textRotation':
                var textRotation = reader.readContentAsString();
                if (!common_1.StringEx._isNullOrWhiteSpace(textRotation)) {
                    style.rotation = parseInt(textRotation, 10);
                }
                break;
            case 'readingOrder':
                var readingOrder = reader.readContentAsString();
                if (!common_1.StringEx._isNullOrWhiteSpace(readingOrder)) {
                    style.readingOrder = parseInt(readingOrder, 10);
                }
                break;
            case 'indent':
                var indent = reader.readContentAsString();
                if (!common_1.StringEx._isNullOrWhiteSpace(indent)) {
                    style.indent = parseInt(indent, 10);
                }
                break;
            case 'justifyLastLine':
                justifyLastLine = reader.readContentAsBoolean(false);
                break;
            case 'shrinkToFit':
                isShrinkToFit = reader.readContentAsBoolean(false);
                break;
            case 'wrapText':
                isWordWrap = reader.readContentAsBoolean(false);
                break;
            default:
                break;
        }
    }
    style.isJustfyLastLine = justifyLastLine;
    style.isShrinkToFit = isShrinkToFit;
    style.isWordWrap = isWordWrap;
    if (common_1.StringEx._isNullOrWhiteSpace(hAlign)) {
        hAlign = 'general';
    }
    if (common_1.StringEx._isNullOrWhiteSpace(vAlign)) {
        vAlign = 'bottom';
    }
    style.verticalAlign = excel_style_1.ExcelVerticalAlignment[vAlign];
    style.horizontalAlign = excelStyle.ExcelHorizontalAlignment[hAlign];
}
function readProtection(reader, style) {
    while (reader.moveToNextAttribute()) {
        var attrName = reader.readAttributeNameAsString();
        if (attrName === 'hidden') {
            style.isHidden = reader.readContentAsBoolean(false);
        }
        else if (attrName === 'locked') {
            var lockedStr = reader.readContentAsString();
            if (!common_1.StringEx._isNullOrEmpty(lockedStr) && (lockedStr === '0' || lockedStr === 'false')) {
                style.isLocked = false;
            }
        }
    }
}
function readCellStyles(reader, readerDataModel, styleCellStyleXfs) {
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            return;
        }
        if (reader.nodeType() === 1 && reader.name() === 'cellStyle') {
            var name_1 = void 0, xfId = 0, builtinId = -1, customBuiltin = false, iLevel = 0;
            while (reader.moveToNextAttribute()) {
                switch (reader.readAttributeNameAsString()) {
                    case 'name':
                        name_1 = common_1.Util._xmlDecode(reader.readContentAsString());
                        break;
                    case 'xfId':
                        xfId = reader.readContentAsInt(0);
                        break;
                    case 'builtinId':
                        builtinId = reader.readContentAsInt(-1);
                        break;
                    case 'customBuiltin':
                        customBuiltin = reader.readContentAsBoolean(false);
                        break;
                    case 'iLevel':
                        iLevel = reader.readContentAsInt(0);
                        break;
                    default:
                        break;
                }
            }
            var cellFormat = styleCellStyleXfs[xfId];
            if (builtinId !== -1) {
                var style = new excelStyle.ExcelStyle();
                style.name = name_1;
                style.format(cellFormat.clone());
                style.isCustomBuiltin = customBuiltin;
                style.builtInStyle = builtinId;
                if (style.builtInStyle === 2 || style.builtInStyle === 1) {
                    style.outLineLevel = iLevel;
                }
                readerDataModel._setExcelStyle(style, xfId);
            }
            else {
                var customStyle = new excelStyle.CustomExcelStyle();
                customStyle.name = name_1;
                customStyle.format(cellFormat.clone());
                readerDataModel._setExcelStyle(customStyle, xfId);
            }
        }
    }
}
function readColors(reader, readerDataModel) {
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth, palette = [];
    while (reader.read()) {
        if (reader.depth <= depth) {
            return;
        }
        if (reader.nodeType() === 1 && reader.name() === 'indexedColors') {
            var indexedColorsDepth = reader.depth;
            while (reader.read()) {
                if (reader.depth <= indexedColorsDepth) {
                    readerDataModel._setColorPalette(palette);
                    return;
                }
                if (reader.nodeType() === 1) {
                    var value = 0;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'rgb') {
                            value = parseInt(reader.readContentAsString(), 16);
                        }
                    }
                    palette.push((value & 0xFFFFFF) + 0xFF000000);
                }
            }
        }
    }
}
function readExtLst(reader, readerDataModel) {
    var dxfsRecords = null;
    var slicerStylesNode = null;
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1 && reader.name() === 'ext') {
            while (reader.moveToNextAttribute()) {
                if (reader.readAttributeNameAsString() === 'uri') {
                    var uriStr = reader.readContentAsString();
                    switch (uriStr) {
                        case "{46F421CA-312F-682f-3DD2-61675219B42D}":
                            dxfsRecords = readExtDxfs(reader);
                            break;
                        case "{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}":
                            var extNode = xml_parser_1.parseXmlToObject(reader.readFullElement(), true).ext;
                            if (!common_1.isNullOrUndefined(extNode)) {
                                slicerStylesNode = extNode['x14:slicerStyles'];
                            }
                            break;
                    }
                }
            }
        }
    }
    readerDataModel._extDxfRecords = dxfsRecords;
    readerDataModel._slicerStylesNode = slicerStylesNode;
}
function readExtDxfs(reader) {
    var dxfsRecords = [];
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1 && reader.name() === 'x14:dxfs') {
            dxfsRecords = readDifferentialFormattingRecords(reader);
        }
    }
    return dxfsRecords;
}
function readDxfs(reader, readerDataModel) {
    var differentialFormattingRecords = readDifferentialFormattingRecords(reader);
    readerDataModel._dxfRecords = differentialFormattingRecords;
}
function readDifferentialFormattingRecords(reader) {
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    var differentialFormattingRecords = [];
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1 && reader.name() === 'dxf') {
            differentialFormattingRecords.push(readDifferentialFormattingRecord(reader));
        }
    }
    return differentialFormattingRecords;
}
exports.readDifferentialFormattingRecords = readDifferentialFormattingRecords;
function readDifferentialFormattingRecord(reader) {
    var differentialFormattingRecord = {};
    if (reader.elementType === 3) {
        return differentialFormattingRecord;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1) {
            switch (reader.name()) {
                case 'font':
                    differentialFormattingRecord.font = readFont(reader);
                    break;
                case 'border':
                    differentialFormattingRecord.border = readBorder(reader);
                    break;
                case 'fill':
                    differentialFormattingRecord.fill = readFill(reader);
                    break;
                case 'numFmt':
                    differentialFormattingRecord.numberFormat = readNumberFormat(reader);
                    break;
                case 'alignment':
                    break;
                case 'protection':
                    break;
                default:
                    break;
            }
        }
    }
    return differentialFormattingRecord;
}
exports.readDifferentialFormattingRecord = readDifferentialFormattingRecord;
function readTableStyles(reader, readerDataModel) {
    if (reader.elementType === 3) {
        return;
    }
    readerDataModel.tableStylesObj = xml_parser_1.parseXmlToObject(reader.readFullElement()).tableStyles;
}


/***/ }),

/***/ "./src/xlsx-io/reader/table-reader.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/reader/table-reader.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var node_helper_1 = __webpack_require__(/*! ./../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var range_parser_1 = __webpack_require__(/*! ./../../common/range-parser */ "./src/common/range-parser.ts");
var autofilter_reader_1 = __webpack_require__(/*! ./autofilter-reader */ "./src/xlsx-io/reader/autofilter-reader.ts");
var autofilter_reader_2 = __webpack_require__(/*! ./autofilter-reader */ "./src/xlsx-io/reader/autofilter-reader.ts");
var getAsArray = node_helper_1.XmlNodeHelper._getAsArray;
var getValueFromObject = node_helper_1.XmlNodeHelper._getValueFromObject;
function getNodeValue(obj, key, subkey) {
    return common_1.Util._xmlDecode(getValueFromObject(obj, key, subkey));
}
var ExcelTableThemeType2SpreadJSThemeType = {
    wholeTable: 'wholeTableStyle',
    headerRow: 'headerRowStyle',
    totalRow: 'footerRowStyle',
    firstColumn: 'highlightFirstColumnStyle',
    lastColumn: 'highlightLastColumnStyle',
    firstRowStripe: 'firstRowStripStyle',
    secondRowStripe: 'secondRowStripStyle',
    firstColumnStripe: 'firstColumnStripStyle',
    secondColumnStripe: 'secondColumnStripStyle',
    firstHeaderCell: 'firstHeaderCellStyle',
    lastHeaderCell: 'lastHeaderCellStyle',
    firstTotalCell: 'firstFooterCellStyle',
    lastTotalCell: 'lastFooterCellStyle'
};
function generateTableTheme() {
    var retValue = {};
    for (var i = 1; i <= 28; i++) {
        if (i <= 21) {
            retValue['TABLESTYLELIGHT' + i] = true;
        }
        if (i <= 11) {
            retValue['TABLESTYLEDARK' + i] = true;
        }
        retValue['TABLESTYLEMEDIUM' + i] = true;
    }
    return retValue;
}
var BuiltInTableThemeNames = generateTableTheme();
function readTables(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData) {
    if (relationFiles) {
        var tableFile = void 0;
        var tables = [];
        for (var key in relationFiles) {
            if (key !== 'count') {
                var relationFile = relationFiles[key];
                if (relationFile) {
                    var fileType = relationFile.fileType;
                    if (fileType === excel_types_1.RelationshipConstants._relationshipTableType) {
                        tableFile = relationFile;
                    }
                    if (tableFile) {
                        var sheetTable = readTablesFromFile(tableFile, getFileDataAndCleanData, readerDataModel, sheetName);
                        if (!common_1.isNullOrUndefined(sheetTable)) {
                            tables.push(sheetTable);
                        }
                    }
                }
            }
        }
        readerDataModel._setTables(tables, sheetName);
    }
}
exports.readTables = readTables;
function readTablesFromFile(tableFile, getFileDataAndCleanData, readerDataModel, sheetName) {
    var dataString = getFileDataAndCleanData(tableFile.fileName);
    if (dataString) {
        return readTable(dataString, readerDataModel, sheetName);
    }
}
exports.readTablesFromFile = readTablesFromFile;
function readTable(dataString, readerDataModel, sheetName) {
    var tableObj = xml_parser_1.parseXmlToObject(dataString);
    var sheetTable = {};
    var tableAttr = tableObj && tableObj.table && tableObj.table._attr;
    if (!common_1.isNullOrUndefined(tableAttr)) {
        sheetTable.id = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(tableAttr.id, 0);
        sheetTable.name = tableAttr.name;
        var refStr = tableAttr.ref;
        if (!common_1.isNullOrUndefined(refStr)) {
            var range = range_parser_1.getRangesFromString(refStr, true)[0];
            sheetTable.row = range.row;
            sheetTable.col = range.col;
            sheetTable.rowCount = range.rowCount;
            sheetTable.colCount = range.colCount;
        }
        var headerRowCount = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(tableAttr.headerRowCount, 1);
        if (headerRowCount >= 1) {
            sheetTable.showHeader = true;
        }
        else {
            sheetTable.showHeader = false;
        }
        sheetTable.showFooter = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(tableAttr.totalsRowShown, true);
        var totalRowCount = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(tableAttr.totalsRowCount, -1);
        if (totalRowCount < 1) {
            sheetTable.showFooter = false;
        }
        else {
            sheetTable.showFooter = true;
        }
        var tableNode = tableObj && tableObj.table;
        var autoFilter = void 0, sortInfo = void 0;
        if (!common_1.isNullOrUndefined(tableNode)) {
            for (var element in tableNode) {
                if (tableNode.hasOwnProperty(element) && !common_1.isNullOrUndefined(tableNode[element])) {
                    switch (element) {
                        case 'autoFilter':
                            autoFilter = autofilter_reader_1.readAutoFilter(tableNode[element]);
                            break;
                        case 'sortState':
                            sortInfo = autofilter_reader_2.readSortInfo(tableNode[element]);
                            break;
                        case 'tableColumns':
                            sheetTable.columns = readTableColumns(tableNode[element]);
                            break;
                        case 'tableStyleInfo':
                            readTableStyleInfo(tableNode[element], sheetTable, readerDataModel);
                            break;
                        case 'extLst':
                            sheetTable.reservedElement = tableNode[element];
                            break;
                    }
                }
            }
        }
        var filter = autoFilter || {};
        sheetTable.rowFilter = readerDataModel._convertAutoFilterToJSON(filter, sheetName) || {};
        sheetTable.rowFilter.sortInfo = sortInfo;
        sheetTable.rowFilter.showFilterButton = true;
        sheetTable.rowFilter.filterButtonVisibleInfo = {};
        for (var i = 0; i < sheetTable.colCount; i++) {
            sheetTable.rowFilter.filterButtonVisibleInfo[i] = true;
        }
        if (!sheetTable.rowFilter.range) {
            if (!sheetTable.rowFilter.sortInfo) {
                sheetTable.rowFilter.showFilterButton = false;
                sheetTable.rowFilter.filterButtonVisibleInfo = {};
                for (var i = 0; i < sheetTable.colCount; i++) {
                    sheetTable.rowFilter.filterButtonVisibleInfo[i] = false;
                }
            }
            sheetTable.rowFilter.range = {
                row: sheetTable.row + 1,
                col: sheetTable.col,
                rowCount: sheetTable.rowCount - 1,
                colCount: sheetTable.colCount
            };
            if (sheetTable.showFooter) {
                sheetTable.rowFilter.range.rowCount--;
            }
        }
        if (sheetTable.rowFilter.filteredColumns && sheetTable.rowFilter.filteredColumns.length > 0) {
            if (filter.filterColumns[0].hiddenButton || sheetTable.rowFilter.showFilterButton === false) {
                sheetTable.rowFilter.showFilterButton = false;
                sheetTable.rowFilter.filterButtonVisibleInfo = {};
                for (var i = 0; i < sheetTable.colCount; i++) {
                    sheetTable.rowFilter.filterButtonVisibleInfo[i] = false;
                }
            }
        }
        if (sheetTable.showHeader === false) {
            sheetTable.rowFilter.showFilterButton = false;
        }
    }
    return sheetTable;
}
function readTableColumns(columnsNode) {
    var columns = [];
    var columnsArray = getAsArray(columnsNode.tableColumn);
    if (!common_1.isNullOrUndefined(columnsArray)) {
        columnsArray.forEach(function (columnNode) {
            var tableColumnInfo = {};
            tableColumnInfo.footerFormula = null;
            tableColumnInfo.footerValue = null;
            var attr = columnNode._attr;
            if (!common_1.isNullOrUndefined(attr)) {
                if (!common_1.isNullOrUndefined(attr.id)) {
                    tableColumnInfo.id = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(attr.id, 0);
                }
                if (!common_1.isNullOrUndefined(attr.name)) {
                    var name_1 = common_1.Util._replaceAll(attr.name, '_x000d__x000a_', '\n');
                    tableColumnInfo.name = common_1.Util._xmlDecode(common_1.Util._replaceAll(name_1, '_x000a_', '\n'));
                }
                if (!common_1.isNullOrUndefined(attr.totalsRowLabel)) {
                    tableColumnInfo.footerValue = common_1.Util._xmlDecode(attr.totalsRowLabel);
                }
                if (!common_1.isNullOrUndefined(attr.totalsRowFunction)) {
                    if (attr.totalsRowFunction === 'custom') {
                        tableColumnInfo.footerFormula = getNodeValue(columnNode, 'totalsRowFormula');
                    }
                    else {
                        tableColumnInfo.footerFormula = attr.totalsRowFunction;
                    }
                }
            }
            var calculatedColumnFormula = columnNode.calculatedColumnFormula;
            if (!common_1.isNullOrUndefined(calculatedColumnFormula)) {
                tableColumnInfo.dataAreaFormula = common_1.Util._xmlDecode(common_1.processFunction(calculatedColumnFormula.calculatedColumnFormula));
            }
            columns.push(tableColumnInfo);
        });
    }
    return columns;
}
function readTableStyleInfo(styleInfoNode, sheetTable, readerDataModel) {
    var tableTheme = {};
    var attr = styleInfoNode._attr;
    if (!common_1.isNullOrUndefined(attr)) {
        if (!common_1.isNullOrUndefined(attr.name)) {
            readTableStyle(sheetTable, tableTheme, readerDataModel, attr.name);
        }
        if (!common_1.isNullOrUndefined(attr.showFirstColumn)) {
            sheetTable.highlightFirstColumn = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.showFirstColumn, false);
        }
        if (!common_1.isNullOrUndefined(attr.showLastColumn)) {
            sheetTable.highlightLastColumn = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.showLastColumn, false);
        }
        if (!common_1.isNullOrUndefined(attr.showRowStripes)) {
            sheetTable.bandRows = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.showRowStripes, false);
        }
        if (!common_1.isNullOrUndefined(attr.showColumnStripes)) {
            sheetTable.bandColumns = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(attr.showColumnStripes, false);
        }
    }
}
function readTableStyle(sheetTable, tableTheme, readerDataModel, name) {
    var isBuildInTableStyle = BuiltInTableThemeNames[name.toUpperCase()];
    if (isBuildInTableStyle) {
        tableTheme.buildInName = getBuiltInTableStyle(name);
    }
    else {
        var tableStylesObj = readerDataModel.tableStylesObj;
        if (!common_1.isNullOrUndefined(tableStylesObj)) {
            var attr = tableStylesObj._attr;
            if (!common_1.isNullOrUndefined(attr)) {
                var tableStyleCount = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(attr.count, 0);
                var styleNode = void 0;
                if (tableStyleCount > 0) {
                    var tableStylesArray = getAsArray(tableStylesObj.tableStyle);
                    if (!common_1.isNullOrUndefined(tableStylesArray)) {
                        for (var i = 0; i < tableStylesArray.length; i++) {
                            var styleName = tableStylesArray[i]._attr.name;
                            if (name === styleName) {
                                styleNode = tableStylesArray[i];
                                break;
                            }
                        }
                    }
                }
                readCustomerStyle(sheetTable, tableTheme, styleNode, readerDataModel);
            }
        }
    }
    sheetTable.style = tableTheme;
}
function readCustomerStyle(sheetTable, tableTheme, styleNode, readerDataModel) {
    var customerStyleNode = styleNode;
    var attr = customerStyleNode._attr;
    tableTheme.name = attr.name;
    if (attr.count && attr.count > 0) {
        readTableStyleElement(sheetTable, tableTheme, styleNode, readerDataModel);
    }
}
function getBuiltInTableStyle(name) {
    return name.substr(10);
}
function readTableStyleElement(sheetTable, tableTheme, styleNode, readerDataModel) {
    var styleElementArray = getAsArray(styleNode.tableStyleElement);
    if (!common_1.isNullOrUndefined(styleElementArray)) {
        styleElementArray.forEach(function (styleElementNode) {
            var elementAttr = styleElementNode._attr;
            if (!common_1.isNullOrUndefined(elementAttr)) {
                var elementType = elementAttr.type || 'wholeTable';
                var dxfid = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(elementAttr.dxfId) || 0;
                var stripSize = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(elementAttr.size) || 1;
                var style = readerDataModel._getStyleByDxfId(dxfid);
                tableTheme[ExcelTableThemeType2SpreadJSThemeType[elementType]] = style;
                if (elementType === 'firstRowStripe' || elementType === 'secondRowStripe' || elementType === 'firstColumnStripe' || elementType === 'secondColumnStripe') {
                    tableTheme[elementType.substr(0, elementType.length - 1) + 'Size'] = stripSize;
                }
            }
        });
    }
    sheetTable.style = tableTheme;
}


/***/ }),

/***/ "./src/xlsx-io/reader/theme-reader.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/reader/theme-reader.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var excel = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var xml_reader_1 = __webpack_require__(/*! ./../../xml-io/xml-reader */ "./src/xml-io/xml-reader.ts");
var chart_reader_1 = __webpack_require__(/*! ./chart-reader */ "./src/xlsx-io/reader/chart-reader.ts");
var ReadCT_OfficeStyleSheet = chart_reader_1.DrawingReader.ReadCT_OfficeStyleSheet;
function readTheme(dataString, readerDataModel) {
    var obj = xml_parser_1.parseXmlToObject(dataString, true);
    var themeObj = obj['a:theme'];
    if (themeObj) {
        var themeName = themeObj._attr.name;
        if (themeName && themeName.toUpperCase().substring(0, 6) === 'OFFICE') {
            themeName = 'Office';
        }
        var themeElementsObj = themeObj['a:themeElements'];
        if (themeElementsObj) {
            var colorScheme = readColorScheme(themeElementsObj);
            var fontScheme = readFontScheme(themeElementsObj);
            var theme = new excel.ExcelTheme(themeName, colorScheme, fontScheme);
            readerDataModel._setTheme(theme);
        }
        var reader = new xml_reader_1.XmlReader();
        reader.setXml(dataString);
        var themeInfo = ReadCT_OfficeStyleSheet(reader);
        readerDataModel._setThemeInfo(themeInfo);
    }
}
exports.readTheme = readTheme;
function readColorScheme(themeElementsObj) {
    var colors = [], clrSchemeObj = themeElementsObj['a:clrScheme'];
    if (clrSchemeObj) {
        var text1 = readThemeColor(clrSchemeObj['a:lt1']);
        if (text1) {
            colors.push(text1);
        }
        var background1 = readThemeColor(clrSchemeObj['a:dk1']);
        if (background1) {
            colors.push(background1);
        }
        var text2 = readThemeColor(clrSchemeObj['a:lt2']);
        if (text2) {
            colors.push(text2);
        }
        var background2 = readThemeColor(clrSchemeObj['a:dk2']);
        if (background2) {
            colors.push(background2);
        }
        var accent1 = readThemeColor(clrSchemeObj['a:accent1']);
        if (accent1) {
            colors.push(accent1);
        }
        var accent2 = readThemeColor(clrSchemeObj['a:accent2']);
        if (accent2) {
            colors.push(accent2);
        }
        var accent3 = readThemeColor(clrSchemeObj['a:accent3']);
        if (accent3) {
            colors.push(accent3);
        }
        var accent4 = readThemeColor(clrSchemeObj['a:accent4']);
        if (accent4) {
            colors.push(accent4);
        }
        var accent5 = readThemeColor(clrSchemeObj['a:accent5']);
        if (accent5) {
            colors.push(accent5);
        }
        var accent6 = readThemeColor(clrSchemeObj['a:accent6']);
        if (accent6) {
            colors.push(accent6);
        }
        var hyperlink = readThemeColor(clrSchemeObj['a:hlink']);
        if (hyperlink) {
            colors.push(hyperlink);
        }
        var followedHyperlink = readThemeColor(clrSchemeObj['a:folHlink']);
        if (followedHyperlink) {
            colors.push(followedHyperlink);
        }
        return new excel.ColorScheme(clrSchemeObj._attr.name, colors);
    }
}
function readFontScheme(themeElementsObj) {
    var fontSchemeObj = themeElementsObj['a:fontScheme'];
    if (fontSchemeObj) {
        var majorFont = readThemeFonts(fontSchemeObj['a:majorFont']);
        var minorFont = readThemeFonts(fontSchemeObj['a:minorFont']);
        return new excel.FontScheme(fontSchemeObj._attr.name, majorFont, minorFont);
    }
    return null;
}
function readThemeFonts(fontObj) {
    var rfs = [], tfs = [];
    if (fontObj) {
        if (fontObj['a:latin']) {
            rfs.push(new excel.RunFormatting(0, common_1.isNullOrUndefined(fontObj['a:latin']._attr.typeface) ? '' : fontObj['a:latin']._attr.typeface));
        }
        else if (fontObj['a:ea']) {
            rfs.push(new excel.RunFormatting(2, common_1.isNullOrUndefined(fontObj['a:ea']._attr.typeface) ? '' : fontObj['a:ea']._attr.typeface));
        }
        else if (fontObj['a:cs']) {
            rfs.push(new excel.RunFormatting(1, common_1.isNullOrUndefined(fontObj['a:cs']._attr.typeface) ? '' : fontObj['a:cs']._attr.typeface));
        }
        else if (fontObj['a:sym']) {
            rfs.push(new excel.RunFormatting(3, common_1.isNullOrUndefined(fontObj['a:sym']._attr.typeface) ? '' : fontObj['a:sym']._attr.typeface));
        }
        else if (fontObj['a:font']) {
            var aFontObjs = fontObj['a:font'];
            if (!Array.isArray(aFontObjs)) {
                aFontObjs = [aFontObjs];
            }
            for (var i = 0, len = aFontObjs.length; i < len; i++) {
                var aFontObj = aFontObjs[i];
                tfs.push(new excel.ThemeFont(aFontObj._attr.script, aFontObj._attr.typeface));
            }
        }
    }
    return new excel.ThemeFonts(rfs, tfs);
}
exports.readThemeFonts = readThemeFonts;
function readThemeColor(colorObj) {
    var color;
    if (!colorObj) {
        return;
    }
    if (colorObj['a:sysClr']) {
        var clc = colorObj['a:sysClr']._attr.val;
        var sysColor = excel_style_1.ExcelSystemColor.getSystemColor(clc);
        if (sysColor !== undefined) {
            color = sysColor;
        }
        else {
            clc = colorObj['a:sysClr']._attr.lastClr;
            if (!common_1.StringEx._isNullOrEmpty(clc)) {
                var colorValue = 0xFF000000 + (parseInt(clc, 16) & 0xFFFFFF);
                color = excel_style_1.ColorHelper.fromArgb(colorValue);
            }
        }
    }
    else if (colorObj['a:srgbClr']) {
        var clc = colorObj['a:srgbClr']._attr.val;
        if (!common_1.StringEx._isNullOrEmpty(clc)) {
            var colorValue = 0xFF000000 + (parseInt(clc, 16) & 0xFFFFFF);
            color = excel_style_1.ColorHelper.fromArgb(colorValue);
        }
    }
    else if (colorObj['a:scrgbClr']) {
        var f = parseFloat(colorObj['a:scrgbClr']._r), g = parseFloat(colorObj['a:scrgbClr']._attr.g), b = parseFloat(colorObj['a:scrgbClr']._attr.b);
        color = new excel_style_1._Color(0xff, excel_style_1.ColorHelper.scRgbTosRgb(f), excel_style_1.ColorHelper.scRgbTosRgb(g), excel_style_1.ColorHelper.scRgbTosRgb(b));
    }
    else if (colorObj['a:hslClr']) {
        var h = parseFloat(colorObj['a:hslClr']._hue), s = parseFloat(colorObj['a:hslClr']._attr.sat), l = parseFloat(colorObj['a:hslClr']._attr.lum);
        color = excel_style_1.ColorHelper.convertHLSToRGB(h, l, s);
    }
    else if (colorObj['a:prstClr']) {
        var value = colorObj['a:prstClr']._attr.val;
        if (!common_1.StringEx._isNullOrWhiteSpace(value)) {
            color = excel_style_1.ColorHelper.fromPresetColorVal(value);
        }
    }
    else if (colorObj['a:schemeClr']) {
    }
    if (color === undefined) {
        return;
    }
    return {
        a: color.a,
        r: color.r,
        g: color.g,
        b: color.b
    };
}
exports.readThemeColor = readThemeColor;


/***/ }),

/***/ "./src/xlsx-io/reader/workbook-reader.ts":
/*!***********************************************!*\
  !*** ./src/xlsx-io/reader/workbook-reader.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_parser_1 = __webpack_require__(/*! ./../../xml-io/xml-parser */ "./src/xml-io/xml-parser.ts");
var node_helper_1 = __webpack_require__(/*! ./../../xml-io/node-helper */ "./src/xml-io/node-helper.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var keyword_undefined = void 0;
function readWorkbook(dataString, readerDataModel) {
    var sheetIDs = [];
    var obj = xml_parser_1.parseXmlToObject(dataString);
    var workbookObj = obj.workbook;
    if (workbookObj) {
        if (workbookObj.workbookPr) {
            readWorkbookProperties(workbookObj.workbookPr, readerDataModel);
        }
        if (workbookObj.bookViews) {
            var workbookViewsObj = workbookObj.bookViews.workbookView, workbookViewsCount = workbookViewsObj.length;
            if (workbookViewsCount === keyword_undefined) {
                workbookViewsObj = [workbookViewsObj];
                workbookViewsCount = 1;
            }
            for (var i = 0; i < workbookViewsCount; i++) {
                readWorkbookView(workbookViewsObj[i], readerDataModel);
            }
        }
        if (workbookObj.pivotCaches) {
            readerDataModel._spread.pivotCaches = {};
            if (!Array.isArray(workbookObj.pivotCaches.pivotCache)) {
                workbookObj.pivotCaches.pivotCache = [workbookObj.pivotCaches.pivotCache];
            }
            for (var i = 0; i < workbookObj.pivotCaches.pivotCache.length; i++) {
                var pivotCache = readPivotCache(workbookObj.pivotCaches.pivotCache[i]);
                readerDataModel._spread.pivotCaches[pivotCache.cacheId] = pivotCache;
            }
        }
        if (workbookObj.sheets && workbookObj.sheets.sheet) {
            var sheetsObj = workbookObj.sheets.sheet;
            if (!Array.isArray(sheetsObj)) {
                sheetsObj = [sheetsObj];
            }
            sheetIDs = readSheets(sheetsObj, readerDataModel);
        }
        if (workbookObj.definedNames) {
            var definedNames = void 0;
            if (Array.isArray(workbookObj.definedNames.definedName)) {
                definedNames = workbookObj.definedNames.definedName;
            }
            else {
                definedNames = [workbookObj.definedNames.definedName];
            }
            readDefinedNames(definedNames, readerDataModel);
        }
        if (workbookObj.calcPr) {
            readWorkbookCalcProperties(workbookObj.calcPr, readerDataModel);
        }
    }
    return sheetIDs;
}
exports.readWorkbook = readWorkbook;
function readWorkbookProperties(workbookPrObj, readerDataModel) {
    var dataCompatibility = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(workbookPrObj._attr.dateCompatibility, true);
    if (dataCompatibility) {
        readerDataModel._setExcelWorkbookProperty(node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(workbookPrObj._attr.date1904, false));
    }
}
exports.readWorkbookProperties = readWorkbookProperties;
function readPivotCache(pivotCacheItem) {
    var result = {};
    result.cacheId = pivotCacheItem._attr.cacheId;
    result.rid = pivotCacheItem._attr['r:id'];
    return result;
}
exports.readPivotCache = readPivotCache;
function readWorkbookView(workbookViewObj, readerDataModel) {
    var showHorizontalScrollbar = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(workbookViewObj._attr.showHorizontalScroll, true);
    var showVerticalScrollbar = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(workbookViewObj._attr.showVerticalScroll, true);
    var showSheetTabs = node_helper_1.XmlNodeHelper._getAttrValueOrDefaultOfBooleanType(workbookViewObj._attr.showSheetTabs, true);
    var firstSheet = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(workbookViewObj._attr.firstSheet, 0);
    var activeTab = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(workbookViewObj._attr.activeTab, 0);
    var tabRatio = node_helper_1.XmlNodeHelper._getAttributeValueOrDefaultOfIntType(workbookViewObj._attr.tabRatio, 600);
    readerDataModel._setScroll(showHorizontalScrollbar, showVerticalScrollbar);
    readerDataModel._setTabs(showSheetTabs, activeTab, firstSheet, tabRatio);
}
exports.readWorkbookView = readWorkbookView;
function getID(obj) {
    var keys = Object.keys(obj);
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var attr = keys_1[_i];
        var tempArr = attr.split(":");
        if (tempArr && tempArr.length === 2 && tempArr[1] === 'id') {
            return obj[attr];
        }
    }
    return null;
}
function readSheets(sheetObjs, readerDataModel) {
    var sheetIDs = [];
    for (var i = 0; i < sheetObjs.length; i++) {
        var sheetObj = sheetObjs[i];
        var si = new excel_types_1.SheetInfo();
        var name_1 = common_1.Util._decodeSpecialCharacterFromXML(common_1.Util._xmlDecode(sheetObj._attr.name));
        si.name = name_1;
        si.index = i;
        si.sheetId = sheetObj._attr.sheetId;
        si.rID = sheetObj._attr['r:id'] || getID(sheetObj._attr);
        if (!common_1.StringEx._isNullOrWhiteSpace(si.rID)) {
            sheetIDs.push(si);
        }
        var state = sheetObj._attr.state, hidden = 0;
        if (state) {
            if (state === 'hidden') {
                hidden = 1;
            }
            else if (state === 'veryHidden') {
                hidden = 2;
            }
        }
        readerDataModel._addSheet(name_1, i, hidden);
    }
    return sheetIDs;
}
function readDefinedNames(definedNames, readerDataModel) {
    if (definedNames.length > 0) {
        readerDataModel._initDefinedNames();
        var definedName = void 0;
        for (var i = 0; i < definedNames.length; i++) {
            definedName = definedNames[i];
            if (definedName) {
                var local = definedName._attr.localSheetId;
                var name_2 = common_1.Util._xmlDecode(definedName._attr.name);
                var comment = common_1.Util._xmlDecode(definedName._attr.comment);
                var formula = common_1.Util._xmlDecode(definedName.definedName);
                var sheetIndex = -1;
                if (!common_1.isNullOrUndefined(local)) {
                    sheetIndex = parseInt(local, 10);
                }
                if (name_2 === '_xlnm.Print_Area') {
                    readerDataModel._setPrintArea(sheetIndex, formula);
                }
                else if (name_2 === '_xlnm.Print_Titles') {
                    readerDataModel._setPrintTitles(sheetIndex, formula);
                }
                else {
                    readerDataModel._addDefinedName(name_2, common_1.processFunction(formula), sheetIndex, comment);
                }
            }
        }
    }
}
function readWorkbookCalcProperties(calcPrObj, readerDataModel) {
    var refModeStr = calcPrObj._attr.refMode;
    var isR1C1 = false;
    if (refModeStr && refModeStr === 'R1C1') {
        isR1C1 = true;
    }
    var iterativeCalculation = {
        iterate: calcPrObj._attr.iterate,
        count: calcPrObj._attr.iterateCount,
        delta: calcPrObj._attr.iterateDelta
    };
    readerDataModel._setCalculationProperty(isR1C1, iterativeCalculation);
}
exports.readWorkbookCalcProperties = readWorkbookCalcProperties;


/***/ }),

/***/ "./src/xlsx-io/reader/worksheet-reader.ts":
/*!************************************************!*\
  !*** ./src/xlsx-io/reader/worksheet-reader.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var color_reader_1 = __webpack_require__(/*! ./../common/color-reader */ "./src/xlsx-io/common/color-reader.ts");
var xml_reader_1 = __webpack_require__(/*! ./../../xml-io/xml-reader */ "./src/xml-io/xml-reader.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var excel = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var excel_helper_1 = __webpack_require__(/*! ./../../datamodel/excel-helper */ "./src/datamodel/excel-helper.ts");
var conditionalformat_reader_1 = __webpack_require__(/*! ./conditionalformat-reader */ "./src/xlsx-io/reader/conditionalformat-reader.ts");
var sparkline_reader_1 = __webpack_require__(/*! ./sparkline-reader */ "./src/xlsx-io/reader/sparkline-reader.ts");
var autofilter_reader_1 = __webpack_require__(/*! ./autofilter-reader */ "./src/xlsx-io/reader/autofilter-reader.ts");
var datavalidation_reader_1 = __webpack_require__(/*! ./datavalidation-reader */ "./src/xlsx-io/reader/datavalidation-reader.ts");
var print_reader_1 = __webpack_require__(/*! ./print-reader */ "./src/xlsx-io/reader/print-reader.ts");
var keyword_null = null;
function readWorksheets(dataString, relationFiles, sheetName, readerDataModel, cellStyleXfsLength, sharedString) {
    var reader = new xml_reader_1.XmlReader();
    reader.reset();
    reader.setXml(dataString);
    var defaultRowHeight = 15;
    var sharedFormula = {};
    readerDataModel._rowInfos = [];
    readerDataModel._colInfos = [];
    readerDataModel._lastReadRow = 0;
    readerDataModel._lastReadColumn = 0;
    while (reader.read()) {
        if (reader.depth !== 1 || reader.elementType === 2) {
            continue;
        }
        try {
            switch (reader.name()) {
                case 'sheetPr':
                    readSheetPr(reader, sheetName, readerDataModel);
                    break;
                case 'dimension':
                    readDimension(reader, sheetName, readerDataModel);
                    break;
                case 'sheetViews':
                    readSheetViews(reader, sheetName, readerDataModel);
                    break;
                case 'sheetFormatPr':
                    defaultRowHeight = readSheetFormatProperties(reader, sheetName, readerDataModel);
                    break;
                case 'cols':
                    readColumnInfo(reader, sheetName, readerDataModel, cellStyleXfsLength);
                    break;
                case 'mergeCells':
                    readMergeCells(reader, sheetName, readerDataModel);
                    break;
                case 'sheetData':
                    readSheetData(reader, sheetName, readerDataModel, sharedFormula, defaultRowHeight, cellStyleXfsLength, sharedString);
                    break;
                case 'sheetProtection':
                    readSheetProtection(reader, sheetName, readerDataModel);
                    break;
                case 'conditionalFormatting':
                    conditionalformat_reader_1.readConditionalFormatting(reader, sheetName, readerDataModel);
                    break;
                case 'extLst':
                    readExtensionList(reader, sheetName, readerDataModel);
                    break;
                case 'autoFilter':
                    autofilter_reader_1.readAutoFilterForSheet(reader, sheetName, readerDataModel);
                    break;
                case 'dataValidations':
                    datavalidation_reader_1.readDataValidations(reader, sheetName, readerDataModel);
                    break;
                case 'pageMargins':
                    print_reader_1.readPageMargins(reader, sheetName, readerDataModel);
                    break;
                case 'printOptions':
                    print_reader_1.readPrintOptions(reader, sheetName, readerDataModel);
                    break;
                case 'pageSetup':
                    print_reader_1.readPageSetup(reader, readerDataModel);
                    break;
                case 'headerFooter':
                    print_reader_1.readHeaderFooter(reader, readerDataModel);
                    break;
                case 'rowBreaks':
                    print_reader_1.readRowColumnBreaks(reader, readerDataModel, true);
                    break;
                case 'colBreaks':
                    print_reader_1.readRowColumnBreaks(reader, readerDataModel, false);
                    break;
                case 'legacyDrawingHF':
                    print_reader_1.readLegacyDrawingHF(reader, readerDataModel);
                    break;
                case 'hyperlinks':
                    readHyperlinks(reader, sheetName, readerDataModel, relationFiles);
                    break;
                default:
                    break;
            }
        }
        catch (e) {
        }
    }
}
exports.readWorksheets = readWorksheets;
function readSheetPr(reader, sheetName, readerDataModel) {
    while (reader.moveToNextAttribute()) {
        var attrName = reader.readAttributeNameAsString();
        if (attrName === 'filterMode') {
            reader.readContentAsString();
        }
    }
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1) {
            switch (reader.name()) {
                case 'tabColor':
                    readerDataModel._setSheetTabColor(sheetName, color_reader_1.readColor(reader));
                    break;
                case 'outlinePr':
                    var summaryBelow = true, summaryRight = true;
                    while (reader.moveToNextAttribute()) {
                        if (reader.readAttributeNameAsString() === 'summaryBelow') {
                            summaryBelow = reader.readContentAsBoolean();
                        }
                        else if (reader.readAttributeNameAsString() === 'summaryRight') {
                            summaryRight = reader.readContentAsBoolean();
                        }
                    }
                    readerDataModel._setOutlineDirection(sheetName, summaryRight, summaryBelow);
                    break;
                case 'pageSetUpPr':
                    print_reader_1.readPageSetupAdditionalProperty(reader, readerDataModel);
                    break;
            }
        }
    }
}
function readDimension(reader, sheetName, readerDataModel) {
    while (reader.moveToNextAttribute()) {
        if (reader.readAttributeNameAsString() === 'ref') {
            var ref = reader.readContentAsString();
            var rc = ref.split(':');
            var rowCount = void 0, columnCount = void 0;
            if (rc.length === 2) {
                var r1 = common_1.IndexHelper._getRowIndexInNumber(rc[0]);
                var r2 = common_1.IndexHelper._getRowIndexInNumber(rc[1]);
                var c1 = common_1.IndexHelper._getColumnIndexInNumber(rc[0]);
                var c2 = common_1.IndexHelper._getColumnIndexInNumber(rc[1]);
                rowCount = Math.max(r1, r2) + 1;
                columnCount = Math.max(c1, c2) + 1;
            }
            else if (rc.length === 1) {
                var r1 = common_1.IndexHelper._getRowIndexInNumber(rc[0]);
                var c1 = common_1.IndexHelper._getColumnIndexInNumber(rc[0]);
                rowCount = r1 + 1;
                columnCount = c1 + 1;
            }
            readerDataModel._setDimensions(sheetName, rowCount, columnCount);
        }
    }
}
function readSheetViews(reader, sheetName, readerDataModel) {
    readerDataModel._resetActivePaneType();
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1 && reader.name() === 'sheetView') {
            readSheetViewAttr(reader, sheetName, readerDataModel);
            var topLeftCell = readerDataModel._sheetViewTopLeftCell, row = void 0, col = void 0;
            if (topLeftCell) {
                row = common_1.IndexHelper._getRowIndexInNumber(topLeftCell);
                col = common_1.IndexHelper._getColumnIndexInNumber(topLeftCell);
            }
            if (row !== undefined && col !== undefined) {
                readerDataModel._setTopLeftCell(row, col, sheetName);
            }
            if (reader.elementType === 3) {
                continue;
            }
            var sheetViewDepth = reader.depth;
            while (reader.read()) {
                if (reader.depth <= sheetViewDepth) {
                    break;
                }
                if (reader.nodeType() === 1) {
                    if (reader.name() === 'selection') {
                        var rowActive = -1, columnActive = -1, refCount = 0, rowFirst = [], rowLast = [], colFirst = [], colLast = [], ranges = [], activeCell = '', paneType = 3;
                        while (reader.moveToNextAttribute()) {
                            switch (reader.readAttributeNameAsString()) {
                                case 'sqref':
                                    ranges = reader.readContentAsString().split(' ');
                                    break;
                                case 'activeCellId':
                                    break;
                                case 'activeCell':
                                    activeCell = reader.readContentAsString();
                                    break;
                                case 'pane':
                                    var pane = reader.readContentAsString();
                                    if (pane && excel.PaneType[pane] !== undefined) {
                                        paneType = excel.PaneType[pane];
                                    }
                                    break;
                                default:
                                    break;
                            }
                        }
                        for (var i = 0, len1 = ranges.length; i < len1; i++) {
                            var qref = ranges[i].split(':');
                            if (qref.length === 1) {
                                var rowIndex = common_1.IndexHelper._getRowIndexInNumber(qref[0]);
                                var colIndex = common_1.IndexHelper._getColumnIndexInNumber(qref[0]);
                                rowFirst.push(rowIndex);
                                rowLast.push(rowIndex);
                                colFirst.push(colIndex);
                                colLast.push(colIndex);
                                refCount++;
                            }
                            else if (qref.length === 2) {
                                rowFirst.push(common_1.IndexHelper._getRowIndexInNumber(qref[0]));
                                colFirst.push(common_1.IndexHelper._getColumnIndexInNumber(qref[0]));
                                rowLast.push(common_1.IndexHelper._getRowIndexInNumber(qref[1]));
                                colLast.push(common_1.IndexHelper._getColumnIndexInNumber(qref[1]));
                                refCount++;
                            }
                        }
                        if (activeCell) {
                            rowActive = common_1.IndexHelper._getRowIndexInNumber(activeCell);
                            columnActive = common_1.IndexHelper._getColumnIndexInNumber(activeCell);
                        }
                        readerDataModel._setSelection(sheetName, paneType, rowActive, columnActive, refCount, rowFirst, rowLast, colFirst, colLast);
                    }
                    else if (reader.name() === 'pane') {
                        var state = null, isFrozen = false, activePane = 3, xSplit = 0, ySplit = 0;
                        while (reader.moveToNextAttribute()) {
                            switch (reader.readAttributeNameAsString()) {
                                case 'topLeftCell':
                                    topLeftCell = reader.readContentAsString();
                                    break;
                                case 'xSplit':
                                    xSplit = reader.readContentAsInt(0);
                                    break;
                                case 'ySplit':
                                    ySplit = reader.readContentAsInt(0);
                                    break;
                                case 'state':
                                    state = reader.readContentAsString();
                                    if (state && (state === 'frozen' || state === 'frozenSplit')) {
                                        isFrozen = true;
                                    }
                                    break;
                                case 'activePane':
                                    var pane = reader.readContentAsString();
                                    if (pane && excel.PaneType[pane] !== undefined) {
                                        activePane = excel.PaneType[pane];
                                    }
                                    break;
                                default:
                                    break;
                            }
                        }
                        readerDataModel._setActivePaneType(activePane);
                        readerDataModel._setPane(sheetName, xSplit, ySplit, topLeftCell, isFrozen);
                    }
                }
            }
        }
    }
}
function readSheetViewAttr(reader, sheetName, readerDataModel) {
    var tabSelected = false, gridLineColor = null, showGridLine = true, showRowColHeaders = true, zoom = 100, showFormulas = false, topLeftCell = 'A1';
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case 'colorId':
                var colorId = reader.readContentAsInt(-1);
                if (colorId >= 0) {
                    gridLineColor = new excel_style_1.ExcelColor(1, colorId, 0.0);
                }
                break;
            case 'showGridLines':
                showGridLine = reader.readContentAsBoolean();
                break;
            case 'showRowColHeaders':
                showRowColHeaders = reader.readContentAsBoolean();
                break;
            case 'showFormulas':
                showFormulas = reader.readContentAsBoolean();
                break;
            case 'zoomScale':
                zoom = reader.readContentAsDouble(100);
                break;
            case 'topLeftCell':
                topLeftCell = reader.readContentAsString();
                break;
            case 'tabSelected':
                tabSelected = reader.readContentAsBoolean();
                break;
            default:
                break;
        }
    }
    readerDataModel._setDisplayElements(sheetName, gridLineColor, showGridLine, showRowColHeaders, zoom, showFormulas, tabSelected);
    readerDataModel._sheetViewTopLeftCell = topLeftCell;
}
function readSheetFormatProperties(reader, sheetName, readerDataModel) {
    var height = NaN, defaultColumnWidth = NaN, baseColumnWidth = 8;
    var defaultRowHeight = 15;
    while (reader.moveToNextAttribute()) {
        if (reader.readAttributeNameAsString() === 'defaultRowHeight') {
            height = reader.readContentAsDouble(NaN);
        }
        else if (reader.readAttributeNameAsString() === 'defaultColWidth') {
            defaultColumnWidth = reader.readContentAsDouble(NaN);
        }
        else if (reader.readAttributeNameAsString() === 'baseColWidth') {
            baseColumnWidth = reader.readContentAsDouble(8);
        }
    }
    if (!isNaN(height)) {
        readerDataModel._setDefaultRowHeight(sheetName, height);
        defaultRowHeight = height;
    }
    readerDataModel._setDefaultColumnWidth(sheetName, baseColumnWidth, defaultColumnWidth);
    return defaultRowHeight;
}
function readColumnInfo(reader, sheetName, readerDataModel, cellStyleXfsLength) {
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1 && reader.name() === 'col') {
            var colFirst = 0, colLast = 0, ixf = 0, width = 0, outlineLevel = 0, hidden = false, collapsed = false;
            while (reader.moveToNextAttribute()) {
                switch (reader.readAttributeNameAsString()) {
                    case 'min':
                        colFirst = reader.readContentAsInt(0) - 1;
                        break;
                    case 'max':
                        colLast = reader.readContentAsInt(0) - 1;
                        break;
                    case 'style':
                        ixf = reader.readContentAsInt(0);
                        break;
                    case 'width':
                        width = reader.readContentAsDouble(8);
                        break;
                    case 'hidden':
                        hidden = reader.readContentAsBoolean(false);
                        break;
                    case 'collapsed':
                        collapsed = reader.readContentAsBoolean(false);
                        break;
                    case 'outlineLevel':
                        outlineLevel = reader.readContentAsInt(0);
                        break;
                    default:
                        break;
                }
            }
            if (colFirst >= 0 && colLast >= 0) {
                readerDataModel._setColumnInfo(sheetName, colFirst, colLast, ixf + cellStyleXfsLength, width, hidden, outlineLevel, collapsed);
            }
        }
    }
    adjustColumnWidthAndHiddenInfoForOutlineColumn(readerDataModel._spread.sheets && readerDataModel._spread.sheets[sheetName]);
}
function adjustColumnWidthAndHiddenInfoForOutlineColumn(sheet) {
    if (sheet && sheet.columns) {
        var columns = sheet.columns;
        var group = sheet.columnOutlines;
        for (var i = 0; i < columns.length; i++) {
            if (columns[i]) {
                var columnCollapsed = excel_helper_1.isCollapsed(i, group);
                if (columnCollapsed && columns[i].size === 0) {
                    columns[i].size = keyword_null;
                }
                if (columnCollapsed && columns[i] && columns[i].visible === false) {
                    delete columns[i].visible;
                }
            }
        }
    }
}
function readMergeCells(reader, sheetName, readerDataModel) {
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1 && reader.name() === 'mergeCell') {
            while (reader.moveToNextAttribute()) {
                if (reader.readAttributeNameAsString() === 'ref') {
                    var s = reader.readContentAsString();
                    var rc = s.split(':');
                    if (rc.length === 2) {
                        var startRow = common_1.IndexHelper._getRowIndexInNumber(rc[0]), endRow = common_1.IndexHelper._getRowIndexInNumber(rc[1]), startCol = common_1.IndexHelper._getColumnIndexInNumber(rc[0]), endCol = common_1.IndexHelper._getColumnIndexInNumber(rc[1]);
                        readerDataModel._setMergeCells(sheetName, startRow, endRow, startCol, endCol);
                    }
                }
            }
        }
    }
}
function readSheetData(reader, sheetName, readerDataModel, sharedFormula, defaultRowHeight, cellStyleXfsLength, sharedString) {
    if (reader.elementType !== 3) {
        var sheetDataDepth = reader.depth;
        readerDataModel._initDataTable(sheetName);
        var lastReadRow = -1;
        do {
            reader.fastRead();
            if (reader.depth <= sheetDataDepth) {
                break;
            }
            lastReadRow = readRow(reader, sheetName, sharedFormula, lastReadRow, readerDataModel, defaultRowHeight, cellStyleXfsLength, sharedString);
        } while (reader.depth > sheetDataDepth);
        if (readerDataModel._lastReadRow < lastReadRow) {
            readerDataModel._lastReadRow = lastReadRow;
        }
    }
    readerDataModel._setSheetData(sheetName);
}
function readRow(reader, sheetName, sharedFormula, lastReadRow, readerDataModel, defaultRowHeight, cellStyleXfsLength, sharedString) {
    var rowIndex = lastReadRow + 1, ixf = -1, collapsed = false, hidden = false, height = defaultRowHeight, outlineLevel = 0;
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case 'r':
                rowIndex = reader.readContentAsInt(0) - 1;
                break;
            case 'spans':
                break;
            case 's':
                ixf = reader.readContentAsInt(-1);
                break;
            case 'collapsed':
                collapsed = reader.readContentAsBoolean(false);
                break;
            case 'hidden':
                hidden = reader.readContentAsBoolean(false);
                break;
            case 'ht':
                height = reader.readContentAsDouble(0);
                break;
            case 'outlineLevel':
                outlineLevel = reader.readContentAsInt(0);
                break;
            default:
                break;
        }
    }
    if (height > 409.5) {
        height = defaultRowHeight;
    }
    var rowIxf = (ixf === -1 ? -1 : ixf + cellStyleXfsLength);
    readerDataModel._setRowInfo(sheetName, rowIndex, rowIxf, height, outlineLevel, collapsed, hidden);
    if (reader.elementType === 3) {
        return rowIndex;
    }
    var lastReadColumn = -1;
    var rowDepth = reader.depth;
    do {
        reader.fastRead();
        if (reader.depth <= rowDepth) {
            break;
        }
        readerDataModel._initRow(sheetName, rowIndex);
        lastReadColumn = readCell(reader, sheetName, sharedFormula, rowIndex, lastReadColumn, readerDataModel, cellStyleXfsLength, sharedString);
    } while (reader.depth > rowDepth);
    if (readerDataModel._lastReadColumn < lastReadColumn) {
        readerDataModel._lastReadColumn = lastReadColumn;
    }
    return rowIndex;
}
function readCell(reader, sheetName, sharedFormula, rowIndex, lastReadColumn, readerDataModel, cellStyleXfsLength, sharedString) {
    var columnIndex = lastReadColumn + 1, dataTypeString = 'n', ixf = 0, cellMetadataIndex, isSpillError;
    while (reader.moveToNextAttribute()) {
        switch (reader.readAttributeNameAsString()) {
            case 'r':
                columnIndex = common_1.IndexHelper._getColumnIndexInNumber(reader.readContentAsString());
                break;
            case 't':
                dataTypeString = reader.readContentAsString();
                break;
            case 's':
                ixf = reader.readContentAsInt(0);
                break;
            case 'vm':
                isSpillError = true;
                break;
            case 'cm':
                cellMetadataIndex = reader.readContentAsInt(0);
                break;
            default:
                break;
        }
    }
    var formatIndex;
    if (ixf !== 0
        || (readerDataModel._rowDataArray && readerDataModel._rowDataArray[rowIndex] && readerDataModel._rowDataArray[rowIndex].style)
        || (readerDataModel._columnDataArray && readerDataModel._columnDataArray[rowIndex] && readerDataModel._columnDataArray[rowIndex].style)) {
        formatIndex = ixf + cellStyleXfsLength;
    }
    readerDataModel._setCellStyle(sheetName, rowIndex, columnIndex, formatIndex);
    if (reader.elementType === 3) {
        return columnIndex;
    }
    var cellDepth = reader.depth;
    var value = void 0, formula = void 0, arrayFormula = null, richText = void 0;
    do {
        reader.fastRead();
        if (reader.depth <= cellDepth) {
            break;
        }
        var c = reader.buffer[reader._nameIndex + reader._nameLength - 1];
        if ((reader.elementType & 1) === 1) {
            if (c === 'v' && reader.elementType === 1) {
                var s = reader.readElementContentAsString();
                switch (dataTypeString) {
                    case 'b':
                        value = s === '1';
                        break;
                    case 'd':
                        value = new Date(s);
                        break;
                    case 'e':
                        var code = keyword_null;
                        switch (s) {
                            case '#DIV/0!':
                                code = 0x07;
                                break;
                            case '#N/A':
                                code = 0x2A;
                                break;
                            case '#NAME?':
                                code = 0x1D;
                                break;
                            case '#NULL!':
                                code = 0x00;
                                break;
                            case '#NUM!':
                                code = 0x24;
                                break;
                            case '#REF!':
                                code = 0x17;
                                break;
                            case '#VALUE!':
                                code = 0x0F;
                                break;
                            default:
                                break;
                        }
                        if (code !== keyword_null) {
                            value = { _error: s, _code: code };
                        }
                        else {
                            value = keyword_null;
                        }
                        if (isSpillError) {
                            value = { _error: '#SPILL!', _code: 99 };
                        }
                        break;
                    case 'inlineStr':
                        value = '';
                        break;
                    case 'n':
                        var num = parseFloat(s);
                        value = isNaN(num) ? keyword_null : num;
                        break;
                    case 's':
                        var sharedStringIndex = parseInt(s, 10);
                        if (sharedString && sharedStringIndex >= 0 && sharedStringIndex < sharedString.length && sharedString[sharedStringIndex]) {
                            value = sharedString[sharedStringIndex].value;
                            richText = sharedString[sharedStringIndex].richText;
                        }
                        else {
                            value = s;
                        }
                        break;
                    case 'str':
                        value = common_1.Util._xmlDecode(s);
                        break;
                    default:
                        value = s;
                        break;
                }
            }
            else if (c === 'f') {
                var formulaTypeString = keyword_null, range = keyword_null, si = keyword_null;
                while (reader.moveToNextAttribute()) {
                    switch (reader.readAttributeNameAsString()) {
                        case 't':
                            formulaTypeString = reader.readContentAsString();
                            break;
                        case 'ref':
                            range = reader.readContentAsString();
                            break;
                        case 'si':
                            si = reader.readContentAsString();
                            break;
                        default:
                            break;
                    }
                }
                if (reader.elementType === 1) {
                    formula = reader.readElementContentAsString();
                }
                if (formulaTypeString === 'array') {
                    var rangeParts = range.split(':');
                    var firstRow = 0, lastRow = 0, firstCol = 0, lastCol = 0;
                    firstRow = common_1.IndexHelper._getRowIndexInNumber(rangeParts[0]);
                    firstCol = common_1.IndexHelper._getColumnIndexInNumber(rangeParts[0]);
                    if (rangeParts.length === 1) {
                        lastRow = firstRow;
                        lastCol = firstCol;
                    }
                    else {
                        lastRow = common_1.IndexHelper._getRowIndexInNumber(rangeParts[1]);
                        lastCol = common_1.IndexHelper._getColumnIndexInNumber(rangeParts[1]);
                    }
                    arrayFormula = {
                        row: firstRow,
                        rowCount: lastRow - firstRow + 1,
                        col: firstCol,
                        colCount: lastCol - firstCol + 1
                    };
                    if (cellMetadataIndex) {
                        arrayFormula.isDynamicArray = readerDataModel._isDynamicArray(cellMetadataIndex);
                    }
                }
                else if (formulaTypeString === 'shared' && si !== keyword_null) {
                    var index = parseInt(si, 10);
                    if (formula) {
                        var sf = { baseFormula: formula };
                        if (range) {
                            var token = range.split(':');
                            if (token.length === 2) {
                                var lastRow = common_1.IndexHelper._getRowIndexInNumber(token[1]);
                                var lastColumn = common_1.IndexHelper._getColumnIndexInNumber(token[1]);
                                sf.baseRow = rowIndex;
                                sf.baseColumn = columnIndex;
                                sf.isRowShared = (lastRow === sf.baseRow);
                                if (sf.isRowShared) {
                                    sf.count = lastColumn - sf.baseColumn + 1;
                                }
                                else {
                                    sf.count = lastRow - sf.baseRow + 1;
                                }
                            }
                            else {
                                sf.baseRow = common_1.IndexHelper._getRowIndexInNumber(token[0]);
                                sf.baseColumn = common_1.IndexHelper._getColumnIndexInNumber(token[0]);
                                sf.isRowShared = true;
                                sf.count = 1;
                            }
                        }
                        if (!sharedFormula[index]) {
                            sharedFormula[index] = sf;
                        }
                    }
                    else {
                        var sf = sharedFormula[index];
                        if (sf) {
                            var columnOffset = columnIndex - sf.baseColumn;
                            var rowOffset = rowIndex - sf.baseRow;
                            formula = common_1._CalcHelper._getSharedFormula(sf, columnOffset, rowOffset);
                        }
                    }
                }
            }
            else if (c === 't' && dataTypeString === 'inlineStr') {
                value = common_1.Util._xmlDecode(reader.readElementContentAsString());
            }
        }
    } while (reader.depth > cellDepth);
    if (isSpillError && arrayFormula && arrayFormula.isDynamicArray) {
        arrayFormula.isInvalid = true;
    }
    readerDataModel._setCell(sheetName, rowIndex, columnIndex, formatIndex, value, common_1.Util._xmlDecode(common_1.processFunction(formula)), arrayFormula, richText);
    return columnIndex;
}
function readSheetProtection(reader, sheetName, readerDataModel) {
    var attributeName, protectionOptions = [], isSheetProtect = false;
    while (reader.moveToNextAttribute()) {
        attributeName = reader.readAttributeNameAsString();
        if (attributeName === "sheet") {
            isSheetProtect = reader.readContentAsBoolean(false);
            readerDataModel._setProtect(sheetName, isSheetProtect);
        }
        else if (attributeName === "algorithmName"
            || attributeName === "hashValue"
            || attributeName === "saltValue"
            || attributeName === "spinCount"
            || attributeName === "password") {
            protectionOptions.push({
                name: attributeName,
                value: reader.readContentAsString()
            });
        }
        else {
            protectionOptions.push({
                name: attributeName,
                value: !reader.readContentAsBoolean(false)
            });
        }
    }
    readerDataModel._setProtectionOptions(sheetName, protectionOptions, isSheetProtect);
}
function readExtensionList(reader, sheetName, readerDataModel) {
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1) {
            var uri = void 0, xmlnsx14 = void 0;
            if (reader.name() === 'ext') {
                while (reader.moveToNextAttribute()) {
                    switch (reader.readAttributeNameAsString()) {
                        case 'uri':
                            uri = reader.readContentAsString();
                            break;
                        case 'xmlns:x14':
                            xmlnsx14 = reader.readContentAsString();
                    }
                }
            }
            if (isConditionalFormatElement(uri, xmlnsx14)) {
                conditionalformat_reader_1.readExtensionConditionalFormating(reader, sheetName, readerDataModel);
            }
            if (isSparklineElement(uri, xmlnsx14)) {
                sparkline_reader_1.readSparklineGroups(reader, sheetName, readerDataModel);
            }
            if (isValidationElement(uri, xmlnsx14)) {
                datavalidation_reader_1.readExtensionDataValidation(reader, sheetName, readerDataModel);
            }
        }
    }
}
function readHyperlinks(reader, sheetName, readerDataModel, relationFiles) {
    if (reader.elementType === 3) {
        return;
    }
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1 && reader.name() === 'hyperlink') {
            var hyperlinkInfo = {
                url: '',
                linkColor: 'hyperlink',
                visitedLinkColor: 'followedHyperlink',
                tooltip: '',
                target: 0,
                drawUnderline: true,
                command: ''
            };
            var linkCellIndex = { row: 0, col: 0 };
            while (reader.moveToNextAttribute()) {
                switch (reader.readAttributeNameAsString()) {
                    case 'ref':
                        var ref = reader.readContentAsString();
                        var rc = ref.split(':');
                        linkCellIndex.row = common_1.IndexHelper._getRowIndexInNumber(rc[0]);
                        linkCellIndex.col = common_1.IndexHelper._getColumnIndexInNumber(rc[0]);
                        break;
                    case 'r:id':
                        hyperlinkInfo.url = common_1.Util._xmlDecode(relationFiles[reader.readContentAsString()].fileName);
                        break;
                    case 'location':
                        if (hyperlinkInfo.url) {
                            hyperlinkInfo.url = hyperlinkInfo.url + "#" + common_1.Util._xmlDecode(reader.readContentAsString());
                        }
                        else {
                            var url = common_1.Util._xmlDecode(reader.readContentAsString());
                            if (url[0] === "#") {
                                url = url.substr(1);
                            }
                            hyperlinkInfo.url = 'sjs://' + url;
                        }
                        break;
                    case 'tooltip':
                        hyperlinkInfo.tooltip = common_1.Util._xmlDecode(reader.readContentAsString());
                        break;
                    default:
                        break;
                }
            }
            readerDataModel._setHyperlink(sheetName, linkCellIndex.row, linkCellIndex.col, hyperlinkInfo);
        }
    }
}
function isConditionalFormatElement(uri, xmlnsx14) {
    var uriTrue = uri === '{78C0D931-6437-407d-A8EE-F0AAD7539E65}';
    var namespaceTrue = xmlnsx14 === 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main';
    return uriTrue && namespaceTrue;
}
function isSparklineElement(uri, xmlnsx14) {
    var uriTrue = uri === '{05C60535-1F16-4fd2-B633-F4F36F0B64E0}';
    var namespaceTrue = xmlnsx14 === 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main';
    return uriTrue && namespaceTrue;
}
function isValidationElement(uri, xmlnsx14) {
    var uriTrue = uri === '{CCE6A557-97BC-4b89-ADB6-D9C93CAAB3DF}';
    var namespaceTrue = xmlnsx14 === 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main';
    return uriTrue && namespaceTrue;
}


/***/ }),

/***/ "./src/xlsx-io/reader/xlsx-reader.ts":
/*!*******************************************!*\
  !*** ./src/xlsx-io/reader/xlsx-reader.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excel_types_1 = __webpack_require__(/*! ../../common/excel-types */ "./src/common/excel-types.ts");
var datamodel_reader_1 = __webpack_require__(/*! ../../datamodel/datamodel-reader */ "./src/datamodel/datamodel-reader.ts");
var docpropscore_reader_1 = __webpack_require__(/*! ./docpropscore-reader */ "./src/xlsx-io/reader/docpropscore-reader.ts");
var docpropsapp_reader_1 = __webpack_require__(/*! ./docpropsapp-reader */ "./src/xlsx-io/reader/docpropsapp-reader.ts");
var docpropscustom_reader_1 = __webpack_require__(/*! ./docpropscustom-reader */ "./src/xlsx-io/reader/docpropscustom-reader.ts");
var sharedstring_reader_1 = __webpack_require__(/*! ./sharedstring-reader */ "./src/xlsx-io/reader/sharedstring-reader.ts");
var theme_reader_1 = __webpack_require__(/*! ./theme-reader */ "./src/xlsx-io/reader/theme-reader.ts");
var workbook_reader_1 = __webpack_require__(/*! ./workbook-reader */ "./src/xlsx-io/reader/workbook-reader.ts");
var style_reader_1 = __webpack_require__(/*! ./style-reader */ "./src/xlsx-io/reader/style-reader.ts");
var worksheet_reader_1 = __webpack_require__(/*! ./worksheet-reader */ "./src/xlsx-io/reader/worksheet-reader.ts");
var comment_reader_1 = __webpack_require__(/*! ./comment-reader */ "./src/xlsx-io/reader/comment-reader.ts");
var drawing_reader_1 = __webpack_require__(/*! ./drawing-reader */ "./src/xlsx-io/reader/drawing-reader.ts");
var slicer_reader_1 = __webpack_require__(/*! ./slicer-reader */ "./src/xlsx-io/reader/slicer-reader.ts");
var table_reader_1 = __webpack_require__(/*! ./table-reader */ "./src/xlsx-io/reader/table-reader.ts");
var print_reader_1 = __webpack_require__(/*! ./print-reader */ "./src/xlsx-io/reader/print-reader.ts");
var excel_style_1 = __webpack_require__(/*! ../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var metadata_reader_1 = __webpack_require__(/*! ./metadata-reader */ "./src/xlsx-io/reader/metadata-reader.ts");
var pivot_reader_1 = __webpack_require__(/*! ./pivot-reader */ "./src/xlsx-io/reader/pivot-reader.ts");
var keyword_null = null;
var XlsxReader = /** @class */ (function () {
    function XlsxReader() {
        var self = this;
        self._filesData = {};
        self._cellStyleXfsLength = 0;
        self._sheetIDs = [];
        self._readerDataModel = new datamodel_reader_1.ReaderDataModel();
    }
    XlsxReader.prototype._load = function (filesData, callback) {
        if (!filesData) {
            return;
        }
        var _this = this;
        _this._filesData = filesData;
        var packageFile = new excel_types_1.XFile('', '');
        packageFile._loadPackageRelationFiles(filesData);
        var workbookFile = packageFile._getFileByType(excel_types_1.RelationshipConstants._relationshipWorkbookType);
        if (!workbookFile) {
            workbookFile = packageFile._getFileByType(excel_types_1.RelationshipConstants._relationshipWorkbookType2);
        }
        _this.onCompleted = function () {
            _this._cleanFilesData();
            _this._dispose();
            callback(_this._readerDataModel._spread);
        };
        _this._loadDocProps(packageFile);
        _this._loadWorkbook(workbookFile);
    };
    XlsxReader.prototype._loadDocProps = function (packageFile) {
        var _this = this;
        var docPropsCoreFile = packageFile._getFileByType(excel_types_1.RelationshipConstants._relationshipDocPropsCoreType);
        var docPropsAppFile = packageFile._getFileByType(excel_types_1.RelationshipConstants._relationshipDocPropsAppType);
        var docPropsCustomFile = packageFile._getFileByType(excel_types_1.RelationshipConstants._relationshipDocPropsCustomType);
        docPropsCoreFile && _this._loadDocPropsCore(docPropsCoreFile);
        docPropsAppFile && _this._loadDocPropsApp(docPropsAppFile);
        docPropsCustomFile && _this._loadDocPropsCustom(docPropsCustomFile);
    };
    XlsxReader.prototype._loadDocPropsCore = function (docPropsCoreFile) {
        var self = this;
        var dataString = self._getFileDataAndCleanData(docPropsCoreFile.fileName, true);
        if (dataString) {
            try {
                docpropscore_reader_1.readDocPropsCoreFile(dataString, self._readerDataModel);
            }
            catch (e) {
            }
        }
    };
    XlsxReader.prototype._loadDocPropsApp = function (docPropsAppFile) {
        var self = this;
        var dataString = self._getFileDataAndCleanData(docPropsAppFile.fileName, true);
        if (dataString) {
            try {
                docpropsapp_reader_1.readDocPropsAppFile(dataString, self._readerDataModel);
            }
            catch (e) {
            }
        }
    };
    XlsxReader.prototype._loadDocPropsCustom = function (docPropsCustomFile) {
        var self = this;
        var dataString = self._getFileDataAndCleanData(docPropsCustomFile.fileName, true);
        if (dataString) {
            try {
                docpropscustom_reader_1.readDocPropsCustomFile(dataString, self._readerDataModel);
            }
            catch (e) {
            }
        }
    };
    XlsxReader.prototype._loadWorkbook = function (workbookFile) {
        if (!workbookFile) {
            throw new Error('Incorrect file format.');
        }
        this._readSharedStrings(workbookFile);
        this._readTheme(workbookFile);
        this._readStyles(workbookFile);
        this._readWorkbook(workbookFile);
        this._readPivotCacheDefinitions(workbookFile);
        this._readSheetMetadata(workbookFile);
        if (this._sheetIDs.length === 0) {
            throw new Error('Incorrect file format.');
        }
        this._readWorksheets(workbookFile);
        this._triggerOnCompleted();
    };
    XlsxReader.prototype._readSharedStrings = function (workbookFile) {
        var stringTableFile = workbookFile._getFileByType(excel_types_1.RelationshipConstants._relationshipSharedStringsType);
        if (!stringTableFile) {
            stringTableFile = workbookFile._getFileByType(excel_types_1.RelationshipConstants._relationshipSharedStringsType2);
        }
        if (!stringTableFile) {
            return;
        }
        var self = this;
        var dataString = self._getFileDataAndCleanData(stringTableFile.fileName);
        if (dataString) {
            try {
                self.sharedString = sharedstring_reader_1.readSharedString(dataString);
            }
            catch (e) {
            }
        }
    };
    XlsxReader.prototype._readTheme = function (workbookFile) {
        var themeFile = workbookFile._getFileByType(excel_types_1.RelationshipConstants._relationshipThemeType);
        if (!themeFile) {
            themeFile = workbookFile._getFileByType(excel_types_1.RelationshipConstants._relationshipThemeType2);
        }
        if (!themeFile) {
            return;
        }
        var self = this;
        var dataString = self._getFileDataAndCleanData(themeFile.fileName);
        if (dataString) {
            try {
                theme_reader_1.readTheme(dataString, this._readerDataModel);
            }
            catch (e) {
            }
        }
    };
    XlsxReader.prototype._readPivotCacheDefinitions = function (workbookFile) {
        var pivotCacheDefinitionFiles = workbookFile._getFilesByType(excel_types_1.RelationshipConstants._relationshipPivotCacheDefinitionType);
        if (!pivotCacheDefinitionFiles) {
            return;
        }
        var self = this, readerDataModel = self._readerDataModel;
        readerDataModel.pivotCaches = [];
        for (var i = 0; i < pivotCacheDefinitionFiles.length; i++) {
            var pivotCacheDefinitionFile = pivotCacheDefinitionFiles[i];
            var pivotCache = readerDataModel._getPivotCache('rid', pivotCacheDefinitionFile.id);
            self._readPivotCacheRecords(pivotCacheDefinitionFile, pivotCache);
            var dataString = self._getFileDataAndCleanData(pivotCacheDefinitionFile.file.fileName);
            if (dataString) {
                try {
                    pivot_reader_1.readPivotCacheDefinitions(dataString, readerDataModel, pivotCache);
                }
                catch (e) {
                }
            }
            readerDataModel.pivotCaches.push(pivotCache);
        }
    };
    XlsxReader.prototype._readPivotCacheRecords = function (pivotCacheDefinitionFile, pivotCache) {
        if (!pivotCacheDefinitionFile) {
            return;
        }
        var pivotCacheRecords = pivotCacheDefinitionFile.file._getFileByType(excel_types_1.RelationshipConstants._relationshipPivotCacheRecordsType);
        if (!pivotCacheRecords) {
            return;
        }
        var self = this;
        var dataString = self._getFileDataAndCleanData(pivotCacheRecords.fileName);
        if (dataString) {
            try {
                pivot_reader_1.readPivotCacheRecords(dataString, pivotCache);
            }
            catch (e) {
            }
        }
    };
    XlsxReader.prototype._readStyles = function (workbookFile) {
        var stylesFile = workbookFile._getFileByType(excel_types_1.RelationshipConstants._relationshipStylesType);
        if (!stylesFile) {
            stylesFile = workbookFile._getFileByType(excel_types_1.RelationshipConstants._relationshipStylesType2);
        }
        if (!stylesFile) {
            return;
        }
        var self = this;
        var dataString = self._getFileDataAndCleanData(stylesFile.fileName, true);
        if (dataString) {
            try {
                self._cellStyleXfsLength = style_reader_1.readStyle(dataString, self._readerDataModel);
            }
            catch (e) {
            }
        }
    };
    XlsxReader.prototype._readWorkbook = function (workbookFile) {
        var self = this;
        var dataString = self._getFileDataAndCleanData(workbookFile.fileName);
        if (dataString) {
            try {
                self._sheetIDs = workbook_reader_1.readWorkbook(dataString, self._readerDataModel);
            }
            catch (e) {
            }
        }
    };
    XlsxReader.prototype._readWorksheets = function (workbookFile) {
        var self = this;
        var readerDataModel = self._readerDataModel;
        var getFileDataAndCleanData = self._getFileDataAndCleanData.bind(self);
        var sheetInfo, sheetName;
        for (var i = 0, len = self._sheetIDs.length; i < len; i++) {
            sheetInfo = self._sheetIDs[i];
            sheetName = sheetInfo.name;
            var sheetviewFile = workbookFile._getFileByRelationID(sheetInfo.rID);
            if (!sheetviewFile) {
                continue;
            }
            var dataString = self._getFileDataAndCleanData(sheetviewFile.fileName);
            var relationFiles = sheetviewFile.relationFiles;
            readerDataModel._excelPrintPageSetting = {};
            if (dataString) {
                try {
                    worksheet_reader_1.readWorksheets(dataString, relationFiles, sheetName, readerDataModel, self._cellStyleXfsLength, self.sharedString);
                }
                catch (e) {
                }
            }
            try {
                pivot_reader_1.readPivotTableDefinition(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData);
            }
            catch (e) {
            }
            try {
                comment_reader_1.readComments(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData);
            }
            catch (e) {
            }
            try {
                drawing_reader_1.readDrawings(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData);
            }
            catch (e) {
            }
            try {
                table_reader_1.readTables(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData);
            }
            catch (e) {
            }
            try {
                print_reader_1.readVmlDrawing(relationFiles, readerDataModel, getFileDataAndCleanData);
            }
            catch (e) {
            }
            readerDataModel._recheckRowColInfo(sheetName);
            readerDataModel._setPrintPageSetting(sheetName, readerDataModel._excelPrintPageSetting);
            readerDataModel._excelPrintPageSetting = {};
        }
        for (var i = 0, len = self._sheetIDs.length; i < len; i++) {
            sheetInfo = self._sheetIDs[i];
            sheetName = sheetInfo.name;
            var sheetviewFile = workbookFile._getFileByRelationID(sheetInfo.rID);
            if (!sheetviewFile) {
                continue;
            }
            var relationFiles = sheetviewFile.relationFiles;
            try {
                slicer_reader_1.readSlicers(relationFiles, sheetName, readerDataModel, getFileDataAndCleanData, workbookFile);
            }
            catch (e) {
            }
        }
        for (var i = 0, len = self._sheetIDs.length; i < len; i++) {
            sheetInfo = self._sheetIDs[i];
            sheetName = sheetInfo.name;
            self._processHiddenRow(sheetName);
        }
    };
    XlsxReader.prototype._triggerOnCompleted = function () {
        var _this = this;
        if (_this.onCompleted) {
            _this.onCompleted();
        }
    };
    XlsxReader.prototype.setRowVisible = function (sheet, rowFilter) {
        if (rowFilter) {
            var filterRange = rowFilter.range, filteredColumns = rowFilter.filteredColumns, i = void 0;
            if (filterRange && sheet.rows && filteredColumns && filteredColumns.length > 0) {
                for (i = filterRange.row; i < filterRange.row + filterRange.rowCount; i++) {
                    if (sheet.rows[i]) {
                        sheet.rows[i].visible = true;
                    }
                }
            }
        }
    };
    XlsxReader.prototype._processHiddenRow = function (sheetName) {
        var spread = this._readerDataModel._spread, sheet = spread.sheets && spread.sheets[sheetName];
        if (sheet) {
            this.setRowVisible(sheet, sheet.rowFilter);
            var tables = sheet.tables;
            if (tables) {
                for (var i = 0; i < tables.length; i++) {
                    var table = tables[i];
                    this.setRowVisible(sheet, table.rowFilter);
                }
            }
        }
    };
    XlsxReader.prototype._getFileDataAndCleanData = function (fileName, keepData) {
        var fileName2 = fileName.substr(fileName.charAt(0) === '/' ? 1 : 0).toLowerCase();
        var dataString = this._filesData[fileName2];
        if (!keepData) {
            this._filesData[fileName2] = keyword_null;
        }
        return dataString;
    };
    XlsxReader.prototype._cleanFilesData = function () {
        this._filesData = {};
    };
    XlsxReader.prototype._dispose = function () {
        excel_style_1.clearCache();
    };
    XlsxReader.prototype._readSheetMetadata = function (workbookFile) {
        var metadataFile = workbookFile._getFileByType(excel_types_1.RelationshipConstants._relationshipSheetMetadata);
        if (!metadataFile) {
            return;
        }
        var self = this;
        var dataString = self._getFileDataAndCleanData(metadataFile.fileName);
        if (dataString) {
            try {
                metadata_reader_1.readSheetMetadata(dataString, self._readerDataModel);
                self._readerDataModel._spread.allowDynamicArray = true;
            }
            catch (e) {
            }
        }
    };
    return XlsxReader;
}());
exports.XlsxReader = XlsxReader;


/***/ }),

/***/ "./src/xlsx-io/writer/autofilter-writer.ts":
/*!*************************************************!*\
  !*** ./src/xlsx-io/writer/autofilter-writer.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var range_parser_1 = __webpack_require__(/*! ./../../common/range-parser */ "./src/common/range-parser.ts");
var xmlEncode = common_1.Util._xmlEncode;
var isNullOrWhiteSpace = common_1.StringEx._isNullOrWhiteSpace;
var keyword_undefined = void 0;
var ComparisonOperators = {
    '-1': 'none',
    '0': 'equal',
    '4': 'lessThan',
    '5': 'lessThanOrEqual',
    '1': 'notEqual',
    '2': 'greaterThan',
    '3': 'greaterThanOrEqual'
};
var DynamicFilterType = {
    '-1': 'null',
    '100': 'aboveAverage',
    '101': 'belowAverage'
};
var DynamicFilterTypeEnum = [
    ['today', 'yesterday', 'tomorrow', 'lastWeek', 'thisMonth', 'lastMonth', 'nextMonth', 'thisWeek', 'lastWeek', 'nextWeek', 'nextQuarter', 'thisQuarter', 'lastQuarter', 'nextYear', 'thisYear', 'lastYear'],
    [],
    ['Q1', 'Q2', 'Q3', 'Q4'], ['M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'M8', 'M9', 'M10', 'M11', 'M12'], [],
    [],
    ['yearToDate']
];
function writeColorFilter(writer, excelColorFilter) {
    writer.writeLeafElement("colorFilter", function () {
        if (!excelColorFilter.cellColor) {
            writer.writeAttributeString("cellColor", "0");
        }
        writer.writeAttributeString("dxfId", excelColorFilter.dxfId);
    });
}
function writeTop10Filter(writer, excelTop10) {
    writer.writeLeafElement("top10", function () {
        if (excelTop10.isBottom) {
            writer.writeAttributeString("top", "0");
        }
        if (excelTop10.percent) {
            writer.writeAttributeString("percent", "1");
        }
        if (!isNaN(excelTop10.value)) {
            writer.writeAttributeString("val", excelTop10.value);
        }
        if (!isNaN(excelTop10.filterValue)) {
            writer.writeAttributeString("filterVal", excelTop10.filterValue);
        }
    });
}
function writeFilters(writer, excelFilters) {
    writer.writeElement("filters", function () {
        if (excelFilters.blank) {
            writer.writeAttributeString("blank", "1");
        }
    }, function () {
        if (excelFilters.filter) {
            excelFilters.filter.forEach(function (filter) {
                if (!isNullOrWhiteSpace(filter)) {
                    writer.writeLeafElement("filter", function () {
                        var encodeFilter = xmlEncode(filter);
                        writer.writeAttributeString("val", encodeFilter);
                    });
                }
            });
        }
        if (excelFilters.dateGroupItem) {
            excelFilters.dateGroupItem.forEach(function (dateItem) {
                writer.writeLeafElement("dateGroupItem", function () {
                    if (dateItem.year > 0) {
                        writer.writeAttributeString("year", dateItem.year);
                    }
                    if (dateItem.month >= 0 && dateItem.month < 12) {
                        writer.writeAttributeString("month", dateItem.month);
                    }
                    if (dateItem.day > 0 && dateItem.day < 32) {
                        writer.writeAttributeString("day", dateItem.day);
                    }
                    if (dateItem.hour < 24) {
                        writer.writeAttributeString("hour", dateItem.hour);
                    }
                    if (dateItem.minute < 60) {
                        writer.writeAttributeString("minute", dateItem.minute);
                    }
                    if (dateItem.second < 60) {
                        writer.writeAttributeString("second", dateItem.second);
                    }
                    writer.writeAttributeString("dateTimeGrouping", "day");
                });
            });
        }
    });
}
function writeDynamicFilter(writer, dynamicFilter) {
    if (common_1._isNullOrUndefined(dynamicFilter.type)) {
        return;
    }
    writer.writeLeafElement("dynamicFilter", function () {
        var type = DynamicFilterType[dynamicFilter.type], conType = dynamicFilter.conType, expectTypeId = dynamicFilter.expectTypeId || 0;
        if (conType === 6) {
            type = DynamicFilterTypeEnum[expectTypeId][dynamicFilter.type];
        }
        if (type && type !== 'null') {
            writer.writeAttributeString("type", type);
        }
        else {
            writer.writeAttributeString("type", "null");
        }
        if (type[0] !== 'Q' && type[0] !== 'M') {
            if (!common_1._isNullOrUndefined(dynamicFilter.value)) {
                writer.writeAttributeString("val", dynamicFilter.value);
            }
            if (!common_1._isNullOrUndefined(dynamicFilter.maxValue)) {
                writer.writeAttributeString("maxVal", dynamicFilter.maxValue);
            }
        }
    });
}
function writePivotDynamicFilter(writer, dynamicFilter) {
    if (common_1._isNullOrUndefined(dynamicFilter.type)) {
        return;
    }
    writer.writeLeafElement("dynamicFilter", function () {
        var type = dynamicFilter.type, expectTypeId = 0;
        if (type && type !== 'null') {
            writer.writeAttributeString("type", type);
        }
        else {
            writer.writeAttributeString("type", "null");
        }
        if (!common_1._isNullOrUndefined(dynamicFilter.value)) {
            writer.writeAttributeString("val", dynamicFilter.value);
        }
        if (!common_1._isNullOrUndefined(dynamicFilter.maxValue)) {
            writer.writeAttributeString("maxVal", dynamicFilter.maxValue);
        }
    });
}
function writeCustomFilters(writer, excelCustomFilters) {
    if (common_1._isNullOrUndefined(excelCustomFilters.filter1) && common_1._isNullOrUndefined(excelCustomFilters.filter2)) {
        return;
    }
    writer.writeElement("customFilters", function () {
        if (excelCustomFilters.and) {
            writer.writeAttributeString("and", "1");
        }
    }, function () {
        if (!common_1._isNullOrUndefined(excelCustomFilters.filter1)) {
            writer.writeLeafElement("customFilter", function () {
                var operator = ComparisonOperators[excelCustomFilters.filter1.operator];
                if (operator !== 'none') {
                    writer.writeAttributeString("operator", operator);
                }
                writer.writeAttributeString("val", excelCustomFilters.filter1.value);
            });
        }
        if (!common_1._isNullOrUndefined(excelCustomFilters.filter2)) {
            writer.writeLeafElement("customFilter", function () {
                var operator = ComparisonOperators[excelCustomFilters.filter2.operator];
                if (operator !== 'none') {
                    writer.writeAttributeString("operator", operator);
                }
                writer.writeAttributeString("val", excelCustomFilters.filter2.value);
            });
        }
    });
}
function writeSortInfo(writer, sortInfo) {
    writer.writeElement('sortState', function () {
        writer.writeAttributeString('ref', range_parser_1.getRangeString([sortInfo.range]));
    }, function () {
        writer.writeLeafElement('sortCondition', function () {
            writer.writeAttributeString('ref', range_parser_1.getRangeString([sortInfo.range]));
            if (sortInfo.descending) {
                writer.writeAttributeString('descending', '1');
            }
            if (sortInfo.isBackColor !== keyword_undefined) {
                var sortBy = sortInfo.isBackColor ? 'cellColor' : 'fontColor';
                writer.writeAttributeString('sortBy', sortBy);
                writer.writeAttributeString('dxfId', sortInfo.dxfid);
            }
        });
    });
}
exports.writeSortInfo = writeSortInfo;
function writeAutoFilter(writer, autoFilter) {
    if (autoFilter && autoFilter.range) {
        if (autoFilter.filterColumns.length > 0 || autoFilter.sortInfo) {
            writer.writeElement('autoFilter', function () {
                writer.writeAttributeString('ref', range_parser_1.getRangeString([autoFilter.range]));
            }, function () {
                if (autoFilter.filterColumns) {
                    autoFilter.filterColumns.forEach(function (filterColumn) {
                        if (filterColumn.colorFilter || filterColumn.top10 || filterColumn.filters || filterColumn.dynamicFilter || filterColumn.customFilters) {
                            writer.writeElement('filterColumn', function () {
                                writer.writeAttributeString('colId', filterColumn.autoFilterColumnId);
                                if (!common_1._isNullOrUndefined(filterColumn.hiddenButton)) {
                                    writer.writeAttributeString('hiddenButton', filterColumn.hiddenButton);
                                }
                            }, function () {
                                if (!common_1._isNullOrUndefined(filterColumn.colorFilter)) {
                                    writeColorFilter(writer, filterColumn.colorFilter);
                                }
                                else if (!common_1._isNullOrUndefined(filterColumn.top10)) {
                                    writeTop10Filter(writer, filterColumn.top10);
                                }
                                else if (!common_1._isNullOrUndefined(filterColumn.filters)) {
                                    writeFilters(writer, filterColumn.filters);
                                }
                                else if (!common_1._isNullOrUndefined(filterColumn.dynamicFilter)) {
                                    writeDynamicFilter(writer, filterColumn.dynamicFilter);
                                }
                                else if (!common_1._isNullOrUndefined(filterColumn.customFilters)) {
                                    writeCustomFilters(writer, filterColumn.customFilters);
                                }
                            });
                        }
                        else {
                            writer.writeLeafElement('filterColumn', function () {
                                writer.writeAttributeString('colId', filterColumn.autoFilterColumnId);
                                if (!common_1._isNullOrUndefined(filterColumn.hiddenButton)) {
                                    writer.writeAttributeString('hiddenButton', filterColumn.hiddenButton);
                                }
                            });
                        }
                    });
                }
                if (autoFilter.sortInfo) {
                    writeSortInfo(writer, autoFilter.sortInfo);
                }
            });
        }
        else {
            writer.writeLeafElement('autoFilter', function () {
                writer.writeAttributeString('ref', range_parser_1.getRangeString([autoFilter.range]));
            });
        }
        if (autoFilter.sortInfo) {
            writeSortInfo(writer, autoFilter.sortInfo);
        }
    }
}
exports.writeAutoFilter = writeAutoFilter;
function writePivotAutoFilter(writer, autoFilter) {
    if (autoFilter && autoFilter.range) {
        if (autoFilter.filterColumns.length > 0 || autoFilter.sortInfo) {
            writer.writeElement('autoFilter', function () {
                writer.writeAttributeString('ref', autoFilter.range);
            }, function () {
                if (autoFilter.filterColumns) {
                    autoFilter.filterColumns.forEach(function (filterColumn) {
                        if (filterColumn.colorFilter || filterColumn.top10 || filterColumn.filters || filterColumn.dynamicFilter || filterColumn.customFilters) {
                            writer.writeElement('filterColumn', function () {
                                writer.writeAttributeString('colId', filterColumn.autoFilterColumnId);
                                if (!common_1._isNullOrUndefined(filterColumn.hiddenButton)) {
                                    writer.writeAttributeString('hiddenButton', filterColumn.hiddenButton);
                                }
                            }, function () {
                                if (!common_1._isNullOrUndefined(filterColumn.top10)) {
                                    writeTop10Filter(writer, filterColumn.top10);
                                }
                                else if (!common_1._isNullOrUndefined(filterColumn.dynamicFilter)) {
                                    writePivotDynamicFilter(writer, filterColumn.dynamicFilter);
                                }
                                else if (!common_1._isNullOrUndefined(filterColumn.customFilters)) {
                                    writeCustomFilters(writer, filterColumn.customFilters);
                                }
                                else if (!common_1._isNullOrUndefined(filterColumn.filters)) {
                                    writeFilters(writer, filterColumn.filters);
                                }
                            });
                        }
                        else {
                            writer.writeLeafElement('filterColumn', function () {
                                writer.writeAttributeString('colId', filterColumn.autoFilterColumnId);
                                if (!common_1._isNullOrUndefined(filterColumn.hiddenButton)) {
                                    writer.writeAttributeString('hiddenButton', filterColumn.hiddenButton);
                                }
                            });
                        }
                    });
                }
            });
        }
        else {
            writer.writeLeafElement('autoFilter', function () {
                writer.writeAttributeString('ref', range_parser_1.getRangeString([autoFilter.range]));
            });
        }
    }
}
exports.writePivotAutoFilter = writePivotAutoFilter;
function writeAutoFilterForSheet(writer, sheetName, writerDataModel) {
    var autoFilter = writerDataModel._getAutoFilter(sheetName);
    if (autoFilter) {
        writeAutoFilter(writer, autoFilter);
    }
}
exports.writeAutoFilterForSheet = writeAutoFilterForSheet;


/***/ }),

/***/ "./src/xlsx-io/writer/chart-writer.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/writer/chart-writer.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var chart_model_1 = __webpack_require__(/*! ./../../datamodel/chart-model */ "./src/datamodel/chart-model.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var pixelToEMU = excel_style_1.UnitHelper.pixelToEMU;
var chart_helper_1 = __webpack_require__(/*! ./../common/chart-helper */ "./src/xlsx-io/common/chart-helper.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var excel_helper_1 = __webpack_require__(/*! ../../datamodel/excel-helper */ "./src/datamodel/excel-helper.ts");
var xmlEncode = common_1.Util._xmlEncode;
var keyword_null = null, CONST_VAL = 'val', CONST_NAME = 'name', CONST_TYPE = 'type', CONST_PRST = 'prst', CONST_EXTLST = 'extLst', CONST_CNVPR = 'cNvPr', CONST_MACRO = 'macro', CONST_EFFECTLST = 'effectLst', CONST_EFFECT_DAG = 'effectDag', CONST_FPUBLISHED = 'fPublished', CONST_GRAPHIC_FRAME = 'graphicFrame', CONST_EXT = 'ext', CONST_SCRGBCLR = 'scrgbClr', CONST_SRGBCLR = 'srgbClr', CONST_HSLCLR = 'hslClr', CONST_SYSCLR = 'sysClr', CONST_SCHEMECLR = 'schemeClr', CONST_PRSTCLR = 'prstClr', CONST_STYLECLR = 'styleClr', CONST_NO_FILL = 'noFill', CONST_SOLID_FILL = 'solidFill', CONST_GRAD_FILL = 'gradFill', CONST_BLIP_FILL = 'blipFill', CONST_PATT_FILL = 'pattFill', CONST_GRP_FILL = 'grpFill', CONST_DELETE = 'delete', CONST_SCENE_3D = 'scene3d', CONST_SPPR = 'spPr', CONST_TXPR = 'txPr', CONST_INVERT_IF_NEGATIVE = 'invertIfNegative', CONST_BUBBLE_3D = 'bubble3D', CONST_MARKER = 'marker', CONST_GRPSP = 'grpSp', CONST_CXNSP = 'cxnSp', CONST_CLR_SCHEME = 'clrScheme', CONST_FONT_SCHEME = 'fontScheme', CONST_FMT_SCHEME = 'fmtScheme', CONST_LAYOUT = 'layout', CONST_PICTURE_OPTIONS = 'pictureOptions', CONST_ORDER = 'order', CONST_GAP_WIDTH = 'gapWidth', COSNT_DLBLS = 'dLbls', CONST_TRENDLINE = 'trendline', CONST_ERR_BARS = 'errBars', CONST_SER = 'ser', CONST_DROP_LINES = 'dropLines', CONST_AXID = 'axId', CONST_GROUPING = 'grouping', CONST_VARY_COLORS = 'varyColors', CONST_SCALING = 'scaling', CONST_AX_POS = 'axPos', CONST_MAJOR_GRIDLINES = 'majorGridlines', CONST_MINOR_GRIDLINES = 'minorGridlines', CONST_TITLE = 'title', CONST_NUMFMT = 'numFmt', CONST_MAJOR_TICK_MARK = 'majorTickMark', CONST_MINOR_TICK_MARK = 'minorTickMark', CONST_TICK_LBLPOS = 'tickLblPos', CONST_CROSSAX = 'crossAx', CONST_CROSSES = 'crosses', CONST_STYLE = 'style', CONST_TOT_WITH_SHAPE = 'rotWithShape', CONST_CNV_PIC_PR = 'cNvPicPr', CONST_NV_PIC_PR = 'nvPicPr', CONST_CNV_GRAPHIC_FRAME_PR = 'cNvGraphicFramePr', CONST_ALTERNATE_CONTENT = 'AlternateContent', CONST_CLIENT_DATA = 'clientData';
var CONST_A = 'a', CONST_CDR = 'cdr', CONST_R = 'r', CONST_XDR = 'xdr', CONST_C = 'c', CONST_C15 = 'c15', CONST_C16 = 'c16', COSNT_A14 = 'a14', CONST_C14 = 'c14', CONST_MC = 'mc', CONST_CX = 'cx', CONST_CS = 'cs', CONST_CHART_DEFINED_NAME = 'chartDefinedName';
function isNullOrUndefinedOrEmpty(value) {
    return common_1._isNullOrUndefined(value) || value === '';
}
function writeEmptyNode(writer, prefix, localName) {
    writer.writeLeafElement(prefix + ":" + localName);
}
function writeSingleAttributeNode(writer, prefix, localName, attrValue, attrName, defaultValue, enumObj, convertEnumFunc) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(attrValue) && (common_1._isNullOrUndefined(defaultValue) || attrValue !== defaultValue)) {
            if (convertEnumFunc) {
                attrValue = convertEnumFunc(attrValue);
            }
            if (enumObj) {
                attrValue = enumObj[attrValue];
            }
            writer.writeAttributeString(attrName, attrValue);
        }
    });
}
function writeSingleSubElementNode(writer, prefix, localName, instance, subElementWriterFunc, nameSpaceString, subElementName) {
    writer.writeElement(prefix + ":" + localName, function () {
        var subElementValue = instance[subElementName];
        if (!common_1._isNullOrUndefined(subElementValue)) {
            subElementWriterFunc(writer, nameSpaceString, subElementName, subElementValue);
        }
    });
}
function writeSubSqrefElement(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.sqref)) {
            writer.writeElementString("c15:sqref", instance.sqref);
        }
    });
}
function writeDoubleSubElementNode(writer, prefix, localName, instance, subElementName1, subElementName2) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var subElementValue1 = instance[subElementName1], subElementValue2 = instance[subElementName2];
        if (!common_1._isNullOrUndefined(subElementValue1)) {
            writer.writeAttributeString(subElementName1, subElementValue1);
        }
        if (!common_1._isNullOrUndefined(subElementValue2)) {
            writer.writeAttributeString(subElementName2, subElementValue2);
        }
    });
}
function writeSubColorElements(writer, instance) {
    if (common_1._isNullOrUndefined(instance)) {
        return;
    }
    var scrgbClr = instance.scrgbClr, srgbClr = instance.srgbClr, hslClr = instance.hslClr, sysClr = instance.sysClr, schemeClr = instance.schemeClr, prstClr = instance.prstClr, styleClr = instance.styleClr;
    if (!common_1._isNullOrUndefined(scrgbClr)) {
        WriteCT_ScRgbColor(writer, CONST_A, CONST_SCRGBCLR, scrgbClr);
    }
    else if (!common_1._isNullOrUndefined(srgbClr)) {
        WriteCT_SRgbColor(writer, CONST_A, CONST_SRGBCLR, srgbClr);
    }
    else if (!common_1._isNullOrUndefined(hslClr)) {
        WriteCT_HslColor(writer, CONST_A, CONST_HSLCLR, hslClr);
    }
    else if (!common_1._isNullOrUndefined(sysClr)) {
        WriteCT_SystemColor(writer, CONST_A, CONST_SYSCLR, sysClr);
    }
    else if (!common_1._isNullOrUndefined(schemeClr)) {
        WriteCT_SchemeColor(writer, CONST_A, CONST_SCHEMECLR, schemeClr);
    }
    else if (!common_1._isNullOrUndefined(prstClr)) {
        WriteCT_PresetColor(writer, CONST_A, CONST_PRSTCLR, prstClr);
    }
    else if (!common_1._isNullOrUndefined(styleClr)) {
        WriteCT_StyleColor(writer, CONST_CS, CONST_STYLECLR, styleClr);
    }
}
function writeFillProperties(writer, instance) {
    var noFill = instance.noFill, solidFill = instance.solidFill, gradFill = instance.gradFill, blipFill = instance.blipFill, pattFill = instance.pattFill, grpFill = instance.grpFill;
    if (!common_1._isNullOrUndefined(noFill)) {
        WriteCT_NoFillProperties(writer, CONST_A, CONST_NO_FILL);
    }
    else if (!common_1._isNullOrUndefined(solidFill)) {
        WriteCT_SolidColorFillProperties(writer, CONST_A, CONST_SOLID_FILL, solidFill);
    }
    else if (!common_1._isNullOrUndefined(gradFill)) {
        WriteCT_GradientFillProperties(writer, CONST_A, CONST_GRAD_FILL, gradFill);
    }
    else if (!common_1._isNullOrUndefined(blipFill)) {
        WriteCT_BlipFillProperties(writer, CONST_A, CONST_BLIP_FILL, blipFill);
    }
    else if (!common_1._isNullOrUndefined(pattFill)) {
        WriteCT_PatternFillProperties(writer, CONST_A, CONST_PATT_FILL, pattFill);
    }
    else if (!common_1._isNullOrUndefined(grpFill)) {
        WriteCT_GroupFillProperties(writer, CONST_A, CONST_GRP_FILL);
    }
}
function writeFillPropertiesFromArray(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (instance.noFill) {
            writeArrayItem(instance.noFill, function () {
                WriteCT_NoFillProperties(writer, CONST_A, CONST_NO_FILL);
            });
        }
        else if (instance.solidFill) {
            writeArrayItem(instance.solidFill, function (solidFillItem) {
                WriteCT_SolidColorFillProperties(writer, CONST_A, CONST_SOLID_FILL, solidFillItem);
            });
        }
        else if (instance.gradFill) {
            writeArrayItem(instance.gradFill, function (gradFillItem) {
                WriteCT_GradientFillProperties(writer, CONST_A, CONST_GRAD_FILL, gradFillItem);
            });
        }
        else if (instance.blipFill) {
            writeArrayItem(instance.blipFill, function (blipFillItem) {
                WriteCT_BlipFillProperties(writer, CONST_A, CONST_BLIP_FILL, blipFillItem);
            });
        }
        else if (instance.pattFill) {
            writeArrayItem(instance.pattFill, function (pattFillItem) {
                WriteCT_PatternFillProperties(writer, CONST_A, CONST_PATT_FILL, pattFillItem);
            });
        }
        else if (instance.grpFill) {
            writeArrayItem(instance.grpFill, function () {
                WriteCT_GroupFillProperties(writer, CONST_A, CONST_GRP_FILL);
            });
        }
    });
}
function writeColorSubElement(writer, instance) {
    writeArrayItem(instance.tint, function (tintItem) {
        WriteCT_PositiveFixedPercentage(writer, CONST_A, "tint", tintItem);
    });
    writeArrayItem(instance.shade, function (shadeItem) {
        WriteCT_PositiveFixedPercentage(writer, CONST_A, "shade", shadeItem);
    });
    writeArrayItem(instance.comp, function () {
        WriteCT_ComplementTransform(writer, CONST_A, "comp");
    });
    writeArrayItem(instance.inv, function () {
        WriteCT_InverseTransform(writer, CONST_A, "inv");
    });
    writeArrayItem(instance.gray, function () {
        WriteCT_GrayscaleTransform(writer, CONST_A, "gray");
    });
    writeArrayItem(instance.alpha, function (alphaItem) {
        WriteCT_PositiveFixedPercentage(writer, CONST_A, "alpha", alphaItem);
    });
    writeArrayItem(instance.alphaMod, function (alphaModItem) {
        WriteCT_PositivePercentage(writer, CONST_A, "alphaMod", alphaModItem);
    });
    writeArrayItem(instance.alphaOff, function (alphaOffItem) {
        WriteCT_FixedPercentage(writer, CONST_A, "alphaOff", alphaOffItem);
    });
    writeArrayItem(instance.hue, function (hueItem) {
        WriteCT_PositiveFixedAngle(writer, CONST_A, "hue", hueItem);
    });
    writeArrayItem(instance.hueMod, function (hueModItem) {
        WriteCT_PositivePercentage(writer, CONST_A, "hueMod", hueModItem);
    });
    writeArrayItem(instance.hueOff, function (hueOffItem) {
        WriteCT_Angle(writer, CONST_A, "hueOff", hueOffItem);
    });
    writeArrayItem(instance.sat, function (satItem) {
        WriteCT_Percentage(writer, CONST_A, "sat", satItem);
    });
    writeArrayItem(instance.satMod, function (satModItem) {
        WriteCT_Percentage(writer, CONST_A, "satMod", satModItem);
    });
    writeArrayItem(instance.satOff, function (satOffItem) {
        WriteCT_Percentage(writer, CONST_A, "satOff", satOffItem);
    });
    writeArrayItem(instance.lum, function (lumItem) {
        WriteCT_Percentage(writer, CONST_A, "lum", lumItem);
    });
    writeArrayItem(instance.lumMod, function (lumModItem) {
        WriteCT_Percentage(writer, CONST_A, "lumMod", lumModItem);
    });
    writeArrayItem(instance.lumOff, function (lumOffItem) {
        WriteCT_Percentage(writer, CONST_A, "lumOff", lumOffItem);
    });
    writeArrayItem(instance.red, function (redItem) {
        WriteCT_Percentage(writer, CONST_A, "red", redItem);
    });
    writeArrayItem(instance.redMod, function (redModItem) {
        WriteCT_Percentage(writer, CONST_A, "redMod", redModItem);
    });
    writeArrayItem(instance.redOff, function (redOffItem) {
        WriteCT_Percentage(writer, CONST_A, "redOff", redOffItem);
    });
    writeArrayItem(instance.green, function (greenItem) {
        WriteCT_Percentage(writer, CONST_A, "green", greenItem);
    });
    writeArrayItem(instance.greenMod, function (greenModItem) {
        WriteCT_Percentage(writer, CONST_A, "greenMod", greenModItem);
    });
    writeArrayItem(instance.greenOff, function (greenOffItem) {
        WriteCT_Percentage(writer, CONST_A, "greenOff", greenOffItem);
    });
    writeArrayItem(instance.blue, function (blueItem) {
        WriteCT_Percentage(writer, CONST_A, "blue", blueItem);
    });
    writeArrayItem(instance.blueMod, function (blueModItem) {
        WriteCT_Percentage(writer, CONST_A, "blueMod", blueModItem);
    });
    writeArrayItem(instance.blueOff, function (blueOffItem) {
        WriteCT_Percentage(writer, CONST_A, "blueOff", blueOffItem);
    });
    writeArrayItem(instance.gamma, function () {
        WriteCT_GammaTransform(writer, CONST_A, "gamma");
    });
    writeArrayItem(instance.invGamma, function () {
        WriteCT_InverseGammaTransform(writer, CONST_A, "invGamma");
    });
}
function writeSurfaceChartSubElement(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var wireframe = instance.wireframe, bandFmts = instance.bandFmts, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(wireframe)) {
            WriteCT_Boolean(writer, CONST_C, "wireframe", wireframe);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_SurfaceSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(bandFmts)) {
            WriteCT_BandFmts(writer, CONST_C, "bandFmts", bandFmts);
        }
        writeArrayItem(instance.axId, function (axIdItem) {
            WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
function writeGraphicFrameNonVisualSubElement(writer, prefix, localName, instance, nameSpaceString) {
    writer.writeElement(prefix + ":" + localName, function () {
        var cNvPr = instance.cNvPr;
        if (!common_1._isNullOrUndefined(cNvPr)) {
            WriteCT_NonVisualDrawingProps(writer, nameSpaceString, CONST_CNVPR, cNvPr);
        }
        WriteCT_NonVisualGraphicFrameProperties(writer, nameSpaceString, CONST_CNV_GRAPHIC_FRAME_PR);
    });
}
function writeAxisSubElement(writer, instance) {
    var axId = instance.axId, scaling = instance.scaling, deleteField = instance.delete, axPos = instance.axPos, majorGridlines = instance.majorGridlines, minorGridlines = instance.minorGridlines, title = instance.title, numFmt = instance.numFmt, majorTickMark = instance.majorTickMark, minorTickMark = instance.minorTickMark, tickLblPos = instance.tickLblPos, spPr = instance.spPr, txPr = instance.txPr, crossAx = instance.crossAx, crosses = instance.crosses, crossesAt = instance.crossesAt;
    if (!common_1._isNullOrUndefined(axId)) {
        WriteCT_Int(writer, CONST_C, CONST_AXID, axId);
    }
    if (!common_1._isNullOrUndefined(scaling)) {
        WriteCT_Scaling(writer, CONST_C, CONST_SCALING, scaling);
    }
    if (!common_1._isNullOrUndefined(deleteField)) {
        WriteCT_Boolean(writer, CONST_C, CONST_DELETE, deleteField);
    }
    if (!common_1._isNullOrUndefined(axPos)) {
        WriteCT_AxPos(writer, CONST_C, CONST_AX_POS, axPos);
    }
    if (!common_1._isNullOrUndefined(majorGridlines)) {
        WriteCT_ChartLines(writer, CONST_C, CONST_MAJOR_GRIDLINES, majorGridlines);
    }
    if (!common_1._isNullOrUndefined(minorGridlines)) {
        WriteCT_ChartLines(writer, CONST_C, CONST_MINOR_GRIDLINES, minorGridlines);
    }
    if (!common_1._isNullOrUndefined(title)) {
        WriteCT_Title(writer, CONST_C, CONST_TITLE, title);
    }
    if (!common_1._isNullOrUndefined(numFmt)) {
        WriteCT_NumFmt(writer, CONST_C, CONST_NUMFMT, numFmt);
    }
    if (!common_1._isNullOrUndefined(majorTickMark)) {
        WriteCT_TickMark(writer, CONST_C, CONST_MAJOR_TICK_MARK, majorTickMark);
    }
    if (!common_1._isNullOrUndefined(minorTickMark)) {
        WriteCT_TickMark(writer, CONST_C, CONST_MINOR_TICK_MARK, minorTickMark);
    }
    if (!common_1._isNullOrUndefined(tickLblPos)) {
        WriteCT_TickLblPos(writer, CONST_C, CONST_TICK_LBLPOS, tickLblPos);
    }
    if (!common_1._isNullOrUndefined(spPr)) {
        WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
    }
    if (!common_1._isNullOrUndefined(txPr)) {
        WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
    }
    if (!common_1._isNullOrUndefined(crossAx)) {
        WriteCT_Int(writer, CONST_C, CONST_CROSSAX, crossAx);
    }
    if (!common_1._isNullOrUndefined(crosses)) {
        WriteCT_Crosses(writer, CONST_C, CONST_CROSSES, crosses);
    }
    if (!common_1._isNullOrUndefined(crossesAt)) {
        WriteCT_Double(writer, CONST_C, "crossesAt", crossesAt);
    }
}
function writeArrayItem(items, callback) {
    if (!common_1._isNullOrUndefined(items)) {
        for (var i = 0, count = items.length; i < count; i++) {
            var item = items[i];
            if (!common_1._isNullOrUndefined(item)) {
                callback(item, i);
            }
        }
    }
}
function writeLineOrScatterSerSubElement(writer, instance) {
    var idx = instance.idx, order = instance.order, tx = instance.tx, spPr = instance.spPr, marker = instance.marker, dLbls = instance.dLbls, smooth = instance.smooth, extLst = instance.extLst;
    if (!common_1._isNullOrUndefined(idx)) {
        WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
    }
    if (!common_1._isNullOrUndefined(order)) {
        WriteCT_UnsignedInt(writer, CONST_C, CONST_ORDER, order);
    }
    if (!common_1._isNullOrUndefined(tx)) {
        WriteCT_SerTx(writer, CONST_C, "tx", tx);
    }
    if (!common_1._isNullOrUndefined(spPr)) {
        WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
    }
    if (!common_1._isNullOrUndefined(marker)) {
        WriteCT_Marker(writer, CONST_C, CONST_MARKER, marker);
    }
    writeArrayItem(instance.dPt, function (dPtItem) {
        WriteCT_DPt(writer, CONST_C, "dPt", dPtItem);
    });
    if (!common_1._isNullOrUndefined(dLbls)) {
        WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
    }
    writeArrayItem(instance.trendline, function (trendlineItem) {
        WriteCT_Trendline(writer, CONST_C, CONST_TRENDLINE, trendlineItem);
    });
    writeArrayItem(instance.errBars, function (errBarsItem) {
        WriteCT_ErrBars(writer, CONST_C, CONST_ERR_BARS, errBarsItem);
    });
    if (!common_1._isNullOrUndefined(smooth)) {
        WriteCT_Boolean(writer, CONST_C, "smooth", smooth);
    }
    if (!common_1._isNullOrUndefined(extLst)) {
        WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
    }
}
function writeAreaOrBarSerSubElement(writer, instance) {
    var idx = instance.idx, order = instance.order, tx = instance.tx, spPr = instance.spPr, pictureOptions = instance.pictureOptions, dLbls = instance.dLbls, cat = instance.cat, val = instance.val, extLst = instance.extLst;
    if (!common_1._isNullOrUndefined(idx)) {
        WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
    }
    if (!common_1._isNullOrUndefined(order)) {
        WriteCT_UnsignedInt(writer, CONST_C, CONST_ORDER, order);
    }
    if (!common_1._isNullOrUndefined(tx)) {
        WriteCT_SerTx(writer, CONST_C, "tx", tx);
    }
    if (!common_1._isNullOrUndefined(spPr)) {
        WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
    }
    if (!common_1._isNullOrUndefined(pictureOptions)) {
        WriteCT_PictureOptions(writer, CONST_C, CONST_PICTURE_OPTIONS, pictureOptions);
    }
    writeArrayItem(instance.dPt, function (dPtItem) {
        WriteCT_DPt(writer, CONST_C, "dPt", dPtItem);
    });
    if (!common_1._isNullOrUndefined(dLbls)) {
        WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
    }
    writeArrayItem(instance.trendline, function (trendlineItem) {
        WriteCT_Trendline(writer, CONST_C, CONST_TRENDLINE, trendlineItem);
    });
    writeArrayItem(instance.errBars, function (errBarsItem) {
        WriteCT_ErrBars(writer, CONST_C, CONST_ERR_BARS, errBarsItem);
    });
    if (!common_1._isNullOrUndefined(cat)) {
        WriteCT_AxDataSource(writer, CONST_C, "cat", cat);
    }
    if (!common_1._isNullOrUndefined(val)) {
        WriteCT_NumDataSource(writer, CONST_C, CONST_VAL, val);
    }
    if (!common_1._isNullOrUndefined(extLst)) {
        WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
    }
}
function writeLockingElementAttribute(writer, instance) {
    if (instance.noGrp === true) {
        writer.writeAttributeString("noGrp", "1");
    }
    if (instance.noSelect === true) {
        writer.writeAttributeString("noSelect", "1");
    }
    if (instance.noRot === true) {
        writer.writeAttributeString("noRot", "1");
    }
    if (instance.noChangeAspect === true) {
        writer.writeAttributeString("noChangeAspect", "1");
    }
    if (instance.noMove === true) {
        writer.writeAttributeString("noMove", "1");
    }
    if (instance.noResize === true) {
        writer.writeAttributeString("noResize", "1");
    }
    if (instance.noEditPoints === true) {
        writer.writeAttributeString("noEditPoints", "1");
    }
    if (instance.noAdjustHandles === true) {
        writer.writeAttributeString("noAdjustHandles", "1");
    }
    if (instance.noChangeArrowheads === true) {
        writer.writeAttributeString("noChangeArrowheads", "1");
    }
    if (instance.noChangeShapeType === true) {
        writer.writeAttributeString("noChangeShapeType", "1");
    }
}
function writeDLblSubElement(writer, instance) {
    var numFmt = instance.numFmt, spPr = instance.spPr, txPr = instance.txPr, dLblPos = instance.dLblPos, showLegendKey = instance.showLegendKey, showVal = instance.showVal, showCatName = instance.showCatName, showSerName = instance.showSerName, showPercent = instance.showPercent, showBubbleSize = instance.showBubbleSize;
    if (!common_1._isNullOrUndefined(numFmt)) {
        WriteCT_NumFmt(writer, CONST_C, CONST_NUMFMT, numFmt);
    }
    if (!common_1._isNullOrUndefined(spPr)) {
        WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
    }
    if (!common_1._isNullOrUndefined(txPr)) {
        WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
    }
    if (!common_1._isNullOrUndefined(dLblPos)) {
        WriteCT_DLblPos(writer, CONST_C, "dLblPos", dLblPos);
    }
    if (!common_1._isNullOrUndefined(showLegendKey)) {
        WriteCT_Boolean(writer, CONST_C, "showLegendKey", showLegendKey);
    }
    if (!common_1._isNullOrUndefined(showVal)) {
        WriteCT_Boolean(writer, CONST_C, "showVal", showVal);
    }
    if (!common_1._isNullOrUndefined(showCatName)) {
        WriteCT_Boolean(writer, CONST_C, "showCatName", showCatName);
    }
    if (!common_1._isNullOrUndefined(showSerName)) {
        WriteCT_Boolean(writer, CONST_C, "showSerName", showSerName);
    }
    if (!common_1._isNullOrUndefined(showPercent)) {
        WriteCT_Boolean(writer, CONST_C, "showPercent", showPercent);
    }
    if (!common_1._isNullOrUndefined(showBubbleSize)) {
        WriteCT_Boolean(writer, CONST_C, "showBubbleSize", showBubbleSize);
    }
    if (!common_1._isNullOrUndefined(instance.separator)) {
        writer.writeElementString("c:separator", instance.separator);
    }
}
function writeEffectElementAttribute(writer, instance) {
    var sx = instance.sx, sy = instance.sy, kx = instance.kx, ky = instance.ky, algn = instance.algn;
    if (!common_1._isNullOrUndefined(sx) && sx !== 100000) {
        writer.writeAttributeString("sx", sx);
    }
    if (!common_1._isNullOrUndefined(sy) && sy !== 100000) {
        writer.writeAttributeString("sy", sy);
    }
    if (!common_1._isNullOrUndefined(kx) && kx !== 0) {
        writer.writeAttributeString("kx", kx);
    }
    if (!common_1._isNullOrUndefined(ky) && ky !== 0) {
        writer.writeAttributeString("ky", ky);
    }
    if (!common_1._isNullOrUndefined(algn) && algn !== 7) {
        writer.writeAttributeString("algn", chart_model_1.Charts.ST_RectAlignment[algn]);
    }
    if (instance.rotWithShape === false) {
        writer.writeAttributeString(CONST_TOT_WITH_SHAPE, "0");
    }
}
function writeShapeElement(writer, prefix, localName, instance, nameSpaceString, specialWriterFunc) {
    writer.writeElement(prefix + ":" + localName, function () {
        var macro = instance.macro, textlink = instance.textlink;
        if (!common_1._isNullOrUndefined(macro)) {
            writer.writeAttributeString(CONST_MACRO, macro);
        }
        if (!common_1._isNullOrUndefined(textlink)) {
            writer.writeAttributeString("textlink", textlink);
        }
        if (instance.fLocksText === false) {
            writer.writeAttributeString("fLocksText", "0");
        }
        if (instance.fPublished === true) {
            writer.writeAttributeString(CONST_FPUBLISHED, "1");
        }
    }, function () {
        var nvSpPr = instance.nvSpPr, spPr = instance.spPr, style = instance.style, txBody = instance.txBody;
        if (!common_1._isNullOrUndefined(nvSpPr)) {
            specialWriterFunc(writer, nameSpaceString, "nvSpPr", nvSpPr);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, nameSpaceString, CONST_SPPR, spPr, false);
        }
        if (!common_1._isNullOrUndefined(style)) {
            WriteCT_ShapeStyle(writer, nameSpaceString, CONST_STYLE, style);
        }
        if (!common_1._isNullOrUndefined(txBody)) {
            WriteCT_TextBody(writer, nameSpaceString, "txBody", txBody);
        }
    });
}
function writeShapeNonVisualElement(writer, prefix, localName, instance, nameSpaceString) {
    writer.writeElement(prefix + ":" + localName, function () {
        var cNvPr = instance.cNvPr, cNvSpPr = instance.cNvSpPr;
        if (!common_1._isNullOrUndefined(cNvPr)) {
            WriteCT_NonVisualDrawingProps(writer, nameSpaceString, CONST_CNVPR, cNvPr);
        }
        if (!common_1._isNullOrUndefined(cNvSpPr)) {
            WriteCT_NonVisualDrawingShapeProps(writer, nameSpaceString, "cNvSpPr", cNvSpPr);
        }
    });
}
function writeAnchorSubElement(writer, instance, extIsRequired) {
    var ext = instance.ext, sp = instance.sp, grpSp = instance.grpSp, graphicFrame = instance.graphicFrame, cxnSp = instance.cxnSp, alternateContent = instance.AlternateContent, clientData = instance.clientData;
    if (!ext && extIsRequired) {
        var w = instance.width, h = instance.height;
        if (!isNaN(w) && !isNaN(h)) {
            ext = { cx: w, cy: h };
        }
    }
    if (!common_1._isNullOrUndefined(ext)) {
        WriteCT_PositiveSize2D(writer, CONST_XDR, CONST_EXT, ext, true);
    }
    if (!common_1._isNullOrUndefined(sp)) {
        WriteCT_Shape(writer, CONST_XDR, "sp", sp);
    }
    if (!common_1._isNullOrUndefined(grpSp)) {
        WriteCT_GroupShape(writer, CONST_XDR, CONST_GRPSP, grpSp);
    }
    if (!common_1._isNullOrUndefined(graphicFrame)) {
        WriteCT_GraphicalObjectFrame(writer, CONST_XDR, CONST_GRAPHIC_FRAME, graphicFrame);
    }
    if (!common_1._isNullOrUndefined(cxnSp)) {
        WriteCT_Connector(writer, CONST_XDR, CONST_CXNSP, cxnSp);
    }
    if (!common_1._isNullOrUndefined(alternateContent)) {
        WriteCT_AlternateContent(writer, CONST_MC, CONST_ALTERNATE_CONTENT);
    }
    if (!common_1._isNullOrUndefined(clientData)) {
        WriteCT_AnchorClientData(writer, CONST_XDR, CONST_CLIENT_DATA, clientData);
    }
}
exports.DrawingWriter = {
    a: "http://schemas.openxmlformats.org/drawingml/2006/main",
    cdr: "http://schemas.openxmlformats.org/drawingml/2006/chartDrawing",
    r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
    xdr: "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",
    c: "http://schemas.openxmlformats.org/drawingml/2006/chart",
    c15: "http://schemas.microsoft.com/office/drawing/2012/chart",
    a14: "http://schemas.microsoft.com/office/drawing/2010/main",
    c14: "http://schemas.microsoft.com/office/drawing/2007/8/2/chart",
    c16: "http://schemas.microsoft.com/office/drawing/2017/03/chart",
    mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
    cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex"
};
var chart2016Write = {};
chart2016Write.WriteCT_ChartStyle = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var attribute = instance.attribute;
        var cs = attribute.cs, a = attribute.a, id = attribute.id;
        if (!isNullOrUndefinedOrEmpty(cs)) {
            writer.writeAttributeString("xmlns:cs", cs);
        }
        if (!isNullOrUndefinedOrEmpty(a)) {
            writer.writeAttributeString("xmlns:a", a);
        }
        if (!isNullOrUndefinedOrEmpty(id)) {
            writer.writeAttributeString("id", id);
        }
    }, function () {
        for (var key in instance) {
            if (key !== 'attribute') {
                if (key === 'dataPointMarkerLayout') {
                    chart2016Write.WriteCT_DataPointMarkerLayout(writer, CONST_CS, key, ns, instance[key]);
                }
                else if (key === 'extLst') {
                    var extLst = instance.extLst;
                    if (!common_1._isNullOrUndefined(extLst)) {
                        WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
                    }
                }
                else {
                    chart2016Write.WriteCT_ChartStyleElement(writer, CONST_CS, key, ns, instance[key]);
                }
            }
        }
    });
};
chart2016Write.WriteCT_ChartStyleElement = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        for (var key in instance.attribute) {
            if (instance.attribute.hasOwnProperty(key)) {
                writer.writeAttributeString(key, instance.attribute[key]);
            }
        }
    }, function () {
        var lnRef = instance.lnRef, fillRef = instance.fillRef, effectRef = instance.effectRef, fontRef = instance.fontRef, spPr = instance.spPr, defRPr = instance.defRPr, bodyPr = instance.bodyPr;
        if (!common_1._isNullOrUndefined(lnRef)) {
            WriteCT_StyleMatrixReference(writer, CONST_CS, "lnRef", lnRef);
        }
        if (!common_1._isNullOrUndefined(fillRef)) {
            WriteCT_StyleMatrixReference(writer, CONST_CS, "fillRef", fillRef);
        }
        if (!common_1._isNullOrUndefined(effectRef)) {
            WriteCT_StyleMatrixReference(writer, CONST_CS, "effectRef", effectRef);
        }
        if (!common_1._isNullOrUndefined(fontRef)) {
            WriteCT_FontReference(writer, CONST_CS, "fontRef", fontRef);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, prefix, "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(defRPr)) {
            WriteCT_TextCharacterProperties(writer, CONST_CS, "defRPr", defRPr);
        }
        if (!common_1._isNullOrUndefined(bodyPr)) {
            WriteCT_TextBodyProperties(writer, CONST_CS, "bodyPr", bodyPr);
        }
    });
};
chart2016Write.WriteCT_DataPointMarkerLayout = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        for (var key in instance.attribute) {
            if (instance.attribute.hasOwnProperty(key)) {
                writer.writeAttributeString(key, instance.attribute[key]);
            }
        }
    });
};
chart2016Write.WriteCT_ChartColors = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var attribute = instance.attribute;
        var cs = attribute.cs, a = attribute.a, id = attribute.id, meth = attribute.meth;
        if (!isNullOrUndefinedOrEmpty(cs)) {
            writer.writeAttributeString("xmlns:cs", cs);
        }
        if (!isNullOrUndefinedOrEmpty(a)) {
            writer.writeAttributeString("xmlns:a", a);
        }
        if (!isNullOrUndefinedOrEmpty(meth)) {
            writer.writeAttributeString("meth", meth);
        }
        if (!isNullOrUndefinedOrEmpty(id)) {
            writer.writeAttributeString("id", id);
        }
    }, function () {
        var schemeClr = instance.schemeClr, variation = instance.variation;
        writeArrayItem(schemeClr, function (schemeClrItem) {
            WriteCT_SchemeColor(writer, CONST_A, CONST_SCHEMECLR, schemeClrItem);
        });
        if (!common_1._isNullOrUndefined(variation)) {
            for (var i = 0; i < variation.length; i++) {
                var variationItem = variation[i];
                chart2016Write.WriteCT_Variation(writer, CONST_CS, "variation", ns, variationItem);
            }
        }
    });
};
chart2016Write.WriteCT_Variation = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (instance) {
            var lumMod = instance.lumMod, lumOff = instance.lumOff;
            if (!common_1._isNullOrUndefined(lumMod)) {
                WriteCT_Percentage(writer, CONST_A, "lumMod", lumMod);
            }
            if (!common_1._isNullOrUndefined(lumOff)) {
                WriteCT_Percentage(writer, CONST_A, "lumOff", lumOff);
            }
        }
    });
};
chart2016Write.WriteCT_Extension = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.uri)) {
            writer.writeAttributeString("uri", instance.uri.toString());
        }
    });
};
chart2016Write.WriteCT_ExtensionList = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (instance && instance.ext && instance.ext.length > 0) {
            for (var i = 0; i < instance.ext.length; i++) {
                if (!common_1._isNullOrUndefined(instance.ext[i])) {
                    chart2016Write.WriteCT_Extension(writer, prefix, "ext", "", instance.ext[i]);
                }
            }
        }
    });
};
chart2016Write.WriteCT_NumberFormat = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.formatCode)) {
            writer.writeAttributeString("formatCode", xmlEncode(instance.formatCode));
        }
        writer.writeAttributeString("sourceLinked", instance.sourceLinked ? "1" : "0");
    });
};
chart2016Write.WriteCT_ValueColors = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (!common_1._isNullOrUndefined(instance.minColor)) {
            WriteCT_SolidColorFillProperties(writer, prefix, "minColor", instance.minColor);
        }
        if (!common_1._isNullOrUndefined(instance.midColor)) {
            WriteCT_SolidColorFillProperties(writer, prefix, "midColor", instance.midColor);
        }
        if (!common_1._isNullOrUndefined(instance.maxColor)) {
            WriteCT_SolidColorFillProperties(writer, prefix, "maxColor", instance.maxColor);
        }
    });
};
chart2016Write.WriteCT_ExternalData = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.id)) {
            writer.writeAttributeString("id", instance.id.toString());
        }
        writer.writeAttributeString("autoUpdate", instance.autoUpdate ? "1" : "0");
    });
};
chart2016Write.WriteCT_Formula = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!isNullOrUndefinedOrEmpty(instance.dir)) {
            writer.writeAttributeString("dir", chart_model_1.Charts.ST_FormulaDirection[instance.dir]);
        }
    }, function () {
        var formula = instance.formula;
        if (!isNullOrUndefinedOrEmpty(formula)) {
            writer.writeValue(formula);
        }
    });
};
chart2016Write.WriteCT_Value = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var value = instance.value;
        if (!isNullOrUndefinedOrEmpty(value)) {
            writer.writeValue(value);
        }
    });
};
chart2016Write.WriteCT_DataId = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("val", instance.val.toString());
    });
};
chart2016Write.WriteST_AxisId = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("val", instance.val.toString());
    });
};
chart2016Write.WriteCT_StringValue = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!isNullOrUndefinedOrEmpty(instance.idx)) {
            writer.writeAttributeString("idx", instance.idx);
        }
    }, function () {
        var value = instance.value;
        if (!isNullOrUndefinedOrEmpty(value)) {
            writer.writeValue(value);
        }
    });
};
chart2016Write.WriteCT_StringLevel = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("ptCount", instance.ptCount.toString());
        if (!common_1._isNullOrUndefined(instance.name)) {
            writer.writeAttributeString("name", instance.name.toString());
        }
    }, function () {
        for (var i = 0; i < instance.pt.length; i++) {
            if (!common_1._isNullOrUndefined(instance.pt[i])) {
                chart2016Write.WriteCT_StringValue(writer, prefix, "pt", "", instance.pt[i]);
            }
        }
    });
};
chart2016Write.WriteCT_StringDimension = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("type", chart_model_1.Charts.ST_StringDimensionType[instance.type]);
    }, function () {
        if (instance.lvl && instance.lvl.length > 0) {
            for (var i = 0; i < instance.lvl.length; i++) {
                if (!common_1._isNullOrUndefined(instance.lvl[i])) {
                    chart2016Write.WriteCT_StringLevel(writer, prefix, "lvl", "", instance.lvl[i]);
                }
            }
        }
        if (!common_1._isNullOrUndefined(instance.nf)) {
            chart2016Write.WriteCT_Formula(writer, prefix, "nf", "", instance.nf);
        }
        if (!common_1._isNullOrUndefined(instance.f)) {
            chart2016Write.WriteCT_Formula(writer, prefix, "f", "", instance.f);
        }
    });
};
chart2016Write.WriteCT_NumericValue = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!isNullOrUndefinedOrEmpty(instance.idx)) {
            writer.writeAttributeString("idx", instance.idx);
        }
    }, function () {
        var value = instance.value;
        if (!isNullOrUndefinedOrEmpty(value)) {
            writer.writeValue(value);
        }
    });
};
chart2016Write.WriteCT_NumericLevel = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("ptCount", instance.ptCount.toString());
        if (!common_1._isNullOrUndefined(instance.formatCode)) {
            writer.writeAttributeString("formatCode", instance.formatCode.toString());
        }
        if (!common_1._isNullOrUndefined(instance.name)) {
            writer.writeAttributeString("name", instance.name.toString());
        }
    }, function () {
        for (var i = 0; i < instance.pt.length; i++) {
            if (!common_1._isNullOrUndefined(instance.pt[i])) {
                chart2016Write.WriteCT_NumericValue(writer, prefix, "pt", "", instance.pt[i]);
            }
        }
    });
};
chart2016Write.WriteCT_NumericDimension = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("type", chart_model_1.Charts.ST_NumericDimensionType[instance.type]);
    }, function () {
        if (instance.lvl && instance.lvl.length > 0) {
            for (var i = 0; i < instance.lvl.length; i++) {
                if (!common_1._isNullOrUndefined(instance.lvl[i])) {
                    chart2016Write.WriteCT_NumericLevel(writer, prefix, "lvl", "", instance.lvl[i]);
                }
            }
        }
        if (!common_1._isNullOrUndefined(instance.nf)) {
            chart2016Write.WriteCT_Formula(writer, prefix, "nf", "", instance.nf);
        }
        if (!common_1._isNullOrUndefined(instance.f)) {
            chart2016Write.WriteCT_Formula(writer, prefix, "f", "", instance.f);
        }
    });
};
chart2016Write.WriteCT_Data = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("id", instance.id.toString());
    }, function () {
        var i;
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
        if (instance.numDim && instance.numDim.length > 0) {
            for (i = 0; i < instance.numDim.length; i++) {
                if (!common_1._isNullOrUndefined(instance.numDim[i])) {
                    chart2016Write.WriteCT_NumericDimension(writer, prefix, "numDim", "", instance.numDim[i]);
                }
            }
        }
        if (instance.strDim && instance.strDim.length > 0) {
            for (i = 0; i < instance.strDim.length; i++) {
                if (!common_1._isNullOrUndefined(instance.strDim[i])) {
                    chart2016Write.WriteCT_StringDimension(writer, prefix, "strDim", "", instance.strDim[i]);
                }
            }
        }
    });
};
chart2016Write.WriteCT_ChartData = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (!common_1._isNullOrUndefined(instance.externalData)) {
            chart2016Write.WriteCT_ExternalData(writer, prefix, "externalData", "", instance.externalData);
        }
        var i;
        for (i = 0; i < instance.data.length; i++) {
            if (!common_1._isNullOrUndefined(instance.data[i])) {
                chart2016Write.WriteCT_Data(writer, prefix, "data", "", instance.data[i]);
            }
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_TextData = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.f)) {
            chart2016Write.WriteCT_Formula(writer, prefix, "f", "", instance.f);
        }
        if (!common_1._isNullOrUndefined(instance.v)) {
            chart2016Write.WriteCT_Value(writer, prefix, "v", "", instance.v);
        }
    });
};
chart2016Write.WriteCT_Text = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.txData)) {
            chart2016Write.WriteCT_TextData(writer, prefix, "txData", "", instance.txData);
        }
        else if (!common_1._isNullOrUndefined(instance.rich)) {
            WriteCT_TextBody(writer, prefix, "rich", instance.rich);
        }
    });
};
chart2016Write.WriteCT_ChartTitle = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.pos)) {
            writer.writeAttributeString("pos", chart_model_1.Charts.ST_SidePos[instance.pos]);
        }
        if (!common_1._isNullOrUndefined(instance.align)) {
            writer.writeAttributeString("align", chart_model_1.Charts.ST_PosAlign[instance.align]);
        }
        if (!common_1._isNullOrUndefined(instance.overlay)) {
            writer.writeAttributeString("overlay", instance.overlay ? "1" : "0");
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.tx)) {
            chart2016Write.WriteCT_Text(writer, prefix, "tx", "", instance.tx);
        }
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, prefix, "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.txPr)) {
            WriteCT_TextBody(writer, prefix, "txPr", instance.txPr);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_CategoryAxisScaling = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.gapWidth)) {
            writer.writeAttributeString("gapWidth", instance.gapWidth.toString());
        }
    });
};
chart2016Write.WriteCT_ValueAxisScaling = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.max)) {
            writer.writeAttributeString("max", instance.max.toString());
        }
        if (!common_1._isNullOrUndefined(instance.min)) {
            writer.writeAttributeString("min", instance.min.toString());
        }
        if (!common_1._isNullOrUndefined(instance.majorUnit)) {
            writer.writeAttributeString("majorUnit", instance.majorUnit.toString());
        }
        if (!common_1._isNullOrUndefined(instance.minorUnit)) {
            writer.writeAttributeString("minorUnit", instance.minorUnit.toString());
        }
    });
};
chart2016Write.WriteCT_AxisTitle = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (!common_1._isNullOrUndefined(instance.tx)) {
            chart2016Write.WriteCT_Text(writer, prefix, "tx", "", instance.tx);
        }
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, prefix, "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.txPr)) {
            WriteCT_TextBody(writer, prefix, "txPr", instance.txPr);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_AxisUnitsLabel = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (!common_1._isNullOrUndefined(instance.tx)) {
            chart2016Write.WriteCT_Text(writer, prefix, "tx", "", instance.tx);
        }
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, "cx", "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.txPr)) {
            WriteCT_TextBody(writer, prefix, "txPr", instance.txPr);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_AxisUnits = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("unit", chart_model_1.Charts.ST_AxisUnit[instance.unit]);
    }, function () {
        if (!common_1._isNullOrUndefined(instance.unitsLabel)) {
            chart2016Write.WriteCT_AxisUnitsLabel(writer, prefix, "unitsLabel", "", instance.unitsLabel);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_Gridlines = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (instance && !common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, "cx", "spPr", instance.spPr);
        }
        if (instance && !common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_TickMarks = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("type", chart_model_1.Charts.ST_TickMarksType[instance]);
    }, function () {
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_TickLabels = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (instance && !common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_Axis = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var id = instance.id ? instance.id : 1;
        writer.writeAttributeString("id", id.toString());
        if (instance.hidden !== false) {
            writer.writeAttributeString("hidden", instance.hidden ? "1" : "0");
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.title)) {
            chart2016Write.WriteCT_AxisTitle(writer, prefix, "title", "", instance.title);
        }
        if (!common_1._isNullOrUndefined(instance.units)) {
            chart2016Write.WriteCT_AxisUnits(writer, prefix, "units", "", instance.units);
        }
        if (!common_1._isNullOrUndefined(instance.majorGridlines)) {
            chart2016Write.WriteCT_Gridlines(writer, prefix, "majorGridlines", "", instance.majorGridlines);
        }
        if (!common_1._isNullOrUndefined(instance.minorGridlines)) {
            chart2016Write.WriteCT_Gridlines(writer, prefix, "minorGridlines", "", instance.minorGridlines);
        }
        if (!common_1._isNullOrUndefined(instance.majorTickMarks) && !common_1._isNullOrUndefined(instance.majorTickMarks)) {
            chart2016Write.WriteCT_TickMarks(writer, prefix, "majorTickMarks", "", instance.majorTickMarks);
        }
        if (!common_1._isNullOrUndefined(instance.minorTickMarks) && !common_1._isNullOrUndefined(instance.minorTickMarks)) {
            chart2016Write.WriteCT_TickMarks(writer, prefix, "minorTickMarks", "", instance.minorTickMarks);
        }
        chart2016Write.WriteCT_TickLabels(writer, prefix, "tickLabels", "", instance.tickLabels);
        if (!common_1._isNullOrUndefined(instance.numFmt)) {
            chart2016Write.WriteCT_NumberFormat(writer, prefix, "numFmt", "", instance.numFmt);
        }
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, prefix, "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.txPr)) {
            WriteCT_TextBody(writer, prefix, "txPr", instance.txPr);
        }
        if (!common_1._isNullOrUndefined(instance.catScaling)) {
            chart2016Write.WriteCT_CategoryAxisScaling(writer, prefix, "catScaling", "", instance.catScaling);
        }
        else {
            var valScalingInstance = instance.valScaling || {};
            chart2016Write.WriteCT_ValueAxisScaling(writer, prefix, "valScaling", "", valScalingInstance);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_ParentLabelLayout = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("val", chart_model_1.Charts.ST_ParentLabelLayout[instance.val]);
    });
};
chart2016Write.WriteCT_RegionLabelLayout = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("val", chart_model_1.Charts.ST_RegionLabelLayout[instance.val]);
    });
};
chart2016Write.WriteCT_SeriesElementVisibilities = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("connectorLines", instance.connectorLines ? "1" : "0");
        writer.writeAttributeString("meanLine", instance.meanLine ? "1" : "0");
        writer.writeAttributeString("meanMarker", instance.meanMarker ? "1" : "0");
        writer.writeAttributeString("nonoutliers", instance.nonoutliers ? "1" : "0");
        writer.writeAttributeString("outliers", instance.outliers ? "1" : "0");
    });
};
chart2016Write.WriteCT_Aggregation = function (writer, prefix, localName) {
    writer.writeLeafElement(prefix + ":" + localName, null);
};
chart2016Write.WriteCT_Binning = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("intervalClosed", chart_model_1.Charts.ST_IntervalClosedSide[instance.intervalClosed]);
        if (!common_1._isNullOrUndefined(instance.underflow)) {
            writer.writeAttributeString("underflow", instance.underflow.toString());
        }
        if (!common_1._isNullOrUndefined(instance.overflow)) {
            writer.writeAttributeString("overflow", instance.overflow.toString());
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.binSize)) {
            chart2016Write.WriteBinSize(writer, prefix, "binSize", "", instance.binSize);
        }
        if (!common_1._isNullOrUndefined(instance.binCount)) {
            chart2016Write.WriteBinCount(writer, prefix, "binCount", "", instance.binCount);
        }
    });
};
chart2016Write.WriteBinSize = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("val", instance.val.toString());
    });
};
chart2016Write.WriteBinCount = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("val", instance.val.toString());
    });
};
chart2016Write.WriteCT_GeoLocationQuery = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.countryRegion)) {
            writer.writeAttributeString("countryRegion", instance.countryRegion.toString());
        }
        if (!common_1._isNullOrUndefined(instance.adminDistrict1)) {
            writer.writeAttributeString("adminDistrict1", instance.adminDistrict1.toString());
        }
        if (!common_1._isNullOrUndefined(instance.adminDistrict2)) {
            writer.writeAttributeString("adminDistrict2", instance.adminDistrict2.toString());
        }
        if (!common_1._isNullOrUndefined(instance.postalCode)) {
            writer.writeAttributeString("postalCode", instance.postalCode.toString());
        }
        writer.writeAttributeString("entityType", chart_model_1.Charts.ST_EntityType[instance.entityType]);
    });
};
chart2016Write.WriteCT_Address = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.address1)) {
            writer.writeAttributeString("address1", instance.address1.toString());
        }
        if (!common_1._isNullOrUndefined(instance.countryRegion)) {
            writer.writeAttributeString("countryRegion", instance.countryRegion.toString());
        }
        if (!common_1._isNullOrUndefined(instance.adminDistrict1)) {
            writer.writeAttributeString("adminDistrict1", instance.adminDistrict1.toString());
        }
        if (!common_1._isNullOrUndefined(instance.adminDistrict2)) {
            writer.writeAttributeString("adminDistrict2", instance.adminDistrict2.toString());
        }
        if (!common_1._isNullOrUndefined(instance.postalCode)) {
            writer.writeAttributeString("postalCode", instance.postalCode.toString());
        }
        if (!common_1._isNullOrUndefined(instance.locality)) {
            writer.writeAttributeString("locality", instance.locality.toString());
        }
        if (!common_1._isNullOrUndefined(instance.isoCountryCode)) {
            writer.writeAttributeString("isoCountryCode", instance.isoCountryCode.toString());
        }
    });
};
chart2016Write.WriteCT_GeoLocation = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("latitude", instance.latitude.toString());
        writer.writeAttributeString("longitude", instance.longitude.toString());
        if (!common_1._isNullOrUndefined(instance.entityName)) {
            writer.writeAttributeString("entityName", instance.entityName.toString());
        }
        writer.writeAttributeString("entityType", chart_model_1.Charts.ST_EntityType[instance.entityType]);
    }, function () {
        if (!common_1._isNullOrUndefined(instance.address)) {
            chart2016Write.WriteCT_Address(writer, prefix, "address", "", instance.address);
        }
    });
};
chart2016Write.WriteCT_GeoLocations = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (!common_1._isNullOrUndefined(instance.geoLocation)) {
            chart2016Write.WriteCT_GeoLocation(writer, prefix, "geoLocation", "", instance.geoLocation);
        }
    });
};
chart2016Write.WriteCT_GeoLocationQueryResult = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (!common_1._isNullOrUndefined(instance.geoLocationQuery)) {
            chart2016Write.WriteCT_GeoLocationQuery(writer, prefix, "geoLocationQuery", "", instance.geoLocationQuery);
        }
        if (!common_1._isNullOrUndefined(instance.geoLocations)) {
            chart2016Write.WriteCT_GeoLocations(writer, prefix, "geoLocations", "", instance.geoLocations);
        }
    });
};
chart2016Write.WriteCT_GeoLocationQueryResults = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        for (var i = 0; i < instance.geoLocationQueryResult.length; i++) {
            if (!common_1._isNullOrUndefined(instance.geoLocationQueryResult[i])) {
                chart2016Write.WriteCT_GeoLocationQueryResult(writer, prefix, "geoLocationQueryResult", "", instance.geoLocationQueryResult[i]);
            }
        }
    });
};
chart2016Write.WriteCT_GeoPolygon = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.polygonId)) {
            writer.writeAttributeString("polygonId", instance.polygonId.toString());
        }
        writer.writeAttributeString("numPoints", instance.numPoints.toString());
        if (!common_1._isNullOrUndefined(instance.pcaRings)) {
            writer.writeAttributeString("pcaRings", instance.pcaRings.toString());
        }
    });
};
chart2016Write.WriteCT_GeoPolygons = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        for (var i = 0; i < instance.geoPolygon.length; i++) {
            if (!common_1._isNullOrUndefined(instance.geoPolygon[i])) {
                chart2016Write.WriteCT_GeoPolygon(writer, prefix, "geoPolygon", "", instance.geoPolygon[i]);
            }
        }
    });
};
chart2016Write.WriteCT_Copyrights = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var copyrights = instance.copyright;
        if (!common_1._isNullOrUndefined(copyrights)) {
            for (var i = 0; i < copyrights.length; i++) {
                writer.writeElementString(prefix + ":copyright", copyrights[i].toString());
            }
        }
    });
};
chart2016Write.WriteCT_GeoData = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.entityName)) {
            writer.writeAttributeString("entityName", instance.entityName.toString());
        }
        if (!common_1._isNullOrUndefined(instance.entityId)) {
            writer.writeAttributeString("entityId", instance.entityId.toString());
        }
        writer.writeAttributeString("east", instance.east.toString());
        writer.writeAttributeString("west", instance.west.toString());
        writer.writeAttributeString("north", instance.north.toString());
        writer.writeAttributeString("south", instance.south.toString());
    }, function () {
        var i;
        for (i = 0; i < instance.geoPolygons.length; i++) {
            if (!common_1._isNullOrUndefined(instance.geoPolygons[i])) {
                chart2016Write.WriteCT_GeoPolygon(writer, prefix, "geoPolygons", "", instance.geoPolygons[i]);
            }
        }
        for (i = 0; i < instance.copyrights.length; i++) {
            if (!common_1._isNullOrUndefined(instance.copyrights[i])) {
                chart2016Write.WriteCT_Copyrights(writer, prefix, "copyrights", "", instance.copyrights);
            }
        }
    });
};
chart2016Write.WriteCT_GeoDataEntityQuery = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("entityType", chart_model_1.Charts.ST_EntityType[instance.entityType]);
        if (!common_1._isNullOrUndefined(instance.entityId)) {
            writer.writeAttributeString("entityId", instance.entityId.toString());
        }
    });
};
chart2016Write.WriteCT_GeoDataEntityQueryResult = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, keyword_null, function () {
        if (!common_1._isNullOrUndefined(instance.geoDataEntityQuery)) {
            chart2016Write.WriteCT_GeoDataEntityQuery(writer, prefix, "geoDataEntityQuery", "", instance.geoDataEntityQuery);
        }
        if (!common_1._isNullOrUndefined(instance.geoData)) {
            chart2016Write.WriteCT_GeoData(writer, prefix, "geoData", "", instance.geoData);
        }
    });
};
chart2016Write.WriteCT_GeoDataEntityQueryResults = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, keyword_null, function () {
        for (var i = 0; i < instance.geoDataEntityQueryResult.length; i++) {
            if (!common_1._isNullOrUndefined(instance.geoDataEntityQueryResult[i])) {
                chart2016Write.WriteCT_GeoDataEntityQueryResult(writer, prefix, "geoDataEntityQueryResult", "", instance.geoDataEntityQueryResult[i]);
            }
        }
    });
};
chart2016Write.WriteCT_GeoDataPointQuery = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("entityType", chart_model_1.Charts.ST_EntityType[instance.entityType]);
        writer.writeAttributeString("latitude", instance.latitude.toString());
        writer.writeAttributeString("longitude", instance.longitude.toString());
    });
};
chart2016Write.WriteCT_GeoDataPointToEntityQuery = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("entityType", chart_model_1.Charts.ST_EntityType[instance.entityType]);
        if (!common_1._isNullOrUndefined(instance.entityId)) {
            writer.writeAttributeString("entityId", instance.entityId.toString());
        }
    });
};
chart2016Write.WriteCT_GeoDataPointToEntityQueryResult = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, keyword_null, function () {
        if (!common_1._isNullOrUndefined(instance.geoDataPointQuery)) {
            chart2016Write.WriteCT_GeoDataPointQuery(writer, prefix, "geoDataPointQuery", "", instance.geoDataPointQuery);
        }
        if (!common_1._isNullOrUndefined(instance.geoDataPointToEntityQuery)) {
            chart2016Write.WriteCT_GeoDataPointToEntityQuery(writer, prefix, "geoDataPointToEntityQuery", "", instance.geoDataPointToEntityQuery);
        }
    });
};
chart2016Write.WriteCT_GeoDataPointToEntityQueryResults = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, keyword_null, function () {
        for (var i = 0; i < instance.geoDataPointToEntityQueryResult.length; i++) {
            if (!common_1._isNullOrUndefined(instance.geoDataPointToEntityQueryResult[i])) {
                chart2016Write.WriteCT_GeoDataPointToEntityQueryResult(writer, prefix, "geoDataPointToEntityQueryResult", "", instance.geoDataPointToEntityQueryResult[i]);
            }
        }
    });
};
chart2016Write.WriteCT_GeoChildTypes = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var entityType = instance.entityType;
        if (entityType && entityType.length > 0) {
            for (var i = 0; i < entityType.length; i++) {
                writer.writeElementString(prefix + ":entityType", entityType[i].toString());
            }
        }
    });
};
chart2016Write.WriteCT_GeoChildEntitiesQuery = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.entityId)) {
            writer.writeAttributeString("entityId", instance.entityId.toString());
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.geoChildTypes)) {
            chart2016Write.WriteCT_GeoChildTypes(writer, prefix, "geoChildTypes", "", instance.geoChildTypes);
        }
    });
};
chart2016Write.WriteCT_GeoHierarchyEntity = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.entityName)) {
            writer.writeAttributeString("entityName", instance.entityName.toString());
        }
        if (!common_1._isNullOrUndefined(instance.entityId)) {
            writer.writeAttributeString("entityId", instance.entityId.toString());
        }
        writer.writeAttributeString("entityType", chart_model_1.Charts.ST_EntityType[instance.entityType]);
    });
};
chart2016Write.WriteCT_GeoChildEntities = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        for (var i = 0; i < instance.geoHierarchyEntity.length; i++) {
            if (!common_1._isNullOrUndefined(instance.geoHierarchyEntity[i])) {
                chart2016Write.WriteCT_GeoHierarchyEntity(writer, prefix, "geoHierarchyEntity", "", instance.geoHierarchyEntity[i]);
            }
        }
    });
};
chart2016Write.WriteCT_GeoChildEntitiesQueryResult = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (!common_1._isNullOrUndefined(instance.geoChildEntitiesQuery)) {
            chart2016Write.WriteCT_GeoChildEntitiesQuery(writer, prefix, "geoChildEntitiesQuery", "", instance.geoChildEntitiesQuery);
        }
        for (var i = 0; i < instance.geoChildEntities.length; i++) {
            if (!common_1._isNullOrUndefined(instance.geoChildEntities[i])) {
                chart2016Write.WriteCT_GeoHierarchyEntity(writer, prefix, "geoChildEntities", "", instance.geoChildEntities[i]);
            }
        }
    });
};
chart2016Write.WriteCT_GeoChildEntitiesQueryResults = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        for (var i = 0; i < instance.geoChildEntitiesQueryResult.length; i++) {
            if (!common_1._isNullOrUndefined(instance.geoChildEntitiesQueryResult[i])) {
                chart2016Write.WriteCT_GeoChildEntitiesQueryResult(writer, prefix, "geoChildEntitiesQueryResult", "", instance.geoChildEntitiesQueryResult[i]);
            }
        }
    });
};
chart2016Write.WriteCT_Clear = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (!common_1._isNullOrUndefined(instance.geoLocationQueryResults)) {
            chart2016Write.WriteCT_GeoLocationQueryResults(writer, prefix, "geoLocationQueryResults", "", instance.geoLocationQueryResults);
        }
        if (!common_1._isNullOrUndefined(instance.geoDataEntityQueryResults)) {
            chart2016Write.WriteCT_GeoDataEntityQueryResults(writer, prefix, "geoDataEntityQueryResults", "", instance.geoDataEntityQueryResults);
        }
        if (!common_1._isNullOrUndefined(instance.geoDataPointToEntityQueryResults)) {
            chart2016Write.WriteCT_GeoDataPointToEntityQueryResults(writer, prefix, "geoDataPointToEntityQueryResults", "", instance.geoDataPointToEntityQueryResults);
        }
        if (!common_1._isNullOrUndefined(instance.geoChildEntitiesQueryResults)) {
            chart2016Write.WriteCT_GeoChildEntitiesQueryResults(writer, prefix, "geoChildEntitiesQueryResults", "", instance.geoChildEntitiesQueryResults);
        }
    });
};
chart2016Write.WriteCT_GeoCache = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.provider)) {
            writer.writeAttributeString("provider", instance.provider.toString());
        }
        if (!common_1._isNullOrUndefined(instance.binary)) {
            writer.writeAttributeString("binary", instance.binary.toString());
        }
        if (!common_1._isNullOrUndefined(instance.clear)) {
            chart2016Write.WriteCT_Clear(writer, prefix, "clear", ns, instance.clear);
        }
    });
};
chart2016Write.WriteCT_Geography = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("projectionType", chart_model_1.Charts.ST_GeoProjectionType[instance.projectionType]);
        writer.writeAttributeString("viewedRegionType", chart_model_1.Charts.ST_GeoMappingLevel[instance.viewedRegionType]);
        if (!common_1._isNullOrUndefined(instance.cultureLanguage)) {
            writer.writeAttributeString("cultureLanguage", instance.cultureLanguage.toString());
        }
        if (!common_1._isNullOrUndefined(instance.cultureRegion)) {
            writer.writeAttributeString("cultureRegion", instance.cultureRegion.toString());
        }
        if (!common_1._isNullOrUndefined(instance.attribution)) {
            writer.writeAttributeString("attribution", instance.attribution.toString());
        }
        if (!common_1._isNullOrUndefined(instance.geoCache)) {
            chart2016Write.WriteCT_GeoCache(writer, prefix, "geoCache", "", instance.geoCache);
        }
    });
};
chart2016Write.WriteCT_Statistics = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("quartileMethod", chart_model_1.Charts.ST_QuartileMethod[instance.quartileMethod]);
    });
};
chart2016Write.WriteCT_Subtotals = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        var idx = instance.idx;
        var fun = function (j) {
            return function () {
                writer.writeAttributeString("val", idx[j].toString());
            };
        };
        if (idx && idx.length > 0) {
            for (var i = 0; i < idx.length; i++) {
                writer.writeLeafElement(prefix + ":idx", fun(i));
            }
        }
    });
};
chart2016Write.WriteCT_SeriesLayoutProperties = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (!common_1._isNullOrUndefined(instance.parentLabelLayout)) {
            chart2016Write.WriteCT_ParentLabelLayout(writer, prefix, "parentLabelLayout", "", instance.parentLabelLayout);
        }
        if (!common_1._isNullOrUndefined(instance.regionLabelLayout)) {
            chart2016Write.WriteCT_RegionLabelLayout(writer, prefix, "regionLabelLayout", "", instance.regionLabelLayout);
        }
        if (!common_1._isNullOrUndefined(instance.visibility)) {
            chart2016Write.WriteCT_SeriesElementVisibilities(writer, prefix, "visibility", "", instance.visibility);
        }
        if (!common_1._isNullOrUndefined(instance.geography)) {
            chart2016Write.WriteCT_Geography(writer, prefix, "geography", "", instance.geography);
        }
        if (!common_1._isNullOrUndefined(instance.statistics)) {
            chart2016Write.WriteCT_Statistics(writer, prefix, "statistics", "", instance.statistics);
        }
        if (!common_1._isNullOrUndefined(instance.aggregation)) {
            chart2016Write.WriteCT_Aggregation(writer, prefix, "aggregation");
        }
        if (!common_1._isNullOrUndefined(instance.binning)) {
            chart2016Write.WriteCT_Binning(writer, prefix, "binning", "", instance.binning);
        }
        if (!common_1._isNullOrUndefined(instance.subtotals)) {
            chart2016Write.WriteCT_Subtotals(writer, prefix, "subtotals", "", instance.subtotals);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_DataPoint = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("idx", instance.idx.toString());
    }, function () {
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, "cx", "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_ExtremeValueColorPosition = function (writer, prefix, localName) {
    writer.writeLeafElement(prefix + ":" + localName, null);
};
chart2016Write.WriteCT_NumberColorPosition = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("val", instance.val.toString());
    });
};
chart2016Write.WriteCT_PercentageColorPosition = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("val", instance.val.toString());
    });
};
chart2016Write.WriteCT_ValueColorEndPosition = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.extremeValue)) {
            chart2016Write.WriteCT_ExtremeValueColorPosition(writer, prefix, "extremeValue");
        }
        if (!common_1._isNullOrUndefined(instance.number)) {
            chart2016Write.WriteCT_NumberColorPosition(writer, prefix, "number", "", instance.number);
        }
        if (!common_1._isNullOrUndefined(instance.percent)) {
            chart2016Write.WriteCT_PercentageColorPosition(writer, prefix, "percent", "", instance.percent);
        }
    });
};
chart2016Write.WriteCT_ValueColorMiddlePosition = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.number)) {
            chart2016Write.WriteCT_NumberColorPosition(writer, prefix, "number", "", instance.number);
        }
        if (!common_1._isNullOrUndefined(instance.percent)) {
            chart2016Write.WriteCT_PercentageColorPosition(writer, prefix, "percent", "", instance.percent);
        }
    });
};
chart2016Write.WriteCT_ValueColorPositions = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (instance.count !== 2) {
            writer.writeAttributeString("count", instance.count.toString());
        }
    }, function () {
        if (common_1._isNullOrUndefined(instance.min)) {
            chart2016Write.WriteCT_ValueColorEndPosition(writer, prefix, "min", "", instance.min);
        }
        if (common_1._isNullOrUndefined(instance.mid)) {
            chart2016Write.WriteCT_ValueColorMiddlePosition(writer, prefix, "mid", "", instance.mid);
        }
        if (common_1._isNullOrUndefined(instance.max)) {
            chart2016Write.WriteCT_ValueColorEndPosition(writer, prefix, "max", "", instance.max);
        }
    });
};
chart2016Write.WriteCT_DataLabelVisibilities = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("seriesName", instance.seriesName ? "1" : "0");
        writer.writeAttributeString("categoryName", instance.categoryName ? "1" : "0");
        writer.writeAttributeString("value", instance.value ? "1" : "0");
    });
};
chart2016Write.WriteCT_DataLabel = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("idx", instance.idx.toString());
        writer.writeAttributeString("pos", chart_model_1.Charts.ST_DataLabelPos[instance.pos]);
    }, function () {
        if (!common_1._isNullOrUndefined(instance.numFmt)) {
            chart2016Write.WriteCT_NumberFormat(writer, prefix, "numFmt", "", instance.numFmt);
        }
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, "cx", "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.txPr)) {
            WriteCT_TextBody(writer, prefix, "txPr", instance.txPr);
        }
        if (!common_1._isNullOrUndefined(instance.visibility)) {
            chart2016Write.WriteCT_DataLabelVisibilities(writer, prefix, "visibility", "", instance.visibility);
        }
        if (!common_1._isNullOrUndefined(instance.separator)) {
            writer.writeElementString(prefix + ":separator", instance.separator.toString());
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_DataLabelHidden = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("idx", instance.idx.toString());
    });
};
chart2016Write.WriteCT_DataLabels = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.pos)) {
            writer.writeAttributeString("pos", chart_model_1.Charts.ST_DataLabelPos[instance.pos]);
        }
    }, function () {
        var i;
        if (!common_1._isNullOrUndefined(instance.numFmt)) {
            chart2016Write.WriteCT_NumberFormat(writer, prefix, "numFmt", "", instance.numFmt);
        }
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, prefix, "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.txPr)) {
            WriteCT_TextBody(writer, prefix, "txPr", instance.txPr);
        }
        if (!common_1._isNullOrUndefined(instance.visibility)) {
            chart2016Write.WriteCT_DataLabelVisibilities(writer, prefix, "visibility", "", instance.visibility);
        }
        if (!common_1._isNullOrUndefined(instance.separator)) {
            writer.writeElementString(prefix + ":separator", instance.separator.toString());
        }
        if (!common_1._isNullOrUndefined(instance.dataLabel)) {
            for (i = 0; i < instance.dataLabel.length; i++) {
                if (!common_1._isNullOrUndefined(instance.dataLabel[i])) {
                    chart2016Write.WriteCT_DataLabel(writer, prefix, "dataLabel", "", instance.dataLabel[i]);
                }
            }
        }
        if (!common_1._isNullOrUndefined(instance.dataLabelHidden)) {
            for (i = 0; i < instance.dataLabelHidden.length; i++) {
                if (!common_1._isNullOrUndefined(instance.dataLabelHidden[i])) {
                    chart2016Write.WriteCT_DataLabelHidden(writer, prefix, "dataLabelHidden", "", instance.dataLabelHidden[i]);
                }
            }
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_Series = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("layoutId", chart_model_1.Charts.ST_SeriesLayout[chart_helper_1.ChartHelper.ToST_SeriesLayout(instance.layoutId)]);
        if (instance.hidden !== false && instance.hidden !== undefined) {
            writer.writeAttributeString("hidden", instance.hidden ? "1" : "0");
        }
        if (!common_1._isNullOrUndefined(instance.ownerIdx)) {
            writer.writeAttributeString("ownerIdx", instance.ownerIdx.toString());
        }
        if (!common_1._isNullOrUndefined(instance.uniqueId)) {
            writer.writeAttributeString("uniqueId", instance.uniqueId.toString());
        }
        if (!common_1._isNullOrUndefined(instance.formatIdx)) {
            writer.writeAttributeString("formatIdx", instance.formatIdx.toString());
        }
    }, function () {
        var i;
        if (!common_1._isNullOrUndefined(instance.tx)) {
            chart2016Write.WriteCT_Text(writer, prefix, "tx", "", instance.tx);
        }
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, prefix, "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.valueColors)) {
            chart2016Write.WriteCT_ValueColors(writer, prefix, "valueColors", "", instance.valueColors);
        }
        if (!common_1._isNullOrUndefined(instance.valueColorPositions)) {
            chart2016Write.WriteCT_ValueColorPositions(writer, prefix, "valueColorPositions", "", instance.valueColorPositions);
        }
        if (instance.dataPt && instance.dataPt.length > 0) {
            for (i = 0; i < instance.dataPt.length; i++) {
                if (!common_1._isNullOrUndefined(instance.dataPt[i])) {
                    chart2016Write.WriteCT_DataPoint(writer, prefix, "dataPt", "", instance.dataPt[i]);
                }
            }
        }
        if (!common_1._isNullOrUndefined(instance.dataLabels)) {
            chart2016Write.WriteCT_DataLabels(writer, prefix, "dataLabels", "", instance.dataLabels);
        }
        if (!common_1._isNullOrUndefined(instance.dataId)) {
            chart2016Write.WriteCT_DataId(writer, prefix, "dataId", "", instance.dataId);
        }
        if (!common_1._isNullOrUndefined(instance.layoutPr)) {
            chart2016Write.WriteCT_SeriesLayoutProperties(writer, prefix, "layoutPr", "", instance.layoutPr);
        }
        if (instance.axisId && instance.axisId.length > 0) {
            for (i = 0; i < instance.axisId.length; i++) {
                if (!common_1._isNullOrUndefined(instance.axisId[i])) {
                    chart2016Write.WriteST_AxisId(writer, prefix, "axisId", "", instance.axisId[i]);
                }
            }
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_Legend = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.legendPos)
            && instance.legendPos === 5) {
            writer.writeAttributeString("pos", chart_model_1.Charts.ST_2016ChartPosLegend[chart_model_1.Charts.ST_2016ChartPosLegend.r]);
            writer.writeAttributeString("align", chart_model_1.Charts.ST_PosAlign[chart_model_1.Charts.ST_PosAlign.min]);
        }
        else {
            if (!common_1._isNullOrUndefined(instance.legendPos)) {
                writer.writeAttributeString("pos", chart_model_1.Charts.ST_2016ChartPosLegend[instance.legendPos]);
            }
            if (!common_1._isNullOrUndefined(instance.align)) {
                writer.writeAttributeString("align", chart_model_1.Charts.ST_PosAlign[instance.align]);
            }
        }
        if (!common_1._isNullOrUndefined(instance.overlay)) {
            writer.writeAttributeString("overlay", instance.overlay ? "1" : "0");
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, prefix, "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.txPr)) {
            WriteCT_TextBody(writer, prefix, "txPr", instance.txPr);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_PlotSurface = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, prefix, "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_PlotAreaRegion = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        var i;
        if (!common_1._isNullOrUndefined(instance.plotSurface)) {
            chart2016Write.WriteCT_PlotSurface(writer, prefix, "plotSurface", "", instance.plotSurface);
        }
        for (i = 0; i < instance.series.length; i++) {
            if (!common_1._isNullOrUndefined(instance.series[i])) {
                chart2016Write.WriteCT_Series(writer, prefix, "series", "", instance.series[i]);
            }
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_PlotArea = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        var i;
        if (!common_1._isNullOrUndefined(instance.plotAreaRegion)) {
            chart2016Write.WriteCT_PlotAreaRegion(writer, prefix, "plotAreaRegion", "", instance.plotAreaRegion);
        }
        if (!common_1._isNullOrUndefined(instance.axes)) {
            for (i = 0; i < instance.axes.length; i++) {
                if (!common_1._isNullOrUndefined(instance.axes[i])) {
                    chart2016Write.WriteCT_Axis(writer, prefix, "axis", "", instance.axes[i]);
                }
            }
        }
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, prefix, "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_Chart = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (!common_1._isNullOrUndefined(instance.title)) {
            chart2016Write.WriteCT_ChartTitle(writer, prefix, "title", "", instance.title);
        }
        if (!common_1._isNullOrUndefined(instance.plotArea)) {
            chart2016Write.WriteCT_PlotArea(writer, prefix, "plotArea", "", instance.plotArea);
        }
        if (!common_1._isNullOrUndefined(instance.legend)) {
            chart2016Write.WriteCT_Legend(writer, prefix, "legend", "", instance.legend);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_FormatOverride = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("idx", instance.idx.toString());
    }, function () {
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, prefix, "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.WriteCT_FormatOverrides = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        for (var i = 0; i < instance.fmtOvr.length; i++) {
            if (!common_1._isNullOrUndefined(instance.fmtOvr[i])) {
                chart2016Write.WriteCT_FormatOverride(writer, prefix, "fmtOvr", "", instance.fmtOvr[i]);
            }
        }
    });
};
chart2016Write.WriteCT_HeaderFooter = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("alignWithMargins", instance.alignWithMargins ? "1" : "0");
        writer.writeAttributeString("differentOddEven", instance.differentOddEven ? "1" : "0");
        writer.writeAttributeString("differentFirst", instance.differentFirst ? "1" : "0");
    }, function () {
        if (!common_1._isNullOrUndefined(instance.oddHeader)) {
            writer.writeElementString(prefix + ":oddHeader", instance.oddHeader.toString());
        }
        if (!common_1._isNullOrUndefined(instance.oddFooter)) {
            writer.writeElementString(prefix + ":oddFooter", instance.oddFooter.toString());
        }
        if (!common_1._isNullOrUndefined(instance.evenHeader)) {
            writer.writeElementString(prefix + ":evenHeader", instance.evenHeader.toString());
        }
        if (!common_1._isNullOrUndefined(instance.evenFooter)) {
            writer.writeElementString(prefix + ":evenFooter", instance.evenFooter.toString());
        }
        if (!common_1._isNullOrUndefined(instance.firstHeader)) {
            writer.writeElementString(prefix + ":firstHeader", instance.firstHeader.toString());
        }
        if (!common_1._isNullOrUndefined(instance.firstFooter)) {
            writer.writeElementString(prefix + ":firstFooter", instance.firstFooter.toString());
        }
    });
};
chart2016Write.WriteCT_PageMargins = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("l", instance.l.toString());
        writer.writeAttributeString("r", instance.r.toString());
        writer.writeAttributeString("t", instance.t.toString());
        writer.writeAttributeString("b", instance.b.toString());
        writer.writeAttributeString("header", instance.header.toString());
        writer.writeAttributeString("footer", instance.footer.toString());
    });
};
chart2016Write.WriteCT_PageSetup = function (writer, prefix, localName, ns, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("paperSize", instance.paperSize.toString());
        writer.writeAttributeString("firstPageNumber", instance.firstPageNumber.toString());
        writer.writeAttributeString("orientation", chart_model_1.Charts.ST_PageOrientation[instance.orientation]);
        writer.writeAttributeString("blackAndWhite", instance.blackAndWhite ? "1" : "0");
        writer.writeAttributeString("draft", instance.draft ? "1" : "0");
        writer.writeAttributeString("useFirstPageNumber", instance.useFirstPageNumber ? "1" : "0");
        writer.writeAttributeString("horizontalDpi", instance.horizontalDpi.toString());
        writer.writeAttributeString("verticalDpi", instance.verticalDpi.toString());
        writer.writeAttributeString("copies", instance.copies.toString());
    });
};
chart2016Write.WriteCT_PrintSettings = function (writer, prefix, localName, ns, instance) {
    writer.writeElement(prefix + ":" + localName, null, function () {
        if (!common_1._isNullOrUndefined(instance.headerFooter)) {
            chart2016Write.WriteCT_HeaderFooter(writer, prefix, "headerFooter", "", instance.headerFooter);
        }
        if (!common_1._isNullOrUndefined(instance.pageMargins)) {
            chart2016Write.WriteCT_PageMargins(writer, prefix, "pageMargins", "", instance.pageMargins);
        }
        if (!common_1._isNullOrUndefined(instance.pageSetup)) {
            chart2016Write.WriteCT_PageSetup(writer, prefix, "pageSetup", "", instance.pageSetup);
        }
    });
};
chart2016Write.WriteCT_ChartSpace = function (writer, prefix, localName, instance, drawingInfoNames, outDefindNames) {
    var series = instance.chart && instance.chart.plotArea && instance.chart.plotArea.plotAreaRegion && instance.chart.plotArea.plotAreaRegion.series;
    var outChartData = [];
    if (series && series.length > 0) {
        instance.chart.plotArea.plotAreaRegion.series = chart2016Write.TranstateSeriesDataToId(series, drawingInfoNames, outDefindNames, outChartData);
    }
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("xmlns:a", exports.DrawingWriter.a);
        writer.writeAttributeString("xmlns:r", exports.DrawingWriter.r);
        writer.writeAttributeString("xmlns:cx", chart2016Write.cx);
    }, function () {
        var chartData = instance.chartData || {};
        chartData.data = outChartData;
        if (!common_1._isNullOrUndefined(chartData)) {
            chart2016Write.WriteCT_ChartData(writer, prefix, "chartData", "", chartData);
        }
        if (!common_1._isNullOrUndefined(instance.chart)) {
            chart2016Write.WriteCT_Chart(writer, prefix, "chart", "", instance.chart);
        }
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, prefix, "spPr", instance.spPr);
        }
        if (!common_1._isNullOrUndefined(instance.txPr)) {
            WriteCT_TextBody(writer, prefix, "txPr", instance.txPr);
        }
        if (!common_1._isNullOrUndefined(instance.clrMapOvr)) {
            WriteCT_ColorMapping(writer, prefix, "clrMapOvr", instance.clrMapOvr);
        }
        if (!common_1._isNullOrUndefined(instance.fmtOvrs)) {
            chart2016Write.WriteCT_FormatOverrides(writer, prefix, "fmtOvrs", "", instance.fmtOvrs);
        }
        if (!common_1._isNullOrUndefined(instance.printSettings)) {
            chart2016Write.WriteCT_PrintSettings(writer, prefix, "printSettings", "", instance.printSettings);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            chart2016Write.WriteCT_ExtensionList(writer, prefix, "extLst", "", instance.extLst);
        }
    });
};
chart2016Write.TranstateSeriesDataToId = function (series, drawingInfoDataNames, outDefindNames, outChartData) {
    var nameSpaceObj = chart2016Write.TranslateNameSpace(drawingInfoDataNames);
    for (var i = 0; i < series.length; i++) {
        var seriesItem = series[i];
        var txDataFormula = seriesItem.tx && seriesItem.tx.txData && seriesItem.tx.txData.f && seriesItem.tx.txData.f.formula;
        if (txDataFormula) {
            var sheetFormula = nameSpaceObj[txDataFormula];
            if (sheetFormula) {
                seriesItem.tx.txData.f.formula = sheetFormula;
            }
        }
        var formulaObj = seriesItem.formulaObj || {}, name_1 = void 0, chartDataItem = {}, beforeName = void 0;
        if (formulaObj.numDim || formulaObj.strDim) {
            seriesItem.dataId = { val: i };
        }
        if (formulaObj.numDim) {
            beforeName = outDefindNames.length > 0 ? outDefindNames[outDefindNames.length - 1].name : null;
            name_1 = this.CreateNameByLastName(beforeName);
            outDefindNames.push({ name: name_1, formula: formulaObj.numDim, hidden: true });
            chartDataItem.id = i;
            chartDataItem.numDim = [];
            if (series[0] && series[0].layoutId === 17) {
                chartDataItem.numDim.push({
                    type: chart_model_1.Charts.ST_NumericDimensionType.val,
                    f: {
                        formula: name_1
                    }
                });
            }
            else {
                chartDataItem.numDim.push({
                    type: chart_model_1.Charts.ST_NumericDimensionType.size,
                    f: {
                        formula: name_1
                    }
                });
            }
        }
        if (formulaObj.strDim) {
            beforeName = outDefindNames.length > 0 ? outDefindNames[outDefindNames.length - 1].name : null;
            name_1 = this.CreateNameByLastName(beforeName);
            outDefindNames.push({ name: name_1, formula: formulaObj.strDim, hidden: true });
            chartDataItem.id = chartDataItem.id || i;
            chartDataItem.strDim = [];
            chartDataItem.strDim.push({
                type: chart_model_1.Charts.ST_StringDimensionType.cat,
                f: {
                    formula: name_1
                }
            });
        }
        if (!common_1._isNullOrUndefined(chartDataItem.id)) {
            outChartData.push(chartDataItem);
        }
    }
    return series;
};
chart2016Write.CreateNameByLastName = function (lastName) {
    if (!lastName) {
        lastName = '0';
    }
    lastName = lastName.replace(CONST_CHART_DEFINED_NAME, '');
    var num = parseInt(lastName, 10) + 1;
    return CONST_CHART_DEFINED_NAME + num;
};
chart2016Write.TranslateNameSpace = function (drawingInfoDataNames) {
    var nameSpaceObj = {};
    for (var i = 0; i < drawingInfoDataNames.length; i++) {
        var name_2 = drawingInfoDataNames[i].name, formula = drawingInfoDataNames[i].formula;
        nameSpaceObj[formula] = name_2;
    }
    return nameSpaceObj;
};
chart2016Write.cx = "http://schemas.microsoft.com/office/drawing/2014/chartex";
exports.DrawingWriter.chart2016Write = chart2016Write;
function WriteCT_ColorScheme(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.name)) {
            writer.writeAttributeString(CONST_NAME, instance.name);
        }
    }, function () {
        var dk1 = instance.dk1, lt1 = instance.lt1, dk2 = instance.dk2, lt2 = instance.lt2, accent1 = instance.accent1, accent2 = instance.accent2, accent3 = instance.accent3, accent4 = instance.accent4, accent5 = instance.accent5, accent6 = instance.accent6, hlink = instance.hlink, folHlink = instance.folHlink, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(dk1)) {
            WriteCT_Color(writer, CONST_A, "dk1", dk1);
        }
        if (!common_1._isNullOrUndefined(lt1)) {
            WriteCT_Color(writer, CONST_A, "lt1", lt1);
        }
        if (!common_1._isNullOrUndefined(dk2)) {
            WriteCT_Color(writer, CONST_A, "dk2", dk2);
        }
        if (!common_1._isNullOrUndefined(lt2)) {
            WriteCT_Color(writer, CONST_A, "lt2", lt2);
        }
        if (!common_1._isNullOrUndefined(accent1)) {
            WriteCT_Color(writer, CONST_A, "accent1", accent1);
        }
        if (!common_1._isNullOrUndefined(accent2)) {
            WriteCT_Color(writer, CONST_A, "accent2", accent2);
        }
        if (!common_1._isNullOrUndefined(accent3)) {
            WriteCT_Color(writer, CONST_A, "accent3", accent3);
        }
        if (!common_1._isNullOrUndefined(accent4)) {
            WriteCT_Color(writer, CONST_A, "accent4", accent4);
        }
        if (!common_1._isNullOrUndefined(accent5)) {
            WriteCT_Color(writer, CONST_A, "accent5", accent5);
        }
        if (!common_1._isNullOrUndefined(accent6)) {
            WriteCT_Color(writer, CONST_A, "accent6", accent6);
        }
        if (!common_1._isNullOrUndefined(hlink)) {
            WriteCT_Color(writer, CONST_A, "hlink", hlink);
        }
        if (!common_1._isNullOrUndefined(folHlink)) {
            WriteCT_Color(writer, CONST_A, "folHlink", folHlink);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_ColorScheme = WriteCT_ColorScheme;
function WriteCT_CustomColor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!isNullOrUndefinedOrEmpty(instance.name)) {
            writer.writeAttributeString(CONST_NAME, instance.name);
        }
    }, function () {
        writeSubColorElements(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_CustomColor = WriteCT_CustomColor;
function WriteCT_SupplementalFont(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var script = instance.script, typeface = instance.typeface;
        if (!common_1._isNullOrUndefined(script)) {
            writer.writeAttributeString("script", script);
        }
        if (!common_1._isNullOrUndefined(typeface)) {
            writer.writeAttributeString("typeface", typeface);
        }
    });
}
exports.DrawingWriter.WriteCT_SupplementalFont = WriteCT_SupplementalFont;
function WriteCT_CustomColorList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.custClr, function (custClrItem) {
            WriteCT_CustomColor(writer, CONST_A, "custClr", custClrItem);
        });
    });
}
exports.DrawingWriter.WriteCT_CustomColorList = WriteCT_CustomColorList;
function WriteCT_FontCollection(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var latin = instance.latin, ea = instance.ea, cs = instance.cs, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(latin)) {
            WriteCT_TextFont(writer, CONST_A, "latin", latin);
        }
        if (!common_1._isNullOrUndefined(ea)) {
            WriteCT_TextFont(writer, CONST_A, "ea", ea);
        }
        if (!common_1._isNullOrUndefined(cs)) {
            WriteCT_TextFont(writer, CONST_A, "cs", cs);
        }
        writeArrayItem(instance.font, function (fontItem) {
            WriteCT_SupplementalFont(writer, CONST_A, "font", fontItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_FontCollection = WriteCT_FontCollection;
function WriteCT_EffectStyleItem(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var effectLst = instance.effectLst, effectDag = instance.effectDag, scene3d = instance.scene3d, sp3d = instance.sp3d;
        if (!common_1._isNullOrUndefined(effectLst)) {
            WriteCT_EffectList(writer, CONST_A, CONST_EFFECTLST, effectLst);
        }
        if (!common_1._isNullOrUndefined(effectDag)) {
            WriteCT_EffectContainer(writer, CONST_A, CONST_EFFECT_DAG, effectDag);
        }
        if (!common_1._isNullOrUndefined(scene3d)) {
            WriteCT_Scene3D(writer, CONST_A, CONST_SCENE_3D, scene3d);
        }
        if (!common_1._isNullOrUndefined(sp3d)) {
            WriteCT_Shape3D(writer, CONST_A, "sp3d", sp3d);
        }
    });
}
exports.DrawingWriter.WriteCT_EffectStyleItem = WriteCT_EffectStyleItem;
function WriteCT_FontScheme(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.name)) {
            writer.writeAttributeString(CONST_NAME, instance.name);
        }
    }, function () {
        var majorFont = instance.majorFont, minorFont = instance.minorFont, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(majorFont)) {
            WriteCT_FontCollection(writer, CONST_A, "majorFont", majorFont);
        }
        if (!common_1._isNullOrUndefined(minorFont)) {
            WriteCT_FontCollection(writer, CONST_A, "minorFont", minorFont);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_FontScheme = WriteCT_FontScheme;
function WriteCT_FillStyleList(writer, prefix, localName, instance) {
    writeFillPropertiesFromArray(writer, prefix, localName, instance);
}
exports.DrawingWriter.WriteCT_FillStyleList = WriteCT_FillStyleList;
function WriteCT_LineStyleList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.ln, function (lnItem) {
            WriteCT_LineProperties(writer, CONST_A, "ln", lnItem);
        });
    });
}
exports.DrawingWriter.WriteCT_LineStyleList = WriteCT_LineStyleList;
function WriteCT_EffectStyleList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.effectStyle, function (effectStyleItem) {
            WriteCT_EffectStyleItem(writer, CONST_A, "effectStyle", effectStyleItem);
        });
    });
}
exports.DrawingWriter.WriteCT_EffectStyleList = WriteCT_EffectStyleList;
function WriteCT_BackgroundFillStyleList(writer, prefix, localName, instance) {
    writeFillPropertiesFromArray(writer, prefix, localName, instance);
}
exports.DrawingWriter.WriteCT_BackgroundFillStyleList = WriteCT_BackgroundFillStyleList;
function WriteCT_StyleMatrix(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!isNullOrUndefinedOrEmpty(instance.name)) {
            writer.writeAttributeString(CONST_NAME, instance.name);
        }
    }, function () {
        var fillStyleLst = instance.fillStyleLst, lnStyleLst = instance.lnStyleLst, effectStyleLst = instance.effectStyleLst, bgFillStyleLst = instance.bgFillStyleLst;
        if (!common_1._isNullOrUndefined(fillStyleLst)) {
            WriteCT_FillStyleList(writer, CONST_A, "fillStyleLst", fillStyleLst);
        }
        if (!common_1._isNullOrUndefined(lnStyleLst)) {
            WriteCT_LineStyleList(writer, CONST_A, "lnStyleLst", lnStyleLst);
        }
        if (!common_1._isNullOrUndefined(effectStyleLst)) {
            WriteCT_EffectStyleList(writer, CONST_A, "effectStyleLst", effectStyleLst);
        }
        if (!common_1._isNullOrUndefined(bgFillStyleLst)) {
            WriteCT_BackgroundFillStyleList(writer, CONST_A, "bgFillStyleLst", bgFillStyleLst);
        }
    });
}
exports.DrawingWriter.WriteCT_StyleMatrix = WriteCT_StyleMatrix;
function WriteCT_BaseStyles(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var clrScheme = instance.clrScheme, fontScheme = instance.fontScheme, fmtScheme = instance.fmtScheme, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(clrScheme)) {
            WriteCT_ColorScheme(writer, CONST_A, CONST_CLR_SCHEME, clrScheme);
        }
        if (!common_1._isNullOrUndefined(fontScheme)) {
            WriteCT_FontScheme(writer, CONST_A, CONST_FONT_SCHEME, fontScheme);
        }
        if (!common_1._isNullOrUndefined(fmtScheme)) {
            WriteCT_StyleMatrix(writer, CONST_A, CONST_FMT_SCHEME, fmtScheme);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_BaseStyles = WriteCT_BaseStyles;
function ConvertArrayNumberToString(value) {
    return value.map(function (n) {
        return ("00" + n.toString(16)).substr(-2);
    }).join('');
}
function WriteCT_OfficeArtExtension(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.uri)) {
            writer.writeAttributeString("uri", instance.uri);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.dataObject)) {
            writer.writeValue(instance.dataObject);
        }
        if (instance.hiddenExtensionType === 0) {
            WriteCT_Scene3D(writer, COSNT_A14, "hiddenScene3d", instance.Scene3d);
        }
        if (instance.hiddenExtensionType === 3) {
            WriteCT_Shape3D(writer, COSNT_A14, "hiddenSp3d", instance.Shape3d);
        }
        if (instance.hiddenExtensionType === 1) {
            WriteCT_FillProperties(writer, COSNT_A14, "hiddenFill", instance.Fill);
        }
        if (instance.hiddenExtensionType === 2) {
            WriteCT_LineProperties(writer, COSNT_A14, "hiddenLine", instance.Line);
        }
        if (instance.hiddenExtensionType === 5) {
            WriteCT_SvgBlipProperties(writer, instance.svgBlip);
        }
        if (!common_1._isNullOrUndefined(instance.creationId) && instance.creationId.length > 0) {
            for (var i = 0; i < instance.creationId.length; i++) {
                WriteCT_creationId(writer, 'a16', 'creationId', instance.creationId[i]);
            }
        }
        if (!common_1._isNullOrUndefined(instance.cameraTool)) {
            WriteCT_cameraTool(writer, COSNT_A14, 'cameraTool', instance.cameraTool);
        }
    });
}
exports.DrawingWriter.WriteCT_OfficeArtExtension = WriteCT_OfficeArtExtension;
function WriteCT_cameraTool(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.cellRange)) {
            writer.writeAttributeString("cellRange", instance.cellRange);
        }
        if (!common_1._isNullOrUndefined(instance.spid)) {
            writer.writeAttributeString("spid", "_x0000_s10" + instance.spid);
        }
    });
}
exports.DrawingWriter.WriteCT_cameraTool = WriteCT_cameraTool;
function WriteCT_creationId(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.name)) {
            writer.writeAttributeString("xmlns:a16", instance.name.toString());
        }
        if (!common_1._isNullOrUndefined(instance.id)) {
            writer.writeAttributeString("id", instance.id.toString());
        }
    });
}
exports.DrawingWriter.WriteCT_creationId = WriteCT_creationId;
function WriteCT_Angle(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_Angle = WriteCT_Angle;
function WriteCT_PositiveFixedAngle(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_PositiveFixedAngle = WriteCT_PositiveFixedAngle;
function WriteCT_Percentage(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_Percentage = WriteCT_Percentage;
function WriteCT_PositivePercentage(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_PositivePercentage = WriteCT_PositivePercentage;
function WriteCT_FixedPercentage(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_FixedPercentage = WriteCT_FixedPercentage;
function WriteCT_PositiveFixedPercentage(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var value = instance;
        if (!common_1._isNullOrUndefined(value)) {
            var s = "" + value, pos = s.indexOf(".");
            if (pos !== -1 && (s.length > pos + 3)) {
                s = numberToFixedString(value);
            }
            writer.writeAttributeString(CONST_VAL, s);
        }
    });
}
function numberToFixedString(value) {
    var s = value.toFixed(2), digits = s.substr(-2);
    if (digits[1] === "0") {
        var n = 1;
        if (digits[0] === "0") {
            n = 3;
        }
        s = s.substr(0, s.length - n);
    }
    return s;
}
exports.DrawingWriter.WriteCT_PositiveFixedPercentage = WriteCT_PositiveFixedPercentage;
function WriteCT_Ratio(writer, prefix, localName, instance) {
    writeDoubleSubElementNode(writer, prefix, localName, instance, "n", "d");
}
exports.DrawingWriter.WriteCT_Ratio = WriteCT_Ratio;
function WriteCT_Point2D(writer, prefix, localName, instance, needPixel) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (common_1._isNullOrUndefined(needPixel)) {
            needPixel = true;
        }
        var xValue = instance.x, yValue = instance.y;
        if (!common_1._isNullOrUndefined(xValue)) {
            if (needPixel) {
                xValue = pixelToEMU(xValue);
            }
            writer.writeAttributeString('x', xValue);
        }
        if (!common_1._isNullOrUndefined(yValue)) {
            if (needPixel) {
                yValue = pixelToEMU(yValue);
            }
            writer.writeAttributeString('y', yValue);
        }
    });
}
exports.DrawingWriter.WriteCT_Point2D = WriteCT_Point2D;
function WriteCT_PositiveSize2D(writer, prefix, localName, instance, needPixel) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (common_1._isNullOrUndefined(needPixel)) {
            needPixel = true;
        }
        var cxValue = instance.cx, cyValue = instance.cy;
        if (!common_1._isNullOrUndefined(cxValue)) {
            if (needPixel) {
                cxValue = pixelToEMU(cxValue);
            }
            writer.writeAttributeString('cx', cxValue);
        }
        if (!common_1._isNullOrUndefined(cyValue)) {
            if (needPixel) {
                cyValue = pixelToEMU(cyValue);
            }
            writer.writeAttributeString('cy', cyValue);
        }
    });
}
exports.DrawingWriter.WriteCT_PositiveSize2D = WriteCT_PositiveSize2D;
function WriteCT_ComplementTransform(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_ComplementTransform = WriteCT_ComplementTransform;
function WriteCT_InverseTransform(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_InverseTransform = WriteCT_InverseTransform;
function WriteCT_GrayscaleTransform(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_GrayscaleTransform = WriteCT_GrayscaleTransform;
function WriteCT_GammaTransform(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_GammaTransform = WriteCT_GammaTransform;
function WriteCT_InverseGammaTransform(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_InverseGammaTransform = WriteCT_InverseGammaTransform;
function WriteCT_ScRgbColor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.r)) {
            writer.writeAttributeString(CONST_R, instance.r);
        }
        if (!common_1._isNullOrUndefined(instance.g)) {
            writer.writeAttributeString("g", instance.g);
        }
        if (!common_1._isNullOrUndefined(instance.b)) {
            writer.writeAttributeString("b", instance.b);
        }
    }, function () {
        writeColorSubElement(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_ScRgbColor = WriteCT_ScRgbColor;
function WriteCT_SRgbColor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var val = instance.val;
        if (!common_1._isNullOrUndefined(val)) {
            var tempValue = typeof val === 'string' ? val : ConvertArrayNumberToString(val);
            writer.writeAttributeString(CONST_VAL, tempValue);
        }
    }, function () {
        writeColorSubElement(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_SRgbColor = WriteCT_SRgbColor;
function WriteCT_HslColor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.hue1)) {
            writer.writeAttributeString("hue", instance.hue1);
        }
        if (!common_1._isNullOrUndefined(instance.sat1)) {
            writer.writeAttributeString("sat", instance.sat1);
        }
        if (!common_1._isNullOrUndefined(instance.lum1)) {
            writer.writeAttributeString("lum", instance.lum1);
        }
    }, function () {
        writeColorSubElement(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_HslColor = WriteCT_HslColor;
function WriteCT_SystemColor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.val)) {
            writer.writeAttributeString(CONST_VAL, chart_model_1.Charts.ST_SystemColorVal[chart_helper_1.ChartHelper.ToST_SystemColorVal(instance.val)]);
        }
        if (!common_1._isNullOrUndefined(instance.lastClr)) {
            writer.writeAttributeString("lastClr", ConvertArrayNumberToString(instance.lastClr));
        }
    }, function () {
        writeColorSubElement(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_SystemColor = WriteCT_SystemColor;
function WriteCT_SchemeColor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.val)) {
            writer.writeAttributeString(CONST_VAL, chart_model_1.Charts.ST_SchemeColorVal[chart_helper_1.ChartHelper.ToST_SchemeColorVal(instance.val)]);
        }
    }, function () {
        writeColorSubElement(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_SchemeColor = WriteCT_SchemeColor;
function WriteCT_PresetColor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.val)) {
            writer.writeAttributeString(CONST_VAL, chart_model_1.Charts.ST_PresetColorVal[instance.val]);
        }
    }, function () {
        writeColorSubElement(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_PresetColor = WriteCT_PresetColor;
function WriteCT_StyleColor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.val)) {
            writer.writeAttributeString(CONST_VAL, chart_model_1.Charts.ST_StyleColorVal[instance.val]);
        }
    }, function () {
        writeColorSubElement(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_StyleColor = WriteCT_StyleColor;
function WriteCT_OfficeArtExtensionList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.ext, function (extItem) {
            if (common_1._isNullOrUndefined(extItem.uri)) {
                extItem.uri = '{96DAC541-7B7A-43D3-8B79-37D633B846F1}';
            }
            if (!common_1._isNullOrUndefined(extItem.cameraTool)) {
                extItem.uri = '{84589F7E-364E-4C9E-8A38-B11213B215E9}';
            }
            WriteCT_OfficeArtExtension(writer, CONST_A, CONST_EXT, extItem);
        });
    });
}
exports.DrawingWriter.WriteCT_OfficeArtExtensionList = WriteCT_OfficeArtExtensionList;
function WriteCT_Scale2D(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.sx)) {
            WriteCT_Ratio(writer, CONST_A, "sx", instance.sx);
        }
        if (!common_1._isNullOrUndefined(instance.sy)) {
            WriteCT_Ratio(writer, CONST_A, "sy", instance.sy);
        }
    });
}
exports.DrawingWriter.WriteCT_Scale2D = WriteCT_Scale2D;
function WriteCT_Transform2D(writer, prefix, localName, instance, isGraphicFrame) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!isGraphicFrame) {
            var rot = instance.rot;
            if (!common_1._isNullOrUndefined(rot) && rot !== 0) {
                writer.writeAttributeString("rot", parseInt(rot, 10));
            }
            if (instance.flipH === true) {
                writer.writeAttributeString("flipH", "1");
            }
            if (instance.flipV === true) {
                writer.writeAttributeString("flipV", "1");
            }
        }
    }, function () {
        if (isGraphicFrame) {
            WriteCT_Point2D(writer, CONST_A, "off", { x: 0, y: 0 }, true);
            WriteCT_PositiveSize2D(writer, CONST_A, CONST_EXT, { cx: 0, cy: 0 }, true);
        }
        else {
            var off = instance.off;
            if (!common_1._isNullOrUndefined(off)) {
                if (common_1._isNullOrUndefined(off.x)) {
                    off.x = 0;
                }
                if (common_1._isNullOrUndefined(off.y)) {
                    off.y = 0;
                }
                WriteCT_Point2D(writer, CONST_A, "off", off, true);
            }
            var ext = instance.ext;
            if (!common_1._isNullOrUndefined(ext)) {
                if (common_1._isNullOrUndefined(ext.cx)) {
                    ext.cx = 0;
                }
                if (common_1._isNullOrUndefined(ext.cy)) {
                    ext.cy = 0;
                }
                WriteCT_PositiveSize2D(writer, CONST_A, CONST_EXT, ext, true);
            }
        }
    });
}
exports.DrawingWriter.WriteCT_Transform2D = WriteCT_Transform2D;
function WriteCT_GroupTransform2D(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var rot = instance.rot;
        if (!common_1._isNullOrUndefined(rot) && rot !== 0) {
            writer.writeAttributeString("rot", parseInt(rot, 10));
        }
        if (instance.flipH === true) {
            writer.writeAttributeString("flipH", "1");
        }
        if (instance.flipV === true) {
            writer.writeAttributeString("flipV", "1");
        }
    }, function () {
        var off = instance.off, ext = instance.ext, chOff = instance.chOff, chExt = instance.chExt;
        if (!common_1._isNullOrUndefined(off)) {
            if (common_1._isNullOrUndefined(off.x)) {
                off.x = 0;
            }
            if (common_1._isNullOrUndefined(off.y)) {
                off.y = 0;
            }
            WriteCT_Point2D(writer, CONST_A, "off", off, true);
        }
        if (!common_1._isNullOrUndefined(ext)) {
            if (common_1._isNullOrUndefined(ext.cx)) {
                ext.cx = 0;
            }
            if (common_1._isNullOrUndefined(ext.cy)) {
                ext.cy = 0;
            }
            WriteCT_PositiveSize2D(writer, CONST_A, CONST_EXT, ext, true);
        }
        if (!common_1._isNullOrUndefined(chOff)) {
            WriteCT_Point2D(writer, CONST_A, "chOff", chOff, true);
        }
        if (!common_1._isNullOrUndefined(chExt)) {
            WriteCT_PositiveSize2D(writer, CONST_A, "chExt", chExt, true);
        }
    });
}
exports.DrawingWriter.WriteCT_GroupTransform2D = WriteCT_GroupTransform2D;
function WriteCT_Point3D(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.x)) {
            writer.writeAttributeString("x", instance.x);
        }
        if (!common_1._isNullOrUndefined(instance.y)) {
            writer.writeAttributeString("y", instance.y);
        }
        if (!common_1._isNullOrUndefined(instance.z)) {
            writer.writeAttributeString("z", instance.z);
        }
    });
}
exports.DrawingWriter.WriteCT_Point3D = WriteCT_Point3D;
function WriteCT_Vector3D(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.dx)) {
            writer.writeAttributeString("dx", instance.dx);
        }
        if (!common_1._isNullOrUndefined(instance.dy)) {
            writer.writeAttributeString("dy", instance.dy);
        }
        if (!common_1._isNullOrUndefined(instance.dz)) {
            writer.writeAttributeString("dz", instance.dz);
        }
    });
}
exports.DrawingWriter.WriteCT_Vector3D = WriteCT_Vector3D;
function WriteCT_SphereCoords(writer, prefix, localName, instance) {
    var hasLat = !common_1._isNullOrUndefined(instance.lat), hasLon = !common_1._isNullOrUndefined(instance.lon), hasRev = !common_1._isNullOrUndefined(instance.rev);
    if (hasLat || hasLon || hasRev) {
        writer.writeLeafElement(prefix + ":" + localName, function () {
            if (hasLat) {
                writer.writeAttributeString("lat", instance.lat);
            }
            if (hasLon) {
                writer.writeAttributeString("lon", instance.lon);
            }
            if (hasRev) {
                writer.writeAttributeString("rev", instance.rev);
            }
        });
    }
}
exports.DrawingWriter.WriteCT_SphereCoords = WriteCT_SphereCoords;
function WriteCT_RelativeRect(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.l) && instance.l !== 0) {
            writer.writeAttributeString("l", instance.l);
        }
        if (!common_1._isNullOrUndefined(instance.t) && instance.t !== 0) {
            writer.writeAttributeString("t", instance.t);
        }
        if (!common_1._isNullOrUndefined(instance.r) && instance.r !== 0) {
            writer.writeAttributeString(CONST_R, instance.r);
        }
        if (!common_1._isNullOrUndefined(instance.b) && instance.b !== 0) {
            writer.writeAttributeString("b", instance.b);
        }
    });
}
exports.DrawingWriter.WriteCT_RelativeRect = WriteCT_RelativeRect;
function WriteCT_Color(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeSubColorElements(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_Color = WriteCT_Color;
function WriteCT_ColorMRU(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (instance.scrgbClr) {
            writeArrayItem(instance.scrgbClr, function (scrgbClrItem) {
                WriteCT_ScRgbColor(writer, CONST_A, CONST_SCRGBCLR, scrgbClrItem);
            });
        }
        else if (instance.srgbClr) {
            writeArrayItem(instance.srgbClr, function (srgbClrItem) {
                WriteCT_SRgbColor(writer, CONST_A, CONST_SRGBCLR, srgbClrItem);
            });
        }
        else if (instance.hslClr) {
            writeArrayItem(instance.hslClr, function (hslClrItem) {
                WriteCT_HslColor(writer, CONST_A, CONST_HSLCLR, hslClrItem);
            });
        }
        else if (instance.sysClr) {
            writeArrayItem(instance.sysClr, function (sysClrItem) {
                WriteCT_SystemColor(writer, CONST_A, CONST_SYSCLR, sysClrItem);
            });
        }
        else if (instance.schemeClr) {
            writeArrayItem(instance.schemeClr, function (schemeClrItem) {
                WriteCT_SchemeColor(writer, CONST_A, CONST_SCHEMECLR, schemeClrItem);
            });
        }
        else if (instance.prstClr) {
            writeArrayItem(instance.prstClr, function (prstClrItem) {
                WriteCT_PresetColor(writer, CONST_A, CONST_PRSTCLR, prstClrItem);
            });
        }
    });
}
exports.DrawingWriter.WriteCT_ColorMRU = WriteCT_ColorMRU;
function WriteCT_EmbeddedWAVAudioFile(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var embed = instance.embed, name = instance.name;
        if (!common_1._isNullOrUndefined(embed)) {
            writer.writeAttributeString("embed", embed);
        }
        if (!isNullOrUndefinedOrEmpty(name)) {
            writer.writeAttributeString(CONST_NAME, name);
        }
        if (instance.builtIn === true) {
            writer.writeAttributeString("builtIn", "1");
        }
    });
}
exports.DrawingWriter.WriteCT_EmbeddedWAVAudioFile = WriteCT_EmbeddedWAVAudioFile;
function WriteCT_Hyperlink(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var action = instance.action, tgtFrame = instance.tgtFrame, tooltip = instance.tooltip;
        if (!isNullOrUndefinedOrEmpty(instance.url)) {
            var hyperlinkFileName = '';
            var hyperlinkFile = new excel_types_1.XFile(hyperlinkFileName, excel_types_1.RelationshipConstants._relationshipHyperlinkType);
            var locationPrefix = 'sjs://';
            if (instance.url.substring(0, locationPrefix.length) === locationPrefix) {
                hyperlinkFile.target = '#' + common_1.Util._xmlEncode(instance.url.replace(locationPrefix, ''));
            }
            else {
                hyperlinkFile.target = common_1.Util._xmlEncode(instance.url);
                hyperlinkFile.targetMode = 'External';
            }
            instance.rid = writer.currentFile._addRelationFile(hyperlinkFile);
            writer.writeAttributeString('r:id', instance.rid);
        }
        writer.writeAttributeString("xmlns:r", exports.DrawingWriter.r);
        if (!isNullOrUndefinedOrEmpty(action)) {
            writer.writeAttributeString("action", instance.action);
        }
        if (!isNullOrUndefinedOrEmpty(tgtFrame)) {
            writer.writeAttributeString("tgtFrame", tgtFrame);
        }
        if (!isNullOrUndefinedOrEmpty(tooltip)) {
            writer.writeAttributeString("tooltip", tooltip);
        }
        if (instance.history === false) {
            writer.writeAttributeString("history", "0");
        }
        if (instance.highlightClick === true) {
            writer.writeAttributeString("highlightClick", "1");
        }
        if (instance.endSnd === true) {
            writer.writeAttributeString("endSnd", "1");
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.snd)) {
            WriteCT_EmbeddedWAVAudioFile(writer, CONST_A, "snd", instance.snd);
        }
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Hyperlink = WriteCT_Hyperlink;
function WriteCT_Boolean(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        writer.writeAttributeString(CONST_VAL, instance ? "1" : "0");
    });
}
exports.DrawingWriter.WriteCT_Boolean = WriteCT_Boolean;
function WriteCT_Double(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_Double = WriteCT_Double;
function WriteCT_UnsignedInt(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_UnsignedInt = WriteCT_UnsignedInt;
function WriteCT_Int(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_Int = WriteCT_Int;
function WriteCT_RelId(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance.id, 'id');
}
exports.DrawingWriter.WriteCT_RelId = WriteCT_RelId;
function WriteCT_Extension(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.uri)) {
            writer.writeAttributeString("uri", instance.uri);
        }
        writer.writeAttributeString("xmlns:c14", exports.DrawingWriter.c14);
    }, function () {
        var dataObject = instance.dataObject;
        if (dataObject) {
            if (dataObject.extDataType === 0) {
                WriteCT_InvertSolidFillFmt(writer, CONST_C14, "invertSolidFillFmt", dataObject);
            }
            else if (dataObject.extDataType === 1) {
                WriteCT_SeriesDataLabelsRange(writer, CONST_C15, "datalabelsRange", dataObject);
            }
            else if (dataObject.extDataType === 2) {
                WriteCT_DispNaAsBlank(writer, CONST_C16, "dataDisplayOptions16", dataObject);
            }
        }
    });
}
exports.DrawingWriter.WriteCT_Extension = WriteCT_Extension;
function WriteCT_ExtensionList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.ext, function (item) {
            WriteCT_Extension(writer, CONST_C14, CONST_EXT, item);
        });
    });
}
exports.DrawingWriter.WriteCT_ExtensionList = WriteCT_ExtensionList;
function WriteCT_NumVal(writer, prefix, localName, value, idx) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(idx)) {
            writer.writeAttributeString("idx", idx);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(value)) {
            var n = value.replace(/,/g, '');
            writer.writeElementString("c:v", n);
        }
    });
}
exports.DrawingWriter.WriteCT_NumVal = WriteCT_NumVal;
function WriteCT_NumData(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var ptCount = instance.ptCount, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(instance.formatCode)) {
            writer.writeElementString("c:formatCode", xmlEncode(instance.formatCode));
        }
        if (!common_1._isNullOrUndefined(ptCount)) {
            WriteCT_UnsignedInt(writer, CONST_C, "ptCount", ptCount);
        }
        writeArrayItem(instance.pt, function (ptItem, i) {
            WriteCT_NumVal(writer, CONST_C, "pt", ptItem, i);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_NumData = WriteCT_NumData;
function WriteCT_NumRef(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var numCache = instance.numCache, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(instance.f)) {
            writer.writeElementString("c:f", xmlEncode(instance.f));
        }
        if (!common_1._isNullOrUndefined(numCache)) {
            WriteCT_NumData(writer, CONST_C, "numCache", numCache);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_NumRef = WriteCT_NumRef;
function WriteCT_NumDataSource(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var numRef = instance.numRef, numLit = instance.numLit;
        if (!common_1._isNullOrUndefined(numRef)) {
            WriteCT_NumRef(writer, CONST_C, "numRef", numRef);
        }
        if (!common_1._isNullOrUndefined(numLit)) {
            WriteCT_NumData(writer, CONST_C, "numLit", numLit);
        }
    });
}
exports.DrawingWriter.WriteCT_NumDataSource = WriteCT_NumDataSource;
function WriteCT_StrVal(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.idx)) {
            writer.writeAttributeString("idx", instance.idx);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.v)) {
            writer.writeElementString("c:v", xmlEncode(instance.v));
        }
    });
}
exports.DrawingWriter.WriteCT_StrVal = WriteCT_StrVal;
function WriteCT_StrData(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var ptCount = instance.ptCount, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(ptCount)) {
            WriteCT_UnsignedInt(writer, CONST_C, "ptCount", ptCount);
        }
        writeArrayItem(instance.pt, function (item, i) {
            WriteCT_StrVal(writer, CONST_C, "pt", { idx: i, v: item });
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_StrData = WriteCT_StrData;
function WriteCT_StrRef(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(instance.f)) {
            writer.writeElementString("c:f", xmlEncode(instance.f));
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_StrRef = WriteCT_StrRef;
function WriteCT_Tx(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var strRef = instance.strRef, rich = instance.rich;
        if (!common_1._isNullOrUndefined(strRef)) {
            WriteCT_StrRef(writer, CONST_C, "strRef", strRef);
        }
        if (!common_1._isNullOrUndefined(rich)) {
            WriteCT_TextBody(writer, CONST_C, "rich", rich);
        }
    });
}
exports.DrawingWriter.WriteCT_Tx = WriteCT_Tx;
function WriteCT_TextLanguageID(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_TextLanguageID = WriteCT_TextLanguageID;
function WriteCT_Lvl(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.pt, function (ptItem) {
            WriteCT_StrVal(writer, CONST_C, "pt", ptItem);
        });
    });
}
exports.DrawingWriter.WriteCT_Lvl = WriteCT_Lvl;
function WriteCT_MultiLvlStrData(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var ptCount = instance.ptCount, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(ptCount)) {
            WriteCT_UnsignedInt(writer, CONST_C, "ptCount", ptCount);
        }
        writeArrayItem(instance.lvl, function (lvlItem) {
            WriteCT_StrData(writer, CONST_C, "lvl", lvlItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_MultiLvlStrData = WriteCT_MultiLvlStrData;
function WriteCT_MultiLvlStrRef(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var multiLvlStrCache = instance.multiLvlStrCache, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(instance.f)) {
            writer.writeElementString("c:f", xmlEncode(instance.f));
        }
        if (!common_1._isNullOrUndefined(multiLvlStrCache)) {
            WriteCT_MultiLvlStrData(writer, CONST_C, "multiLvlStrCache", multiLvlStrCache);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_MultiLvlStrRef = WriteCT_MultiLvlStrRef;
function WriteCT_AxDataSource(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var multiLvlStrRef = instance.multiLvlStrRef, numRef = instance.numRef, numLit = instance.numLit, strRef = instance.strRef, strLit = instance.strLit;
        if (!common_1._isNullOrUndefined(multiLvlStrRef)) {
            WriteCT_MultiLvlStrRef(writer, CONST_C, "multiLvlStrRef", multiLvlStrRef);
        }
        if (!common_1._isNullOrUndefined(numRef)) {
            WriteCT_NumRef(writer, CONST_C, "numRef", numRef);
        }
        if (!common_1._isNullOrUndefined(numLit)) {
            WriteCT_NumData(writer, CONST_C, "numLit", numLit);
        }
        if (!common_1._isNullOrUndefined(strRef)) {
            WriteCT_StrRef(writer, CONST_C, "strRef", strRef);
        }
        if (!common_1._isNullOrUndefined(strLit)) {
            WriteCT_StrData(writer, CONST_C, "strLit", strLit);
        }
    });
}
exports.DrawingWriter.WriteCT_AxDataSource = WriteCT_AxDataSource;
function WriteCT_SerTx(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.strRef)) {
            WriteCT_StrRef(writer, CONST_C, "strRef", instance.strRef);
        }
        if (!common_1._isNullOrUndefined(instance.v)) {
            writer.writeElementString("c:v", instance.v);
        }
    });
}
exports.DrawingWriter.WriteCT_SerTx = WriteCT_SerTx;
function WriteCT_LayoutTarget(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 1, chart_model_1.Charts.ST_LayoutTarget);
}
exports.DrawingWriter.WriteCT_LayoutTarget = WriteCT_LayoutTarget;
function WriteCT_LayoutMode(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 1, chart_model_1.Charts.ST_LayoutMode);
}
exports.DrawingWriter.WriteCT_LayoutMode = WriteCT_LayoutMode;
function WriteCT_ManualLayout(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var layoutTarget = instance.layoutTarget, xMode = instance.xMode, yMode = instance.yMode, wMode = instance.wMode, hMode = instance.hMode, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(layoutTarget)) {
            WriteCT_LayoutTarget(writer, CONST_C, "layoutTarget", layoutTarget);
        }
        if (!common_1._isNullOrUndefined(xMode)) {
            WriteCT_LayoutMode(writer, CONST_C, "xMode", xMode);
        }
        if (!common_1._isNullOrUndefined(yMode)) {
            WriteCT_LayoutMode(writer, CONST_C, "yMode", yMode);
        }
        if (!common_1._isNullOrUndefined(wMode)) {
            WriteCT_LayoutMode(writer, CONST_C, "wMode", wMode);
        }
        if (!common_1._isNullOrUndefined(hMode)) {
            WriteCT_LayoutMode(writer, CONST_C, "hMode", hMode);
        }
        if (!common_1._isNullOrUndefined(instance.x)) {
            WriteCT_Double(writer, CONST_C, "x", instance.x);
        }
        if (!common_1._isNullOrUndefined(instance.y)) {
            WriteCT_Double(writer, CONST_C, "y", instance.y);
        }
        if (!common_1._isNullOrUndefined(instance.w)) {
            WriteCT_Double(writer, CONST_C, "w", instance.w);
        }
        if (!common_1._isNullOrUndefined(instance.h)) {
            WriteCT_Double(writer, CONST_C, "h", instance.h);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_ManualLayout = WriteCT_ManualLayout;
function WriteCT_Layout(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var manualLayout = instance.manualLayout, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(manualLayout)) {
            WriteCT_ManualLayout(writer, CONST_C, "manualLayout", manualLayout);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Layout = WriteCT_Layout;
function WriteCT_Title(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var tx = instance.tx, layout = instance.layout, overlay = instance.overlay, spPr = instance.spPr, txPr = instance.txPr, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(tx)) {
            WriteCT_Tx(writer, CONST_C, "tx", tx);
        }
        if (!common_1._isNullOrUndefined(layout)) {
            WriteCT_Layout(writer, CONST_C, CONST_LAYOUT, layout);
        }
        if (!common_1._isNullOrUndefined(overlay)) {
            WriteCT_Boolean(writer, CONST_C, "overlay", overlay);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(txPr)) {
            WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Title = WriteCT_Title;
function WriteCT_RotX(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0);
}
exports.DrawingWriter.WriteCT_RotX = WriteCT_RotX;
function WriteCT_HPercent(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_HPercent = WriteCT_HPercent;
function WriteCT_RotY(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_RotY = WriteCT_RotY;
function WriteCT_DepthPercent(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_DepthPercent = WriteCT_DepthPercent;
function WriteCT_Perspective(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 30);
}
exports.DrawingWriter.WriteCT_Perspective = WriteCT_Perspective;
function WriteCT_View3D(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var rotX = instance.rotX, hPercent = instance.hPercent, rotY = instance.rotY, depthPercent = instance.depthPercent, rAngAx = instance.rAngAx, perspective = instance.perspective, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(rotX)) {
            WriteCT_RotX(writer, CONST_C, "rotX", rotX);
        }
        if (!common_1._isNullOrUndefined(hPercent)) {
            WriteCT_HPercent(writer, CONST_C, "hPercent", hPercent);
        }
        if (!common_1._isNullOrUndefined(rotY)) {
            WriteCT_RotY(writer, CONST_C, "rotY", rotY);
        }
        if (!common_1._isNullOrUndefined(depthPercent)) {
            WriteCT_DepthPercent(writer, CONST_C, "depthPercent", depthPercent);
        }
        if (!common_1._isNullOrUndefined(rAngAx)) {
            WriteCT_Boolean(writer, CONST_C, "rAngAx", rAngAx);
        }
        if (!common_1._isNullOrUndefined(perspective)) {
            WriteCT_Perspective(writer, CONST_C, "perspective", perspective);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_View3D = WriteCT_View3D;
function WriteCT_Surface(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var thickness = instance.thickness, spPr = instance.spPr, pictureOptions = instance.pictureOptions, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(thickness)) {
            WriteCT_UnsignedInt(writer, CONST_C, "thickness", thickness);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(pictureOptions)) {
            WriteCT_PictureOptions(writer, CONST_C, CONST_PICTURE_OPTIONS, pictureOptions);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Surface = WriteCT_Surface;
function WriteCT_DTable(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var showHorzBorder = instance.showHorzBorder, showVertBorder = instance.showVertBorder, showOutline = instance.showOutline, showKeys = instance.showKeys, spPr = instance.spPr, txPr = instance.txPr, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(showHorzBorder)) {
            WriteCT_Boolean(writer, CONST_C, "showHorzBorder", showHorzBorder);
        }
        if (!common_1._isNullOrUndefined(showVertBorder)) {
            WriteCT_Boolean(writer, CONST_C, "showVertBorder", showVertBorder);
        }
        if (!common_1._isNullOrUndefined(showOutline)) {
            WriteCT_Boolean(writer, CONST_C, "showOutline", showOutline);
        }
        if (!common_1._isNullOrUndefined(showKeys)) {
            WriteCT_Boolean(writer, CONST_C, "showKeys", showKeys);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(txPr)) {
            WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_DTable = WriteCT_DTable;
function WriteCT_GapAmount(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_GapAmount = WriteCT_GapAmount;
function WriteCT_Overlap(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0);
}
exports.DrawingWriter.WriteCT_Overlap = WriteCT_Overlap;
function WriteCT_BubbleScale(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 100);
}
exports.DrawingWriter.WriteCT_BubbleScale = WriteCT_BubbleScale;
function WriteCT_SizeRepresents(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0, chart_model_1.Charts.ST_SizeRepresents);
}
exports.DrawingWriter.WriteCT_SizeRepresents = WriteCT_SizeRepresents;
function WriteCT_FirstSliceAng(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0);
}
exports.DrawingWriter.WriteCT_FirstSliceAng = WriteCT_FirstSliceAng;
function WriteCT_HoleSize(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_HoleSize = WriteCT_HoleSize;
function WriteCT_SplitType(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0, chart_model_1.Charts.ST_SplitType, chart_helper_1.ChartHelper.ToST_SplitType);
}
exports.DrawingWriter.WriteCT_SplitType = WriteCT_SplitType;
function WriteCT_CustSplit(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.secondPiePt, function (secondPiePtItem) {
            WriteCT_UnsignedInt(writer, CONST_C, "secondPiePt", secondPiePtItem);
        });
    });
}
exports.DrawingWriter.WriteCT_CustSplit = WriteCT_CustSplit;
function WriteCT_SecondPieSize(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 75);
}
exports.DrawingWriter.WriteCT_SecondPieSize = WriteCT_SecondPieSize;
function WriteCT_NumFmt(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.formatCode)) {
            writer.writeAttributeString("formatCode", xmlEncode(instance.formatCode));
        }
        if (instance.sourceLinked === false) {
            writer.writeAttributeString("sourceLinked", "0");
        }
    });
}
exports.DrawingWriter.WriteCT_NumFmt = WriteCT_NumFmt;
function WriteCT_LblAlgn(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_LblAlgn);
}
exports.DrawingWriter.WriteCT_LblAlgn = WriteCT_LblAlgn;
function WriteCT_DLblPos(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_DLblPos);
}
exports.DrawingWriter.WriteCT_DLblPos = WriteCT_DLblPos;
function WriteCT_DLbl(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var idx = instance.idx, deleteField = instance.delete, layout = instance.layout, tx = instance.tx, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(idx)) {
            WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
        }
        if (!common_1._isNullOrUndefined(deleteField)) {
            WriteCT_Boolean(writer, CONST_C, CONST_DELETE, deleteField);
        }
        if (!common_1._isNullOrUndefined(layout)) {
            WriteCT_Layout(writer, CONST_C, CONST_LAYOUT, layout);
        }
        if (!common_1._isNullOrUndefined(tx)) {
            WriteCT_Tx(writer, CONST_C, "tx", tx);
        }
        writeDLblSubElement(writer, instance);
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_DLblExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_DLbl = WriteCT_DLbl;
function WriteCT_DLbls(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var deleteField = instance.delete, showLeaderLines = instance.showLeaderLines, leaderLines = instance.leaderLines, extLst = instance.extLst;
        writeArrayItem(instance.dLbl, function (dLblItem) {
            WriteCT_DLbl(writer, CONST_C, "dLbl", dLblItem);
        });
        if (!common_1._isNullOrUndefined(deleteField)) {
            WriteCT_Boolean(writer, CONST_C, CONST_DELETE, deleteField);
        }
        writeDLblSubElement(writer, instance);
        if (!common_1._isNullOrUndefined(showLeaderLines)) {
            WriteCT_Boolean(writer, CONST_C, "showLeaderLines", showLeaderLines);
        }
        if (!common_1._isNullOrUndefined(leaderLines)) {
            WriteCT_ChartLines(writer, CONST_C, "leaderLines", leaderLines);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_DLblsExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_DLbls = WriteCT_DLbls;
function WriteCT_MarkerStyle(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_MarkerStyle, chart_helper_1.ChartHelper.ToST_MarkerStyle);
}
exports.DrawingWriter.WriteCT_MarkerStyle = WriteCT_MarkerStyle;
function WriteCT_MarkerSize(writer, prefix, localName, instance) {
    var size = Math.min(72, Math.round(excel_style_1.UnitHelper.pixelToPoint(instance)));
    writeSingleAttributeNode(writer, prefix, localName, size, CONST_VAL);
}
exports.DrawingWriter.WriteCT_MarkerSize = WriteCT_MarkerSize;
function WriteCT_Marker(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var symbol = instance.symbol, size = instance.size, spPr = instance.spPr, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(symbol)) {
            WriteCT_MarkerStyle(writer, CONST_C, "symbol", symbol);
        }
        if (!common_1._isNullOrUndefined(size)) {
            WriteCT_MarkerSize(writer, CONST_C, "size", size);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Marker = WriteCT_Marker;
function WriteCT_DPt(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var idx = instance.idx, invertIfNegative = instance.invertIfNegative, marker = instance.marker, bubble3D = instance.bubble3D, explosion = instance.explosion, spPr = instance.spPr, pictureOptions = instance.pictureOptions, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(idx)) {
            WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
        }
        if (!common_1._isNullOrUndefined(invertIfNegative)) {
            WriteCT_Boolean(writer, CONST_C, CONST_INVERT_IF_NEGATIVE, invertIfNegative);
        }
        if (!common_1._isNullOrUndefined(marker)) {
            WriteCT_Marker(writer, CONST_C, CONST_MARKER, marker);
        }
        if (!common_1._isNullOrUndefined(bubble3D)) {
            WriteCT_Boolean(writer, CONST_C, CONST_BUBBLE_3D, bubble3D);
        }
        if (!common_1._isNullOrUndefined(explosion)) {
            WriteCT_UnsignedInt(writer, CONST_C, "explosion", explosion);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(pictureOptions)) {
            WriteCT_PictureOptions(writer, CONST_C, CONST_PICTURE_OPTIONS, pictureOptions);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_DPt = WriteCT_DPt;
function WriteCT_TrendlineType(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_TrendlineType);
}
exports.DrawingWriter.WriteCT_TrendlineType = WriteCT_TrendlineType;
function WriteCT_Order(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_Order = WriteCT_Order;
function WriteCT_Period(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_Period = WriteCT_Period;
function WriteCT_TrendlineLbl(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var layout = instance.layout, tx = instance.tx, numFmt = instance.numFmt, spPr = instance.spPr, txPr = instance.txPr, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(layout)) {
            WriteCT_Layout(writer, CONST_C, CONST_LAYOUT, layout);
        }
        if (!common_1._isNullOrUndefined(tx)) {
            WriteCT_Tx(writer, CONST_C, "tx", tx);
        }
        if (!common_1._isNullOrUndefined(numFmt)) {
            WriteCT_NumFmt(writer, CONST_C, CONST_NUMFMT, numFmt);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(txPr)) {
            WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_TrendlineLbl = WriteCT_TrendlineLbl;
function WriteCT_Trendline(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var spPr = instance.spPr, trendlineType = instance.trendlineType, order = instance.order, period = instance.period, forward = instance.forward, backward = instance.backward, intercept = instance.intercept, dispRSqr = instance.dispRSqr, dispEq = instance.dispEq, trendlineLbl = instance.trendlineLbl, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(instance.name)) {
            writer.writeElementString("c:name", instance.name);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(trendlineType)) {
            WriteCT_TrendlineType(writer, CONST_C, "trendlineType", trendlineType);
        }
        if (!common_1._isNullOrUndefined(order)) {
            WriteCT_Order(writer, CONST_C, CONST_ORDER, order);
        }
        if (!common_1._isNullOrUndefined(period)) {
            WriteCT_Period(writer, CONST_C, "period", period);
        }
        if (!common_1._isNullOrUndefined(forward)) {
            WriteCT_Double(writer, CONST_C, "forward", forward);
        }
        if (!common_1._isNullOrUndefined(backward)) {
            WriteCT_Double(writer, CONST_C, "backward", backward);
        }
        if (!common_1._isNullOrUndefined(intercept)) {
            WriteCT_Double(writer, CONST_C, "intercept", intercept);
        }
        if (!common_1._isNullOrUndefined(dispRSqr)) {
            WriteCT_Boolean(writer, CONST_C, "dispRSqr", dispRSqr);
        }
        if (!common_1._isNullOrUndefined(dispEq)) {
            WriteCT_Boolean(writer, CONST_C, "dispEq", dispEq);
        }
        if (!common_1._isNullOrUndefined(trendlineLbl)) {
            WriteCT_TrendlineLbl(writer, CONST_C, "trendlineLbl", trendlineLbl);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Trendline = WriteCT_Trendline;
function WriteCT_ErrDir(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_ErrDir);
}
exports.DrawingWriter.WriteCT_ErrDir = WriteCT_ErrDir;
function WriteCT_ErrBarType(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_ErrBarType);
}
exports.DrawingWriter.WriteCT_ErrBarType = WriteCT_ErrBarType;
function WriteCT_ErrValType(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_ErrValType);
}
exports.DrawingWriter.WriteCT_ErrValType = WriteCT_ErrValType;
function WriteCT_ErrBars(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var errDir = instance.errDir, errBarType = instance.errBarType, errValType = instance.errValType, noEndCap = instance.noEndCap, plus = instance.plus, minus = instance.minus, val = instance.val, spPr = instance.spPr, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(errDir)) {
            WriteCT_ErrDir(writer, CONST_C, "errDir", errDir);
        }
        if (!common_1._isNullOrUndefined(errBarType)) {
            WriteCT_ErrBarType(writer, CONST_C, "errBarType", errBarType);
        }
        if (!common_1._isNullOrUndefined(errValType)) {
            WriteCT_ErrValType(writer, CONST_C, "errValType", errValType);
        }
        if (!common_1._isNullOrUndefined(noEndCap)) {
            WriteCT_Boolean(writer, CONST_C, "noEndCap", noEndCap);
        }
        if (!common_1._isNullOrUndefined(plus)) {
            WriteCT_NumDataSource(writer, CONST_C, "plus", plus);
        }
        if (!common_1._isNullOrUndefined(minus)) {
            WriteCT_NumDataSource(writer, CONST_C, "minus", minus);
        }
        if (!common_1._isNullOrUndefined(val)) {
            WriteCT_Double(writer, CONST_C, CONST_VAL, val);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_ErrBars = WriteCT_ErrBars;
function WriteCT_UpDownBar(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_ShapeProperties, CONST_C, CONST_SPPR);
}
exports.DrawingWriter.WriteCT_UpDownBar = WriteCT_UpDownBar;
function WriteCT_UpDownBars(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var gapWidth = instance.gapWidth, upBars = instance.upBars, downBars = instance.downBars, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(gapWidth)) {
            WriteCT_GapAmount(writer, CONST_C, CONST_GAP_WIDTH, gapWidth);
        }
        if (!common_1._isNullOrUndefined(upBars)) {
            WriteCT_UpDownBar(writer, CONST_C, "upBars", upBars);
        }
        if (!common_1._isNullOrUndefined(downBars)) {
            WriteCT_UpDownBar(writer, CONST_C, "downBars", downBars);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_UpDownBars = WriteCT_UpDownBars;
function WriteCT_LineSer(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var cat = instance.cat, val = instance.val;
        writeLineOrScatterSerSubElement(writer, instance);
        if (!common_1._isNullOrUndefined(cat)) {
            WriteCT_AxDataSource(writer, CONST_C, "cat", cat);
        }
        if (!common_1._isNullOrUndefined(val)) {
            WriteCT_NumDataSource(writer, CONST_C, CONST_VAL, val);
        }
    });
}
exports.DrawingWriter.WriteCT_LineSer = WriteCT_LineSer;
function WriteCT_ScatterSer(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var xVal = instance.xVal, yVal = instance.yVal;
        writeLineOrScatterSerSubElement(writer, instance);
        if (!common_1._isNullOrUndefined(xVal)) {
            WriteCT_AxDataSource(writer, CONST_C, "xVal", xVal);
        }
        if (!common_1._isNullOrUndefined(yVal)) {
            WriteCT_NumDataSource(writer, CONST_C, "yVal", yVal);
        }
    });
}
exports.DrawingWriter.WriteCT_ScatterSer = WriteCT_ScatterSer;
function WriteCT_RadarSer(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var idx = instance.idx, order = instance.order, tx = instance.tx, spPr = instance.spPr, marker = instance.marker, dLbls = instance.dLbls, cat = instance.cat, val = instance.val, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(idx)) {
            WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
        }
        if (!common_1._isNullOrUndefined(order)) {
            WriteCT_UnsignedInt(writer, CONST_C, CONST_ORDER, order);
        }
        if (!common_1._isNullOrUndefined(tx)) {
            WriteCT_SerTx(writer, CONST_C, "tx", tx);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(marker)) {
            WriteCT_Marker(writer, CONST_C, CONST_MARKER, marker);
        }
        writeArrayItem(instance.dPt, function (dPtItem) {
            WriteCT_DPt(writer, CONST_C, "dPt", dPtItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(cat)) {
            WriteCT_AxDataSource(writer, CONST_C, "cat", cat);
        }
        if (!common_1._isNullOrUndefined(val)) {
            WriteCT_NumDataSource(writer, CONST_C, CONST_VAL, val);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_RadarSer = WriteCT_RadarSer;
function WriteCT_BarSer(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var invertIfNegative = instance.invertIfNegative, shape = instance.shape;
        writeAreaOrBarSerSubElement(writer, instance);
        if (!common_1._isNullOrUndefined(invertIfNegative)) {
            WriteCT_Boolean(writer, CONST_C, CONST_INVERT_IF_NEGATIVE, invertIfNegative);
        }
        if (!common_1._isNullOrUndefined(shape)) {
            WriteCT_ShapeBox(writer, CONST_C, "shape", shape);
        }
    });
}
exports.DrawingWriter.WriteCT_BarSer = WriteCT_BarSer;
function WriteCT_AreaSer(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeAreaOrBarSerSubElement(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_AreaSer = WriteCT_AreaSer;
function WriteCT_PieSer(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var idx = instance.idx, order = instance.order, tx = instance.tx, spPr = instance.spPr, explosion = instance.explosion, dLbls = instance.dLbls, cat = instance.cat, val = instance.val, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(idx)) {
            WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
        }
        if (!common_1._isNullOrUndefined(order)) {
            WriteCT_UnsignedInt(writer, CONST_C, CONST_ORDER, order);
        }
        if (!common_1._isNullOrUndefined(tx)) {
            WriteCT_SerTx(writer, CONST_C, "tx", tx);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(explosion)) {
            WriteCT_UnsignedInt(writer, CONST_C, "explosion", explosion);
        }
        writeArrayItem(instance.dPt, function (dPtItem) {
            WriteCT_DPt(writer, CONST_C, "dPt", dPtItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(cat)) {
            WriteCT_AxDataSource(writer, CONST_C, "cat", cat);
        }
        if (!common_1._isNullOrUndefined(val)) {
            WriteCT_NumDataSource(writer, CONST_C, CONST_VAL, val);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_PieSer = WriteCT_PieSer;
function WriteCT_BubbleSer(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var idx = instance.idx, order = instance.order, tx = instance.tx, spPr = instance.spPr, invertIfNegative = instance.invertIfNegative, dLbls = instance.dLbls, xVal = instance.xVal, yVal = instance.yVal, bubbleSize = instance.bubbleSize, bubble3D = instance.bubble3D, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(idx)) {
            WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
        }
        if (!common_1._isNullOrUndefined(order)) {
            WriteCT_UnsignedInt(writer, CONST_C, CONST_ORDER, order);
        }
        if (!common_1._isNullOrUndefined(tx)) {
            WriteCT_SerTx(writer, CONST_C, "tx", tx);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(invertIfNegative)) {
            WriteCT_Boolean(writer, CONST_C, CONST_INVERT_IF_NEGATIVE, invertIfNegative);
        }
        writeArrayItem(instance.dPt, function (dPtItem) {
            WriteCT_DPt(writer, CONST_C, "dPt", dPtItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        writeArrayItem(instance.trendline, function (trendlineItem) {
            WriteCT_Trendline(writer, CONST_C, CONST_TRENDLINE, trendlineItem);
        });
        writeArrayItem(instance.errBars, function (errBarsItem) {
            WriteCT_ErrBars(writer, CONST_C, CONST_ERR_BARS, errBarsItem);
        });
        if (!common_1._isNullOrUndefined(xVal)) {
            WriteCT_AxDataSource(writer, CONST_C, "xVal", xVal);
        }
        if (!common_1._isNullOrUndefined(yVal)) {
            WriteCT_NumDataSource(writer, CONST_C, "yVal", yVal);
        }
        if (!common_1._isNullOrUndefined(bubbleSize)) {
            WriteCT_NumDataSource(writer, CONST_C, "bubbleSize", bubbleSize);
        }
        if (!common_1._isNullOrUndefined(bubble3D)) {
            WriteCT_Boolean(writer, CONST_C, CONST_BUBBLE_3D, bubble3D);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_BubbleSer = WriteCT_BubbleSer;
function WriteCT_SurfaceSer(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var idx = instance.idx, order = instance.order, tx = instance.tx, spPr = instance.spPr, cat = instance.cat, val = instance.val, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(idx)) {
            WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
        }
        if (!common_1._isNullOrUndefined(order)) {
            WriteCT_UnsignedInt(writer, CONST_C, CONST_ORDER, order);
        }
        if (!common_1._isNullOrUndefined(tx)) {
            WriteCT_SerTx(writer, CONST_C, "tx", tx);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(cat)) {
            WriteCT_AxDataSource(writer, CONST_C, "cat", cat);
        }
        if (!common_1._isNullOrUndefined(val)) {
            WriteCT_NumDataSource(writer, CONST_C, CONST_VAL, val);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_SurfaceSer = WriteCT_SurfaceSer;
function WriteCT_Grouping(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_Grouping);
}
exports.DrawingWriter.WriteCT_Grouping = WriteCT_Grouping;
function WriteCT_ChartLines(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_ShapeProperties, CONST_C, CONST_SPPR);
}
exports.DrawingWriter.WriteCT_ChartLines = WriteCT_ChartLines;
function WriteCT_LineChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var grouping = instance.grouping, varyColors = instance.varyColors, dLbls = instance.dLbls, dropLines = instance.dropLines, hiLowLines = instance.hiLowLines, upDownBars = instance.upDownBars, marker = instance.marker, smooth = instance.smooth, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(grouping)) {
            WriteCT_Grouping(writer, CONST_C, CONST_GROUPING, grouping);
        }
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_LineSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(dropLines)) {
            WriteCT_ChartLines(writer, CONST_C, CONST_DROP_LINES, dropLines);
        }
        if (!common_1._isNullOrUndefined(hiLowLines)) {
            WriteCT_ChartLines(writer, CONST_C, "hiLowLines", hiLowLines);
        }
        if (!common_1._isNullOrUndefined(upDownBars)) {
            WriteCT_UpDownBars(writer, CONST_C, "upDownBars", upDownBars);
        }
        if (!common_1._isNullOrUndefined(marker)) {
            WriteCT_Boolean(writer, CONST_C, CONST_MARKER, marker);
        }
        if (!common_1._isNullOrUndefined(smooth)) {
            WriteCT_Boolean(writer, CONST_C, "smooth", smooth);
        }
        writeArrayItem(instance.axId, function (axIdItem) {
            WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_LineChart = WriteCT_LineChart;
function WriteCT_Line3DChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var grouping = instance.grouping, varyColors = instance.varyColors, dLbls = instance.dLbls, dropLines = instance.dropLines, gapDepth = instance.gapDepth, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(grouping)) {
            WriteCT_Grouping(writer, CONST_C, CONST_GROUPING, grouping);
        }
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_LineSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(dropLines)) {
            WriteCT_ChartLines(writer, CONST_C, CONST_DROP_LINES, dropLines);
        }
        if (!common_1._isNullOrUndefined(gapDepth)) {
            WriteCT_GapAmount(writer, CONST_C, "gapDepth", gapDepth);
        }
        writeArrayItem(instance.axId, function (axIdItem) {
            WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Line3DChart = WriteCT_Line3DChart;
function WriteCT_StockChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var dLbls = instance.dLbls, dropLines = instance.dropLines, hiLowLines = instance.hiLowLines, upDownBars = instance.upDownBars, extLst = instance.extLst;
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_LineSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(dropLines)) {
            WriteCT_ChartLines(writer, CONST_C, CONST_DROP_LINES, dropLines);
        }
        if (!common_1._isNullOrUndefined(hiLowLines)) {
            WriteCT_ChartLines(writer, CONST_C, "hiLowLines", hiLowLines);
        }
        if (!common_1._isNullOrUndefined(upDownBars)) {
            WriteCT_UpDownBars(writer, CONST_C, "upDownBars", upDownBars);
        }
        writeArrayItem(instance.axId, function (axIdItem) {
            WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_StockChart = WriteCT_StockChart;
function WriteCT_ScatterStyle(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 3, chart_model_1.Charts.ST_ScatterStyle);
}
exports.DrawingWriter.WriteCT_ScatterStyle = WriteCT_ScatterStyle;
function WriteCT_ScatterChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var scatterStyle = instance.scatterStyle, varyColors = instance.varyColors, dLbls = instance.dLbls, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(scatterStyle)) {
            var value = scatterStyle;
            if (value === 1 || value === 3) {
                scatterStyle = 2;
            }
            else if (value === 4) {
                scatterStyle = 5;
            }
            WriteCT_ScatterStyle(writer, CONST_C, "scatterStyle", scatterStyle);
        }
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_ScatterSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        writeArrayItem(instance.axId, function (axIdItem) {
            WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_ScatterChart = WriteCT_ScatterChart;
function WriteCT_RadarStyle(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0, chart_model_1.Charts.ST_RadarStyle);
}
exports.DrawingWriter.WriteCT_RadarStyle = WriteCT_RadarStyle;
function WriteCT_RadarChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var radarStyle = instance.radarStyle, varyColors = instance.varyColors, dLbls = instance.dLbls, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(radarStyle)) {
            WriteCT_RadarStyle(writer, CONST_C, "radarStyle", radarStyle);
        }
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_RadarSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        writeArrayItem(instance.axId, function (axIdItem) {
            WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_RadarChart = WriteCT_RadarChart;
function WriteCT_BarGrouping(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_BarGrouping);
}
exports.DrawingWriter.WriteCT_BarGrouping = WriteCT_BarGrouping;
function WriteCT_BarDir(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_BarDir);
}
exports.DrawingWriter.WriteCT_BarDir = WriteCT_BarDir;
function WriteCT_ShapeBox(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 2, chart_model_1.Charts.ST_Shape);
}
exports.DrawingWriter.WriteCT_ShapeBox = WriteCT_ShapeBox;
function WriteCT_BarChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var barDir = instance.barDir, grouping = instance.grouping, varyColors = instance.varyColors, dLbls = instance.dLbls, gapWidth = instance.gapWidth, overlap = instance.overlap, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(barDir)) {
            WriteCT_BarDir(writer, CONST_C, "barDir", barDir);
        }
        if (!common_1._isNullOrUndefined(grouping)) {
            WriteCT_BarGrouping(writer, CONST_C, CONST_GROUPING, grouping);
        }
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_BarSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(gapWidth)) {
            WriteCT_GapAmount(writer, CONST_C, CONST_GAP_WIDTH, gapWidth);
        }
        if (!common_1._isNullOrUndefined(overlap)) {
            WriteCT_Overlap(writer, CONST_C, "overlap", overlap);
        }
        writeArrayItem(instance.serLines, function (serLinesItem) {
            WriteCT_ChartLines(writer, CONST_C, "serLines", serLinesItem);
        });
        writeArrayItem(instance.axId, function (axIdItem) {
            WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_BarChart = WriteCT_BarChart;
function WriteCT_Bar3DChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var barDir = instance.barDir, grouping = instance.grouping, varyColors = instance.varyColors, dLbls = instance.dLbls, gapWidth = instance.gapWidth, gapDepth = instance.gapDepth, shape = instance.shape, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(barDir)) {
            WriteCT_BarDir(writer, CONST_C, "barDir", barDir);
        }
        if (!common_1._isNullOrUndefined(grouping)) {
            WriteCT_BarGrouping(writer, CONST_C, CONST_GROUPING, grouping);
        }
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_BarSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(gapWidth)) {
            WriteCT_GapAmount(writer, CONST_C, CONST_GAP_WIDTH, gapWidth);
        }
        if (!common_1._isNullOrUndefined(gapDepth)) {
            WriteCT_GapAmount(writer, CONST_C, "gapDepth", gapDepth);
        }
        if (!common_1._isNullOrUndefined(shape)) {
            WriteCT_ShapeBox(writer, CONST_C, "shape", shape);
        }
        writeArrayItem(instance.axId, function (axIdItem) {
            WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Bar3DChart = WriteCT_Bar3DChart;
function WriteCT_AreaChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var grouping = instance.grouping, varyColors = instance.varyColors, dLbls = instance.dLbls, dropLines = instance.dropLines, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(grouping)) {
            WriteCT_Grouping(writer, CONST_C, CONST_GROUPING, grouping);
        }
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_AreaSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(dropLines)) {
            WriteCT_ChartLines(writer, CONST_C, CONST_DROP_LINES, dropLines);
        }
        writeArrayItem(instance.axId, function (axIdItem) {
            WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_AreaChart = WriteCT_AreaChart;
function WriteCT_Area3DChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var grouping = instance.grouping, varyColors = instance.varyColors, dLbls = instance.dLbls, dropLines = instance.dropLines, gapDepth = instance.gapDepth, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(grouping)) {
            WriteCT_Grouping(writer, CONST_C, CONST_GROUPING, grouping);
        }
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_AreaSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(dropLines)) {
            WriteCT_ChartLines(writer, CONST_C, CONST_DROP_LINES, dropLines);
        }
        if (!common_1._isNullOrUndefined(gapDepth)) {
            WriteCT_GapAmount(writer, CONST_C, "gapDepth", gapDepth);
        }
        writeArrayItem(instance.axId, function (axIdItem) {
            WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Area3DChart = WriteCT_Area3DChart;
function WriteCT_PieChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var varyColors = instance.varyColors, dLbls = instance.dLbls, firstSliceAng = instance.firstSliceAng, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_PieSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(firstSliceAng)) {
            WriteCT_FirstSliceAng(writer, CONST_C, "firstSliceAng", firstSliceAng);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_PieChart = WriteCT_PieChart;
function WriteCT_Pie3DChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var varyColors = instance.varyColors, dLbls = instance.dLbls, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_PieSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Pie3DChart = WriteCT_Pie3DChart;
function WriteCT_DoughnutChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var varyColors = instance.varyColors, dLbls = instance.dLbls, firstSliceAng = instance.firstSliceAng, holeSize = instance.holeSize, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_PieSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(firstSliceAng)) {
            WriteCT_FirstSliceAng(writer, CONST_C, "firstSliceAng", firstSliceAng);
        }
        if (!common_1._isNullOrUndefined(holeSize)) {
            WriteCT_HoleSize(writer, CONST_C, "holeSize", holeSize);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_DoughnutChart = WriteCT_DoughnutChart;
function WriteCT_OfPieType(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_OfPieType);
}
exports.DrawingWriter.WriteCT_OfPieType = WriteCT_OfPieType;
function WriteCT_OfPieChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var ofPieType = instance.ofPieType, varyColors = instance.varyColors, dLbls = instance.dLbls, gapWidth = instance.gapWidth, splitType = instance.splitType, splitPos = instance.splitPos, custSplit = instance.custSplit, secondPieSize = instance.secondPieSize, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(ofPieType)) {
            WriteCT_OfPieType(writer, CONST_C, "ofPieType", ofPieType);
        }
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_PieSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(gapWidth)) {
            WriteCT_GapAmount(writer, CONST_C, CONST_GAP_WIDTH, gapWidth);
        }
        if (!common_1._isNullOrUndefined(splitType)) {
            WriteCT_SplitType(writer, CONST_C, "splitType", splitType);
        }
        if (!common_1._isNullOrUndefined(splitPos)) {
            WriteCT_Double(writer, CONST_C, "splitPos", splitPos);
        }
        if (!common_1._isNullOrUndefined(custSplit)) {
            WriteCT_CustSplit(writer, CONST_C, "custSplit", custSplit);
        }
        if (!common_1._isNullOrUndefined(secondPieSize)) {
            WriteCT_SecondPieSize(writer, CONST_C, "secondPieSize", secondPieSize);
        }
        writeArrayItem(instance.serLines, function (serLinesItem) {
            WriteCT_ChartLines(writer, CONST_C, "serLines", serLinesItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_OfPieChart = WriteCT_OfPieChart;
function WriteCT_BubbleChart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var varyColors = instance.varyColors, dLbls = instance.dLbls, bubble3D = instance.bubble3D, bubbleScale = instance.bubbleScale, showNegBubbles = instance.showNegBubbles, sizeRepresents = instance.sizeRepresents, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(varyColors)) {
            WriteCT_Boolean(writer, CONST_C, CONST_VARY_COLORS, varyColors);
        }
        writeArrayItem(instance.ser, function (seriesItem) {
            WriteCT_BubbleSer(writer, CONST_C, CONST_SER, seriesItem);
        });
        if (!common_1._isNullOrUndefined(dLbls)) {
            WriteCT_DLbls(writer, CONST_C, COSNT_DLBLS, dLbls);
        }
        if (!common_1._isNullOrUndefined(bubble3D)) {
            WriteCT_Boolean(writer, CONST_C, CONST_BUBBLE_3D, bubble3D);
        }
        if (!common_1._isNullOrUndefined(bubbleScale)) {
            WriteCT_BubbleScale(writer, CONST_C, "bubbleScale", bubbleScale);
        }
        if (!common_1._isNullOrUndefined(showNegBubbles)) {
            WriteCT_Boolean(writer, CONST_C, "showNegBubbles", showNegBubbles);
        }
        if (!common_1._isNullOrUndefined(sizeRepresents)) {
            WriteCT_SizeRepresents(writer, CONST_C, "sizeRepresents", sizeRepresents);
        }
        writeArrayItem(instance.axId, function (axIdItem) {
            WriteCT_Int(writer, CONST_C, CONST_AXID, axIdItem);
        });
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_BubbleChart = WriteCT_BubbleChart;
function WriteCT_BandFmt(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.idx)) {
            WriteCT_UnsignedInt(writer, CONST_C, "idx", instance.idx);
        }
        if (!common_1._isNullOrUndefined(instance.spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, instance.spPr);
        }
    });
}
exports.DrawingWriter.WriteCT_BandFmt = WriteCT_BandFmt;
function WriteCT_BandFmts(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.bandFmt, function (bandFmtItem) {
            WriteCT_BandFmt(writer, CONST_C, "bandFmt", bandFmtItem);
        });
    });
}
exports.DrawingWriter.WriteCT_BandFmts = WriteCT_BandFmts;
function WriteCT_SurfaceChart(writer, prefix, localName, instance) {
    writeSurfaceChartSubElement(writer, prefix, localName, instance);
}
exports.DrawingWriter.WriteCT_SurfaceChart = WriteCT_SurfaceChart;
function WriteCT_Surface3DChart(writer, prefix, localName, instance) {
    writeSurfaceChartSubElement(writer, prefix, localName, instance);
}
exports.DrawingWriter.WriteCT_Surface3DChart = WriteCT_Surface3DChart;
function WriteCT_AxPos(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_AxPos);
}
exports.DrawingWriter.WriteCT_AxPos = WriteCT_AxPos;
function WriteCT_Crosses(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_Crosses, chart_helper_1.ChartHelper.ToST_Crosses);
}
exports.DrawingWriter.WriteCT_Crosses = WriteCT_Crosses;
function WriteCT_CrossBetween(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_CrossBetween);
}
exports.DrawingWriter.WriteCT_CrossBetween = WriteCT_CrossBetween;
function WriteCT_TickMark(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 0, chart_model_1.Charts.ST_TickMark);
}
exports.DrawingWriter.WriteCT_TickMark = WriteCT_TickMark;
function WriteCT_TickLblPos(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_TickLblPos);
}
exports.DrawingWriter.WriteCT_TickLblPos = WriteCT_TickLblPos;
function WriteCT_Skip(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_Skip = WriteCT_Skip;
function WriteCT_TimeUnit(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_TimeUnit);
}
exports.DrawingWriter.WriteCT_TimeUnit = WriteCT_TimeUnit;
function WriteCT_AxisUnit(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_AxisUnit = WriteCT_AxisUnit;
function WriteCT_BuiltInUnit(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_BuiltInUnit, chart_helper_1.ChartHelper.ToST_BuiltInUnit);
}
exports.DrawingWriter.WriteCT_BuiltInUnit = WriteCT_BuiltInUnit;
function WriteCT_PictureFormat(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_PictureFormat);
}
exports.DrawingWriter.WriteCT_PictureFormat = WriteCT_PictureFormat;
function WriteCT_PictureStackUnit(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_PictureStackUnit = WriteCT_PictureStackUnit;
function WriteCT_PictureOptions(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var applyToFront = instance.applyToFront, applyToSides = instance.applyToSides, applyToEnd = instance.applyToEnd, pictureFormat = instance.pictureFormat, pictureStackUnit = instance.pictureStackUnit;
        if (!common_1._isNullOrUndefined(applyToFront)) {
            WriteCT_Boolean(writer, CONST_C, "applyToFront", applyToFront);
        }
        if (!common_1._isNullOrUndefined(applyToSides)) {
            WriteCT_Boolean(writer, CONST_C, "applyToSides", applyToSides);
        }
        if (!common_1._isNullOrUndefined(applyToEnd)) {
            WriteCT_Boolean(writer, CONST_C, "applyToEnd", applyToEnd);
        }
        if (!common_1._isNullOrUndefined(pictureFormat)) {
            WriteCT_PictureFormat(writer, CONST_C, "pictureFormat", pictureFormat);
        }
        if (!common_1._isNullOrUndefined(pictureStackUnit)) {
            WriteCT_PictureStackUnit(writer, CONST_C, "pictureStackUnit", pictureStackUnit);
        }
    });
}
exports.DrawingWriter.WriteCT_PictureOptions = WriteCT_PictureOptions;
function WriteCT_DispUnitsLbl(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var layout = instance.layout, tx = instance.tx, spPr = instance.spPr, txPr = instance.txPr;
        if (!common_1._isNullOrUndefined(layout)) {
            WriteCT_Layout(writer, CONST_C, CONST_LAYOUT, layout);
        }
        if (!common_1._isNullOrUndefined(tx)) {
            WriteCT_Tx(writer, CONST_C, "tx", tx);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(txPr)) {
            WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
        }
    });
}
exports.DrawingWriter.WriteCT_DispUnitsLbl = WriteCT_DispUnitsLbl;
function WriteCT_DispUnits(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var custUnit = instance.custUnit, builtInUnit = instance.builtInUnit, dispUnitsLbl = instance.dispUnitsLbl, extLst = instance.extLst, visible = instance.visible;
        if (!common_1._isNullOrUndefined(custUnit)) {
            WriteCT_Double(writer, CONST_C, "custUnit", custUnit);
        }
        else if (!common_1._isNullOrUndefined(builtInUnit)) {
            WriteCT_BuiltInUnit(writer, CONST_C, "builtInUnit", builtInUnit);
        }
        if (!common_1._isNullOrUndefined(dispUnitsLbl) && visible) {
            WriteCT_DispUnitsLbl(writer, CONST_C, "dispUnitsLbl", dispUnitsLbl);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_DispUnits = WriteCT_DispUnits;
function WriteCT_Orientation(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_Orientation);
}
exports.DrawingWriter.WriteCT_Orientation = WriteCT_Orientation;
function WriteCT_LogBase(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_LogBase = WriteCT_LogBase;
function WriteCT_Scaling(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var logBase = instance.logBase, orientation = instance.orientation, max = instance.max, min = instance.min, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(logBase)) {
            WriteCT_LogBase(writer, CONST_C, "logBase", logBase);
        }
        if (!common_1._isNullOrUndefined(orientation)) {
            WriteCT_Orientation(writer, CONST_C, "orientation", orientation);
        }
        if (!common_1._isNullOrUndefined(max)) {
            WriteCT_Double(writer, CONST_C, "max", max);
        }
        if (!common_1._isNullOrUndefined(min)) {
            WriteCT_Double(writer, CONST_C, "min", min);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Scaling = WriteCT_Scaling;
function WriteCT_LblOffset(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, 100);
}
exports.DrawingWriter.WriteCT_LblOffset = WriteCT_LblOffset;
function WriteCT_CatAx(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var auto = instance.auto, lblAlgn = instance.lblAlgn, lblOffset = instance.lblOffset, tickLblSkip = instance.tickLblSkip, tickMarkSkip = instance.tickMarkSkip, noMultiLvlLbl = instance.noMultiLvlLbl, extLst = instance.extLst;
        writeAxisSubElement(writer, instance);
        if (!common_1._isNullOrUndefined(auto)) {
            WriteCT_Boolean(writer, CONST_C, "auto", auto);
        }
        if (!common_1._isNullOrUndefined(lblAlgn)) {
            WriteCT_LblAlgn(writer, CONST_C, "lblAlgn", lblAlgn);
        }
        if (!common_1._isNullOrUndefined(lblOffset)) {
            WriteCT_LblOffset(writer, CONST_C, "lblOffset", lblOffset);
        }
        if (!common_1._isNullOrUndefined(tickLblSkip)) {
            WriteCT_Skip(writer, CONST_C, "tickLblSkip", tickLblSkip);
        }
        if (!common_1._isNullOrUndefined(tickMarkSkip)) {
            WriteCT_Skip(writer, CONST_C, "tickMarkSkip", tickMarkSkip);
        }
        if (!common_1._isNullOrUndefined(noMultiLvlLbl)) {
            WriteCT_Boolean(writer, CONST_C, "noMultiLvlLbl", noMultiLvlLbl);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_CatAx = WriteCT_CatAx;
function WriteCT_DateAx(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var auto = instance.auto, lblOffset = instance.lblOffset, baseTimeUnit = instance.baseTimeUnit, majorUnit = instance.majorUnit, majorTimeUnit = instance.majorTimeUnit, minorUnit = instance.minorUnit, minorTimeUnit = instance.minorTimeUnit, extLst = instance.extLst;
        writeAxisSubElement(writer, instance);
        if (!common_1._isNullOrUndefined(auto)) {
            WriteCT_Boolean(writer, CONST_C, "auto", auto);
        }
        if (!common_1._isNullOrUndefined(lblOffset)) {
            WriteCT_LblOffset(writer, CONST_C, "lblOffset", lblOffset);
        }
        if (!common_1._isNullOrUndefined(baseTimeUnit)) {
            WriteCT_TimeUnit(writer, CONST_C, "baseTimeUnit", baseTimeUnit);
        }
        if (!common_1._isNullOrUndefined(majorUnit)) {
            WriteCT_AxisUnit(writer, CONST_C, "majorUnit", majorUnit);
        }
        if (!common_1._isNullOrUndefined(majorTimeUnit)) {
            WriteCT_TimeUnit(writer, CONST_C, "majorTimeUnit", majorTimeUnit);
        }
        if (!common_1._isNullOrUndefined(minorUnit)) {
            WriteCT_AxisUnit(writer, CONST_C, "minorUnit", minorUnit);
        }
        if (!common_1._isNullOrUndefined(minorTimeUnit)) {
            WriteCT_TimeUnit(writer, CONST_C, "minorTimeUnit", minorTimeUnit);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_DateAx = WriteCT_DateAx;
function WriteCT_SerAx(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var tickLblSkip = instance.tickLblSkip, tickMarkSkip = instance.tickMarkSkip, extLst = instance.extLst;
        writeAxisSubElement(writer, instance);
        if (!common_1._isNullOrUndefined(tickLblSkip)) {
            WriteCT_Skip(writer, CONST_C, "tickLblSkip", tickLblSkip);
        }
        if (!common_1._isNullOrUndefined(tickMarkSkip)) {
            WriteCT_Skip(writer, CONST_C, "tickMarkSkip", tickMarkSkip);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_SerAx = WriteCT_SerAx;
function WriteCT_ValAx(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var crossBetween = instance.crossBetween, majorUnit = instance.majorUnit, minorUnit = instance.minorUnit, dispUnits = instance.dispUnits, extLst = instance.extLst;
        writeAxisSubElement(writer, instance);
        if (!common_1._isNullOrUndefined(crossBetween)) {
            WriteCT_CrossBetween(writer, CONST_C, "crossBetween", crossBetween);
        }
        if (!common_1._isNullOrUndefined(majorUnit)) {
            WriteCT_AxisUnit(writer, CONST_C, "majorUnit", majorUnit);
        }
        if (!common_1._isNullOrUndefined(minorUnit)) {
            WriteCT_AxisUnit(writer, CONST_C, "minorUnit", minorUnit);
        }
        if (!common_1._isNullOrUndefined(dispUnits)) {
            WriteCT_DispUnits(writer, CONST_C, "dispUnits", dispUnits);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_ValAx = WriteCT_ValAx;
function WriteCT_PlotArea(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var layout = instance.layout, dTable = instance.dTable, spPr = instance.spPr, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(layout)) {
            WriteCT_Layout(writer, CONST_C, CONST_LAYOUT, layout);
        }
        writeArrayItem(instance.chartGroups, function (chart) {
            var chartType = chart.chartType;
            if (chartType === 4) {
                WriteCT_AreaChart(writer, CONST_C, "areaChart", chart);
            }
            else if (chartType === 5) {
                WriteCT_Area3DChart(writer, CONST_C, "area3DChart", chart);
            }
            else if (chartType === 6) {
                WriteCT_BarChart(writer, CONST_C, "barChart", chart);
            }
            else if (chartType === 7) {
                WriteCT_Bar3DChart(writer, CONST_C, "bar3DChart", chart);
            }
            else if (chartType === 8) {
                WriteCT_LineChart(writer, CONST_C, "lineChart", chart);
            }
            else if (chartType === 9) {
                WriteCT_Line3DChart(writer, CONST_C, "line3DChart", chart);
            }
            else if (chartType === 0) {
                WriteCT_StockChart(writer, CONST_C, "stockChart", chart);
            }
            else if (chartType === 2) {
                WriteCT_RadarChart(writer, CONST_C, "radarChart", chart);
            }
            else if (chartType === 1) {
                WriteCT_ScatterChart(writer, CONST_C, "scatterChart", chart);
            }
            else if (chartType === 10) {
                WriteCT_PieChart(writer, CONST_C, "pieChart", chart);
            }
            else if (chartType === 11) {
                WriteCT_Pie3DChart(writer, CONST_C, "pie3DChart", chart);
            }
            else if (chartType === 12) {
                WriteCT_DoughnutChart(writer, CONST_C, "doughnutChart", chart);
            }
            else if (chartType === 13) {
                WriteCT_OfPieChart(writer, CONST_C, "ofPieChart", chart);
            }
            else if (chartType === 14) {
                WriteCT_SurfaceChart(writer, CONST_C, "surfaceChart", chart);
            }
            else if (chartType === 15) {
                WriteCT_Surface3DChart(writer, CONST_C, "surface3DChart", chart);
            }
            else if (chartType === 3) {
                WriteCT_BubbleChart(writer, CONST_C, "bubbleChart", chart);
            }
        });
        var axes = instance.axes;
        if (axes) {
            var primeCatAx = axes.filter(function (item) {
                return item.AxisGroup === 0 && item.AxisType === 0;
            })[0];
            if (primeCatAx) {
                if (primeCatAx.axisType === 0) {
                    WriteCT_CatAx(writer, CONST_C, "catAx", primeCatAx);
                }
                else if (primeCatAx.axisType === 1) {
                    WriteCT_DateAx(writer, CONST_C, "dateAx", primeCatAx);
                }
                else if (primeCatAx.axisType === 3) {
                    WriteCT_ValAx(writer, CONST_C, "valAx", primeCatAx);
                }
            }
            var primeValAx = axes.filter(function (item) {
                return item.AxisGroup === 0 && item.AxisType === 1;
            })[0];
            if (!common_1._isNullOrUndefined(primeValAx)) {
                WriteCT_ValAx(writer, CONST_C, "valAx", primeValAx);
            }
            var secondValAx = axes.filter(function (item) {
                return item.AxisGroup === 1 && item.AxisType === 1;
            })[0];
            if (!common_1._isNullOrUndefined(secondValAx)) {
                WriteCT_ValAx(writer, CONST_C, "valAx", secondValAx);
            }
            var secondCatAx = axes.filter(function (item) {
                return item.AxisGroup === 1 && item.AxisType === 0;
            })[0];
            if (secondCatAx) {
                if (secondCatAx.axisType === 0) {
                    WriteCT_CatAx(writer, CONST_C, "catAx", secondCatAx);
                }
                else if (secondCatAx.axisType === 1) {
                    WriteCT_DateAx(writer, CONST_C, "dateAx", secondCatAx);
                }
                else if (secondCatAx.axisType === 3) {
                    WriteCT_ValAx(writer, CONST_C, "valAx", secondCatAx);
                }
            }
            var serAx = axes.filter(function (item) {
                return item.axisType === 2;
            });
            writeArrayItem(serAx, function (item) {
                WriteCT_SerAx(writer, CONST_C, "serAx", item);
            });
        }
        if (!common_1._isNullOrUndefined(dTable)) {
            WriteCT_DTable(writer, CONST_C, "dTable", dTable);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_PlotArea = WriteCT_PlotArea;
function WriteCT_PivotFmt(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var idx = instance.idx, spPr = instance.spPr, txPr = instance.txPr, marker = instance.marker, dLbl = instance.dLbl, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(idx)) {
            WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(txPr)) {
            WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
        }
        if (!common_1._isNullOrUndefined(marker)) {
            WriteCT_Marker(writer, CONST_C, CONST_MARKER, marker);
        }
        if (!common_1._isNullOrUndefined(dLbl)) {
            WriteCT_DLbl(writer, CONST_C, "dLbl", dLbl);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_PivotFmt = WriteCT_PivotFmt;
function WriteCT_PivotFmts(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.pivotFmt, function (pivotFmtItem) {
            WriteCT_PivotFmt(writer, CONST_C, "pivotFmt", pivotFmtItem);
        });
    });
}
exports.DrawingWriter.WriteCT_PivotFmts = WriteCT_PivotFmts;
function WriteCT_LegendPos(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_LegendPos, chart_helper_1.ChartHelper.ToST_LegendPos);
}
exports.DrawingWriter.WriteCT_LegendPos = WriteCT_LegendPos;
function WriteCT_LegendEntry(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var idx = instance.idx, deleteField = instance.delete, txPr = instance.txPr, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(idx)) {
            WriteCT_UnsignedInt(writer, CONST_C, "idx", idx);
        }
        if (!common_1._isNullOrUndefined(deleteField)) {
            WriteCT_Boolean(writer, CONST_C, CONST_DELETE, deleteField);
        }
        if (!common_1._isNullOrUndefined(txPr)) {
            WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_LegendEntry = WriteCT_LegendEntry;
function WriteCT_Legend(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var legendPos = instance.legendPos, layout = instance.layout, overlay = instance.overlay || false, spPr = instance.spPr, txPr = instance.txPr, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(legendPos)) {
            WriteCT_LegendPos(writer, CONST_C, "legendPos", legendPos);
        }
        writeArrayItem(instance.legendEntry, function (legendEntryItem) {
            WriteCT_LegendEntry(writer, CONST_C, "legendEntry", legendEntryItem);
        });
        if (!common_1._isNullOrUndefined(layout)) {
            WriteCT_Layout(writer, CONST_C, CONST_LAYOUT, layout);
        }
        WriteCT_Boolean(writer, CONST_C, "overlay", overlay);
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(txPr)) {
            WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Legend = WriteCT_Legend;
function WriteCT_DispBlanksAs(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, null, chart_model_1.Charts.ST_DispBlanksAs);
}
exports.DrawingWriter.WriteCT_DispBlanksAs = WriteCT_DispBlanksAs;
function WriteCT_DispNaAsBlank(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("xmlns:c16", exports.DrawingWriter.c16);
    }, function () {
        if (!common_1._isNullOrUndefined(instance.dispNaAsBlank)) {
            writer.writeLeafElement(prefix + ":" + "dispNaAsBlank", function () {
                writer.writeAttributeString(CONST_VAL, instance.dispNaAsBlank ? "1" : "0");
            });
        }
    });
}
exports.DrawingWriter.WriteCT_DispNaAsBlank = WriteCT_DispNaAsBlank;
function WriteCT_Chart(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var title = instance.title, autoTitleDeleted = instance.autoTitleDeleted, view3D = instance.view3D, floor = instance.floor, sideWall = instance.sideWall, backWall = instance.backWall, plotArea = instance.plotArea, legend = instance.legend, plotVisOnly = instance.plotVisOnly, dispBlanksAs = instance.dispBlanksAs, showDLblsOverMax = instance.showDLblsOverMax, extLst = instance.extLst, pivotFmts = instance.pivotFmts;
        if (!common_1._isNullOrUndefined(title)) {
            WriteCT_Title(writer, CONST_C, CONST_TITLE, title);
        }
        if (!common_1._isNullOrUndefined(autoTitleDeleted)) {
            WriteCT_Boolean(writer, CONST_C, "autoTitleDeleted", autoTitleDeleted);
        }
        if (!common_1._isNullOrUndefined(pivotFmts)) {
            var count_1 = pivotFmts.length;
            if (count_1 > 0) {
                writer.writeElement("c:pivotFmts", function () {
                    for (var i = 0; i < count_1; i++) {
                        var pivotFmtsItems = pivotFmts[i].pivotFmt;
                        if (!common_1._isNullOrUndefined(pivotFmtsItems)) {
                            for (var j = 0; j < pivotFmtsItems.length; j++) {
                                var pivotFmtsItem = pivotFmtsItems[i];
                                if (!common_1._isNullOrUndefined(pivotFmtsItem)) {
                                    WriteCT_PivotFmt(writer, CONST_C, "pivotFmt", pivotFmtsItem);
                                }
                            }
                        }
                    }
                });
            }
        }
        if (!common_1._isNullOrUndefined(view3D)) {
            WriteCT_View3D(writer, CONST_C, "view3D", view3D);
        }
        if (!common_1._isNullOrUndefined(floor)) {
            WriteCT_Surface(writer, CONST_C, "floor", floor);
        }
        if (!common_1._isNullOrUndefined(sideWall)) {
            WriteCT_Surface(writer, CONST_C, "sideWall", sideWall);
        }
        if (!common_1._isNullOrUndefined(backWall)) {
            WriteCT_Surface(writer, CONST_C, "backWall", backWall);
        }
        if (!common_1._isNullOrUndefined(plotArea)) {
            WriteCT_PlotArea(writer, CONST_C, "plotArea", plotArea);
        }
        if (!common_1._isNullOrUndefined(legend)) {
            WriteCT_Legend(writer, CONST_C, "legend", legend);
        }
        if (!common_1._isNullOrUndefined(plotVisOnly)) {
            WriteCT_Boolean(writer, CONST_C, "plotVisOnly", plotVisOnly);
        }
        if (!common_1._isNullOrUndefined(dispBlanksAs)) {
            WriteCT_DispBlanksAs(writer, CONST_C, "dispBlanksAs", dispBlanksAs);
        }
        if (!common_1._isNullOrUndefined(showDLblsOverMax)) {
            WriteCT_Boolean(writer, CONST_C, "showDLblsOverMax", showDLblsOverMax);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Chart = WriteCT_Chart;
function WriteCT_Style(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_Style = WriteCT_Style;
function WriteCT_PivotSource(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.name)) {
            writer.writeElementString("c:name", instance.name);
        }
        var fmtId = instance.fmtId;
        if (!common_1._isNullOrUndefined(fmtId)) {
            WriteCT_UnsignedInt(writer, CONST_C, "fmtId", fmtId);
        }
        writeArrayItem(instance.extLst, function (extLstItem) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLstItem);
        });
    });
}
exports.DrawingWriter.WriteCT_PivotSource = WriteCT_PivotSource;
function WriteCT_Protection(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var chartObject = instance.chartObject, data = instance.data, formatting = instance.formatting, selection = instance.selection, userInterface = instance.userInterface;
        if (!common_1._isNullOrUndefined(chartObject)) {
            WriteCT_Boolean(writer, CONST_C, "chartObject", chartObject);
        }
        if (!common_1._isNullOrUndefined(data)) {
            WriteCT_Boolean(writer, CONST_C, "data", data);
        }
        if (!common_1._isNullOrUndefined(formatting)) {
            WriteCT_Boolean(writer, CONST_C, "formatting", formatting);
        }
        if (!common_1._isNullOrUndefined(selection)) {
            WriteCT_Boolean(writer, CONST_C, "selection", selection);
        }
        if (!common_1._isNullOrUndefined(userInterface)) {
            WriteCT_Boolean(writer, CONST_C, "userInterface", userInterface);
        }
    });
}
exports.DrawingWriter.WriteCT_Protection = WriteCT_Protection;
function WriteCT_HeaderFooter(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (instance.alignWithMargins === false) {
            writer.writeAttributeString("alignWithMargins", "0");
        }
        if (instance.differentOddEven === true) {
            writer.writeAttributeString("differentOddEven", "1");
        }
        if (instance.differentFirst === true) {
            writer.writeAttributeString("differentFirst", "1");
        }
    }, function () {
        var oddHeader = instance.oddHeader, oddFooter = instance.oddFooter, evenHeader = instance.evenHeader, evenFooter = instance.evenFooter, firstHeader = instance.firstHeader, firstFooter = instance.firstFooter;
        if (!common_1._isNullOrUndefined(oddHeader)) {
            writer.writeElementString("c:oddHeader", oddHeader);
        }
        if (!common_1._isNullOrUndefined(oddFooter)) {
            writer.writeElementString("c:oddFooter", oddFooter);
        }
        if (!common_1._isNullOrUndefined(evenHeader)) {
            writer.writeElementString("c:evenHeader", evenHeader);
        }
        if (!common_1._isNullOrUndefined(evenFooter)) {
            writer.writeElementString("c:evenFooter", evenFooter);
        }
        if (!common_1._isNullOrUndefined(firstHeader)) {
            writer.writeElementString("c:firstHeader", firstHeader);
        }
        if (!common_1._isNullOrUndefined(firstFooter)) {
            writer.writeElementString("c:firstFooter", firstFooter);
        }
    });
}
exports.DrawingWriter.WriteCT_HeaderFooter = WriteCT_HeaderFooter;
function WriteCT_PageMargins(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var header = instance.header, footer = instance.footer;
        if (!common_1._isNullOrUndefined(instance.l)) {
            writer.writeAttributeString("l", instance.l);
        }
        if (!common_1._isNullOrUndefined(instance.r)) {
            writer.writeAttributeString(CONST_R, instance.r);
        }
        if (!common_1._isNullOrUndefined(instance.t)) {
            writer.writeAttributeString("t", instance.t);
        }
        if (!common_1._isNullOrUndefined(instance.b)) {
            writer.writeAttributeString("b", instance.b);
        }
        if (!common_1._isNullOrUndefined(header)) {
            writer.writeAttributeString("header", header);
        }
        if (!common_1._isNullOrUndefined(footer)) {
            writer.writeAttributeString("footer", footer);
        }
    });
}
exports.DrawingWriter.WriteCT_PageMargins = WriteCT_PageMargins;
function WriteCT_ExternalData(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.id)) {
            writer.writeAttributeString("id", instance.id);
        }
    }, function () {
        var autoUpdate = instance.autoUpdate;
        if (!common_1._isNullOrUndefined(autoUpdate)) {
            WriteCT_Boolean(writer, CONST_C, "autoUpdate", autoUpdate);
        }
    });
}
exports.DrawingWriter.WriteCT_ExternalData = WriteCT_ExternalData;
function WriteCT_PageSetup(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var paperSize = instance.paperSize, firstPageNumber = instance.firstPageNumber, orientation = instance.orientation, horizontalDpi = instance.horizontalDpi, verticalDpi = instance.verticalDpi, copies = instance.copies;
        if (!common_1._isNullOrUndefined(paperSize) && paperSize !== 1) {
            writer.writeAttributeString("paperSize", paperSize);
        }
        if (!common_1._isNullOrUndefined(firstPageNumber) && firstPageNumber !== 1) {
            writer.writeAttributeString("firstPageNumber", firstPageNumber);
        }
        if (!common_1._isNullOrUndefined(orientation) && orientation !== 0) {
            writer.writeAttributeString("orientation", chart_model_1.Charts.ST_PageSetupOrientation[orientation]);
        }
        if (instance.blackAndWhite === true) {
            writer.writeAttributeString("blackAndWhite", "1");
        }
        if (instance.draft === true) {
            writer.writeAttributeString("draft", "1");
        }
        if (instance.useFirstPageNumber === true) {
            writer.writeAttributeString("useFirstPageNumber", "1");
        }
        if (!common_1._isNullOrUndefined(horizontalDpi) && horizontalDpi !== 600) {
            writer.writeAttributeString("horizontalDpi", horizontalDpi);
        }
        if (!common_1._isNullOrUndefined(verticalDpi) && verticalDpi !== 600) {
            writer.writeAttributeString("verticalDpi", verticalDpi);
        }
        if (!common_1._isNullOrUndefined(copies) && copies !== 1) {
            writer.writeAttributeString("copies", copies);
        }
    });
}
exports.DrawingWriter.WriteCT_PageSetup = WriteCT_PageSetup;
function WriteCT_PrintSettings(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var headerFooter = instance.headerFooter, pageMargins = instance.pageMargins, pageSetup = instance.pageSetup, legacyDrawingHF = instance.legacyDrawingHF;
        if (!common_1._isNullOrUndefined(headerFooter)) {
            WriteCT_HeaderFooter(writer, CONST_C, "headerFooter", headerFooter);
        }
        if (!common_1._isNullOrUndefined(pageMargins)) {
            WriteCT_PageMargins(writer, CONST_C, "pageMargins", pageMargins);
        }
        if (!common_1._isNullOrUndefined(pageSetup)) {
            WriteCT_PageSetup(writer, CONST_C, "pageSetup", pageSetup);
        }
        if (!common_1._isNullOrUndefined(legacyDrawingHF)) {
            WriteCT_RelId(writer, CONST_C, "legacyDrawingHF", legacyDrawingHF);
        }
    });
}
exports.DrawingWriter.WriteCT_PrintSettings = WriteCT_PrintSettings;
function WriteCT_ChartSpace(writer, prefix, localName, instance) {
    writer.writeElement("c:" + localName, function () {
        writer.writeAttributeString("xmlns:c", exports.DrawingWriter.c);
        writer.writeAttributeString("xmlns:a", exports.DrawingWriter.a);
        writer.writeAttributeString("xmlns:r", exports.DrawingWriter.r);
    }, function () {
        var roundedCorners = instance.roundedCorners, style = instance.style, clrMapOvr = instance.clrMapOvr, pivotSource = instance.pivotSource, protection = instance.protection, chart = instance.chart, spPr = instance.spPr, txPr = instance.txPr, externalData = instance.externalData, printSettings = instance.printSettings, userShapes = instance.userShapes, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(roundedCorners)) {
            WriteCT_Boolean(writer, CONST_C, "roundedCorners", roundedCorners);
        }
        if (!common_1._isNullOrUndefined(style)) {
            WriteCT_Style(writer, CONST_C, CONST_STYLE, style);
        }
        if (!common_1._isNullOrUndefined(clrMapOvr)) {
            WriteCT_ColorMapping(writer, CONST_A, "clrMapOvr", clrMapOvr);
        }
        if (!common_1._isNullOrUndefined(pivotSource)) {
            WriteCT_PivotSource(writer, CONST_C, "pivotSource", pivotSource);
        }
        if (!common_1._isNullOrUndefined(protection)) {
            WriteCT_Protection(writer, CONST_C, "protection", protection);
        }
        if (!common_1._isNullOrUndefined(chart)) {
            WriteCT_Chart(writer, CONST_C, "chart", chart);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(txPr)) {
            WriteCT_TextBody(writer, CONST_C, CONST_TXPR, txPr);
        }
        if (!common_1._isNullOrUndefined(externalData)) {
            WriteCT_ExternalData(writer, CONST_C, "externalData", externalData);
        }
        if (!common_1._isNullOrUndefined(printSettings)) {
            WriteCT_PrintSettings(writer, CONST_C, "printSettings", printSettings);
        }
        if (!common_1._isNullOrUndefined(userShapes)) {
            WriteCT_UserShapes(writer, CONST_C, "userShapes", userShapes);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_ExtensionList(writer, CONST_C, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_ChartSpace = WriteCT_ChartSpace;
function WriteCT_DLblExtensionList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.ext, function (extItem) {
            WriteCT_DLblExt(writer, CONST_C, CONST_EXT, extItem);
        });
    });
}
exports.DrawingWriter.WriteCT_DLblExtensionList = WriteCT_DLblExtensionList;
function WriteCT_DLblExt(writer, prefix, localName, instance) {
    writer.writeElement("c:" + localName, function () {
        writer.writeAttributeString("xmlns:c15", exports.DrawingWriter.c15);
        if (!common_1._isNullOrUndefined(instance.uri)) {
            writer.writeAttributeString("uri", instance.uri);
        }
    }, function () {
        var layout = instance.layout, dlblFieldTable = instance.dlblFieldTable, showDataLabelsRange = instance.showDataLabelsRange;
        if (!common_1._isNullOrUndefined(layout)) {
            WriteCT_Layout(writer, CONST_C15, CONST_LAYOUT, layout);
        }
        if (!common_1._isNullOrUndefined(dlblFieldTable)) {
            WriteCT_DataLabelFieldTable(writer, CONST_C15, "dlblFieldTable", dlblFieldTable);
        }
        if (!common_1._isNullOrUndefined(showDataLabelsRange)) {
            WriteCT_Boolean(writer, CONST_C15, "showDataLabelsRange", showDataLabelsRange);
        }
    });
}
exports.DrawingWriter.WriteCT_DLblExt = WriteCT_DLblExt;
function WriteCT_DLblsExtensionList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.ext, function (extItem) {
            WriteCT_DLblsExt(writer, CONST_C, CONST_EXT, extItem);
        });
    });
}
exports.DrawingWriter.WriteCT_DLblsExtensionList = WriteCT_DLblsExtensionList;
function WriteCT_DLblsExt(writer, prefix, localName, instance) {
    writer.writeElement("c:" + localName, function () {
        writer.writeAttributeString("xmlns:c15", exports.DrawingWriter.c15);
        if (!common_1._isNullOrUndefined(instance.uri)) {
            writer.writeAttributeString("uri", instance.uri);
        }
    }, function () {
        var layout = instance.layout, showLeaderLines = instance.showLeaderLines, showDataLabelsRange = instance.showDataLabelsRange, leaderLines = instance.leaderLines, spPr = instance.spPr;
        if (!common_1._isNullOrUndefined(layout)) {
            WriteCT_Layout(writer, CONST_C15, CONST_LAYOUT, layout);
        }
        if (!common_1._isNullOrUndefined(showLeaderLines)) {
            WriteCT_Boolean(writer, CONST_C15, "showLeaderLines", showLeaderLines);
        }
        if (!common_1._isNullOrUndefined(showDataLabelsRange)) {
            WriteCT_Boolean(writer, CONST_C15, "showDataLabelsRange", showDataLabelsRange);
        }
        if (!common_1._isNullOrUndefined(leaderLines)) {
            WriteCT_ChartLines(writer, CONST_C15, "leaderLines", leaderLines);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_C15, CONST_SPPR, spPr);
        }
    });
}
exports.DrawingWriter.WriteCT_DLblsExt = WriteCT_DLblsExt;
function WriteCT_UserShapes(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.id)) {
            writer.writeAttributeString("r:id", instance.id);
        }
    });
}
exports.DrawingWriter.WriteCT_UserShapes = WriteCT_UserShapes;
function WriteCT_InvertSolidFillFmt(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_ShapeProperties, CONST_C14, CONST_SPPR);
}
exports.DrawingWriter.WriteCT_InvertSolidFillFmt = WriteCT_InvertSolidFillFmt;
function WriteCT_ColorMapping(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var ST_ColorSchemeIndex = chart_model_1.Charts.ST_ColorSchemeIndex;
        writer.writeAttributeString("bg1", ST_ColorSchemeIndex[instance.bg1]);
        writer.writeAttributeString("tx1", ST_ColorSchemeIndex[instance.tx1]);
        writer.writeAttributeString("bg2", ST_ColorSchemeIndex[instance.bg2]);
        writer.writeAttributeString("tx2", ST_ColorSchemeIndex[instance.tx2]);
        writer.writeAttributeString("accent1", ST_ColorSchemeIndex[instance.accent1]);
        writer.writeAttributeString("accent2", ST_ColorSchemeIndex[instance.accent2]);
        writer.writeAttributeString("accent3", ST_ColorSchemeIndex[instance.accent3]);
        writer.writeAttributeString("accent4", ST_ColorSchemeIndex[instance.accent4]);
        writer.writeAttributeString("accent5", ST_ColorSchemeIndex[instance.accent5]);
        writer.writeAttributeString("accent6", ST_ColorSchemeIndex[instance.accent6]);
        writer.writeAttributeString("hlink", ST_ColorSchemeIndex[instance.hlink]);
        writer.writeAttributeString("folHlink", ST_ColorSchemeIndex[instance.folHlink]);
    }, function () {
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_ColorMapping = WriteCT_ColorMapping;
function WriteCT_FullRef(writer, prefix, localName, instance) {
    writeSubSqrefElement(writer, prefix, localName, instance);
}
exports.DrawingWriter.WriteCT_FullRef = WriteCT_FullRef;
function WriteCT_LevelRef(writer, prefix, localName, instance) {
    writeSubSqrefElement(writer, prefix, localName, instance);
}
exports.DrawingWriter.WriteCT_LevelRef = WriteCT_LevelRef;
function WriteCT_FormulaRef(writer, prefix, localName, instance) {
    writeSubSqrefElement(writer, prefix, localName, instance);
}
exports.DrawingWriter.WriteCT_FormulaRef = WriteCT_FormulaRef;
function WriteCT_FilteredSeriesTitle(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_Tx, CONST_C, "tx");
}
exports.DrawingWriter.WriteCT_FilteredSeriesTitle = WriteCT_FilteredSeriesTitle;
function WriteCT_FilteredCategoryTitle(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_AxDataSource, CONST_C, "cat");
}
exports.DrawingWriter.WriteCT_FilteredCategoryTitle = WriteCT_FilteredCategoryTitle;
function WriteCT_FilteredBarSer(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_BarSer, CONST_C, CONST_SER);
}
exports.DrawingWriter.WriteCT_FilteredBarSer = WriteCT_FilteredBarSer;
function WriteCT_FilteredLineSer(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_LineSer, CONST_C, CONST_SER);
}
exports.DrawingWriter.WriteCT_FilteredLineSer = WriteCT_FilteredLineSer;
function WriteCT_FilteredScatterSer(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_ScatterSer, CONST_C, CONST_SER);
}
exports.DrawingWriter.WriteCT_FilteredScatterSer = WriteCT_FilteredScatterSer;
function WriteCT_FilteredAreaSer(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_AreaSer, CONST_C, CONST_SER);
}
exports.DrawingWriter.WriteCT_FilteredAreaSer = WriteCT_FilteredAreaSer;
function WriteCT_FilteredPieSer(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_PieSer, CONST_C, CONST_SER);
}
exports.DrawingWriter.WriteCT_FilteredPieSer = WriteCT_FilteredPieSer;
function WriteCT_FilteredBubbleSer(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_BubbleSer, CONST_C, CONST_SER);
}
exports.DrawingWriter.WriteCT_FilteredBubbleSer = WriteCT_FilteredBubbleSer;
function WriteCT_FilteredRadarSer(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_RadarSer, CONST_C, CONST_SER);
}
exports.DrawingWriter.WriteCT_FilteredRadarSer = WriteCT_FilteredRadarSer;
function WriteCT_FilteredSurfaceSer(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_SurfaceSer, CONST_C, CONST_SER);
}
exports.DrawingWriter.WriteCT_FilteredSurfaceSer = WriteCT_FilteredSurfaceSer;
function WriteCT_SeriesDataLabelsRange(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("xmlns:c15", exports.DrawingWriter.c15);
    }, function () {
        var dlblRangeCache = instance.dlblRangeCache;
        if (!common_1._isNullOrUndefined(instance.f)) {
            writer.writeElementString("c15:f", xmlEncode(instance.f));
        }
        if (!common_1._isNullOrUndefined(dlblRangeCache)) {
            WriteCT_StrData(writer, CONST_C, "dlblRangeCache", dlblRangeCache);
        }
    });
}
exports.DrawingWriter.WriteCT_SeriesDataLabelsRange = WriteCT_SeriesDataLabelsRange;
function WriteCT_CategoryFilterException(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var sqref = instance.sqref, spPr = instance.spPr, explosion = instance.explosion, invertIfNegative = instance.invertIfNegative, bubble3D = instance.bubble3D, marker = instance.marker, dLbl = instance.dLbl;
        if (!common_1._isNullOrUndefined(sqref)) {
            writer.writeElementString("c15:sqref", sqref);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_A, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(explosion)) {
            WriteCT_UnsignedInt(writer, CONST_C, "explosion", explosion);
        }
        if (!common_1._isNullOrUndefined(invertIfNegative)) {
            WriteCT_Boolean(writer, CONST_C, CONST_INVERT_IF_NEGATIVE, invertIfNegative);
        }
        if (!common_1._isNullOrUndefined(bubble3D)) {
            WriteCT_Boolean(writer, CONST_C, CONST_BUBBLE_3D, bubble3D);
        }
        if (!common_1._isNullOrUndefined(marker)) {
            WriteCT_Marker(writer, CONST_C, CONST_MARKER, marker);
        }
        if (!common_1._isNullOrUndefined(dLbl)) {
            WriteCT_DLbl(writer, CONST_C, "dLbl", dLbl);
        }
    });
}
exports.DrawingWriter.WriteCT_CategoryFilterException = WriteCT_CategoryFilterException;
function WriteCT_CategoryFilterExceptions(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.categoryFilterException, function (categoryFilterExceptionItem) {
            WriteCT_CategoryFilterException(writer, CONST_C15, "categoryFilterException", categoryFilterExceptionItem);
        });
    });
}
exports.DrawingWriter.WriteCT_CategoryFilterExceptions = WriteCT_CategoryFilterExceptions;
function WriteCT_DataLabelFieldTableEntry(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var dlblFieldTableCache = instance.dlblFieldTableCache;
        if (!common_1._isNullOrUndefined(instance.txfldGUID)) {
            writer.writeElementString("c15:txfldGUID", instance.txfldGUID);
        }
        if (!common_1._isNullOrUndefined(instance.f)) {
            writer.writeElementString("c15:f", xmlEncode(instance.f));
        }
        if (!common_1._isNullOrUndefined(dlblFieldTableCache)) {
            WriteCT_StrData(writer, CONST_C15, "dlblFieldTableCache", dlblFieldTableCache);
        }
    });
}
exports.DrawingWriter.WriteCT_DataLabelFieldTableEntry = WriteCT_DataLabelFieldTableEntry;
function WriteCT_DataLabelFieldTable(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.dlblFTEntry, function (dlblFTEntryItem) {
            WriteCT_DataLabelFieldTableEntry(writer, CONST_C15, "dlblFTEntry", dlblFTEntryItem);
        });
    });
}
exports.DrawingWriter.WriteCT_DataLabelFieldTable = WriteCT_DataLabelFieldTable;
function WriteCT_GraphicFrameNonVisual(writer, prefix, localName, instance) {
    writeGraphicFrameNonVisualSubElement(writer, prefix, localName, instance, CONST_A);
}
exports.DrawingWriter.WriteCT_GraphicFrameNonVisual = WriteCT_GraphicFrameNonVisual;
function WriteCT_CdrPosition(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.x)) {
            writer.writeElementString("cdr:x", instance.x);
        }
        if (!common_1._isNullOrUndefined(instance.y)) {
            writer.writeElementString("cdr:y", instance.y);
        }
    });
}
exports.DrawingWriter.WriteCT_CdrPosition = WriteCT_CdrPosition;
function WriteCT_RelSizeAnchor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var from = instance.startPoint, to = instance.endPoint, sp = instance.sp, grpSp = instance.grpSp;
        if (!common_1._isNullOrUndefined(from)) {
            WriteCT_CdrPosition(writer, CONST_CDR, "from", from);
        }
        if (!common_1._isNullOrUndefined(to)) {
            WriteCT_CdrPosition(writer, CONST_CDR, "to", to);
        }
        if (!common_1._isNullOrUndefined(sp)) {
            WriteCT_ShapeForCdr(writer, CONST_CDR, "sp", sp);
        }
        if (!common_1._isNullOrUndefined(grpSp)) {
            WriteCT_GroupShape(writer, CONST_CDR, CONST_GRPSP, grpSp);
        }
        if (!common_1._isNullOrUndefined(instance.graphicFrame)) {
            WriteCT_GraphicalObjectFrame_cdr(writer, CONST_CDR, CONST_GRAPHIC_FRAME, instance.graphicFrame);
        }
        if (!common_1._isNullOrUndefined(instance.cxnSp)) {
            WriteCT_ConnectorCdr(writer, CONST_CDR, CONST_CXNSP, instance.cxnSp);
        }
        if (!common_1._isNullOrUndefined(instance.pic)) {
            WriteCT_PictureRelSizeAnchor(writer, CONST_CDR, "pic", instance.pic);
        }
    });
}
exports.DrawingWriter.WriteCT_RelSizeAnchor = WriteCT_RelSizeAnchor;
function WriteCT_AbsSizeAnchor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString('xmlns:cdr', exports.DrawingWriter.cdr);
    }, function () {
        var from = instance.from, ext = instance.ext, sp = instance.sp, grpSp = instance.grpSp, cxnSp = instance.cxnSp, pic = instance.pic;
        if (!common_1._isNullOrUndefined(from)) {
            WriteCT_CdrPosition(writer, CONST_CDR, "from", from);
        }
        if (!common_1._isNullOrUndefined(ext)) {
            WriteCT_PositiveSize2D(writer, CONST_A, CONST_EXT, ext, true);
        }
        if (!common_1._isNullOrUndefined(sp)) {
            WriteCT_Shape(writer, CONST_XDR, "sp", sp);
        }
        if (!common_1._isNullOrUndefined(grpSp)) {
            WriteCT_GroupShape(writer, CONST_XDR, CONST_GRPSP, grpSp);
        }
        if (!common_1._isNullOrUndefined(instance.graphicFrame)) {
            WriteCT_GraphicalObjectFrame(writer, CONST_CDR, CONST_GRAPHIC_FRAME, instance.graphicFrame);
        }
        if (!common_1._isNullOrUndefined(cxnSp)) {
            WriteCT_Connector(writer, CONST_XDR, CONST_CXNSP, cxnSp);
        }
        if (!common_1._isNullOrUndefined(pic)) {
            WriteCT_Picture(writer, CONST_XDR, "pic", pic);
        }
    });
}
exports.DrawingWriter.WriteCT_AbsSizeAnchor = WriteCT_AbsSizeAnchor;
function WriteCT_ChartDrawing(writer, prefix, localName, instance) {
    writer.writeElement("c:" + localName, function () {
        writer.writeAttributeString('xmlns:c', exports.DrawingWriter.c);
        writer.writeAttributeString('xmlns:cdr', exports.DrawingWriter.cdr);
        writer.writeAttributeString('xmlns:a', exports.DrawingWriter.a);
    }, function () {
        var relSizeAnchor = instance.relSizeAnchor, absSizeAnchor = instance.absSizeAnchor;
        relSizeAnchor && relSizeAnchor.forEach(function (relSizeAnchorItem) {
            if (relSizeAnchorItem) {
                WriteCT_RelSizeAnchor(writer, CONST_CDR, "relSizeAnchor", relSizeAnchorItem);
            }
        });
        absSizeAnchor && absSizeAnchor.forEach(function (absSizeAnchorItem) {
            if (absSizeAnchorItem) {
                WriteCT_AbsSizeAnchor(writer, CONST_CDR, "absSizeAnchor", absSizeAnchorItem);
            }
        });
    });
}
exports.DrawingWriter.WriteCT_ChartDrawing = WriteCT_ChartDrawing;
function WriteCT_ConnectorLocking(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeLockingElementAttribute(writer, instance);
    }, function () {
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_ConnectorLocking = WriteCT_ConnectorLocking;
function WriteCT_ShapeLocking(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeLockingElementAttribute(writer, instance);
        if (instance.noTextEdit === true) {
            writer.writeAttributeString("noTextEdit", "1");
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_ShapeLocking = WriteCT_ShapeLocking;
function WriteCT_PictureLocking(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeLockingElementAttribute(writer, instance);
        if (instance.noCrop === true) {
            writer.writeAttributeString("noCrop", "1");
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_PictureLocking = WriteCT_PictureLocking;
function WriteCT_GroupLocking(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (instance.noGrp === true) {
            writer.writeAttributeString("noGrp", "1");
        }
        if (instance.noUngrp === true) {
            writer.writeAttributeString("noUngrp", "1");
        }
        if (instance.noSelect === true) {
            writer.writeAttributeString("noSelect", "1");
        }
        if (instance.noRot === true) {
            writer.writeAttributeString("noRot", "1");
        }
        if (instance.noChangeAspect === true) {
            writer.writeAttributeString("noChangeAspect", "1");
        }
        if (instance.noMove === true) {
            writer.writeAttributeString("noMove", "1");
        }
        if (instance.noResize === true) {
            writer.writeAttributeString("noResize", "1");
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_GroupLocking = WriteCT_GroupLocking;
function WriteCT_GraphicalObjectFrameLocking(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (instance.noGrp === true) {
            writer.writeAttributeString("noGrp", "1");
        }
        if (instance.noDrilldown === true) {
            writer.writeAttributeString("noDrilldown", "1");
        }
        if (instance.noSelect === true) {
            writer.writeAttributeString("noSelect", "1");
        }
        if (instance.noChangeAspect === true) {
            writer.writeAttributeString("noChangeAspect", "1");
        }
        if (instance.noMove === true) {
            writer.writeAttributeString("noMove", "1");
        }
        if (instance.noResize === true) {
            writer.writeAttributeString("noResize", "1");
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, instance.extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_GraphicalObjectFrameLocking = WriteCT_GraphicalObjectFrameLocking;
function WriteCT_NonVisualDrawingProps(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var descr = instance.descr, title = instance.title;
        writer.writeAttributeString("id", instance.id || writer._id++);
        if (!common_1._isNullOrUndefined(instance.name)) {
            writer.writeAttributeString(CONST_NAME, xmlEncode(instance.name));
        }
        if (!isNullOrUndefinedOrEmpty(descr)) {
            writer.writeAttributeString("descr", descr);
        }
        if (!isNullOrUndefinedOrEmpty(title)) {
            writer.writeAttributeString(CONST_TITLE, title);
        }
        if (instance.hidden === true) {
            writer.writeAttributeString("hidden", "1");
        }
    }, function () {
        var hlinkClick = instance.hlinkClick, hlinkHover = instance.hlinkHover, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(hlinkClick)) {
            WriteCT_Hyperlink(writer, CONST_A, "hlinkClick", hlinkClick);
        }
        if (!common_1._isNullOrUndefined(hlinkHover)) {
            WriteCT_Hyperlink(writer, CONST_A, "hlinkHover", hlinkHover);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_NonVisualDrawingProps = WriteCT_NonVisualDrawingProps;
function WriteCT_NonVisualDrawingShapeProps(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (instance.txBox === true) {
            writer.writeAttributeString("txBox", "1");
        }
    }, function () {
        var spLocks = instance.spLocks, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(spLocks)) {
            WriteCT_ShapeLocking(writer, CONST_A, "spLocks", spLocks);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_NonVisualDrawingShapeProps = WriteCT_NonVisualDrawingShapeProps;
function WriteCT_NonVisualConnectorProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var cxnSpLocks = instance.cxnSpLocks, stCxn = instance.stCxn, endCxn = instance.endCxn, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(cxnSpLocks)) {
            WriteCT_ConnectorLocking(writer, CONST_A, "cxnSpLocks", cxnSpLocks);
        }
        if (!common_1._isNullOrUndefined(stCxn)) {
            WriteCT_Connection(writer, CONST_A, "stCxn", stCxn);
        }
        if (!common_1._isNullOrUndefined(endCxn)) {
            WriteCT_Connection(writer, CONST_A, "endCxn", endCxn);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_NonVisualConnectorProperties = WriteCT_NonVisualConnectorProperties;
function WriteCT_NonVisualPictureProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (instance.preferRelativeResize === false) {
            writer.writeAttributeString("preferRelativeResize", "0");
        }
    }, function () {
        var picLocks = instance.picLocks, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(picLocks)) {
            WriteCT_PictureLocking(writer, CONST_A, "picLocks", picLocks);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_NonVisualPictureProperties = WriteCT_NonVisualPictureProperties;
function WriteCT_NonVisualGroupDrawingShapeProps(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var grpSpLocks = instance.grpSpLocks, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(grpSpLocks)) {
            WriteCT_GroupLocking(writer, CONST_A, "grpSpLocks", grpSpLocks);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_NonVisualGroupDrawingShapeProps = WriteCT_NonVisualGroupDrawingShapeProps;
function WriteCT_NonVisualGraphicFrameProperties(writer, prefix, localName) {
    writer.writeLeafElement(prefix + ":" + localName);
}
exports.DrawingWriter.WriteCT_NonVisualGraphicFrameProperties = WriteCT_NonVisualGraphicFrameProperties;
function WriteCT_GraphicalObjectDataContent(writer, prefix, localName, instance, is2016Chart) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (is2016Chart) {
            writer.writeAttributeString("xmlns:" + prefix, chart2016Write.cx);
        }
        else {
            writer.writeAttributeString("xmlns:" + prefix, exports.DrawingWriter.c);
        }
        writer.writeAttributeString("xmlns:r", exports.DrawingWriter.r);
        if (!common_1._isNullOrUndefined(instance.id)) {
            writer.writeAttributeString("r:id", instance.id);
        }
    });
}
exports.DrawingWriter.WriteCT_GraphicalObjectDataContent = WriteCT_GraphicalObjectDataContent;
function WriteCT_GraphicalObjectData(writer, prefix, localName, instance, is2016Chart) {
    writer.writeElement(prefix + ":" + localName, function () {
        var uri = is2016Chart ? chart2016Write.cx : exports.DrawingWriter.c;
        writer.writeAttributeString("uri", uri);
    }, function () {
        if (!common_1._isNullOrUndefined(instance.chart)) {
            var cOrCx = is2016Chart ? CONST_CX : CONST_C;
            WriteCT_GraphicalObjectDataContent(writer, cOrCx, "chart", instance.chart, is2016Chart);
        }
    });
}
exports.DrawingWriter.WriteCT_GraphicalObjectData = WriteCT_GraphicalObjectData;
function WriteCT_GraphicalObject(writer, prefix, localName, instance, is2016Chart) {
    writer.writeElement(prefix + ":" + localName, function () {
        var graphicData = instance.graphicData;
        if (!common_1._isNullOrUndefined(graphicData)) {
            WriteCT_GraphicalObjectData(writer, CONST_A, "graphicData", graphicData, is2016Chart);
        }
    });
}
exports.DrawingWriter.WriteCT_GraphicalObject = WriteCT_GraphicalObject;
function WriteCT_Camera(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.prst)) {
            writer.writeAttributeString(CONST_PRST, chart_model_1.Charts.ST_PresetCameraType[chart_helper_1.ChartHelper.ToST_PresetCameraType(instance.prst)]);
        }
        if (!common_1._isNullOrUndefined(instance.fov) && instance.fov !== 0) {
            writer.writeAttributeString("fov", instance.fov);
        }
        if (!common_1._isNullOrUndefined(instance.zoom) && instance.zoom !== 100000) {
            writer.writeAttributeString("zoom", instance.zoom);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.rot)) {
            WriteCT_SphereCoords(writer, CONST_A, "rot", instance.rot);
        }
    });
}
exports.DrawingWriter.WriteCT_Camera = WriteCT_Camera;
function WriteCT_LightRig(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.rig)) {
            writer.writeAttributeString("rig", chart_model_1.Charts.ST_LightRigType[instance.rig]);
        }
        if (!common_1._isNullOrUndefined(instance.dir)) {
            writer.writeAttributeString("dir", chart_model_1.Charts.ST_LightRigDirection[chart_helper_1.ChartHelper.ToST_LightRigDirection(instance.dir)]);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.rot)) {
            WriteCT_SphereCoords(writer, CONST_A, "rot", instance.rot);
        }
    });
}
exports.DrawingWriter.WriteCT_LightRig = WriteCT_LightRig;
function WriteCT_Scene3D(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var camera = instance.camera, lightRig = instance.lightRig, backdrop = instance.backdrop, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(camera)) {
            WriteCT_Camera(writer, CONST_A, "camera", camera);
        }
        if (!common_1._isNullOrUndefined(lightRig)) {
            WriteCT_LightRig(writer, CONST_A, "lightRig", lightRig);
        }
        if (!common_1._isNullOrUndefined(backdrop)) {
            WriteCT_Backdrop(writer, CONST_A, "backdrop", backdrop);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Scene3D = WriteCT_Scene3D;
function WriteCT_Backdrop(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var anchor = instance.anchor, norm = instance.norm, up = instance.up, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(anchor)) {
            WriteCT_Point3D(writer, CONST_A, "anchor", anchor);
        }
        if (!common_1._isNullOrUndefined(norm)) {
            WriteCT_Vector3D(writer, CONST_A, "norm", norm);
        }
        if (!common_1._isNullOrUndefined(up)) {
            WriteCT_Vector3D(writer, CONST_A, "up", up);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Backdrop = WriteCT_Backdrop;
function WriteCT_Bevel(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.w) && instance.w !== 76200) {
            writer.writeAttributeString("w", instance.w);
        }
        if (!common_1._isNullOrUndefined(instance.h) && instance.h !== 76200) {
            writer.writeAttributeString("h", instance.h);
        }
        if (!common_1._isNullOrUndefined(instance.prst) && instance.prst !== 1) {
            writer.writeAttributeString(CONST_PRST, chart_model_1.Charts.ST_BevelPresetType[instance.prst]);
        }
    });
}
exports.DrawingWriter.WriteCT_Bevel = WriteCT_Bevel;
function WriteCT_Shape3D(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var z = instance.z, extrusionH = instance.extrusionH, contourW = instance.contourW, prstMaterial = instance.prstMaterial;
        if (!common_1._isNullOrUndefined(z) && z !== 0) {
            writer.writeAttributeString("z", pixelToEMU(z));
        }
        if (!common_1._isNullOrUndefined(extrusionH) && extrusionH !== 0) {
            writer.writeAttributeString("extrusionH", pixelToEMU(extrusionH));
        }
        if (!common_1._isNullOrUndefined(contourW) && contourW !== 0) {
            writer.writeAttributeString("contourW", pixelToEMU(contourW));
        }
        if (!common_1._isNullOrUndefined(prstMaterial) && prstMaterial !== 7) {
            writer.writeAttributeString("prstMaterial", chart_model_1.Charts.ST_PresetMaterialType[prstMaterial]);
        }
    }, function () {
        var bevelT = instance.bevelT, bevelB = instance.bevelB, extrusionClr = instance.extrusionClr, contourClr = instance.contourClr, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(bevelT)) {
            WriteCT_Bevel(writer, CONST_A, "bevelT", bevelT);
        }
        if (!common_1._isNullOrUndefined(bevelB)) {
            WriteCT_Bevel(writer, CONST_A, "bevelB", bevelB);
        }
        if (!common_1._isNullOrUndefined(extrusionClr)) {
            WriteCT_Color(writer, CONST_A, "extrusionClr", extrusionClr);
        }
        if (!common_1._isNullOrUndefined(contourClr)) {
            WriteCT_Color(writer, CONST_A, "contourClr", contourClr);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Shape3D = WriteCT_Shape3D;
function WriteCT_FlatText(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance.z, "z", 0);
}
exports.DrawingWriter.WriteCT_FlatText = WriteCT_FlatText;
function WriteCT_AlphaBiLevelEffect(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance.thresh, "thresh");
}
exports.DrawingWriter.WriteCT_AlphaBiLevelEffect = WriteCT_AlphaBiLevelEffect;
function WriteCT_AlphaCeilingEffect(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_AlphaCeilingEffect = WriteCT_AlphaCeilingEffect;
function WriteCT_AlphaFloorEffect(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_AlphaFloorEffect = WriteCT_AlphaFloorEffect;
function WriteCT_AlphaInverseEffect(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeSubColorElements(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_AlphaInverseEffect = WriteCT_AlphaInverseEffect;
function WriteCT_AlphaModulateFixedEffect(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance.amt, "amt", 100000);
}
exports.DrawingWriter.WriteCT_AlphaModulateFixedEffect = WriteCT_AlphaModulateFixedEffect;
function WriteCT_AlphaOutsetEffect(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance.rad, "rad", 0);
}
exports.DrawingWriter.WriteCT_AlphaOutsetEffect = WriteCT_AlphaOutsetEffect;
function WriteCT_AlphaReplaceEffect(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance[CONST_A], CONST_A);
}
exports.DrawingWriter.WriteCT_AlphaReplaceEffect = WriteCT_AlphaReplaceEffect;
function WriteCT_BiLevelEffect(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance.thresh, "thresh");
}
exports.DrawingWriter.WriteCT_BiLevelEffect = WriteCT_BiLevelEffect;
function WriteCT_BlurEffect(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.rad) && instance.rad !== 0) {
            writer.writeAttributeString("rad", instance.rad);
        }
        if (instance.grow === false) {
            writer.writeAttributeString("grow", "0");
        }
    });
}
exports.DrawingWriter.WriteCT_BlurEffect = WriteCT_BlurEffect;
function WriteCT_ColorChangeEffect(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (instance.useA === false) {
            writer.writeAttributeString("useA", "0");
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.clrFrom)) {
            WriteCT_Color(writer, CONST_A, "clrFrom", instance.clrFrom);
        }
        if (!common_1._isNullOrUndefined(instance.clrTo)) {
            WriteCT_Color(writer, CONST_A, "clrTo", instance.clrTo);
        }
    });
}
exports.DrawingWriter.WriteCT_ColorChangeEffect = WriteCT_ColorChangeEffect;
function WriteCT_ColorReplaceEffect(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeSubColorElements(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_ColorReplaceEffect = WriteCT_ColorReplaceEffect;
function WriteCT_DuotoneEffect(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var scrgbClr = instance.scrgbClr, hslClr = instance.hslClr, sysClr = instance.sysClr, schemeClr = instance.schemeClr, prstClr = instance.prstClr, srgbClr = instance.srgbClr;
        if (!common_1._isNullOrUndefined(scrgbClr)) {
            WriteCT_ScRgbColor(writer, CONST_A, CONST_SCRGBCLR, scrgbClr);
        }
        if (!common_1._isNullOrUndefined(hslClr)) {
            WriteCT_HslColor(writer, CONST_A, CONST_HSLCLR, hslClr);
        }
        if (!common_1._isNullOrUndefined(sysClr)) {
            WriteCT_SystemColor(writer, CONST_A, CONST_SYSCLR, sysClr);
        }
        if (!common_1._isNullOrUndefined(schemeClr)) {
            WriteCT_SchemeColor(writer, CONST_A, CONST_SCHEMECLR, schemeClr);
        }
        if (!common_1._isNullOrUndefined(prstClr)) {
            WriteCT_PresetColor(writer, CONST_A, CONST_PRSTCLR, prstClr);
        }
        if (!common_1._isNullOrUndefined(srgbClr)) {
            WriteCT_SRgbColor(writer, CONST_A, CONST_SRGBCLR, srgbClr);
        }
    });
}
exports.DrawingWriter.WriteCT_DuotoneEffect = WriteCT_DuotoneEffect;
function WriteCT_GlowEffect(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.rad) && instance.rad !== 0) {
            writer.writeAttributeString("rad", instance.rad);
        }
    }, function () {
        writeSubColorElements(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_GlowEffect = WriteCT_GlowEffect;
function WriteCT_GrayscaleEffect(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_GrayscaleEffect = WriteCT_GrayscaleEffect;
function WriteCT_HSLEffect(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var hue = instance.hue, sat = instance.sat, lum = instance.lum;
        if (!common_1._isNullOrUndefined(hue) && hue !== 0) {
            writer.writeAttributeString("hue", hue);
        }
        if (!common_1._isNullOrUndefined(sat) && sat !== 0) {
            writer.writeAttributeString("sat", sat);
        }
        if (!common_1._isNullOrUndefined(lum) && lum !== 0) {
            writer.writeAttributeString("lum", lum);
        }
    });
}
exports.DrawingWriter.WriteCT_HSLEffect = WriteCT_HSLEffect;
function WriteCT_InnerShadowEffect(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var blurRad = instance.blurRad, dist = instance.dist, dir = instance.dir;
        if (!common_1._isNullOrUndefined(blurRad) && blurRad !== 0) {
            writer.writeAttributeString("blurRad", blurRad);
        }
        if (!common_1._isNullOrUndefined(dist) && dist !== 0) {
            writer.writeAttributeString("dist", dist);
        }
        if (!common_1._isNullOrUndefined(dir) && dir !== 0) {
            writer.writeAttributeString("dir", dir);
        }
    }, function () {
        writeSubColorElements(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_InnerShadowEffect = WriteCT_InnerShadowEffect;
function WriteCT_LuminanceEffect(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var bright = instance.bright, contrast = instance.contrast;
        if (!common_1._isNullOrUndefined(bright) && bright !== 0) {
            writer.writeAttributeString("bright", bright);
        }
        if (!common_1._isNullOrUndefined(contrast) && contrast !== 0) {
            writer.writeAttributeString("contrast", contrast);
        }
    });
}
exports.DrawingWriter.WriteCT_LuminanceEffect = WriteCT_LuminanceEffect;
function WriteCT_OuterShadowEffect(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var blurRad = instance.blurRad, dist = instance.dist, dir = instance.dir;
        if (!common_1._isNullOrUndefined(blurRad) && blurRad !== 0) {
            writer.writeAttributeString("blurRad", blurRad);
        }
        if (!common_1._isNullOrUndefined(dist) && dist !== 0) {
            writer.writeAttributeString("dist", dist);
        }
        if (!common_1._isNullOrUndefined(dir) && dir !== 0) {
            writer.writeAttributeString("dir", dir);
        }
        writeEffectElementAttribute(writer, instance);
    }, function () {
        writeSubColorElements(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_OuterShadowEffect = WriteCT_OuterShadowEffect;
function WriteCT_PresetShadowEffect(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.prst)) {
            writer.writeAttributeString(CONST_PRST, chart_model_1.Charts.ST_PresetShadowVal[chart_helper_1.ChartHelper.ToST_PresetShadowVal(instance.prst)]);
        }
        var dist = instance.dist, dir = instance.dir;
        if (!common_1._isNullOrUndefined(dist) && dist !== 0) {
            writer.writeAttributeString("dist", dist);
        }
        if (!common_1._isNullOrUndefined(dir) && dir !== 0) {
            writer.writeAttributeString("dir", dir);
        }
    }, function () {
        writeSubColorElements(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_PresetShadowEffect = WriteCT_PresetShadowEffect;
function WriteCT_ReflectionEffect(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var blurRad = instance.blurRad, stA = instance.stA, stPos = instance.stPos, endA = instance.endA, endPos = instance.endPos, dist = instance.dist, dir = instance.dir, fadeDir = instance.fadeDir;
        if (!common_1._isNullOrUndefined(blurRad) && blurRad !== 0) {
            writer.writeAttributeString("blurRad", blurRad);
        }
        if (!common_1._isNullOrUndefined(stA) && stA !== 100000) {
            writer.writeAttributeString("stA", stA);
        }
        if (!common_1._isNullOrUndefined(stPos) && stPos !== 0) {
            writer.writeAttributeString("stPos", stPos);
        }
        if (!common_1._isNullOrUndefined(endA) && endA !== 0) {
            writer.writeAttributeString("endA", endA);
        }
        if (!common_1._isNullOrUndefined(endPos) && endPos !== 100000) {
            writer.writeAttributeString("endPos", endPos);
        }
        if (!common_1._isNullOrUndefined(dist) && dist !== 0) {
            writer.writeAttributeString("dist", dist);
        }
        if (!common_1._isNullOrUndefined(dir) && dir !== 0) {
            writer.writeAttributeString("dir", dir);
        }
        if (!common_1._isNullOrUndefined(fadeDir) && fadeDir !== 5400000) {
            writer.writeAttributeString("fadeDir", fadeDir);
        }
        writeEffectElementAttribute(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_ReflectionEffect = WriteCT_ReflectionEffect;
function WriteCT_RelativeOffsetEffect(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.tx) && instance.tx !== 0) {
            writer.writeAttributeString("tx", instance.tx);
        }
        if (!common_1._isNullOrUndefined(instance.ty) && instance.ty !== 0) {
            writer.writeAttributeString("ty", instance.ty);
        }
    });
}
exports.DrawingWriter.WriteCT_RelativeOffsetEffect = WriteCT_RelativeOffsetEffect;
function WriteCT_SoftEdgesEffect(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance.rad, "rad");
}
exports.DrawingWriter.WriteCT_SoftEdgesEffect = WriteCT_SoftEdgesEffect;
function WriteCT_TintEffect(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.hue) && instance.hue !== 0) {
            writer.writeAttributeString("hue", instance.hue);
        }
        if (!common_1._isNullOrUndefined(instance.amt) && instance.amt !== 0) {
            writer.writeAttributeString("amt", instance.amt);
        }
    });
}
exports.DrawingWriter.WriteCT_TintEffect = WriteCT_TintEffect;
function WriteCT_TransformEffect(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.sx) && instance.sx !== 100000) {
            writer.writeAttributeString("sx", instance.sx);
        }
        if (!common_1._isNullOrUndefined(instance.sy) && instance.sy !== 100000) {
            writer.writeAttributeString("sy", instance.sy);
        }
        if (!common_1._isNullOrUndefined(instance.kx) && instance.kx !== 0) {
            writer.writeAttributeString("kx", instance.kx);
        }
        if (!common_1._isNullOrUndefined(instance.ky) && instance.ky !== 0) {
            writer.writeAttributeString("ky", instance.ky);
        }
        if (!common_1._isNullOrUndefined(instance.tx) && instance.tx !== 0) {
            writer.writeAttributeString("tx", instance.tx);
        }
        if (!common_1._isNullOrUndefined(instance.ty) && instance.ty !== 0) {
            writer.writeAttributeString("ty", instance.ty);
        }
    });
}
exports.DrawingWriter.WriteCT_TransformEffect = WriteCT_TransformEffect;
function WriteCT_NoFillProperties(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_NoFillProperties = WriteCT_NoFillProperties;
function WriteCT_SolidColorFillProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeSubColorElements(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_SolidColorFillProperties = WriteCT_SolidColorFillProperties;
function WriteCT_LinearShadeProperties(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.ang)) {
            writer.writeAttributeString("ang", instance.ang);
        }
        if (!common_1._isNullOrUndefined(instance.scaled)) {
            writer.writeAttributeString("scaled", instance.scaled ? "1" : "0");
        }
    });
}
exports.DrawingWriter.WriteCT_LinearShadeProperties = WriteCT_LinearShadeProperties;
function WriteCT_PathShadeProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.path)) {
            writer.writeAttributeString("path", chart_model_1.Charts.ST_PathShadeType[instance.path]);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.fillToRect)) {
            WriteCT_RelativeRect(writer, CONST_A, "fillToRect", instance.fillToRect);
        }
    });
}
exports.DrawingWriter.WriteCT_PathShadeProperties = WriteCT_PathShadeProperties;
function WriteCT_GradientStop(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.pos)) {
            writer.writeAttributeString("pos", instance.pos.toFixed(0));
        }
    }, function () {
        writeSubColorElements(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_GradientStop = WriteCT_GradientStop;
function WriteCT_GradientStopList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.gs, function (gsItem) {
            WriteCT_GradientStop(writer, CONST_A, "gs", gsItem);
        });
    });
}
exports.DrawingWriter.WriteCT_GradientStopList = WriteCT_GradientStopList;
function WriteCT_GradientFillProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.flip)) {
            writer.writeAttributeString("flip", chart_model_1.Charts.ST_TileFlipMode[instance.flip]);
        }
        if (instance.rotWithShape === false) {
            writer.writeAttributeString(CONST_TOT_WITH_SHAPE, "0");
        }
    }, function () {
        var gsLst = instance.gsLst, lin = instance.lin, path = instance.path, tileRect = instance.tileRect;
        if (!common_1._isNullOrUndefined(gsLst)) {
            WriteCT_GradientStopList(writer, CONST_A, "gsLst", gsLst);
        }
        if (!common_1._isNullOrUndefined(lin)) {
            WriteCT_LinearShadeProperties(writer, CONST_A, "lin", lin);
        }
        if (!common_1._isNullOrUndefined(path)) {
            WriteCT_PathShadeProperties(writer, CONST_A, "path", path);
        }
        if (!common_1._isNullOrUndefined(tileRect)) {
            WriteCT_RelativeRect(writer, CONST_A, "tileRect", tileRect);
        }
    });
}
exports.DrawingWriter.WriteCT_GradientFillProperties = WriteCT_GradientFillProperties;
function WriteCT_TileInfoProperties(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.tx)) {
            writer.writeAttributeString("tx", pixelToEMU(instance.tx));
        }
        if (!common_1._isNullOrUndefined(instance.ty)) {
            writer.writeAttributeString("ty", pixelToEMU(instance.ty));
        }
        if (!common_1._isNullOrUndefined(instance.sx)) {
            writer.writeAttributeString("sx", instance.sx);
        }
        if (!common_1._isNullOrUndefined(instance.sy)) {
            writer.writeAttributeString("sy", instance.sy);
        }
        if (!common_1._isNullOrUndefined(instance.flip)) {
            writer.writeAttributeString("flip", chart_model_1.Charts.ST_TileFlipMode[instance.flip]);
        }
        if (!common_1._isNullOrUndefined(instance.algn)) {
            writer.writeAttributeString("algn", chart_model_1.Charts.ST_RectAlignment[instance.algn]);
        }
    });
}
exports.DrawingWriter.WriteCT_TileInfoProperties = WriteCT_TileInfoProperties;
function WriteCT_StretchInfoProperties(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_RelativeRect, CONST_A, "fillRect");
}
exports.DrawingWriter.WriteCT_StretchInfoProperties = WriteCT_StretchInfoProperties;
function WriteCT_Blip(writer, prefix, localName, instance) {
    var base64Str = instance && instance.blipBlob && instance.blipBlob.blob;
    if (excel_helper_1.isSVGPicture(base64Str) && instance.embed) {
        var extLst = instance.extLst || {};
        extLst.ext = extLst.ext || [];
        extLst.ext.push({
            hiddenExtensionType: 5,
            uri: "{96DAC541-7B7A-43D3-8B79-37D633B846F1}",
            svgBlip: { embed: instance.embed }
        });
        instance.extLst = extLst;
    }
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("xmlns:r", exports.DrawingWriter.r);
        if (!common_1._isNullOrUndefined(instance.embed) && instance.embed !== "") {
            writer.writeAttributeString("r:embed", instance.embed);
        }
        var link = instance.link, cstate = instance.cstate;
        if (!isNullOrUndefinedOrEmpty(link)) {
            writer.writeAttributeString("link", link);
        }
        if (!common_1._isNullOrUndefined(cstate) && cstate !== 4) {
            writer.writeAttributeString("cstate", chart_model_1.Charts.ST_BlipCompression[cstate]);
        }
    }, function () {
        var alphaBiLevel = instance.alphaBiLevel, alphaCeiling = instance.alphaCeiling, alphaFloor = instance.alphaFloor, alphaInv = instance.alphaInv, alphaMod = instance.alphaMod, alphaModFix = instance.alphaModFix, alphaRepl = instance.alphaRepl, biLevel = instance.biLevel, blur = instance.blur, clrChange = instance.clrChange, clrRepl = instance.clrRepl, duotone = instance.duotone, fillOverlay = instance.fillOverlay, grayscl = instance.grayscl, hsl = instance.hsl, lum = instance.lum, tint = instance.tint, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(alphaBiLevel)) {
            WriteCT_AlphaBiLevelEffect(writer, CONST_A, "alphaBiLevel", alphaBiLevel);
        }
        if (!common_1._isNullOrUndefined(alphaCeiling)) {
            WriteCT_AlphaCeilingEffect(writer, CONST_A, "alphaCeiling");
        }
        if (!common_1._isNullOrUndefined(alphaFloor)) {
            WriteCT_AlphaFloorEffect(writer, CONST_A, "alphaFloor");
        }
        if (!common_1._isNullOrUndefined(alphaInv)) {
            WriteCT_AlphaInverseEffect(writer, CONST_A, "alphaInv", alphaInv);
        }
        if (!common_1._isNullOrUndefined(alphaMod)) {
            WriteCT_AlphaModulateEffect(writer, CONST_A, "alphaMod", alphaMod);
        }
        if (!common_1._isNullOrUndefined(alphaModFix)) {
            WriteCT_AlphaModulateFixedEffect(writer, CONST_A, "alphaModFix", alphaModFix);
        }
        if (!common_1._isNullOrUndefined(alphaRepl)) {
            WriteCT_AlphaReplaceEffect(writer, CONST_A, "alphaRepl", alphaRepl);
        }
        if (!common_1._isNullOrUndefined(biLevel)) {
            WriteCT_BiLevelEffect(writer, CONST_A, "biLevel", biLevel);
        }
        if (!common_1._isNullOrUndefined(blur)) {
            WriteCT_BlurEffect(writer, CONST_A, "blur", blur);
        }
        if (!common_1._isNullOrUndefined(clrChange)) {
            WriteCT_ColorChangeEffect(writer, CONST_A, "clrChange", clrChange);
        }
        if (!common_1._isNullOrUndefined(clrRepl)) {
            WriteCT_ColorReplaceEffect(writer, CONST_A, "clrRepl", clrRepl);
        }
        if (!common_1._isNullOrUndefined(duotone)) {
            WriteCT_DuotoneEffect(writer, CONST_A, "duotone", duotone);
        }
        if (!common_1._isNullOrUndefined(fillOverlay)) {
            WriteCT_FillOverlayEffect(writer, CONST_A, "fillOverlay", fillOverlay);
        }
        if (!common_1._isNullOrUndefined(grayscl)) {
            WriteCT_GrayscaleEffect(writer, CONST_A, "grayscl");
        }
        if (!common_1._isNullOrUndefined(hsl)) {
            WriteCT_HSLEffect(writer, CONST_A, "hsl", hsl);
        }
        if (!common_1._isNullOrUndefined(lum)) {
            WriteCT_LuminanceEffect(writer, CONST_A, "lum", lum);
        }
        if (!common_1._isNullOrUndefined(tint)) {
            WriteCT_TintEffect(writer, CONST_A, "tint", tint);
        }
        if (!common_1._isNullOrUndefined(instance.blipBlob)) {
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_Blip = WriteCT_Blip;
function WriteCT_BlipBlob(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.type) && instance.type !== 0) {
            writer.writeAttributeString(CONST_TYPE, chart_model_1.Charts.ST_BobType[instance.type]);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.blob)) {
            writer.writeElementString("a:blob", instance.blob);
        }
    });
}
exports.DrawingWriter.WriteCT_BlipBlob = WriteCT_BlipBlob;
function WriteCT_BlipFillProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.dpi)) {
            writer.writeAttributeString("dpi", instance.dpi);
        }
        if (!common_1._isNullOrUndefined(instance.rotWithShape)) {
            writer.writeAttributeString(CONST_TOT_WITH_SHAPE, instance.rotWithShape ? "1" : "0");
        }
    }, function () {
        var blip = instance.blip, srcRect = instance.srcRect, tile = instance.tile, stretch = instance.stretch;
        if (!common_1._isNullOrUndefined(blip)) {
            WriteCT_Blip(writer, CONST_A, "blip", blip);
        }
        if (!common_1._isNullOrUndefined(srcRect)) {
            WriteCT_RelativeRect(writer, CONST_A, "srcRect", srcRect);
        }
        if (!common_1._isNullOrUndefined(tile)) {
            WriteCT_TileInfoProperties(writer, CONST_A, "tile", tile);
        }
        if (!common_1._isNullOrUndefined(stretch)) {
            WriteCT_StretchInfoProperties(writer, CONST_A, "stretch", stretch);
        }
    });
}
exports.DrawingWriter.WriteCT_BlipFillProperties = WriteCT_BlipFillProperties;
function WriteCT_PatternFillProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.prst)) {
            writer.writeAttributeString(CONST_PRST, chart_model_1.Charts.ST_PresetPatternVal[chart_helper_1.ChartHelper.ToST_PresetPatternVal(parseInt(instance.prst, 10))]);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.fgClr)) {
            WriteCT_Color(writer, CONST_A, "fgClr", instance.fgClr);
        }
        if (!common_1._isNullOrUndefined(instance.bgClr)) {
            WriteCT_Color(writer, CONST_A, "bgClr", instance.bgClr);
        }
    });
}
exports.DrawingWriter.WriteCT_PatternFillProperties = WriteCT_PatternFillProperties;
function WriteCT_GroupFillProperties(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_GroupFillProperties = WriteCT_GroupFillProperties;
function WriteCT_FillProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeFillProperties(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_FillProperties = WriteCT_FillProperties;
function WriteCT_FillEffect(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeFillProperties(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_FillEffect = WriteCT_FillEffect;
function WriteCT_FillOverlayEffect(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.blend)) {
            writer.writeAttributeString("blend", chart_model_1.Charts.ST_BlendMode[instance.blend]);
        }
    }, function () {
        writeFillProperties(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_FillOverlayEffect = WriteCT_FillOverlayEffect;
function WriteCT_EffectReference(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance.ref, "ref");
}
exports.DrawingWriter.WriteCT_EffectReference = WriteCT_EffectReference;
function WriteCT_EffectContainer(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var type = instance.type, name = instance.name;
        if (!common_1._isNullOrUndefined(type) && type !== 0) {
            writer.writeAttributeString(CONST_TYPE, chart_model_1.Charts.ST_EffectContainerType[type]);
        }
        if (!common_1._isNullOrUndefined(name)) {
            writer.writeAttributeString(CONST_NAME, name);
        }
    }, function () {
        var cont = instance.cont, effect = instance.effect, alphaBiLevel = instance.alphaBiLevel, alphaCeiling = instance.alphaCeiling, alphaFloor = instance.alphaFloor, alphaInv = instance.alphaInv, alphaMod = instance.alphaMod, alphaModFix = instance.alphaModFix, alphaOutset = instance.alphaOutset, alphaRepl = instance.alphaRepl, biLevel = instance.biLevel, blend = instance.blend, blur = instance.blur, clrChange = instance.clrChange, clrRepl = instance.clrRepl, duotone = instance.duotone, fill = instance.fill, fillOverlay = instance.fillOverlay, glow = instance.glow, grayscl = instance.grayscl, hsl = instance.hsl, innerShdw = instance.innerShdw, lum = instance.lum, outerShdw = instance.outerShdw, prstShdw = instance.prstShdw, reflection = instance.reflection, relOff = instance.relOff, softEdge = instance.softEdge, tint = instance.tint, xfrm = instance.xfrm;
        if (!common_1._isNullOrUndefined(cont)) {
            WriteCT_EffectContainer(writer, CONST_A, "cont", cont);
        }
        if (!common_1._isNullOrUndefined(effect)) {
            WriteCT_EffectReference(writer, CONST_A, "effect", effect);
        }
        if (!common_1._isNullOrUndefined(alphaBiLevel)) {
            WriteCT_AlphaBiLevelEffect(writer, CONST_A, "alphaBiLevel", alphaBiLevel);
        }
        if (!common_1._isNullOrUndefined(alphaCeiling)) {
            WriteCT_AlphaCeilingEffect(writer, CONST_A, "alphaCeiling");
        }
        if (!common_1._isNullOrUndefined(alphaFloor)) {
            WriteCT_AlphaFloorEffect(writer, CONST_A, "alphaFloor");
        }
        if (!common_1._isNullOrUndefined(alphaInv)) {
            WriteCT_AlphaInverseEffect(writer, CONST_A, "alphaInv", alphaInv);
        }
        if (!common_1._isNullOrUndefined(alphaMod)) {
            WriteCT_AlphaModulateEffect(writer, CONST_A, "alphaMod", alphaMod);
        }
        if (!common_1._isNullOrUndefined(alphaModFix)) {
            WriteCT_AlphaModulateFixedEffect(writer, CONST_A, "alphaModFix", alphaModFix);
        }
        if (!common_1._isNullOrUndefined(alphaOutset)) {
            WriteCT_AlphaOutsetEffect(writer, CONST_A, "alphaOutset", alphaOutset);
        }
        if (!common_1._isNullOrUndefined(alphaRepl)) {
            WriteCT_AlphaReplaceEffect(writer, CONST_A, "alphaRepl", alphaRepl);
        }
        if (!common_1._isNullOrUndefined(biLevel)) {
            WriteCT_BiLevelEffect(writer, CONST_A, "biLevel", biLevel);
        }
        if (!common_1._isNullOrUndefined(blend)) {
            WriteCT_BlendEffect(writer, CONST_A, "blend", blend);
        }
        if (!common_1._isNullOrUndefined(blur)) {
            WriteCT_BlurEffect(writer, CONST_A, "blur", blur);
        }
        if (!common_1._isNullOrUndefined(clrChange)) {
            WriteCT_ColorChangeEffect(writer, CONST_A, "clrChange", clrChange);
        }
        if (!common_1._isNullOrUndefined(clrRepl)) {
            WriteCT_ColorReplaceEffect(writer, CONST_A, "clrRepl", clrRepl);
        }
        if (!common_1._isNullOrUndefined(duotone)) {
            WriteCT_DuotoneEffect(writer, CONST_A, "duotone", duotone);
        }
        if (!common_1._isNullOrUndefined(fill)) {
            WriteCT_FillEffect(writer, CONST_A, "fill", fill);
        }
        if (!common_1._isNullOrUndefined(fillOverlay)) {
            WriteCT_FillOverlayEffect(writer, CONST_A, "fillOverlay", fillOverlay);
        }
        if (!common_1._isNullOrUndefined(glow)) {
            WriteCT_GlowEffect(writer, CONST_A, "glow", glow);
        }
        if (!common_1._isNullOrUndefined(grayscl)) {
            WriteCT_GrayscaleEffect(writer, CONST_A, "grayscl");
        }
        if (!common_1._isNullOrUndefined(hsl)) {
            WriteCT_HSLEffect(writer, CONST_A, "hsl", hsl);
        }
        if (!common_1._isNullOrUndefined(innerShdw)) {
            WriteCT_InnerShadowEffect(writer, CONST_A, "innerShdw", innerShdw);
        }
        if (!common_1._isNullOrUndefined(lum)) {
            WriteCT_LuminanceEffect(writer, CONST_A, "lum", lum);
        }
        if (!common_1._isNullOrUndefined(outerShdw)) {
            WriteCT_OuterShadowEffect(writer, CONST_A, "outerShdw", outerShdw);
        }
        if (!common_1._isNullOrUndefined(prstShdw)) {
            WriteCT_PresetShadowEffect(writer, CONST_A, "prstShdw", prstShdw);
        }
        if (!common_1._isNullOrUndefined(reflection)) {
            WriteCT_ReflectionEffect(writer, CONST_A, "reflection", reflection);
        }
        if (!common_1._isNullOrUndefined(relOff)) {
            WriteCT_RelativeOffsetEffect(writer, CONST_A, "relOff", relOff);
        }
        if (!common_1._isNullOrUndefined(softEdge)) {
            WriteCT_SoftEdgesEffect(writer, CONST_A, "softEdge", softEdge);
        }
        if (!common_1._isNullOrUndefined(tint)) {
            WriteCT_TintEffect(writer, CONST_A, "tint", tint);
        }
        if (!common_1._isNullOrUndefined(xfrm)) {
            WriteCT_TransformEffect(writer, CONST_A, "xfrm", xfrm);
        }
    });
}
exports.DrawingWriter.WriteCT_EffectContainer = WriteCT_EffectContainer;
function WriteCT_AlphaModulateEffect(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_EffectContainer, CONST_A, "cont");
}
exports.DrawingWriter.WriteCT_AlphaModulateEffect = WriteCT_AlphaModulateEffect;
function WriteCT_BlendEffect(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.blend)) {
            writer.writeAttributeString("blend", chart_model_1.Charts.ST_BlendMode[instance.blend]);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.cont)) {
            WriteCT_EffectContainer(writer, CONST_A, "cont", instance.cont);
        }
    });
}
exports.DrawingWriter.WriteCT_BlendEffect = WriteCT_BlendEffect;
function WriteCT_EffectList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var blur = instance.blur, fillOverlay = instance.fillOverlay, glow = instance.glow, innerShdw = instance.innerShdw, outerShdw = instance.outerShdw, prstShdw = instance.prstShdw, reflection = instance.reflection, softEdge = instance.softEdge;
        if (!common_1._isNullOrUndefined(blur)) {
            WriteCT_BlurEffect(writer, CONST_A, "blur", blur);
        }
        if (!common_1._isNullOrUndefined(fillOverlay)) {
            WriteCT_FillOverlayEffect(writer, CONST_A, "fillOverlay", fillOverlay);
        }
        if (!common_1._isNullOrUndefined(glow)) {
            WriteCT_GlowEffect(writer, CONST_A, "glow", glow);
        }
        if (!common_1._isNullOrUndefined(innerShdw)) {
            WriteCT_InnerShadowEffect(writer, CONST_A, "innerShdw", innerShdw);
        }
        if (!common_1._isNullOrUndefined(outerShdw)) {
            WriteCT_OuterShadowEffect(writer, CONST_A, "outerShdw", outerShdw);
        }
        if (!common_1._isNullOrUndefined(prstShdw)) {
            WriteCT_PresetShadowEffect(writer, CONST_A, "prstShdw", prstShdw);
        }
        if (!common_1._isNullOrUndefined(reflection)) {
            WriteCT_ReflectionEffect(writer, CONST_A, "reflection", reflection);
        }
        if (!common_1._isNullOrUndefined(softEdge)) {
            WriteCT_SoftEdgesEffect(writer, CONST_A, "softEdge", softEdge);
        }
    });
}
exports.DrawingWriter.WriteCT_EffectList = WriteCT_EffectList;
function WriteCT_EffectProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var effectLst = instance.effectLst, effectDag = instance.effectDag;
        if (!common_1._isNullOrUndefined(effectLst)) {
            WriteCT_EffectList(writer, CONST_A, CONST_EFFECTLST, effectLst);
        }
        if (!common_1._isNullOrUndefined(effectDag)) {
            WriteCT_EffectContainer(writer, CONST_A, CONST_EFFECT_DAG, effectDag);
        }
    });
}
exports.DrawingWriter.WriteCT_EffectProperties = WriteCT_EffectProperties;
function WriteCT_GeomGuide(writer, prefix, localName, instance) {
    writeDoubleSubElementNode(writer, prefix, localName, instance, CONST_NAME, "fmla");
}
exports.DrawingWriter.WriteCT_GeomGuide = WriteCT_GeomGuide;
function WriteCT_GeomGuideList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.gd, function (gdItem) {
            WriteCT_GeomGuide(writer, CONST_A, "gd", gdItem);
        });
    });
}
exports.DrawingWriter.WriteCT_GeomGuideList = WriteCT_GeomGuideList;
function WriteCT_AdjPoint2D(writer, prefix, localName, instance) {
    writeDoubleSubElementNode(writer, prefix, localName, instance, "x", "y");
}
exports.DrawingWriter.WriteCT_AdjPoint2D = WriteCT_AdjPoint2D;
function WriteCT_GeomRect(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.l)) {
            writer.writeAttributeString("l", instance.l);
        }
        if (!common_1._isNullOrUndefined(instance.t)) {
            writer.writeAttributeString("t", instance.t);
        }
        if (!common_1._isNullOrUndefined(instance.r)) {
            writer.writeAttributeString(CONST_R, instance.r);
        }
        if (!common_1._isNullOrUndefined(instance.b)) {
            writer.writeAttributeString("b", instance.b);
        }
    });
}
exports.DrawingWriter.WriteCT_GeomRect = WriteCT_GeomRect;
function WriteCT_XYAdjustHandle(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var gdRefX = instance.gdRefX, minX = instance.minX, maxX = instance.maxX, gdRefY = instance.gdRefY, minY = instance.minY, maxY = instance.maxY;
        if (!common_1._isNullOrUndefined(gdRefX)) {
            writer.writeAttributeString("gdRefX", gdRefX);
        }
        if (!common_1._isNullOrUndefined(minX)) {
            writer.writeAttributeString("minX", minX);
        }
        if (!common_1._isNullOrUndefined(maxX)) {
            writer.writeAttributeString("maxX", maxX);
        }
        if (!common_1._isNullOrUndefined(gdRefY)) {
            writer.writeAttributeString("gdRefY", gdRefY);
        }
        if (!common_1._isNullOrUndefined(minY)) {
            writer.writeAttributeString("minY", minY);
        }
        if (!common_1._isNullOrUndefined(maxY)) {
            writer.writeAttributeString("maxY", maxY);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.pos)) {
            WriteCT_AdjPoint2D(writer, CONST_A, "pos", instance.pos);
        }
    });
}
exports.DrawingWriter.WriteCT_XYAdjustHandle = WriteCT_XYAdjustHandle;
function WriteCT_PolarAdjustHandle(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var gdRefR = instance.gdRefR, minR = instance.minR, maxR = instance.maxR, gdRefAng = instance.gdRefAng, minAng = instance.minAng, maxAng = instance.maxAng;
        if (!common_1._isNullOrUndefined(gdRefR)) {
            writer.writeAttributeString("gdRefR", gdRefR);
        }
        if (!common_1._isNullOrUndefined(minR)) {
            writer.writeAttributeString("minR", minR);
        }
        if (!common_1._isNullOrUndefined(maxR)) {
            writer.writeAttributeString("maxR", maxR);
        }
        if (!common_1._isNullOrUndefined(gdRefAng)) {
            writer.writeAttributeString("gdRefAng", gdRefAng);
        }
        if (!common_1._isNullOrUndefined(minAng)) {
            writer.writeAttributeString("minAng", minAng);
        }
        if (!common_1._isNullOrUndefined(maxAng)) {
            writer.writeAttributeString("maxAng", maxAng);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.pos)) {
            WriteCT_AdjPoint2D(writer, CONST_A, "pos", instance.pos);
        }
    });
}
exports.DrawingWriter.WriteCT_PolarAdjustHandle = WriteCT_PolarAdjustHandle;
function WriteCT_ConnectionSite(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.ang)) {
            writer.writeAttributeString("ang", instance.ang);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.pos)) {
            WriteCT_AdjPoint2D(writer, CONST_A, "pos", instance.pos);
        }
    });
}
exports.DrawingWriter.WriteCT_ConnectionSite = WriteCT_ConnectionSite;
function WriteCT_AdjustHandleList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.ahXY)) {
            WriteCT_XYAdjustHandle(writer, CONST_A, "ahXY", instance.ahXY);
        }
        if (!common_1._isNullOrUndefined(instance.ahPolar)) {
            WriteCT_PolarAdjustHandle(writer, CONST_A, "ahPolar", instance.ahPolar);
        }
    });
}
exports.DrawingWriter.WriteCT_AdjustHandleList = WriteCT_AdjustHandleList;
function WriteCT_ConnectionSiteList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.cxn, function (cxnItem) {
            WriteCT_ConnectionSite(writer, CONST_A, "cxn", cxnItem);
        });
    });
}
exports.DrawingWriter.WriteCT_ConnectionSiteList = WriteCT_ConnectionSiteList;
function WriteCT_Connection(writer, prefix, localName, instance) {
    writeDoubleSubElementNode(writer, prefix, localName, instance, "id", "idx");
}
exports.DrawingWriter.WriteCT_Connection = WriteCT_Connection;
function WriteCT_Path2DMoveTo(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_AdjPoint2D, CONST_A, "pt");
}
exports.DrawingWriter.WriteCT_Path2DMoveTo = WriteCT_Path2DMoveTo;
function WriteCT_Path2DLineTo(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_AdjPoint2D, CONST_A, "pt");
}
exports.DrawingWriter.WriteCT_Path2DLineTo = WriteCT_Path2DLineTo;
function WriteCT_Path2DArcTo(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var wR = instance.wR, hR = instance.hR, stAng = instance.stAng, swAng = instance.swAng;
        if (!common_1._isNullOrUndefined(wR)) {
            writer.writeAttributeString("wR", wR);
        }
        if (!common_1._isNullOrUndefined(hR)) {
            writer.writeAttributeString("hR", hR);
        }
        if (!common_1._isNullOrUndefined(stAng)) {
            writer.writeAttributeString("stAng", stAng);
        }
        if (!common_1._isNullOrUndefined(swAng)) {
            writer.writeAttributeString("swAng", swAng);
        }
    });
}
exports.DrawingWriter.WriteCT_Path2DArcTo = WriteCT_Path2DArcTo;
function WriteCT_Path2DQuadBezierTo(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.pt, function (ptItem) {
            WriteCT_AdjPoint2D(writer, CONST_A, "pt", ptItem);
        });
    });
}
exports.DrawingWriter.WriteCT_Path2DQuadBezierTo = WriteCT_Path2DQuadBezierTo;
function WriteCT_Path2DCubicBezierTo(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.pt, function (ptItem) {
            WriteCT_AdjPoint2D(writer, CONST_A, "pt", ptItem);
        });
    });
}
exports.DrawingWriter.WriteCT_Path2DCubicBezierTo = WriteCT_Path2DCubicBezierTo;
function WriteCT_Path2DClose(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_Path2DClose = WriteCT_Path2DClose;
function WriteCT_Path2D(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var w = instance.w, h = instance.h, fill = instance.fill;
        if (!common_1._isNullOrUndefined(w) && w !== 0) {
            writer.writeAttributeString("w", w);
        }
        if (!common_1._isNullOrUndefined(h) && h !== 0) {
            writer.writeAttributeString("h", h);
        }
        if (!common_1._isNullOrUndefined(fill) && fill !== 1) {
            writer.writeAttributeString("fill", chart_model_1.Charts.ST_PathFillMode[fill]);
        }
        if (instance.stroke === false) {
            writer.writeAttributeString("stroke", "0");
        }
        if (instance.extrusionOk === false) {
            writer.writeAttributeString("extrusionOk", "0");
        }
    }, function () {
        writeArrayItem(instance.pathToList, function (item) {
            if (item.typeName === chart_model_1.Charts.CT_PathType.CT_Path2DClose) {
                WriteCT_Path2DClose(writer, CONST_A, "close");
            }
            else if (item.typeName === chart_model_1.Charts.CT_PathType.CT_PathToList) {
                var pathToList = item;
                switch (pathToList.pathToType) {
                    case 0:
                        WriteCT_AdjPoint2DList(writer, CONST_A, "lnTo", item);
                        break;
                    case 1:
                        WriteCT_AdjPoint2DList(writer, CONST_A, "moveTo", item);
                        break;
                    case 2:
                        WriteCT_AdjPoint2DList(writer, CONST_A, "quadBezTo", item);
                        break;
                    case 3:
                        WriteCT_AdjPoint2DList(writer, CONST_A, "cubicBezTo", item);
                        break;
                }
            }
            else if (item.typeName === chart_model_1.Charts.CT_PathType.CT_Path2DArcTo) {
                WriteCT_Path2DArcTo(writer, CONST_A, "arcTo", item);
            }
        });
    });
}
exports.DrawingWriter.WriteCT_Path2D = WriteCT_Path2D;
function WriteCT_AdjPoint2DList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.PtList, function (item) {
            WriteCT_AdjPoint2D(writer, CONST_A, "pt", item);
        });
    });
}
exports.DrawingWriter.WriteCT_AdjPoint2DList = WriteCT_AdjPoint2DList;
function WriteCT_Path2DList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance, function (item) {
            WriteCT_Path2D(writer, CONST_A, "path", item);
        });
    });
}
exports.DrawingWriter.WriteCT_Path2DList = WriteCT_Path2DList;
function WriteCT_PresetGeometry2D(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.prst)) {
            writer.writeAttributeString(CONST_PRST, chart_model_1.Charts.ST_ShapeType[instance.prst]);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.avLst)) {
            WriteCT_GeomGuideList(writer, CONST_A, "avLst", instance.avLst);
        }
    });
}
exports.DrawingWriter.WriteCT_PresetGeometry2D = WriteCT_PresetGeometry2D;
function WriteCT_PresetTextShape(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.prst)) {
            writer.writeAttributeString(CONST_PRST, chart_model_1.Charts.ST_TextShapeType[instance.prst]);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.avLst)) {
            WriteCT_GeomGuideList(writer, CONST_A, "avLst", instance.avLst);
        }
    });
}
exports.DrawingWriter.WriteCT_PresetTextShape = WriteCT_PresetTextShape;
function WriteCT_CustomGeometry2D(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var avLst = instance.avLst, gdLst = instance.gdLst, ahLst = instance.ahLst, cxnLst = instance.cxnLst, rect = instance.rect;
        if (!common_1._isNullOrUndefined(avLst)) {
            WriteCT_GeomGuideList(writer, CONST_A, "avLst", avLst);
        }
        if (!common_1._isNullOrUndefined(gdLst)) {
            WriteCT_GeomGuideList(writer, CONST_A, "gdLst", gdLst);
        }
        if (!common_1._isNullOrUndefined(ahLst)) {
            WriteCT_AdjustHandleList(writer, CONST_A, "ahLst", ahLst);
        }
        if (!common_1._isNullOrUndefined(cxnLst)) {
            WriteCT_ConnectionSiteList(writer, CONST_A, "cxnLst", cxnLst);
        }
        if (!common_1._isNullOrUndefined(rect)) {
            WriteCT_GeomRect(writer, CONST_A, "rect", rect);
        }
        WriteCT_Path2DList(writer, CONST_A, "pathLst", instance.pathLst);
    });
}
exports.DrawingWriter.WriteCT_CustomGeometry2D = WriteCT_CustomGeometry2D;
function WriteCT_LineEndProperties(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.type)) {
            writer.writeAttributeString(CONST_TYPE, chart_model_1.Charts.ST_LineEndType[instance.type]);
        }
        if (!common_1._isNullOrUndefined(instance.w)) {
            writer.writeAttributeString("w", chart_model_1.Charts.ST_LineEndWidth[instance.w]);
        }
        if (!common_1._isNullOrUndefined(instance.len)) {
            writer.writeAttributeString("len", chart_model_1.Charts.ST_LineEndLength[instance.len]);
        }
    });
}
exports.DrawingWriter.WriteCT_LineEndProperties = WriteCT_LineEndProperties;
function WriteCT_LineJoinBevel(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_LineJoinBevel = WriteCT_LineJoinBevel;
function WriteCT_LineJoinRound(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_LineJoinRound = WriteCT_LineJoinRound;
function WriteCT_LineJoinMiterProperties(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance.lim, "lim");
}
exports.DrawingWriter.WriteCT_LineJoinMiterProperties = WriteCT_LineJoinMiterProperties;
function WriteCT_PresetLineDashProperties(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL, keyword_null, chart_model_1.Charts.ST_PresetLineDashVal, chart_helper_1.ChartHelper.ToST_PresetLineDashVal);
}
exports.DrawingWriter.WriteCT_PresetLineDashProperties = WriteCT_PresetLineDashProperties;
function WriteCT_DashStop(writer, prefix, localName, instance) {
    writeDoubleSubElementNode(writer, prefix, localName, instance, "d", "sp");
}
exports.DrawingWriter.WriteCT_DashStop = WriteCT_DashStop;
function WriteCT_DashStopList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.ds, function (dsItem) {
            WriteCT_DashStop(writer, CONST_A, "ds", dsItem);
        });
    });
}
exports.DrawingWriter.WriteCT_DashStopList = WriteCT_DashStopList;
function WriteCT_LineProperties(writer, prefix, localName, instance) {
    if (instance.w <= 0) {
        instance.noFill = true;
    }
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.w) && instance.w >= 0) {
            writer.writeAttributeString("w", pixelToEMU(instance.w));
        }
        if (!common_1._isNullOrUndefined(instance.cap)) {
            writer.writeAttributeString("cap", chart_model_1.Charts.ST_LineCap[instance.cap]);
        }
        if (!common_1._isNullOrUndefined(instance.cmpd)) {
            writer.writeAttributeString("cmpd", chart_model_1.Charts.ST_CompoundLine[instance.cmpd]);
        }
        if (!common_1._isNullOrUndefined(instance.algn)) {
            writer.writeAttributeString("algn", chart_model_1.Charts.ST_PenAlignment[instance.algn]);
        }
    }, function () {
        var noFill = instance.noFill, solidFill = instance.solidFill, gradFill = instance.gradFill, pattFill = instance.pattFill, prstDash = instance.prstDash, custDash = instance.custDash, round = instance.round, bevel = instance.bevel, miter = instance.miter, headEnd = instance.headEnd, tailEnd = instance.tailEnd, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(noFill)) {
            WriteCT_NoFillProperties(writer, CONST_A, CONST_NO_FILL);
        }
        else if (!common_1._isNullOrUndefined(solidFill)) {
            WriteCT_SolidColorFillProperties(writer, CONST_A, CONST_SOLID_FILL, solidFill);
        }
        else if (!common_1._isNullOrUndefined(gradFill)) {
            WriteCT_GradientFillProperties(writer, CONST_A, CONST_GRAD_FILL, gradFill);
        }
        else if (!common_1._isNullOrUndefined(pattFill)) {
            WriteCT_PatternFillProperties(writer, CONST_A, CONST_PATT_FILL, pattFill);
        }
        if (!common_1._isNullOrUndefined(prstDash)) {
            WriteCT_PresetLineDashProperties(writer, CONST_A, "prstDash", prstDash);
        }
        else if (!common_1._isNullOrUndefined(custDash)) {
            WriteCT_DashStopList(writer, CONST_A, "custDash", custDash);
        }
        if (!common_1._isNullOrUndefined(round)) {
            WriteCT_LineJoinRound(writer, CONST_A, "round");
        }
        if (!common_1._isNullOrUndefined(bevel)) {
            WriteCT_LineJoinBevel(writer, CONST_A, "bevel");
        }
        if (!common_1._isNullOrUndefined(miter)) {
            WriteCT_LineJoinMiterProperties(writer, CONST_A, "miter", miter);
        }
        if (!common_1._isNullOrUndefined(headEnd)) {
            WriteCT_LineEndProperties(writer, CONST_A, "headEnd", headEnd);
        }
        if (!common_1._isNullOrUndefined(tailEnd)) {
            WriteCT_LineEndProperties(writer, CONST_A, "tailEnd", tailEnd);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_LineProperties = WriteCT_LineProperties;
function WriteCT_SvgBlipProperties(writer, instance) {
    writer.writeLeafElement("asvg:svgBlip", function () {
        writer.writeAttributeString("xmlns:asvg", excel_types_1.XFileConstants._asvg);
        var embed = instance.embed;
        if (!common_1._isNullOrUndefined(embed)) {
            writer.writeAttributeString("r:embed", embed);
        }
    });
}
exports.DrawingWriter.WriteCT_SvgBlipProperties = WriteCT_SvgBlipProperties;
function WriteCT_ShapeProperties(writer, prefix, localName, instance, isGraphicFrame) {
    writer.writeElement(prefix + ":" + localName, function () {
        var bwMode = instance.bwMode;
        if (!common_1._isNullOrUndefined(bwMode) && bwMode !== 0) {
            writer.writeAttributeString("bwMode", chart_model_1.Charts.ST_BlackWhiteMode[bwMode]);
        }
    }, function () {
        var xfrm = instance.xfrm, custGeom = instance.custGeom, prstGeom = instance.prstGeom, noFill = instance.noFill, solidFill = instance.solidFill, gradFill = instance.gradFill, blipFill = instance.blipFill, pattFill = instance.pattFill, grpFill = instance.grpFill, ln = instance.ln, effectLst = instance.effectLst, effectDag = instance.effectDag, scene3d = instance.scene3d, sp3d = instance.sp3d, extLst = instance.extLst;
        if (common_1._isNullOrUndefined(isGraphicFrame)) {
            isGraphicFrame = true;
        }
        WriteCT_Transform2D(writer, CONST_A, "xfrm", xfrm, isGraphicFrame);
        if (!common_1._isNullOrUndefined(custGeom)) {
            WriteCT_CustomGeometry2D(writer, CONST_A, "custGeom", custGeom);
        }
        else if (!common_1._isNullOrUndefined(prstGeom)) {
            WriteCT_PresetGeometry2D(writer, CONST_A, "prstGeom", prstGeom);
        }
        if (!common_1._isNullOrUndefined(noFill)) {
            WriteCT_NoFillProperties(writer, CONST_A, CONST_NO_FILL);
        }
        else if (!common_1._isNullOrUndefined(solidFill)) {
            WriteCT_SolidColorFillProperties(writer, CONST_A, CONST_SOLID_FILL, solidFill);
        }
        else if (!common_1._isNullOrUndefined(gradFill)) {
            WriteCT_GradientFillProperties(writer, CONST_A, CONST_GRAD_FILL, gradFill);
        }
        else if (!common_1._isNullOrUndefined(blipFill)) {
            WriteCT_BlipFillProperties(writer, CONST_A, CONST_BLIP_FILL, blipFill);
        }
        else if (!common_1._isNullOrUndefined(pattFill)) {
            WriteCT_PatternFillProperties(writer, CONST_A, CONST_PATT_FILL, pattFill);
        }
        else if (!common_1._isNullOrUndefined(grpFill)) {
            WriteCT_GroupFillProperties(writer, CONST_A, CONST_GRP_FILL);
        }
        if (!common_1._isNullOrUndefined(ln)) {
            WriteCT_LineProperties(writer, CONST_A, "ln", ln);
        }
        if (!common_1._isNullOrUndefined(effectLst)) {
            WriteCT_EffectList(writer, CONST_A, CONST_EFFECTLST, effectLst);
        }
        if (!common_1._isNullOrUndefined(effectDag)) {
            WriteCT_EffectContainer(writer, CONST_A, CONST_EFFECT_DAG, effectDag);
        }
        if (!common_1._isNullOrUndefined(scene3d)) {
            WriteCT_Scene3D(writer, CONST_A, CONST_SCENE_3D, scene3d);
        }
        if (!common_1._isNullOrUndefined(sp3d)) {
            WriteCT_Shape3D(writer, CONST_A, "sp3d", sp3d);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_ShapeProperties = WriteCT_ShapeProperties;
function WriteCT_GroupShapeProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var bwMode = instance.bwMode;
        if (!common_1._isNullOrUndefined(bwMode) && bwMode !== 0) {
            writer.writeAttributeString("bwMode", chart_model_1.Charts.ST_BlackWhiteMode[bwMode]);
        }
    }, function () {
        var xfrm = instance.xfrm, scene3d = instance.scene3d, extLst = instance.extLst, effectLst = instance.effectLst, effectDag = instance.effectDag;
        if (!common_1._isNullOrUndefined(xfrm)) {
            WriteCT_GroupTransform2D(writer, CONST_A, "xfrm", xfrm);
        }
        writeFillProperties(writer, instance);
        if (!common_1._isNullOrUndefined(effectLst)) {
            WriteCT_EffectList(writer, CONST_A, CONST_EFFECTLST, effectLst);
        }
        if (!common_1._isNullOrUndefined(effectDag)) {
            WriteCT_EffectContainer(writer, CONST_A, CONST_EFFECT_DAG, effectDag);
        }
        if (!common_1._isNullOrUndefined(scene3d)) {
            WriteCT_Scene3D(writer, CONST_A, CONST_SCENE_3D, scene3d);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_GroupShapeProperties = WriteCT_GroupShapeProperties;
function WriteCT_StyleMatrixReference(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.idx)) {
            writer.writeAttributeString("idx", instance.idx);
        }
    }, function () {
        if (instance.ColorProp) {
            writeSubColorElements(writer, instance.ColorProp);
        }
    });
}
exports.DrawingWriter.WriteCT_StyleMatrixReference = WriteCT_StyleMatrixReference;
function WriteCT_FontReference(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.idx)) {
            writer.writeAttributeString("idx", chart_model_1.Charts.ST_FontCollectionIndex[instance.idx]);
        }
    }, function () {
        var solidFillProperties = instance.TextCharacterProperties.solidFill;
        if (solidFillProperties) {
            writeSubColorElements(writer, solidFillProperties);
        }
    });
}
exports.DrawingWriter.WriteCT_FontReference = WriteCT_FontReference;
function WriteCT_ShapeStyle(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var lnRef = instance.lnRef, fillRef = instance.fillRef, effectRef = instance.effectRef, fontRef = instance.fontRef;
        if (!common_1._isNullOrUndefined(lnRef)) {
            WriteCT_StyleMatrixReference(writer, CONST_A, "lnRef", lnRef);
        }
        if (!common_1._isNullOrUndefined(fillRef)) {
            WriteCT_StyleMatrixReference(writer, CONST_A, "fillRef", fillRef);
        }
        if (!common_1._isNullOrUndefined(effectRef)) {
            WriteCT_StyleMatrixReference(writer, CONST_A, "effectRef", effectRef);
        }
        if (!common_1._isNullOrUndefined(fontRef)) {
            WriteCT_FontReference(writer, CONST_A, "fontRef", fontRef);
        }
    });
}
exports.DrawingWriter.WriteCT_ShapeStyle = WriteCT_ShapeStyle;
function WriteCT_AnchorClientData(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (instance.fLocksWithSheet === false) {
            writer.writeAttributeString("fLocksWithSheet", "0");
        }
        if (instance.fPrintsWithSheet === false) {
            writer.writeAttributeString("fPrintsWithSheet", "0");
        }
    });
}
exports.DrawingWriter.WriteCT_AnchorClientData = WriteCT_AnchorClientData;
function WriteCT_ShapeNonVisual(writer, prefix, localName, instance) {
    writeShapeNonVisualElement(writer, prefix, localName, instance, prefix);
}
exports.DrawingWriter.WriteCT_ShapeNonVisual = WriteCT_ShapeNonVisual;
function WriteCT_ShapeNonVisualForCdr(writer, prefix, localName, instance) {
    writeShapeNonVisualElement(writer, prefix, localName, instance, CONST_CDR);
}
exports.DrawingWriter.WriteCT_ShapeNonVisualForCdr = WriteCT_ShapeNonVisualForCdr;
function WriteCT_ShapeNonVisualForXdr(writer, prefix, localName, instance) {
    writeShapeNonVisualElement(writer, prefix, localName, instance, CONST_XDR);
}
exports.DrawingWriter.WriteCT_ShapeNonVisualForXdr = WriteCT_ShapeNonVisualForXdr;
function WriteCT_Shape(writer, prefix, localName, instance) {
    writeShapeElement(writer, prefix, localName, instance, prefix, WriteCT_ShapeNonVisual);
}
exports.DrawingWriter.WriteCT_Shape = WriteCT_Shape;
function WriteCT_ShapeForCdr(writer, prefix, localName, instance) {
    writeShapeElement(writer, prefix, localName, instance, CONST_CDR, WriteCT_ShapeNonVisualForCdr);
}
exports.DrawingWriter.WriteCT_ShapeForCdr = WriteCT_ShapeForCdr;
function WriteCT_ShapeForXdr(writer, prefix, localName, instance) {
    writeShapeElement(writer, prefix, localName, instance, CONST_XDR, WriteCT_ShapeNonVisualForXdr);
}
exports.DrawingWriter.WriteCT_ShapeForXdr = WriteCT_ShapeForXdr;
function WriteCT_ConnectorNonVisual(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var cNvPr = instance.cNvPr, cNvCxnSpPr = instance.cNvCxnSpPr;
        if (!common_1._isNullOrUndefined(cNvPr)) {
            WriteCT_NonVisualDrawingProps(writer, CONST_XDR, CONST_CNVPR, cNvPr);
        }
        if (!common_1._isNullOrUndefined(cNvCxnSpPr)) {
            WriteCT_NonVisualConnectorProperties(writer, CONST_XDR, "cNvCxnSpPr", cNvCxnSpPr);
        }
    });
}
exports.DrawingWriter.WriteCT_ConnectorNonVisual = WriteCT_ConnectorNonVisual;
function WriteCT_ConnectorNonVisualCdr(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var cNvPr = instance.cNvPr, cNvCxnSpPr = instance.cNvCxnSpPr;
        if (!common_1._isNullOrUndefined(cNvPr)) {
            WriteCT_NonVisualDrawingProps(writer, CONST_CDR, CONST_CNVPR, cNvPr);
        }
        if (!common_1._isNullOrUndefined(cNvCxnSpPr)) {
            WriteCT_NonVisualConnectorProperties(writer, CONST_CDR, "cNvCxnSpPr", cNvCxnSpPr);
        }
    });
}
exports.DrawingWriter.WriteCT_ConnectorNonVisualCdr = WriteCT_ConnectorNonVisualCdr;
function WriteCT_Connector(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var macro = instance.macro;
        if (!common_1._isNullOrUndefined(macro)) {
            writer.writeAttributeString(CONST_MACRO, macro);
        }
        if (instance.fPublished === true) {
            writer.writeAttributeString(CONST_FPUBLISHED, "1");
        }
    }, function () {
        var nvCxnSpPr = instance.nvCxnSpPr, spPr = instance.spPr, style = instance.style;
        if (!common_1._isNullOrUndefined(nvCxnSpPr)) {
            WriteCT_ConnectorNonVisual(writer, CONST_XDR, "nvCxnSpPr", nvCxnSpPr);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_XDR, CONST_SPPR, spPr, false);
        }
        if (!common_1._isNullOrUndefined(style)) {
            WriteCT_ShapeStyle(writer, CONST_XDR, CONST_STYLE, style);
        }
    });
}
exports.DrawingWriter.WriteCT_Connector = WriteCT_Connector;
function WriteCT_ConnectorCdr(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var macro = instance.macro;
        if (!common_1._isNullOrUndefined(macro)) {
            writer.writeAttributeString(CONST_MACRO, macro);
        }
        if (instance.fPublished === true) {
            writer.writeAttributeString(CONST_FPUBLISHED, "1");
        }
    }, function () {
        var nvCxnSpPr = instance.nvCxnSpPr, spPr = instance.spPr, style = instance.style;
        if (!common_1._isNullOrUndefined(nvCxnSpPr)) {
            WriteCT_ConnectorNonVisual(writer, CONST_CDR, "nvCxnSpPr", nvCxnSpPr);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_CDR, CONST_SPPR, spPr, false);
        }
        if (!common_1._isNullOrUndefined(style)) {
            WriteCT_ShapeStyle(writer, CONST_CDR, CONST_STYLE, style);
        }
    });
}
exports.DrawingWriter.WriteCT_ConnectorCdr = WriteCT_ConnectorCdr;
function WriteCT_PictureNonVisualGroup(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var cNvPr = instance.cNvPr, cNvPicPr = instance.cNvPicPr;
        if (!common_1._isNullOrUndefined(cNvPr)) {
            WriteCT_NonVisualDrawingProps(writer, CONST_XDR, CONST_CNVPR, cNvPr);
        }
        if (!common_1._isNullOrUndefined(cNvPicPr)) {
            WriteCT_NonVisualPictureProperties(writer, CONST_XDR, CONST_CNV_PIC_PR, cNvPicPr);
        }
    });
}
exports.DrawingWriter.WriteCT_PictureNonVisualGroup = WriteCT_PictureNonVisualGroup;
function WriteCT_PictureNonVisual(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var cNvPr = instance.cNvPr, cNvPicPr = instance.cNvPicPr;
        if (!common_1._isNullOrUndefined(cNvPr)) {
            WriteCT_NonVisualDrawingProps(writer, CONST_A, CONST_CNVPR, cNvPr);
        }
        if (!common_1._isNullOrUndefined(cNvPicPr)) {
            WriteCT_NonVisualPictureProperties(writer, CONST_A, CONST_CNV_PIC_PR, cNvPicPr);
        }
    });
}
exports.DrawingWriter.WriteCT_PictureNonVisual = WriteCT_PictureNonVisual;
function WriteCT_PictureNonVisualrelSizeAnchor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var cNvPr = instance.cNvPr, cNvPicPr = instance.cNvPicPr;
        if (!common_1._isNullOrUndefined(cNvPr)) {
            WriteCT_NonVisualDrawingProps(writer, CONST_CDR, CONST_CNVPR, cNvPr);
        }
        if (!common_1._isNullOrUndefined(cNvPicPr)) {
            WriteCT_NonVisualPictureProperties(writer, CONST_CDR, CONST_CNV_PIC_PR, cNvPicPr);
        }
    });
}
exports.DrawingWriter.WriteCT_PictureNonVisualrelSizeAnchor = WriteCT_PictureNonVisualrelSizeAnchor;
function WriteCT_PictureNonVisualOneCellAnchor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var cNvPr = instance.cNvPr, cNvPicPr = instance.cNvPicPr;
        if (!common_1._isNullOrUndefined(cNvPr)) {
            WriteCT_NonVisualDrawingProps(writer, CONST_XDR, CONST_CNVPR, cNvPr);
        }
        if (!common_1._isNullOrUndefined(cNvPicPr)) {
            WriteCT_NonVisualPictureProperties(writer, CONST_XDR, CONST_CNV_PIC_PR, cNvPicPr);
        }
    });
}
exports.DrawingWriter.WriteCT_PictureNonVisualOneCellAnchor = WriteCT_PictureNonVisualOneCellAnchor;
function WriteCT_PictureNonVisualForXdr(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var cNvPr = instance.cNvPr, cNvPicPr = instance.cNvPicPr;
        if (!common_1._isNullOrUndefined(cNvPr)) {
            WriteCT_NonVisualDrawingProps(writer, CONST_XDR, CONST_CNVPR, cNvPr);
        }
        if (!common_1._isNullOrUndefined(cNvPicPr)) {
            WriteCT_NonVisualPictureProperties(writer, CONST_XDR, CONST_CNV_PIC_PR, cNvPicPr);
        }
    });
}
exports.DrawingWriter.WriteCT_PictureNonVisualForXdr = WriteCT_PictureNonVisualForXdr;
function WriteCT_PictureGroup(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!isNullOrUndefinedOrEmpty(instance.macro)) {
            writer.writeAttributeString(CONST_MACRO, instance.macro);
        }
        if (instance.fPublished === true) {
            writer.writeAttributeString(CONST_FPUBLISHED, "1");
        }
    }, function () {
        var nvPicPr = instance.nvPicPr, blipFill = instance.blipFill, spPr = instance.spPr, style = instance.style;
        if (!common_1._isNullOrUndefined(nvPicPr)) {
            WriteCT_PictureNonVisualGroup(writer, CONST_XDR, CONST_NV_PIC_PR, nvPicPr);
        }
        if (!common_1._isNullOrUndefined(blipFill)) {
            WriteCT_BlipFillProperties(writer, CONST_XDR, CONST_BLIP_FILL, blipFill);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_XDR, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(style)) {
            WriteCT_ShapeStyle(writer, CONST_A, CONST_STYLE, style);
        }
    });
}
exports.DrawingWriter.WriteCT_PictureGroup = WriteCT_PictureGroup;
function WriteCT_PictureRelSizeAnchor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!isNullOrUndefinedOrEmpty(instance.macro)) {
            writer.writeAttributeString(CONST_MACRO, instance.macro);
        }
        if (instance.fPublished === true) {
            writer.writeAttributeString(CONST_FPUBLISHED, "1");
        }
    }, function () {
        var nvPicPr = instance.nvPicPr, blipFill = instance.blipFill, spPr = instance.spPr, style = instance.style;
        if (!common_1._isNullOrUndefined(nvPicPr)) {
            WriteCT_PictureNonVisualrelSizeAnchor(writer, CONST_CDR, CONST_NV_PIC_PR, nvPicPr);
        }
        if (!common_1._isNullOrUndefined(blipFill)) {
            WriteCT_BlipFillProperties(writer, CONST_CDR, CONST_BLIP_FILL, blipFill);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_CDR, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(style)) {
            WriteCT_ShapeStyle(writer, CONST_CDR, CONST_STYLE, style);
        }
    });
}
exports.DrawingWriter.WriteCT_PictureRelSizeAnchor = WriteCT_PictureRelSizeAnchor;
function WriteCT_Picture(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var macro = instance.macro;
        if (!isNullOrUndefinedOrEmpty(macro)) {
            writer.writeAttributeString(CONST_MACRO, macro);
        }
        if (instance.fPublished === true) {
            writer.writeAttributeString(CONST_FPUBLISHED, "1");
        }
    }, function () {
        var nvPicPr = instance.nvPicPr, blipFill = instance.blipFill, spPr = instance.spPr, style = instance.style;
        if (!common_1._isNullOrUndefined(nvPicPr)) {
            WriteCT_PictureNonVisual(writer, CONST_XDR, CONST_NV_PIC_PR, nvPicPr);
        }
        if (!common_1._isNullOrUndefined(blipFill)) {
            WriteCT_BlipFillProperties(writer, CONST_A, CONST_BLIP_FILL, blipFill);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_A, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(style)) {
            WriteCT_ShapeStyle(writer, CONST_A, CONST_STYLE, style);
        }
    });
}
exports.DrawingWriter.WriteCT_Picture = WriteCT_Picture;
function WriteCT_PictureOneCellAnchor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var macro = instance.macro;
        if (!isNullOrUndefinedOrEmpty(macro)) {
            writer.writeAttributeString(CONST_MACRO, macro);
        }
        if (instance.fPublished === true) {
            writer.writeAttributeString(CONST_FPUBLISHED, "1");
        }
    }, function () {
        var nvPicPr = instance.nvPicPr, blipFill = instance.blipFill, spPr = instance.spPr, style = instance.style;
        if (!common_1._isNullOrUndefined(nvPicPr)) {
            WriteCT_PictureNonVisual(writer, CONST_XDR, CONST_NV_PIC_PR, nvPicPr);
        }
        if (!common_1._isNullOrUndefined(blipFill)) {
            WriteCT_BlipFillProperties(writer, CONST_XDR, CONST_BLIP_FILL, blipFill);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_XDR, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(style)) {
            WriteCT_ShapeStyle(writer, CONST_A, CONST_STYLE, style);
        }
    });
}
exports.DrawingWriter.WriteCT_PictureOneCellAnchor = WriteCT_PictureOneCellAnchor;
function WriteCT_PictureForXdr(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var macro = instance.macro;
        if (!isNullOrUndefinedOrEmpty(macro)) {
            writer.writeAttributeString(CONST_MACRO, macro);
        }
        if (instance.fPublished === true) {
            writer.writeAttributeString(CONST_FPUBLISHED, "1");
        }
    }, function () {
        var nvPicPr = instance.nvPicPr, blipFill = instance.blipFill, spPr = instance.spPr, style = instance.style;
        if (!common_1._isNullOrUndefined(nvPicPr)) {
            WriteCT_PictureNonVisualForXdr(writer, CONST_XDR, CONST_NV_PIC_PR, nvPicPr);
        }
        if (!common_1._isNullOrUndefined(blipFill)) {
            WriteCT_BlipFillProperties(writer, CONST_XDR, CONST_BLIP_FILL, blipFill);
        }
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_XDR, CONST_SPPR, spPr, instance.cellRange ? false : undefined);
        }
        if (!common_1._isNullOrUndefined(style)) {
            WriteCT_ShapeStyle(writer, CONST_XDR, CONST_STYLE, style);
        }
    });
}
exports.DrawingWriter.WriteCT_PictureForXdr = WriteCT_PictureForXdr;
function WriteCT_GraphicalObjectFrameNonVisual(writer, prefix, localName, instance) {
    writeGraphicFrameNonVisualSubElement(writer, prefix, localName, instance, CONST_XDR);
}
exports.DrawingWriter.WriteCT_GraphicalObjectFrameNonVisual = WriteCT_GraphicalObjectFrameNonVisual;
function WriteCT_GraphicalObjectFrameNonVisual_cdr(writer, prefix, localName, instance) {
    writeGraphicFrameNonVisualSubElement(writer, prefix, localName, instance, CONST_CDR);
}
exports.DrawingWriter.WriteCT_GraphicalObjectFrameNonVisual_cdr = WriteCT_GraphicalObjectFrameNonVisual_cdr;
function WriteCT_GraphicalObjectFrame(writer, prefix, localName, instance, is2016Chart) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString(CONST_MACRO, '');
    }, function () {
        var nvGraphicFramePr = instance.nvGraphicFramePr, graphic = instance.graphic;
        if (!common_1._isNullOrUndefined(nvGraphicFramePr)) {
            WriteCT_GraphicalObjectFrameNonVisual(writer, CONST_XDR, "nvGraphicFramePr", nvGraphicFramePr);
        }
        WriteCT_Transform2D(writer, CONST_XDR, "xfrm", keyword_null, true);
        if (!common_1._isNullOrUndefined(graphic)) {
            WriteCT_GraphicalObject(writer, CONST_A, "graphic", graphic, is2016Chart);
        }
    });
}
exports.DrawingWriter.WriteCT_GraphicalObjectFrame = WriteCT_GraphicalObjectFrame;
function WriteCT_GraphicalObjectFrame_cdr(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.macro)) {
            writer.writeAttributeString(CONST_MACRO, instance.macro);
        }
        if (instance.fPublished === true) {
            writer.writeAttributeString(CONST_FPUBLISHED, "1");
        }
    }, function () {
        var nvGraphicFramePr = instance.nvGraphicFramePr, xfrm = instance.xfrm, graphic = instance.graphic;
        if (!common_1._isNullOrUndefined(nvGraphicFramePr)) {
            WriteCT_GraphicalObjectFrameNonVisual_cdr(writer, CONST_CDR, "nvGraphicFramePr", nvGraphicFramePr);
        }
        WriteCT_Transform2D(writer, CONST_CDR, "xfrm", xfrm, true);
        if (!common_1._isNullOrUndefined(graphic)) {
            WriteCT_GraphicalObject(writer, CONST_A, "graphic", graphic);
        }
    });
}
exports.DrawingWriter.WriteCT_GraphicalObjectFrame_cdr = WriteCT_GraphicalObjectFrame_cdr;
function WriteCT_GroupShapeNonVisual(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var cNvPr = instance.cNvPr, cNvGrpSpPr = instance.cNvGrpSpPr;
        if (!common_1._isNullOrUndefined(cNvPr)) {
            WriteCT_NonVisualDrawingProps(writer, prefix, CONST_CNVPR, cNvPr);
        }
        if (!common_1._isNullOrUndefined(cNvGrpSpPr)) {
            WriteCT_NonVisualGroupDrawingShapeProps(writer, prefix, "cNvGrpSpPr", cNvGrpSpPr);
        }
    });
}
exports.DrawingWriter.WriteCT_GroupShapeNonVisual = WriteCT_GroupShapeNonVisual;
function WriteCT_GroupShape(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var nvGrpSpPr = instance.nvGrpSpPr, grpSpPr = instance.grpSpPr;
        if (!common_1._isNullOrUndefined(nvGrpSpPr)) {
            WriteCT_GroupShapeNonVisual(writer, CONST_XDR, "nvGrpSpPr", nvGrpSpPr);
        }
        if (!common_1._isNullOrUndefined(grpSpPr)) {
            WriteCT_GroupShapeProperties(writer, CONST_XDR, "grpSpPr", grpSpPr);
        }
        instance.sp.forEach(function (item) {
            if (item.shapeType === 5) {
                WriteCT_Shape(writer, prefix, "sp", item);
            }
            else if (item.shapeType === 3) {
                WriteCT_GroupShape(writer, prefix, CONST_GRPSP, item);
            }
            else if (item.shapeType === 2) {
                WriteCT_GraphicalObjectFrame(writer, prefix, CONST_GRAPHIC_FRAME, item);
            }
            else if (item.shapeType === 4) {
                WriteCT_Connector(writer, prefix, CONST_CXNSP, item);
            }
            else if (item.shapeType === 1) {
                if (!common_1._isNullOrUndefined(item.cellRange) && item.cameraTool === true) {
                    var choice = { a14: exports.DrawingWriter.a14, Requires: "a14", pic: item };
                    var fallBack = {};
                    item = {
                        AlternateContent: exports.DrawingWriter.mc,
                        Choice: choice,
                        Fallback: fallBack
                    };
                    WriteCT_AlternateContent(writer, "mc", "AlternateContent", item);
                }
                else {
                    WriteCT_PictureGroup(writer, prefix, "pic", item);
                }
            }
            else if (item.shapeType === 0) {
                WriteCT_AlternateContent(writer, CONST_MC, CONST_ALTERNATE_CONTENT);
            }
        });
    });
}
exports.DrawingWriter.WriteCT_GroupShape = WriteCT_GroupShape;
function WriteCT_Position(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.col)) {
            writer.writeElementString("xdr:col", instance.col);
        }
        var colOffset = instance.colOffset;
        if (!common_1._isNullOrUndefined(colOffset)) {
            writer.writeElementString("xdr:colOff", pixelToEMU(colOffset));
        }
        if (!common_1._isNullOrUndefined(instance.row)) {
            writer.writeElementString("xdr:row", instance.row);
        }
        var rowOffset = instance.rowOffset;
        if (!common_1._isNullOrUndefined(rowOffset)) {
            writer.writeElementString("xdr:rowOff", pixelToEMU(rowOffset));
        }
    });
}
exports.DrawingWriter.WriteCT_Position = WriteCT_Position;
function WriteCT_TwoCellAnchor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var editAs = instance.editAs;
        if (!common_1._isNullOrUndefined(editAs) && editAs !== 0) {
            writer.writeAttributeString("editAs", chart_model_1.Charts.ST_EditAs[editAs]);
        }
    }, function () {
        var from = instance.startPoint, to = instance.endPoint, AlternateContent = instance.AlternateContent, sp = instance.sp, grpSp = instance.grpSp, graphicFrame = instance.graphicFrame, cxnSp = instance.cxnSp, pic = instance.pic, clientData = instance.clientData;
        var seriesItemTemp = common_1.Util._get2016ChartSeries(instance);
        var layoutId = seriesItemTemp && seriesItemTemp.layoutId;
        var Is2016Chart = common_1.Util._is2016ChartByLayoutId(layoutId);
        if (!common_1._isNullOrUndefined(from)) {
            WriteCT_Position(writer, CONST_XDR, "from", from);
        }
        if (!common_1._isNullOrUndefined(to)) {
            WriteCT_Position(writer, CONST_XDR, "to", to);
        }
        if (!common_1._isNullOrUndefined(AlternateContent) && Is2016Chart) {
            WriteCT_AlternateContent(writer, CONST_MC, CONST_ALTERNATE_CONTENT, AlternateContent, Is2016Chart);
        }
        if (!common_1._isNullOrUndefined(sp)) {
            WriteCT_ShapeForXdr(writer, CONST_XDR, "sp", sp);
        }
        if (!common_1._isNullOrUndefined(grpSp)) {
            WriteCT_GroupShape(writer, CONST_XDR, CONST_GRPSP, grpSp);
        }
        if (!common_1._isNullOrUndefined(graphicFrame) && !Is2016Chart) {
            WriteCT_GraphicalObjectFrame(writer, CONST_XDR, CONST_GRAPHIC_FRAME, graphicFrame, Is2016Chart);
        }
        if (!common_1._isNullOrUndefined(cxnSp)) {
            WriteCT_Connector(writer, CONST_XDR, CONST_CXNSP, cxnSp);
        }
        if (!common_1._isNullOrUndefined(pic)) {
            WriteCT_PictureForXdr(writer, CONST_XDR, "pic", pic);
        }
        if (!common_1._isNullOrUndefined(clientData)) {
            WriteCT_AnchorClientData(writer, CONST_XDR, CONST_CLIENT_DATA, clientData);
        }
    });
}
exports.DrawingWriter.WriteCT_TwoCellAnchor = WriteCT_TwoCellAnchor;
function WriteCT_AlternateContent(writer, prefix, localName, instance, is2016Chart) {
    writer.writeElement(prefix + ":" + localName, function () {
        writer.writeAttributeString("xmlns:mc", instance.AlternateContent);
    }, function () {
        var choice = instance.Choice, fallBack = instance.Fallback;
        if (common_1._isNullOrUndefined(choice) && IsCameraTool(instance)) {
            choice = { a14: exports.DrawingWriter.a14, Requires: "a14", twoCellAnchor: instance };
            fallBack = {};
        }
        if (!common_1._isNullOrUndefined(choice)) {
            WriteCT_Choice(writer, CONST_MC, "Choice", choice, is2016Chart);
        }
        if (!common_1._isNullOrUndefined(fallBack)) {
            WriteCT_FallBack(writer, CONST_MC, "Fallback", fallBack);
        }
    });
}
exports.DrawingWriter.WriteCT_AlternateContent = WriteCT_AlternateContent;
function IsCameraTool(instance) {
    return !!(instance && instance.pic && instance.pic.cameraTool === true);
}
function WriteCT_Choice(writer, prefix, localName, instance, is2016Chart) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (is2016Chart && !common_1._isNullOrUndefined(instance.Requires) && !common_1._isNullOrUndefined(instance.cx)) {
            writer.writeAttributeString("xmlns:" + instance.Requires, instance.cx);
        }
        var a14 = instance.a14;
        if (!common_1._isNullOrUndefined(a14)) {
            writer.writeAttributeString("xmlns:a14", instance.a14);
        }
        writer.writeAttributeString("Requires", instance.Requires);
    }, function () {
        var GraphicalObjectFrame = instance.GraphicalObjectFrame;
        if (!common_1._isNullOrUndefined(GraphicalObjectFrame)) {
            WriteCT_GraphicalObjectFrame(writer, CONST_XDR, "graphicFrame", GraphicalObjectFrame, is2016Chart);
        }
        var twoCellAnchor = instance.twoCellAnchor;
        if (!common_1._isNullOrUndefined(twoCellAnchor)) {
            WriteCT_TwoCellAnchor(writer, CONST_XDR, "twoCellAnchor", twoCellAnchor);
        }
        var pic = instance.pic;
        if (!common_1._isNullOrUndefined(pic)) {
            WriteCT_PictureForXdr(writer, CONST_XDR, "pic", pic);
        }
    });
}
exports.DrawingWriter.WriteCT_Choice = WriteCT_Choice;
function WriteCT_FallBack(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
    }, function () {
        var GraphicalObjectFrame = instance.GraphicalObjectFrame;
        if (!common_1._isNullOrUndefined(GraphicalObjectFrame)) {
            WriteCT_GraphicalObjectFrame(writer, CONST_XDR, "graphicFrame", GraphicalObjectFrame);
        }
    });
}
exports.DrawingWriter.WriteCT_FallBack = WriteCT_FallBack;
function WriteCT_OneCellAnchor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var from = instance.startPoint, pic = instance.pic;
        if (!common_1._isNullOrUndefined(from)) {
            WriteCT_Position(writer, CONST_XDR, "from", from);
        }
        if (!common_1._isNullOrUndefined(pic)) {
            WriteCT_PictureOneCellAnchor(writer, CONST_XDR, "pic", pic);
        }
        writeAnchorSubElement(writer, instance, true);
    });
}
exports.DrawingWriter.WriteCT_OneCellAnchor = WriteCT_OneCellAnchor;
function WriteCT_AbsoluteAnchor(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var pos = instance.pos, pic = instance.pic;
        if (!common_1._isNullOrUndefined(pos)) {
            WriteCT_Point2D(writer, CONST_XDR, "pos", pos, true);
        }
        if (!common_1._isNullOrUndefined(pic)) {
            WriteCT_Picture(writer, CONST_XDR, "pic", pic);
        }
        writeAnchorSubElement(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_AbsoluteAnchor = WriteCT_AbsoluteAnchor;
function WriteCT_Drawing(writer, prefix, localName, instance) {
    writer.writeElement("xdr:" + localName, function () {
        writer.writeAttributeString("xmlns:a", exports.DrawingWriter.a);
        writer.writeAttributeString("xmlns:xdr", exports.DrawingWriter.xdr);
    }, function () {
        instance.AnchorBaseList.forEach(function (item) {
            if (item.anchorType === 1) {
                WriteCT_OneCellAnchor(writer, CONST_XDR, "oneCellAnchor", item);
            }
            else if (item.anchorType === 0) {
                WriteCT_TwoCellAnchor(writer, CONST_XDR, "twoCellAnchor", item);
            }
            else if (item.anchorType === 2) {
                WriteCT_AbsoluteAnchor(writer, CONST_XDR, "absoluteAnchor", item);
            }
        });
    });
}
exports.DrawingWriter.WriteCT_Drawing = WriteCT_Drawing;
function WriteCT_DefaultShapeDefinition(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var spPr = instance.spPr, bodyPr = instance.bodyPr, lstStyle = instance.lstStyle, style = instance.style, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(spPr)) {
            WriteCT_ShapeProperties(writer, CONST_A, CONST_SPPR, spPr);
        }
        if (!common_1._isNullOrUndefined(bodyPr)) {
            WriteCT_TextBodyProperties(writer, CONST_A, "bodyPr", bodyPr);
        }
        if (!common_1._isNullOrUndefined(lstStyle)) {
            WriteCT_TextListStyle(writer, CONST_A, "lstStyle", lstStyle);
        }
        if (!common_1._isNullOrUndefined(style)) {
            WriteCT_ShapeStyle(writer, CONST_A, CONST_STYLE, style);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_DefaultShapeDefinition = WriteCT_DefaultShapeDefinition;
function WriteCT_ObjectStyleDefaults(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var spDef = instance.spDef, lnDef = instance.lnDef, txDef = instance.txDef, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(spDef)) {
            WriteCT_DefaultShapeDefinition(writer, CONST_A, "spDef", spDef);
        }
        if (!common_1._isNullOrUndefined(lnDef)) {
            WriteCT_DefaultShapeDefinition(writer, CONST_A, "lnDef", lnDef);
        }
        if (!common_1._isNullOrUndefined(txDef)) {
            WriteCT_DefaultShapeDefinition(writer, CONST_A, "txDef", txDef);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_ObjectStyleDefaults = WriteCT_ObjectStyleDefaults;
function WriteCT_EmptyElement(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_EmptyElement = WriteCT_EmptyElement;
function WriteCT_ColorMappingOverride(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var masterClrMapping = instance.masterClrMapping, overrideClrMapping = instance.overrideClrMapping;
        if (!common_1._isNullOrUndefined(masterClrMapping)) {
            WriteCT_EmptyElement(writer, CONST_A, "masterClrMapping");
        }
        if (!common_1._isNullOrUndefined(overrideClrMapping)) {
            WriteCT_ColorMapping(writer, CONST_A, "overrideClrMapping", overrideClrMapping);
        }
    });
}
exports.DrawingWriter.WriteCT_ColorMappingOverride = WriteCT_ColorMappingOverride;
function WriteCT_ColorSchemeAndMapping(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var clrScheme = instance.clrScheme, clrMap = instance.clrMap;
        if (!common_1._isNullOrUndefined(clrScheme)) {
            WriteCT_ColorScheme(writer, CONST_A, CONST_CLR_SCHEME, clrScheme);
        }
        if (!common_1._isNullOrUndefined(clrMap)) {
            WriteCT_ColorMapping(writer, CONST_A, "clrMap", clrMap);
        }
    });
}
exports.DrawingWriter.WriteCT_ColorSchemeAndMapping = WriteCT_ColorSchemeAndMapping;
function WriteCT_ColorSchemeList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.extraClrScheme, function (extraClrSchemeItem) {
            WriteCT_ColorSchemeAndMapping(writer, CONST_A, "extraClrScheme", extraClrSchemeItem);
        });
    });
}
exports.DrawingWriter.WriteCT_ColorSchemeList = WriteCT_ColorSchemeList;
function WriteCT_OfficeStyleSheet(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var name = instance.name;
        if (!isNullOrUndefinedOrEmpty(name)) {
            writer.writeAttributeString(CONST_NAME, name);
        }
    }, function () {
        var themeElements = instance.themeElements, objectDefaults = instance.objectDefaults, extraClrSchemeLst = instance.extraClrSchemeLst, custClrLst = instance.custClrLst, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(themeElements)) {
            WriteCT_BaseStyles(writer, CONST_A, "themeElements", themeElements);
        }
        if (!common_1._isNullOrUndefined(objectDefaults)) {
            WriteCT_ObjectStyleDefaults(writer, CONST_A, "objectDefaults", objectDefaults);
        }
        if (!common_1._isNullOrUndefined(extraClrSchemeLst)) {
            WriteCT_ColorSchemeList(writer, CONST_A, "extraClrSchemeLst", extraClrSchemeLst);
        }
        if (!common_1._isNullOrUndefined(custClrLst)) {
            WriteCT_CustomColorList(writer, CONST_A, "custClrLst", custClrLst);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_OfficeStyleSheet = WriteCT_OfficeStyleSheet;
function WriteCT_BaseStylesOverride(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var clrScheme = instance.clrScheme, fontScheme = instance.fontScheme, fmtScheme = instance.fmtScheme;
        if (!common_1._isNullOrUndefined(clrScheme)) {
            WriteCT_ColorScheme(writer, CONST_A, CONST_CLR_SCHEME, clrScheme);
        }
        if (!common_1._isNullOrUndefined(fontScheme)) {
            WriteCT_FontScheme(writer, CONST_A, CONST_FONT_SCHEME, fontScheme);
        }
        if (!common_1._isNullOrUndefined(fmtScheme)) {
            WriteCT_StyleMatrix(writer, CONST_A, CONST_FMT_SCHEME, fmtScheme);
        }
    });
}
exports.DrawingWriter.WriteCT_BaseStylesOverride = WriteCT_BaseStylesOverride;
function WriteCT_ClipboardStyleSheet(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var themeElements = instance.themeElements, clrMap = instance.clrMap;
        if (!common_1._isNullOrUndefined(themeElements)) {
            WriteCT_BaseStyles(writer, CONST_A, "themeElements", themeElements);
        }
        if (!common_1._isNullOrUndefined(clrMap)) {
            WriteCT_ColorMapping(writer, CONST_A, "clrMap", clrMap);
        }
    });
}
exports.DrawingWriter.WriteCT_ClipboardStyleSheet = WriteCT_ClipboardStyleSheet;
function WriteCT_TextParagraph(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var pPr = instance.pPr, endParaRPr = instance.endParaRPr, elements = instance.elements;
        if (!common_1._isNullOrUndefined(pPr)) {
            WriteCT_TextParagraphProperties(writer, prefix, "pPr", pPr);
        }
        if (!common_1._isNullOrUndefined(elements)) {
            elements.forEach(function (item) {
                if (item.elementType === 0) {
                    WriteCT_RegularTextRun(writer, prefix, CONST_R, item);
                }
                else if (item.elementType === 1) {
                    WriteCT_TextLineBreak(writer, prefix, "br", item);
                }
                else if (item.elementType === 2) {
                    WriteCT_TextField(writer, prefix, "fld", item);
                }
            });
        }
        if (!common_1._isNullOrUndefined(endParaRPr)) {
            WriteCT_TextCharacterProperties(writer, prefix, "endParaRPr", endParaRPr);
        }
    });
}
exports.DrawingWriter.WriteCT_TextParagraph = WriteCT_TextParagraph;
function WriteCT_TextListStyle(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var defPPr = instance.defPPr, lvl1pPr = instance.lvl1pPr, lvl2pPr = instance.lvl2pPr, lvl3pPr = instance.lvl3pPr, lvl4pPr = instance.lvl4pPr, lvl5pPr = instance.lvl5pPr, lvl6pPr = instance.lvl6pPr, lvl7pPr = instance.lvl7pPr, lvl8pPr = instance.lvl8pPr, lvl9pPr = instance.lvl9pPr, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(defPPr)) {
            WriteCT_TextParagraphProperties(writer, CONST_A, "defPPr", defPPr);
        }
        if (!common_1._isNullOrUndefined(lvl1pPr)) {
            WriteCT_TextParagraphProperties(writer, CONST_A, "lvl1pPr", lvl1pPr);
        }
        if (!common_1._isNullOrUndefined(lvl2pPr)) {
            WriteCT_TextParagraphProperties(writer, CONST_A, "lvl2pPr", lvl2pPr);
        }
        if (!common_1._isNullOrUndefined(lvl3pPr)) {
            WriteCT_TextParagraphProperties(writer, CONST_A, "lvl3pPr", lvl3pPr);
        }
        if (!common_1._isNullOrUndefined(lvl4pPr)) {
            WriteCT_TextParagraphProperties(writer, CONST_A, "lvl4pPr", lvl4pPr);
        }
        if (!common_1._isNullOrUndefined(lvl5pPr)) {
            WriteCT_TextParagraphProperties(writer, CONST_A, "lvl5pPr", lvl5pPr);
        }
        if (!common_1._isNullOrUndefined(lvl6pPr)) {
            WriteCT_TextParagraphProperties(writer, CONST_A, "lvl6pPr", lvl6pPr);
        }
        if (!common_1._isNullOrUndefined(lvl7pPr)) {
            WriteCT_TextParagraphProperties(writer, CONST_A, "lvl7pPr", lvl7pPr);
        }
        if (!common_1._isNullOrUndefined(lvl8pPr)) {
            WriteCT_TextParagraphProperties(writer, CONST_A, "lvl8pPr", lvl8pPr);
        }
        if (!common_1._isNullOrUndefined(lvl9pPr)) {
            WriteCT_TextParagraphProperties(writer, CONST_A, "lvl9pPr", lvl9pPr);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_TextListStyle = WriteCT_TextListStyle;
function WriteCT_TextNormalAutofit(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var fontScale = instance.fontScale, lnSpcReduction = instance.lnSpcReduction;
        if (!common_1._isNullOrUndefined(fontScale) && fontScale !== 100000) {
            writer.writeAttributeString("fontScale", fontScale);
        }
        if (!common_1._isNullOrUndefined(lnSpcReduction) && lnSpcReduction !== 0) {
            writer.writeAttributeString("lnSpcReduction", lnSpcReduction);
        }
    });
}
exports.DrawingWriter.WriteCT_TextNormalAutofit = WriteCT_TextNormalAutofit;
function WriteCT_TextShapeAutofit(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_TextShapeAutofit = WriteCT_TextShapeAutofit;
function WriteCT_TextNoAutofit(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_TextNoAutofit = WriteCT_TextNoAutofit;
function getRotationData(rotationDegree) {
    return rotationDegree * 60000;
}
exports.DrawingWriter.getRotationData = getRotationData;
function WriteCT_TextBodyProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var rot = instance.rot, vertOverflow = instance.vertOverflow, horzOverflow = instance.horzOverflow, wrap = instance.wrap, lIns = instance.lIns, tIns = instance.tIns, rIns = instance.rIns, bIns = instance.bIns, numCol = instance.numCol, spcCol = instance.spcCol, anchor = instance.anchor;
        if (!common_1._isNullOrUndefined(rot)) {
            writer.writeAttributeString("rot", getRotationData(rot));
        }
        if (instance.spcFirstLastPara === true) {
            writer.writeAttributeString("spcFirstLastPara", "1");
        }
        if (!common_1._isNullOrUndefined(vertOverflow) && vertOverflow !== 0) {
            writer.writeAttributeString("vertOverflow", chart_model_1.Charts.ST_TextVertOverflowType[vertOverflow]);
        }
        if (!common_1._isNullOrUndefined(horzOverflow) && horzOverflow !== 0) {
            writer.writeAttributeString("horzOverflow", chart_model_1.Charts.ST_TextHorzOverflowType[horzOverflow]);
        }
        if (!common_1._isNullOrUndefined(instance.vert)) {
            writer.writeAttributeString("vert", chart_model_1.Charts.ST_TextVerticalType[instance.vert]);
        }
        if (!common_1._isNullOrUndefined(wrap) && wrap !== 0) {
            writer.writeAttributeString("wrap", chart_model_1.Charts.ST_TextWrappingType[wrap]);
        }
        if (!common_1._isNullOrUndefined(lIns) && lIns !== 0) {
            writer.writeAttributeString("lIns", lIns);
        }
        if (!common_1._isNullOrUndefined(tIns) && tIns !== 0) {
            writer.writeAttributeString("tIns", tIns);
        }
        if (!common_1._isNullOrUndefined(rIns) && rIns !== 0) {
            writer.writeAttributeString("rIns", rIns);
        }
        if (!common_1._isNullOrUndefined(bIns) && bIns !== 0) {
            writer.writeAttributeString("bIns", bIns);
        }
        if (!common_1._isNullOrUndefined(numCol) && numCol !== 0) {
            writer.writeAttributeString("numCol", numCol);
        }
        if (!common_1._isNullOrUndefined(spcCol) && spcCol !== 0) {
            writer.writeAttributeString("spcCol", spcCol);
        }
        if (instance.rtlCol === true) {
            writer.writeAttributeString("rtlCol", "1");
        }
        if (instance.fromWordArt === true) {
            writer.writeAttributeString("fromWordArt", "1");
        }
        if (!common_1._isNullOrUndefined(anchor) && anchor !== 0) {
            writer.writeAttributeString("anchor", chart_model_1.Charts.ST_TextAnchoringType[anchor]);
        }
        if (instance.anchorCtr === true) {
            writer.writeAttributeString("anchorCtr", "1");
        }
        if (instance.forceAA === true) {
            writer.writeAttributeString("forceAA", "1");
        }
        if (instance.upright === true) {
            writer.writeAttributeString("upright", "1");
        }
        if (instance.compatLnSpc === true) {
            writer.writeAttributeString("compatLnSpc", "1");
        }
    }, function () {
        var prstTxWarp = instance.prstTxWarp, noAutofit = instance.noAutofit, normAutofit = instance.normAutofit, spAutoFit = instance.spAutoFit, scene3d = instance.scene3d, sp3d = instance.sp3d, flatTx = instance.flatTx, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(prstTxWarp)) {
            WriteCT_PresetTextShape(writer, CONST_A, "prstTxWarp", prstTxWarp);
        }
        if (!common_1._isNullOrUndefined(noAutofit)) {
            WriteCT_TextNoAutofit(writer, CONST_A, "noAutofit");
        }
        if (!common_1._isNullOrUndefined(normAutofit)) {
            WriteCT_TextNormalAutofit(writer, CONST_A, "normAutofit", normAutofit);
        }
        if (!common_1._isNullOrUndefined(spAutoFit)) {
            WriteCT_TextShapeAutofit(writer, CONST_A, "spAutoFit");
        }
        if (!common_1._isNullOrUndefined(scene3d)) {
            WriteCT_Scene3D(writer, CONST_A, CONST_SCENE_3D, scene3d);
        }
        if (!common_1._isNullOrUndefined(sp3d)) {
            WriteCT_Shape3D(writer, CONST_A, "sp3d", sp3d);
        }
        if (!common_1._isNullOrUndefined(flatTx)) {
            WriteCT_FlatText(writer, CONST_A, "flatTx", flatTx);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_TextBodyProperties = WriteCT_TextBodyProperties;
function WriteCT_TextBody(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var bodyPr = instance.bodyPr, lstStyle = instance.lstStyle;
        WriteCT_TextBodyProperties(writer, CONST_A, "bodyPr", bodyPr || {});
        if (!common_1._isNullOrUndefined(lstStyle)) {
            WriteCT_TextListStyle(writer, CONST_A, "lstStyle", lstStyle);
        }
        var p = instance.p;
        if (common_1._isNullOrUndefined(p)) {
            var defaultP = { pPr: { defRPr: {} }, endParaRPr: {}, elements: [] };
            WriteCT_TextParagraph(writer, CONST_A, "p", defaultP);
        }
        else {
            writeArrayItem(instance.p, function (item) {
                WriteCT_TextParagraph(writer, CONST_A, "p", item);
            });
        }
    });
}
exports.DrawingWriter.WriteCT_TextBody = WriteCT_TextBody;
function WriteCT_TextBulletColorFollowText(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_TextBulletColorFollowText = WriteCT_TextBulletColorFollowText;
function WriteCT_TextBulletSizeFollowText(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_TextBulletSizeFollowText = WriteCT_TextBulletSizeFollowText;
function WriteCT_TextBulletSizePercent(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_TextBulletSizePercent = WriteCT_TextBulletSizePercent;
function WriteCT_TextBulletSizePoint(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_TextBulletSizePoint = WriteCT_TextBulletSizePoint;
function WriteCT_TextBulletTypefaceFollowText(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_TextBulletTypefaceFollowText = WriteCT_TextBulletTypefaceFollowText;
function WriteCT_TextAutonumberBullet(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var startAt = instance.startAt;
        if (!common_1._isNullOrUndefined(instance.type)) {
            writer.writeAttributeString(CONST_TYPE, chart_model_1.Charts.ST_TextAutonumberScheme[instance.type]);
        }
        if (!common_1._isNullOrUndefined(startAt) && startAt !== 1) {
            writer.writeAttributeString("startAt", startAt);
        }
    });
}
exports.DrawingWriter.WriteCT_TextAutonumberBullet = WriteCT_TextAutonumberBullet;
function WriteCT_TextCharBullet(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.char)) {
            writer.writeAttributeString("char", instance.char);
        }
    });
}
exports.DrawingWriter.WriteCT_TextCharBullet = WriteCT_TextCharBullet;
function WriteCT_TextBlipBullet(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_Blip, CONST_A, "blip");
}
exports.DrawingWriter.WriteCT_TextBlipBullet = WriteCT_TextBlipBullet;
function WriteCT_TextNoBullet(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_TextNoBullet = WriteCT_TextNoBullet;
function WriteCT_TextFont(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        var typeface = instance.typeface, panose = instance.panose, pitchFamily = instance.pitchFamily, charset = instance.charset;
        if (!common_1._isNullOrUndefined(typeface)) {
            writer.writeAttributeString("typeface", excel_style_1.ConverterHelper.getFontName(typeface));
        }
        if (!common_1._isNullOrUndefined(panose)) {
            writer.writeAttributeString("panose", panose);
        }
        if (!common_1._isNullOrUndefined(pitchFamily) && pitchFamily !== 0) {
            writer.writeAttributeString("pitchFamily", pitchFamily);
        }
        if (!common_1._isNullOrUndefined(charset) && charset !== 1) {
            writer.writeAttributeString("charset", charset);
        }
    });
}
exports.DrawingWriter.WriteCT_TextFont = WriteCT_TextFont;
function WriteCT_TextUnderlineLineFollowText(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_TextUnderlineLineFollowText = WriteCT_TextUnderlineLineFollowText;
function WriteCT_TextUnderlineFillFollowText(writer, prefix, localName) {
    writeEmptyNode(writer, prefix, localName);
}
exports.DrawingWriter.WriteCT_TextUnderlineFillFollowText = WriteCT_TextUnderlineFillFollowText;
function WriteCT_TextUnderlineFillGroupWrapper(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeFillProperties(writer, instance);
    });
}
exports.DrawingWriter.WriteCT_TextUnderlineFillGroupWrapper = WriteCT_TextUnderlineFillGroupWrapper;
function WriteCT_TextCharacterProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var altLang = instance.altLang, sz = instance.sz, kern = instance.kern, cap = instance.cap, spc = instance.spc, baseline = instance.baseline, smtId = instance.smtId, bmk = instance.bmk;
        if (instance.kumimoji === true) {
            writer.writeAttributeString("kumimoji", "1");
        }
        if (!common_1._isNullOrUndefined(altLang)) {
            writer.writeAttributeString("altLang", altLang);
        }
        if (!common_1._isNullOrUndefined(sz) && sz !== 0) {
            writer.writeAttributeString("sz", Math.round(excel_style_1.UnitHelper.pixelToPoint(sz) * 100));
        }
        if (!common_1._isNullOrUndefined(instance.b)) {
            writer.writeAttributeString("b", instance.b ? "1" : "0");
        }
        if (!common_1._isNullOrUndefined(instance.i)) {
            writer.writeAttributeString("i", instance.i ? "1" : "0");
        }
        if (!common_1._isNullOrUndefined(instance.u)) {
            writer.writeAttributeString("u", chart_model_1.Charts.ST_TextUnderlineType[instance.u]);
        }
        if (!common_1._isNullOrUndefined(instance.strike)) {
            writer.writeAttributeString("strike", chart_model_1.Charts.ST_TextStrikeType[instance.strike]);
        }
        if (!common_1._isNullOrUndefined(kern) && kern !== 0) {
            writer.writeAttributeString("kern", kern);
        }
        if (!common_1._isNullOrUndefined(cap) && cap !== 0) {
            writer.writeAttributeString("cap", chart_model_1.Charts.ST_TextCapsType[cap]);
        }
        if (!common_1._isNullOrUndefined(spc)) {
            writer.writeAttributeString("spc", spc);
        }
        if (instance.normalizeH === true) {
            writer.writeAttributeString("normalizeH", "1");
        }
        if (!common_1._isNullOrUndefined(baseline)) {
            writer.writeAttributeString("baseline", baseline);
        }
        if (instance.noProof === true) {
            writer.writeAttributeString("noProof", "1");
        }
        if (instance.dirty === false) {
            writer.writeAttributeString("dirty", "0");
        }
        if (instance.err === true) {
            writer.writeAttributeString("err", "1");
        }
        if (instance.smtClean === false) {
            writer.writeAttributeString("smtClean", "0");
        }
        if (!common_1._isNullOrUndefined(smtId) && smtId !== 0) {
            writer.writeAttributeString("smtId", smtId);
        }
        if (!common_1._isNullOrUndefined(bmk)) {
            writer.writeAttributeString("bmk", bmk);
        }
    }, function () {
        var ln = instance.ln, highlight = instance.highlight, uLnTx = instance.uLnTx, uLn = instance.uLn, uFillTx = instance.uFillTx, uFill = instance.uFill, latin = instance.latin, ea = instance.ea, cs = instance.cs, sym = instance.sym, hlinkClick = instance.hlinkClick, hlinkMouseOver = instance.hlinkMouseOver, extLst = instance.extLst, effectLst = instance.effectLst, effectDag = instance.effectDag;
        if (!common_1._isNullOrUndefined(ln)) {
            WriteCT_LineProperties(writer, CONST_A, "ln", ln);
        }
        writeFillProperties(writer, instance);
        if (!common_1._isNullOrUndefined(effectLst)) {
            WriteCT_EffectList(writer, CONST_A, CONST_EFFECTLST, effectLst);
        }
        if (!common_1._isNullOrUndefined(effectDag)) {
            WriteCT_EffectContainer(writer, CONST_A, CONST_EFFECT_DAG, effectDag);
        }
        if (!common_1._isNullOrUndefined(highlight)) {
            WriteCT_Color(writer, CONST_A, "highlight", highlight);
        }
        if (!common_1._isNullOrUndefined(uLnTx)) {
            WriteCT_TextUnderlineLineFollowText(writer, CONST_A, "uLnTx");
        }
        if (!common_1._isNullOrUndefined(uLn)) {
            WriteCT_LineProperties(writer, CONST_A, "uLn", uLn);
        }
        if (!common_1._isNullOrUndefined(uFillTx)) {
            WriteCT_TextUnderlineFillFollowText(writer, CONST_A, "uFillTx");
        }
        if (!common_1._isNullOrUndefined(uFill)) {
            WriteCT_TextUnderlineFillGroupWrapper(writer, CONST_A, "uFill", uFill);
        }
        if (!common_1._isNullOrUndefined(latin)) {
            WriteCT_TextFont(writer, CONST_A, "latin", latin);
        }
        if (!common_1._isNullOrUndefined(ea)) {
            WriteCT_TextFont(writer, CONST_A, "ea", ea);
        }
        if (!common_1._isNullOrUndefined(cs)) {
            WriteCT_TextFont(writer, CONST_A, "cs", cs);
        }
        if (!common_1._isNullOrUndefined(sym)) {
            WriteCT_TextFont(writer, CONST_A, "sym", sym);
        }
        if (!common_1._isNullOrUndefined(hlinkClick)) {
            WriteCT_Hyperlink(writer, CONST_A, "hlinkClick", hlinkClick);
        }
        if (!common_1._isNullOrUndefined(hlinkMouseOver)) {
            WriteCT_Hyperlink(writer, CONST_A, "hlinkMouseOver", hlinkMouseOver);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_TextCharacterProperties = WriteCT_TextCharacterProperties;
function WriteCT_TextSpacingPercent(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_TextSpacingPercent = WriteCT_TextSpacingPercent;
function WriteCT_TextSpacingPoint(writer, prefix, localName, instance) {
    writeSingleAttributeNode(writer, prefix, localName, instance, CONST_VAL);
}
exports.DrawingWriter.WriteCT_TextSpacingPoint = WriteCT_TextSpacingPoint;
function WriteCT_TextTabStop(writer, prefix, localName, instance) {
    writer.writeLeafElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.pos)) {
            writer.writeAttributeString("pos", instance.pos);
        }
        if (!common_1._isNullOrUndefined(instance.algn)) {
            writer.writeAttributeString("algn", chart_model_1.Charts.ST_TextTabAlignType[instance.algn]);
        }
    });
}
exports.DrawingWriter.WriteCT_TextTabStop = WriteCT_TextTabStop;
function WriteCT_TextTabStopList(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        writeArrayItem(instance.tab, function (item) {
            WriteCT_TextTabStop(writer, CONST_A, "tab", item);
        });
    });
}
exports.DrawingWriter.WriteCT_TextTabStopList = WriteCT_TextTabStopList;
function WriteCT_TextLineBreak(writer, prefix, localName, instance) {
    writeSingleSubElementNode(writer, prefix, localName, instance, WriteCT_TextCharacterProperties, CONST_A, "rPr");
}
exports.DrawingWriter.WriteCT_TextLineBreak = WriteCT_TextLineBreak;
function WriteCT_TextSpacing(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.spcPct)) {
            WriteCT_TextSpacingPercent(writer, CONST_A, "spcPct", instance.spcPct);
        }
        if (!common_1._isNullOrUndefined(instance.spcPts)) {
            WriteCT_TextSpacingPoint(writer, CONST_A, "spcPts", instance.spcPts);
        }
    });
}
exports.DrawingWriter.WriteCT_TextSpacing = WriteCT_TextSpacing;
function WriteCT_TextParagraphProperties(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        var marL = instance.marL, marR = instance.marR, lvl = instance.lvl, indent = instance.indent, algn = instance.algn, defTabSz = instance.defTabSz, fontAlgn = instance.fontAlgn;
        if (!common_1._isNullOrUndefined(marL) && marL !== 0) {
            writer.writeAttributeString("marL", marL);
        }
        if (!common_1._isNullOrUndefined(marR) && marR !== 0) {
            writer.writeAttributeString("marR", marR);
        }
        if (!common_1._isNullOrUndefined(lvl) && lvl !== 0) {
            writer.writeAttributeString("lvl", lvl);
        }
        if (!common_1._isNullOrUndefined(indent) && indent !== 0) {
            writer.writeAttributeString("indent", indent);
        }
        if (!common_1._isNullOrUndefined(algn) && algn !== 0) {
            writer.writeAttributeString("algn", chart_model_1.Charts.ST_TextAlignType[algn]);
        }
        if (!common_1._isNullOrUndefined(defTabSz) && defTabSz !== 0) {
            writer.writeAttributeString("defTabSz", defTabSz);
        }
        if (instance.rtl === true) {
            writer.writeAttributeString("rtl", "1");
        }
        if (instance.eaLnBrk === true) {
            writer.writeAttributeString("eaLnBrk", "1");
        }
        if (!common_1._isNullOrUndefined(fontAlgn) && fontAlgn !== 0) {
            writer.writeAttributeString("fontAlgn", chart_model_1.Charts.ST_TextFontAlignType[fontAlgn]);
        }
        if (instance.latinLnBrk === true) {
            writer.writeAttributeString("latinLnBrk", "1");
        }
        if (instance.hangingPunct === true) {
            writer.writeAttributeString("hangingPunct", "1");
        }
    }, function () {
        var lnSpc = instance.lnSpc, spcBef = instance.spcBef, spcAft = instance.spcAft, buClrTx = instance.buClrTx, buClr = instance.buClr, buSzTx = instance.buSzTx, buSzPct = instance.buSzPct, buSzPts = instance.buSzPts, buFontTx = instance.buFontTx, buFont = instance.buFont, buNone = instance.buNone, buAutoNum = instance.buAutoNum, buChar = instance.buChar, buBlip = instance.buBlip, tabLst = instance.tabLst, defRPr = instance.defRPr, extLst = instance.extLst;
        if (!common_1._isNullOrUndefined(lnSpc)) {
            WriteCT_TextSpacing(writer, CONST_A, "lnSpc", lnSpc);
        }
        if (!common_1._isNullOrUndefined(spcBef)) {
            WriteCT_TextSpacing(writer, CONST_A, "spcBef", spcBef);
        }
        if (!common_1._isNullOrUndefined(spcAft)) {
            WriteCT_TextSpacing(writer, CONST_A, "spcAft", spcAft);
        }
        if (!common_1._isNullOrUndefined(buClrTx)) {
            WriteCT_TextBulletColorFollowText(writer, CONST_A, "buClrTx");
        }
        if (!common_1._isNullOrUndefined(buClr)) {
            WriteCT_Color(writer, CONST_A, "buClr", buClr);
        }
        if (!common_1._isNullOrUndefined(buSzTx)) {
            WriteCT_TextBulletSizeFollowText(writer, CONST_A, "buSzTx");
        }
        if (!common_1._isNullOrUndefined(buSzPct)) {
            WriteCT_TextBulletSizePercent(writer, CONST_A, "buSzPct", buSzPct);
        }
        if (!common_1._isNullOrUndefined(buSzPts)) {
            WriteCT_TextBulletSizePoint(writer, CONST_A, "buSzPts", buSzPts);
        }
        if (!common_1._isNullOrUndefined(buFontTx)) {
            WriteCT_TextBulletTypefaceFollowText(writer, CONST_A, "buFontTx");
        }
        if (!common_1._isNullOrUndefined(buFont)) {
            WriteCT_TextFont(writer, CONST_A, "buFont", buFont);
        }
        if (!common_1._isNullOrUndefined(buNone)) {
            WriteCT_TextNoBullet(writer, CONST_A, "buNone");
        }
        if (!common_1._isNullOrUndefined(buAutoNum)) {
            WriteCT_TextAutonumberBullet(writer, CONST_A, "buAutoNum", buAutoNum);
        }
        if (!common_1._isNullOrUndefined(buChar)) {
            WriteCT_TextCharBullet(writer, CONST_A, "buChar", buChar);
        }
        if (!common_1._isNullOrUndefined(buBlip)) {
            WriteCT_TextBlipBullet(writer, CONST_A, "buBlip", buBlip);
        }
        if (!common_1._isNullOrUndefined(tabLst)) {
            WriteCT_TextTabStopList(writer, CONST_A, "tabLst", tabLst);
        }
        if (!common_1._isNullOrUndefined(defRPr)) {
            WriteCT_TextCharacterProperties(writer, CONST_A, "defRPr", defRPr);
        }
        if (!common_1._isNullOrUndefined(extLst)) {
            WriteCT_OfficeArtExtensionList(writer, CONST_A, CONST_EXTLST, extLst);
        }
    });
}
exports.DrawingWriter.WriteCT_TextParagraphProperties = WriteCT_TextParagraphProperties;
function WriteCT_TextField(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.id)) {
            writer.writeAttributeString("id", instance.id);
        }
        if (!common_1._isNullOrUndefined(instance.type)) {
            writer.writeAttributeString(CONST_TYPE, instance.type);
        }
    }, function () {
        if (!common_1._isNullOrUndefined(instance.rPr)) {
            WriteCT_TextCharacterProperties(writer, CONST_A, "rPr", instance.rPr);
        }
        if (!common_1._isNullOrUndefined(instance.pPr)) {
            WriteCT_TextParagraphProperties(writer, CONST_A, "pPr", instance.pPr);
        }
        if (!common_1._isNullOrUndefined(instance.t)) {
            writer.writeElementString("a:t", instance.t);
        }
    });
}
exports.DrawingWriter.WriteCT_TextField = WriteCT_TextField;
function WriteCT_RegularTextRun(writer, prefix, localName, instance) {
    writer.writeElement(prefix + ":" + localName, function () {
        if (!common_1._isNullOrUndefined(instance.rPr)) {
            WriteCT_TextCharacterProperties(writer, CONST_A, "rPr", instance.rPr);
        }
        if (!common_1._isNullOrUndefined(instance.t)) {
            writer.writeElementString("a:t", xmlEncode(instance.t));
        }
    });
}
exports.DrawingWriter.WriteCT_RegularTextRun = WriteCT_RegularTextRun;


/***/ }),

/***/ "./src/xlsx-io/writer/comment-writer.ts":
/*!**********************************************!*\
  !*** ./src/xlsx-io/writer/comment-writer.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var color_writer_1 = __webpack_require__(/*! ./../common/color-writer */ "./src/xlsx-io/common/color-writer.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var xmlEncode = common_1.Util._xmlEncode;
function writeComments(model, comments) {
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('comments', function () {
        writer.writeAttributeString('xmlns', excel_types_1.XFileConstants._workbookNameSpace);
    }, function () {
        writeAuthors(writer);
        writer.writeElement('commentList', function () {
            comments.forEach(function (comment) {
                writeComment(writer, comment);
            });
        });
    });
    return writer.getXmlString();
}
exports.writeComments = writeComments;
function writeComment(writer, comment) {
    function isFontBold(fontWeight) {
        var value = fontWeight;
        if (value) {
            return (value.toLowerCase().indexOf('bold') !== -1 || parseInt(value, 10) > 400);
        }
        return false;
    }
    function isFontItalic(fontStyle) {
        var value = fontStyle;
        if (value) {
            return ['italic', 'oblique'].indexOf(value.toLowerCase().trim()) !== -1;
        }
        return false;
    }
    writer.writeElement('comment', function () {
        writer.writeAttributeString('ref', common_1.IndexHelper._getColumnIndexInA1Letter(comment.col) + (comment.row + 1));
        writer.writeAttributeString('authorId', '0');
    }, function () {
        writer.writeElement('text', function () {
            writer.writeElement('r', function () {
                writer.writeElement('rPr', function () {
                    var value = comment.fontWeight;
                    if (isFontBold(value)) {
                        writer.writeLeafElement('b');
                    }
                    value = comment.fontStyle;
                    if (isFontItalic(value)) {
                        writer.writeLeafElement('i');
                    }
                    var textDecoration = comment.textDecoration;
                    if (textDecoration) {
                        if (textDecoration & 1) {
                            writer.writeLeafElement('u');
                        }
                        if (textDecoration & 8) {
                            writer.writeLeafElement('u', function () {
                                writer.writeAttributeString('val', excel_style_1.UnderLineStyle[2]);
                            });
                        }
                        if (textDecoration & 2) {
                            writer.writeLeafElement('strike');
                        }
                    }
                    value = comment.fontSize;
                    if (value) {
                        writer.writeLeafElement('sz', function () {
                            writer.writeAttributeString('val', value);
                        });
                    }
                    value = comment.foreColor;
                    if (value) {
                        color_writer_1.writeColor(writer, 'color', value);
                    }
                    else {
                        writer.writeLeafElement('color', function () {
                            writer.writeAttributeString('indexed', '81');
                        });
                    }
                    value = comment.fontFamily;
                    if (value) {
                        writer.writeLeafElement('rFont', function () {
                            writer.writeAttributeString('val', value);
                        });
                    }
                    writer.writeLeafElement('family', function () {
                        writer.writeAttributeString('val', '2');
                    });
                });
                var commentText = comment.text;
                var text = common_1._isNullOrUndefined(commentText) ? '' : commentText, keepSpace = text.length !== text.trim().length;
                writer.writeElement('t', function () {
                    if (keepSpace) {
                        writer.writeAttributeString('xml:space', 'preserve');
                    }
                }, function () {
                    writer.writeValue(xmlEncode(text));
                });
            });
        });
    });
}
function writeAuthors(writer) {
    writer.writeElement('authors', undefined, function () {
        writer.writeElement('author', undefined, function () {
            writer.writeValue('Author');
        });
    });
}
function writeCommentShapes(model, sheetIndex, comments) {
    var writer = new xml_writer_1.XmlWriter();
    writer.writeElement('xml', writeAttribues, writeConent);
    function writeAttribues() {
        writer.writeAttributeString('xmlns:v', 'urn:schemas-microsoft-com:vml');
        writer.writeAttributeString('xmlns:o', 'urn:schemas-microsoft-com:office:office');
        writer.writeAttributeString('xmlns:x', 'urn:schemas-microsoft-com:office:excel');
    }
    function writeConent() {
        var shapetypeIDPrefix = '_x0000_t';
        var shapetypeIDValue = '202';
        var shapeIDPrefix = '_x0000_s';
        var shapeIDValue = 1024 * (sheetIndex + 1) + 1;
        writer.writeElement('o:shapelayout', function () {
            writer.writeAttributeString('v:ext', 'edit');
        }, function () {
            writer.writeLeafElement('o:idmap', function () {
                writer.writeAttributeString('v:ext', 'edit');
                writer.writeAttributeString('data', '1');
            });
        });
        writer.writeElement('v:shapetype', function () {
            writer.writeAttributeString('id', shapetypeIDPrefix + shapetypeIDValue);
            writer.writeAttributeString('coordsize', '21600,21600');
            writer.writeAttributeString('o:spt', shapetypeIDValue);
            writer.writeAttributeString('path', 'm,l,21600r21600,l21600,xe');
        }, function () {
            writer.writeLeafElement('v:stroke', function () {
                writer.writeAttributeString('joinstyle', 'miter');
            });
            writer.writeLeafElement('v:path', function () {
                writer.writeAttributeString('gradientshapeok', 't');
                writer.writeAttributeString('o:connecttype', 'rect');
            });
        });
        comments.forEach(_writeComment);
        function getColorString(color) {
            if (color && color.indexOf('rgb') >= 0) {
                var value = excel_style_1.ColorHelper.fromHtmlColor(color), rgb = value.toString(16).substr(-6);
                return '#' + rgb;
            }
            return color;
        }
        function _writeComment(comment) {
            var inset = comment.inset;
            writer.writeElement('v:shape', function () {
                writer.writeAttributeString('id', shapeIDPrefix + shapeIDValue);
                shapeIDValue++;
                writer.writeAttributeString('type', '#' + shapetypeIDPrefix + shapetypeIDValue);
                writer.writeAttributeString('style', getStyleString(comment));
                writer.writeAttributeString('fillcolor', getColorString(comment.backColor));
                writer.writeAttributeString('strokecolor', getColorString(comment.borderColor));
                writer.writeAttributeString('strokeweight', comment.borderWidth.toString());
                if (!inset) {
                    writer.writeAttributeString('o:insetmode', 'auto');
                }
            }, function () {
                var dashStyle = comment.dashStyle, lineStyle = comment.lineStyle;
                if (dashStyle) {
                    writer.writeLeafElement('v:stroke', function () {
                        writer.writeAttributeString('dashstyle', dashStyle);
                    });
                }
                else if (lineStyle) {
                    writer.writeLeafElement('v:stroke', function () {
                        writer.writeAttributeString('linestyle', lineStyle);
                    });
                }
                writer.writeLeafElement('v:fill', function () {
                    var opacity = comment.opacity;
                    if (!common_1._isNullOrUndefined(opacity) && opacity !== 1) {
                        writer.writeAttributeString('opacity', Math.floor(opacity * 65535) + 'f');
                    }
                    writer.writeAttributeString('color2', '#ffffe1');
                });
                writer.writeLeafElement('v:shadow', function () {
                    writer.writeAttributeString('color', 'black');
                    writer.writeAttributeString('obscured', 't');
                });
                writer.writeLeafElement('v:path', function () {
                    writer.writeAttributeString('o:connecttype', 'none');
                });
                writer.writeElement('v:textbox', function () {
                    writer.writeAttributeString('style', 'mso-direction-alt:auto' + (comment.autoSize ? ';mso-fit-shape-to-text:t' : ''));
                    if (inset) {
                        writer.writeAttributeString('inset', inset);
                    }
                }, function () {
                    writer.writeElement('div', function () {
                        writer.writeAttributeString('style', 'text-align:' + comment.hAlign.toLowerCase());
                    }, null);
                });
                writer.writeElement('x:ClientData', function () {
                    writer.writeAttributeString('ObjectType', 'Note');
                }, function () {
                    if (comment.dynamicMove === false) {
                        writer.writeLeafElement('x:MoveWithCells');
                    }
                    if (comment.dynamicSize === false) {
                        writer.writeLeafElement('x:SizeWithCells');
                    }
                    if (comment.locked === false) {
                        writer.writeElementString('x:Locked', 'False');
                    }
                    if (comment.lockText === false) {
                        writer.writeElementString('x:LockText', 'False');
                    }
                    writer.writeElementString('x:AutoFill', 'False');
                    var hAlign = comment.hAlign;
                    if (hAlign !== 'Left') {
                        writer.writeElementString('x:TextHAlign', hAlign);
                    }
                    writer.writeElementString('x:Row', comment.row);
                    writer.writeElementString('x:Column', comment.col);
                    if (comment.displayMode === 1) {
                        writer.writeLeafElement('x:Visible');
                    }
                });
            });
            function getStyleString(item) {
                var style = ['position:absolute'];
                var value = item.marginLeft;
                if (value >= 0) {
                    style.push('margin-left:' + value + 'pt');
                }
                value = item.marginTop;
                if (value >= 0) {
                    style.push('margin-top:' + value + 'pt');
                }
                value = item.width;
                if (value) {
                    style.push('width:' + value);
                }
                value = item.height;
                if (value) {
                    style.push('height:' + value);
                }
                style.push('z-index:' + item.zIndex);
                value = item.visibility;
                if (value) {
                    style.push('visibility:' + value);
                }
                return style.join(';');
            }
        }
    }
    return writer.getXmlString();
}
exports.writeCommentShapes = writeCommentShapes;


/***/ }),

/***/ "./src/xlsx-io/writer/conditionalformat-writer.ts":
/*!********************************************************!*\
  !*** ./src/xlsx-io/writer/conditionalformat-writer.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var range_parser_1 = __webpack_require__(/*! ./../../common/range-parser */ "./src/common/range-parser.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var color_writer_1 = __webpack_require__(/*! ./../common/color-writer */ "./src/xlsx-io/common/color-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var style_writer_1 = __webpack_require__(/*! ./style-writer */ "./src/xlsx-io/writer/style-writer.ts");
var RuleType;
(function (RuleType) {
    RuleType[RuleType["conditionRuleBase"] = 0] = "conditionRuleBase";
    RuleType[RuleType["cellValueRule"] = 1] = "cellValueRule";
    RuleType[RuleType["specificTextRule"] = 2] = "specificTextRule";
    RuleType[RuleType["formulaRule"] = 3] = "formulaRule";
    RuleType[RuleType["dateOccurringRule"] = 4] = "dateOccurringRule";
    RuleType[RuleType["top10Rule"] = 5] = "top10Rule";
    RuleType[RuleType["uniqueRule"] = 6] = "uniqueRule";
    RuleType[RuleType["duplicateRule"] = 7] = "duplicateRule";
    RuleType[RuleType["averageRule"] = 8] = "averageRule";
    RuleType[RuleType["twoScaleRule"] = 10] = "twoScaleRule";
    RuleType[RuleType["threeScaleRule"] = 11] = "threeScaleRule";
    RuleType[RuleType["dataBarRule"] = 12] = "dataBarRule";
    RuleType[RuleType["iconSetRule"] = 13] = "iconSetRule";
    RuleType[RuleType["rowStateRule"] = 14] = "rowStateRule";
    RuleType[RuleType["columnStateRule"] = 15] = "columnStateRule";
})(RuleType || (RuleType = {}));
var ScaleValueType = {
    0: 'num',
    1: 'min',
    2: 'max',
    3: 'percent',
    4: 'percentile',
    6: 'formula',
    5: 'autoMin',
    7: 'autoMax'
};
var IconSetTypes = {
    0: '3Arrows',
    1: '3ArrowsGray',
    4: '3Flags',
    5: '3TrafficLights1',
    6: '3TrafficLights2',
    7: '3Signs',
    8: '3Symbols',
    9: '3Symbols2',
    10: '4Arrows',
    11: '4ArrowsGray',
    12: '4RedToBlack',
    13: '4Rating',
    14: '4TrafficLights',
    15: '5Arrows',
    16: '5ArrowsGray',
    17: '5Rating',
    18: '5Quarters',
    3: '3Stars',
    2: '3Triangles',
    19: '5Boxes',
    20: 'NoIcons'
};
var IconValueTypes = {
    1: 'num',
    4: 'percent',
    7: 'formula',
    5: 'percentile'
};
var ComparisonOperators = {
    0: 'equal',
    1: 'notEqual',
    2: 'greaterThan',
    3: 'greaterThanOrEqual',
    4: 'lessThan',
    5: 'lessThanOrEqual',
    6: 'between',
    7: 'notBetween'
};
function removeEqualSignIfExist(val) {
    var val2 = '' + val;
    if ((val2).charAt(0) === '=') {
        return (val2).substr(1);
    }
    return val2;
}
function getFormulaString(formula) {
    if (typeof formula === 'string') {
        return formula[0] === '=' ? formula.substr(1) : formula;
    }
    return formula;
}
function writeConditionalFormating(writer, sheetName, writerDataModel) {
    var conditionalformats = writerDataModel._getConditionalFormatting(sheetName);
    var rules = conditionalformats && conditionalformats.rules;
    if (rules && rules.length > 0) {
        var _loop_1 = function (i) {
            var rule = rules[i];
            if (common_1._isNullOrUndefined(rule.priority)) {
                rule.priority = 1;
            }
            if (isIconSetTypeExtension(rule) || isFormulaRuleExtension(rule, sheetName, writerDataModel._getSheetsName()) || isStateRule(rule)) {
                return "continue";
            }
            writer.writeElement('conditionalFormatting', function () {
                writer.writeAttributeString('sqref', range_parser_1.getRangeString(rule.ranges));
                if (rule.pivot) {
                    writer.writeAttributeString('pivot', "1");
                }
            }, function () {
                if (rule.ruleType === RuleType.dataBarRule) {
                    writer.writeElement('cfRule', function () {
                        writer.writeAttributeString('type', RuleType[rule.ruleType].replace('Rule', ''));
                        writer.writeAttributeString('priority', rule.priority);
                    }, function () {
                        writer.writeElement('dataBar', function () {
                            if (rule.showBarOnly) {
                                writer.writeAttributeString('showValue', '0');
                            }
                        }, function () {
                            var minType = ScaleValueType[rule.minType];
                            if (common_1._isNullOrUndefined(minType) || minType === 'autoMin') {
                                minType = 'min';
                            }
                            writer.writeLeafElement('cfvo', function () {
                                writer.writeAttributeString('type', minType);
                                if (!common_1._isNullOrUndefined(rule.minValue)) {
                                    writer.writeAttributeString('val', common_1.Util._xmlEncode(removeEqualSignIfExist(rule.minValue)));
                                }
                            });
                            var maxType = ScaleValueType[rule.maxType];
                            if (common_1._isNullOrUndefined(maxType) || maxType === 'autoMax') {
                                maxType = 'max';
                            }
                            writer.writeLeafElement('cfvo', function () {
                                writer.writeAttributeString('type', maxType);
                                if (!common_1._isNullOrUndefined(rule.maxValue)) {
                                    writer.writeAttributeString('val', common_1.Util._xmlEncode(removeEqualSignIfExist(rule.maxValue)));
                                }
                            });
                            color_writer_1.writeColor(writer, 'color', convertColor(rule.color));
                        });
                        writer.writeElement('extLst', function () {
                            writer.writeElement('ext', function () {
                                writer.writeAttributeString('uri', '{B025F937-C7B1-47D3-B67F-A62EFF666E3E}');
                                writer.writeAttributeString('xmlns:x14', 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main');
                            }, function () {
                                rule.id = common_1.Util._createURI();
                                writer.writeElement('x14:id', function () {
                                    writer.writeValue(rule.id);
                                });
                            });
                        });
                    });
                }
                else if (rule.ruleType === RuleType.twoScaleRule || rule.ruleType === RuleType.threeScaleRule) {
                    writer.writeElement('cfRule', function () {
                        writer.writeAttributeString('type', 'colorScale');
                        writer.writeAttributeString('priority', rule.priority);
                    }, function () {
                        writer.writeElement('colorScale', function () {
                            writer.writeLeafElement('cfvo', function () {
                                writer.writeAttributeString('type', ScaleValueType[rule.minType]);
                                if (!common_1._isNullOrUndefined(rule.minValue)) {
                                    writer.writeAttributeString('val', common_1.Util._xmlEncode(removeEqualSignIfExist(rule.minValue)));
                                }
                            });
                            var hasMiddleNode = rule.ruleType === RuleType.threeScaleRule;
                            if (hasMiddleNode) {
                                writer.writeLeafElement('cfvo', function () {
                                    writer.writeAttributeString('type', ScaleValueType[rule.midType]);
                                    if (!common_1._isNullOrUndefined(rule.midValue)) {
                                        writer.writeAttributeString('val', common_1.Util._xmlEncode(removeEqualSignIfExist(rule.midValue)));
                                    }
                                    else {
                                        writer.writeAttributeString('val', '50');
                                    }
                                });
                            }
                            writer.writeLeafElement('cfvo', function () {
                                writer.writeAttributeString('type', ScaleValueType[rule.maxType]);
                                if (!common_1._isNullOrUndefined(rule.maxValue)) {
                                    writer.writeAttributeString('val', common_1.Util._xmlEncode(removeEqualSignIfExist(rule.maxValue)));
                                }
                            });
                            color_writer_1.writeColor(writer, 'color', convertColor(rule.minColor));
                            if (hasMiddleNode) {
                                color_writer_1.writeColor(writer, 'color', convertColor(rule.midColor));
                            }
                            color_writer_1.writeColor(writer, 'color', convertColor(rule.maxColor));
                        });
                    });
                }
                else if (rule.ruleType === RuleType.iconSetRule) {
                    if (isIconSetTypeExtension(rule)) {
                        return;
                    }
                    writer.writeElement('cfRule', function () {
                        writer.writeAttributeString('type', 'iconSet');
                        writer.writeAttributeString('priority', rule.priority);
                    }, function () {
                        writer.writeElement('iconSet', function () {
                            var iconSetType = rule.iconSetType;
                            if (common_1._isNullOrUndefined(iconSetType)) {
                                iconSetType = 0;
                            }
                            writer.writeAttributeString('iconSet', IconSetTypes[iconSetType]);
                            if (rule.reverseIconOrder) {
                                writer.writeAttributeString('reverse', '1');
                            }
                            if (rule.showIconOnly) {
                                writer.writeAttributeString('showValue', '0');
                            }
                        }, function () {
                            writer.writeLeafElement('cfvo', function () {
                                writer.writeAttributeString('type', 'percent');
                                writer.writeAttributeString('val', '0');
                            });
                            var _loop_2 = function (j) {
                                var criteria = rule.iconCriteria[j];
                                writer.writeLeafElement('cfvo', function () {
                                    writer.writeAttributeString('type', IconValueTypes[criteria.iconValueType]);
                                    writer.writeAttributeString('val', removeEqualSignIfExist(criteria.iconValue));
                                    if (criteria.isGreaterThanOrEqualTo === false) {
                                        writer.writeAttributeString('gte', '0');
                                    }
                                });
                            };
                            for (var j = 0; j < rule.iconCriteria.length; j++) {
                                _loop_2(j);
                            }
                        });
                    });
                }
                else if (rule.ruleType === RuleType.cellValueRule) {
                    writer.writeElement('cfRule', function () {
                        writer.writeAttributeString('type', 'cellIs');
                        if (rule.priority) {
                            writer.writeAttributeString('priority', rule.priority);
                        }
                        if (rule.dxfId >= 0) {
                            writer.writeAttributeString('dxfId', rule.dxfId);
                        }
                        if (rule.stopIfTrue) {
                            writer.writeAttributeString('stopIfTrue', '1');
                        }
                        if (!common_1._isNullOrUndefined(rule.operator)) {
                            writer.writeAttributeString('operator', ComparisonOperators[rule.operator]);
                        }
                    }, function () {
                        if (!common_1._isNullOrUndefined(rule.value1)) {
                            writer.writeElement('formula', function () {
                                writer.writeValue(_xmlEncodeForCfRuleFormula(getFormulaString(rule.value1)));
                            });
                        }
                        if (!common_1._isNullOrUndefined(rule.value2)) {
                            writer.writeElement('formula', function () {
                                writer.writeValue(_xmlEncodeForCfRuleFormula(getFormulaString(rule.value2)));
                            });
                        }
                    });
                }
                else {
                    var generalRule_1 = processSpreadJSRule(rule);
                    writer.writeElement('cfRule', function () {
                        if (rule.ruleType === 4) {
                            writer.writeAttributeString('type', 'timePeriod');
                        }
                        else if (rule.ruleType === 8) {
                            writer.writeAttributeString('type', 'aboveAverage');
                            if (generalRule_1.type === 'aboveOrEqualToAverage' || generalRule_1.type === 'belowOrEqualToAverage') {
                                generalRule_1.equalAverage = true;
                            }
                            if (generalRule_1.type === 'belowAverage' || generalRule_1.type === 'belowOrEqualToAverage') {
                                generalRule_1.aboveAverage = false;
                            }
                        }
                        else if (rule.ruleType === 2) {
                            if (!common_1._isNullOrUndefined(generalRule_1.type)) {
                                writer.writeAttributeString("type", generalRule_1.type);
                            }
                            else {
                                writer.writeAttributeString("type", "containsText");
                            }
                        }
                        else {
                            writer.writeAttributeString("type", generalRule_1.type);
                        }
                        if (generalRule_1.dxfId >= 0) {
                            writer.writeAttributeString('dxfId', generalRule_1.dxfId);
                        }
                        if (generalRule_1.priority >= 0) {
                            writer.writeAttributeString('priority', generalRule_1.priority);
                        }
                        if (generalRule_1.stopIfTrue) {
                            writer.writeAttributeString("stopIfTrue", "1");
                        }
                        if (!common_1._isNullOrUndefined(generalRule_1.aboveAverage)) {
                            if (generalRule_1.aboveAverage) {
                                writer.writeAttributeString("aboveAverage", "1");
                            }
                            else {
                                writer.writeAttributeString("aboveAverage", "0");
                            }
                        }
                        if (!common_1._isNullOrUndefined(generalRule_1.equalAverage)) {
                            if (generalRule_1.equalAverage) {
                                writer.writeAttributeString("equalAverage", "1");
                            }
                            else {
                                writer.writeAttributeString("equalAverage", "0");
                            }
                        }
                        if (!common_1._isNullOrUndefined(generalRule_1.bottom)) {
                            if (generalRule_1.bottom) {
                                writer.writeAttributeString("bottom", "1");
                            }
                            else {
                                writer.writeAttributeString("bottom", "0");
                            }
                        }
                        if (generalRule_1.percent) {
                            writer.writeAttributeString("percent", "1");
                        }
                        if (!common_1._isNullOrUndefined(generalRule_1.operator)) {
                            writer.writeAttributeString("operator", generalRule_1.operator);
                        }
                        if (!common_1._isNullOrUndefined(generalRule_1.rank)) {
                            writer.writeAttributeString('rank', generalRule_1.rank);
                        }
                        if (!common_1._isNullOrUndefined(generalRule_1.stdDev)) {
                            writer.writeAttributeString('stdDev', generalRule_1.stdDev);
                        }
                        if (!common_1._isNullOrUndefined(generalRule_1.text)) {
                            writer.writeAttributeString('text', common_1.Util._xmlEncode(generalRule_1.text));
                        }
                        if (rule.ruleType === 4) {
                            writer.writeAttributeString("timePeriod", generalRule_1.type);
                        }
                    }, function () {
                        if (!common_1._isNullOrUndefined(generalRule_1.formulas)) {
                            var _loop_3 = function (j) {
                                writer.writeElement('formula', function () {
                                    writer.writeValue(common_1.Util._xmlEncode(getFormulaString(generalRule_1.formulas[j])));
                                });
                            };
                            for (var j = 0; j < generalRule_1.formulas.length; j++) {
                                _loop_3(j);
                            }
                        }
                    });
                }
            });
        };
        for (var i = 0; i < rules.length; i++) {
            _loop_1(i);
        }
    }
}
exports.writeConditionalFormating = writeConditionalFormating;
function processSpreadJSRule(rule) {
    switch (rule.ruleType) {
        case 2: return processConditionalFormatSpecificTextRule(rule);
        case 3: return processConditionalFormatFormulaRule(rule);
        case 4: return processConditionalFormatDateOccurringRule(rule);
        case 5: return processConditionalFormatTop10Rule(rule);
        case 6:
        case 7: return processConditionalFormatUniqueRule(rule);
        case 8: return processConditionalFormatAverageRule(rule);
        default:
            break;
    }
}
function processConditionalFormatAverageRule(rule) {
    var stdDev = 0;
    var type = 'aboveAverage';
    switch (rule.type) {
        case 0:
            type = 'aboveAverage';
            break;
        case 1:
            type = 'belowAverage';
            break;
        case 2:
            type = 'aboveOrEqualToAverage';
            break;
        case 3:
            type = 'belowOrEqualToAverage';
            break;
        case 4:
            type = 'aboveAverage';
            stdDev = 1;
            break;
        case 5:
            type = 'belowAverage';
            stdDev = 1;
            break;
        case 6:
            type = 'aboveAverage';
            stdDev = 2;
            break;
        case 7:
            type = 'belowAverage';
            stdDev = 2;
            break;
        case 8:
            type = 'aboveAverage';
            stdDev = 3;
            break;
        case 9:
            type = 'belowAverage';
            stdDev = 3;
            break;
    }
    var generalRule = {
        type: type,
        ranges: rule.ranges,
        priority: rule.priority,
        stopIfTrue: rule.stopIfTrue,
        stdDev: stdDev,
        dxfId: rule.dxfId
    };
    var formula = createConditionalFormatFormula(generalRule);
    if (formula) {
        generalRule.formulas = [formula];
    }
    return generalRule;
}
function processConditionalFormatUniqueRule(rule) {
    var type = 'uniqueValues';
    if (rule.ruleType === 7) {
        type = 'duplicateValues';
    }
    var generalRule = {
        type: type,
        ranges: rule.ranges,
        priority: rule.priority,
        stopIfTrue: rule.stopIfTrue,
        dxfId: rule.dxfId
    };
    var formula = createConditionalFormatFormula(generalRule);
    if (formula) {
        generalRule.formulas = [formula];
    }
    return generalRule;
}
function processConditionalFormatTop10Rule(rule) {
    var bottom = void 0;
    if (rule.type === 1) {
        bottom = true;
    }
    var generalRule = {
        type: 'top10',
        ranges: rule.ranges,
        stopIfTrue: rule.stopIfTrue,
        percent: false,
        priority: rule.priority,
        rank: rule.rank,
        dxfId: rule.dxfId,
        bottom: bottom
    };
    var formula = createConditionalFormatFormula(generalRule);
    if (formula) {
        generalRule.formulas = [formula];
    }
    return generalRule;
}
var DateOccurringType = {
    0: 'today',
    1: 'yesterday',
    2: 'tomorrow',
    3: 'last7Days',
    4: 'thisMonth',
    5: 'lastMonth',
    6: 'nextMonth',
    7: 'thisWeek',
    8: 'lastWeek',
    9: 'nextWeek'
};
function processConditionalFormatDateOccurringRule(rule) {
    var type = DateOccurringType[rule.type];
    var generalRule = {
        type: type,
        ranges: rule.ranges,
        priority: rule.priority,
        stopIfTrue: rule.stopIfTrue,
        dxfId: rule.dxfId
    };
    var formula = createConditionalFormatFormula(generalRule);
    if (formula) {
        generalRule.formulas = [formula];
    }
    return generalRule;
}
function processConditionalFormatFormulaRule(rule) {
    return {
        type: 'expression',
        ranges: rule.ranges,
        priority: rule.priority,
        stopIfTrue: rule.stopIfTrue,
        dxfId: rule.dxfId,
        formulas: [rule.formula]
    };
}
function _xmlEncodeForCfRuleFormula(string) {
    var exp1 = /&/g;
    var exp2 = /</g;
    var exp3 = />/g;
    if (typeof string === 'string') {
        return string.replace(exp1, '&amp;')
            .replace(exp2, '&lt;')
            .replace(exp3, '&gt;');
    }
    if (!common_1._isNullOrUndefined(string)) {
        return '' + string;
    }
    return string;
}
function processConditionalFormatSpecificTextRule(rule) {
    var operator = rule.operator;
    var type = 'containsText';
    var compareOp = 'contains';
    if (operator === 2) {
        type = 'beginsWith';
        compareOp = 'beginsWith';
    }
    else if (operator === 3) {
        type = 'endsWith';
        compareOp = 'endsWith';
    }
    else if (operator === 1) {
        type = 'notContainsText';
        compareOp = 'notContains';
    }
    else if (operator === 0) {
        compareOp = 'containsText';
    }
    var generalRule = {
        type: type,
        priority: rule.priority,
        operator: compareOp,
        text: rule.text,
        stopIfTrue: rule.stopIfTrue,
        dxfId: rule.dxfId,
        ranges: rule.ranges
    };
    var formula = createConditionalFormatFormula(generalRule);
    if (formula) {
        generalRule.formulas = [formula];
    }
    return generalRule;
}
function createConditionalFormatFormula(rule) {
    if (!rule || !rule.ranges) {
        return null;
    }
    var range = rule.ranges[0];
    if (range.row < 0 || range.col < 0) {
        return null;
    }
    var baseCell = common_1.IndexHelper._getColumnIndexInA1Letter(range.col) + (range.row + 1);
    var rangeStr = '';
    if (range.rowCount === excel_types_1.ExcelConstants._openXmlMaxRow) {
        rangeStr = stringFormat("${0}:${1}", common_1.IndexHelper._getColumnIndexInA1Letter(range.col), common_1.IndexHelper._getColumnIndexInA1Letter(range.col + range.colCount - 1));
    }
    else if (range.colCount === excel_types_1.ExcelConstants._openXmlMaxColumn) {
        rangeStr = stringFormat("${0}:${1}", range.row + 1, range.row + range.rowCount);
    }
    else {
        rangeStr = stringFormat("${0}${1}:${2}${3}", common_1.IndexHelper._getColumnIndexInA1Letter(range.col), range.row + 1, common_1.IndexHelper._getColumnIndexInA1Letter(range.col + range.colCount - 1), range.row + range.rowCount);
    }
    if (rule.type === 'top10') {
        if (rule.bottom) {
            if (rule.percent) {
                return stringFormat("IF(INT(COUNT({0})*{1}%)>0,SMALL({0},INT(COUNT({0})*{1}%)),MIN({0}))>={2}", rangeStr, rule.rank, baseCell);
            }
            return stringFormat("SMALL(({0}),MIN({1},COUNT({0})))>={2}", rangeStr, rule.rank, baseCell);
        }
        else if (rule.percent) {
            return stringFormat("IF(INT(COUNT({0})*{1}%)>0,LARGE({0},INT(COUNT({0})*{1}%)),MIN({0}))<={2}", rangeStr, rule.rank, baseCell);
        }
        return stringFormat("LARGE(({0}),MIN({1},COUNT({0})))<={2}", rangeStr, rule.rank, baseCell);
    }
    else if (rule.type === 'containsText') {
        return stringFormat("NOT(ISERROR(SEARCH(\"{0}\",{1})))", rule.text, baseCell);
    }
    else if (rule.type === 'notContainsText') {
        return stringFormat("ISERROR(SEARCH(\"{0}\",{1}))", rule.text, baseCell);
    }
    else if (rule.type === 'beginsWith') {
        return stringFormat("LEFT({0},{1}) = \"{2}\"", baseCell, rule.text.length, rule.text);
    }
    else if (rule.type === 'endsWith') {
        return stringFormat("RIGHT({0},{1}) = \"{2}\"", baseCell, rule.text.length, rule.text);
    }
    else if (rule.type === 'duplicateValues') {
        return stringFormat("AND(COUNTIF({0},{1})>1,NOT(ISBLANK({1})))", rangeStr, baseCell);
    }
    else if (rule.type === 'uniqueValues') {
        return stringFormat("AND(COUNTIF({0},{1})=1,NOT(ISBLANK({1})))", rangeStr, baseCell);
    }
    else if (rule.type === 'aboveAverage'
        || rule.type === 'belowAverage'
        || rule.type === 'aboveOrEqualToAverage'
        || rule.type === 'belowOrEqualToAverage') {
        if (rule.type === 'aboveAverage' && common_1._isNullOrUndefined(rule.stdDev)) {
            return stringFormat("{0}>AVERAGE({1})", baseCell, rangeStr);
        }
        if (!common_1._isNullOrUndefined(rule.aboveAverage)) {
            if (!common_1._isNullOrUndefined(rule.equalAverage)
                && !rule.aboveAverage
                && !common_1._isNullOrUndefined(rule.equalAverage)
                && rule.equalAverage
                && common_1._isNullOrUndefined(rule.stdDev)) {
                return stringFormat("{0}<=AVERAGE({1})", baseCell, rangeStr);
            }
            else if (!rule.aboveAverage && common_1._isNullOrUndefined(rule.stdDev)) {
                return stringFormat("{0}<AVERAGE({1})", baseCell, rangeStr);
            }
        }
        if (!common_1._isNullOrUndefined(rule.equalAverage) && rule.equalAverage && common_1._isNullOrUndefined(rule.stdDev)) {
            return stringFormat("{0}>=AVERAGE({1})", baseCell, rangeStr);
        }
        if (!common_1._isNullOrUndefined(rule.stdDev)) {
            if (!common_1._isNullOrUndefined(rule.aboveAverage)
                && !rule.aboveAverage) {
                return stringFormat("({0}-AVERAGE({1}))<=STDEVP({1})*(-{2})", baseCell, rangeStr, rule.stdDev);
            }
            return stringFormat("({0}-AVERAGE({1}))>=STDEVP({1})*({2})", baseCell, rangeStr, rule.stdDev);
        }
    }
    return null;
}
function stringFormat(format) {
    var arg = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        arg[_i - 1] = arguments[_i];
    }
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(/{(\d+)}/g, function (match, number) {
        return typeof args[number] !== 'undefined' ? args[number] : match;
    });
}
function convertColor(color) {
    return excel_style_1.ColorHelper.toExcelColor(color);
}
function isIconSetTypeExtension(rule) {
    return (rule.ruleType === RuleType.iconSetRule) &&
        (rule.iconSetType === 3 ||
            rule.iconSetType === 2 ||
            rule.iconSetType === 19 ||
            isCustomIconSet(rule.iconSetType, rule.icons));
}
function isStateRule(rule) {
    return rule.ruleType === RuleType.rowStateRule || rule.ruleType === RuleType.columnStateRule;
}
function isDataBarExtension(rule) {
    if (rule.ruleType === RuleType.dataBarRule) {
        return true;
    }
    return false;
}
function isFormulaRuleExtension(rule, currentSheetName, sheetNames) {
    if (rule.ruleType === RuleType.formulaRule) {
        return common_1.Util._isExternalRange(rule.formula, currentSheetName, sheetNames);
    }
    return false;
}
function needWriteConditionalFormatExtension(rules, currentSheetName, sheetNames) {
    var extensionCount = 0;
    for (var i = 0; i < rules.length; i++) {
        var rule = rules[i];
        if (isDataBarExtension(rule) || isIconSetTypeExtension(rule) || isFormulaRuleExtension(rule, currentSheetName, sheetNames)) {
            extensionCount++;
        }
    }
    if (extensionCount === 0) {
        return false;
    }
    return true;
}
exports.needWriteConditionalFormatExtension = needWriteConditionalFormatExtension;
function writeExtensionConditionalFormats(writer, sheetName, writerDataModel) {
    var conditionalFormats = writerDataModel._getConditionalFormatting(sheetName);
    var rules = conditionalFormats && conditionalFormats.rules;
    if (!rules || rules.length === 0 || !needWriteConditionalFormatExtension(rules, sheetName, writerDataModel._getSheetsName())) {
        return;
    }
    writer.writeElement('ext', function () {
        writer.writeAttributeString('uri', '{78C0D931-6437-407d-A8EE-F0AAD7539E65}');
        writer.writeAttributeString('xmlns:x14', 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main');
    }, function () {
        writer.writeElement('x14:conditionalFormattings', function () {
            for (var i = 0; i < rules.length; i++) {
                var rule = rules[i];
                if (common_1._isNullOrUndefined(rule.id)) {
                    rule.id = common_1.Util._createURI();
                }
                if (isDataBarExtension(rule)) {
                    writeDataBarExtensionRecord(writer, sheetName, rule);
                }
                if (isIconSetTypeExtension(rule)) {
                    writeIconSetExtensionRecord(writer, sheetName, rule);
                }
                if (isFormulaRuleExtension(rule, sheetName, writerDataModel._getSheetsName())) {
                    writeFormulaRuleExtension(writer, sheetName, rule);
                }
            }
        });
    });
}
exports.writeExtensionConditionalFormats = writeExtensionConditionalFormats;
function writeFormulaRuleExtension(writer, sheetName, rule) {
    writer.writeElement('x14:conditionalFormatting', function () {
        writer.writeAttributeString('xmlns:xm', 'http://schemas.microsoft.com/office/excel/2006/main');
    }, function () {
        writer.writeElement('x14:cfRule', function () {
            writer.writeAttributeString('type', 'expression');
            writer.writeAttributeString('priority', rule.priority);
            writer.writeAttributeString('id', rule.id);
        }, function () {
            writer.writeElement('xm:f', function () {
                writer.writeValue(common_1.Util._xmlEncode(removeEqualSignIfExist(rule.formula)));
            });
            style_writer_1.writeDxf(writer, undefined, rule.style, 'x14:dxf');
        });
        writer.writeElement('xm:sqref', function () {
            writer.writeValue(range_parser_1.getRangeString(rule.ranges));
        });
    });
}
function writeDataBarExtensionRecord(writer, sheetName, rule) {
    writer.writeElement('x14:conditionalFormatting', function () {
        writer.writeAttributeString('xmlns:xm', 'http://schemas.microsoft.com/office/excel/2006/main');
    }, function () {
        writer.writeElement('x14:cfRule', function () {
            writer.writeAttributeString('type', RuleType[rule.ruleType].replace('Rule', ''));
            writer.writeAttributeString('id', rule.id);
        }, function () {
            writer.writeElement('x14:dataBar', function () {
                writer.writeAttributeString('minLength', '0');
                writer.writeAttributeString('maxLength', '100');
                if (rule.showBarOnly) {
                    writer.writeAttributeString('showValue', '0');
                }
                if (rule.showBorder) {
                    writer.writeAttributeString('border', '1');
                }
                if (rule.gradient === false) {
                    writer.writeAttributeString('gradient', '0');
                }
                if (rule.useNegativeFillColor === false) {
                    writer.writeAttributeString('negativeBarColorSameAsPositive', '1');
                }
                if (rule.useNegativeBorderColor) {
                    writer.writeAttributeString('negativeBarBorderColorSameAsPositive', '0');
                }
                writer.writeAttributeString('direction', rule.dataBarDirection === 1 ? 'rightToLeft' : 'leftToRight');
                if (rule.axisPosition !== 0) {
                    if (rule.axisPosition === 1) {
                        writer.writeAttributeString('axisPosition', 'middle');
                    }
                    if (rule.axisPosition === 2) {
                        writer.writeAttributeString('axisPosition', 'none');
                    }
                }
            }, function () {
                if (common_1._isNullOrUndefined(rule.minType) || rule.minType === 5) {
                    writer.writeLeafElement('x14:cfvo', function () {
                        writer.writeAttributeString('type', 'autoMin');
                    });
                }
                else if (!common_1._isNullOrUndefined(rule.minValue)) {
                    writer.writeElement('x14:cfvo', function () {
                        writer.writeAttributeString('type', ScaleValueType[rule.minType]);
                    }, function () {
                        writer.writeElement('xm:f', function () {
                            writer.writeValue(common_1.Util._xmlEncode(removeEqualSignIfExist(rule.minValue)));
                        });
                    });
                }
                else {
                    writer.writeLeafElement('x14:cfvo', function () {
                        writer.writeAttributeString('type', ScaleValueType[rule.minType]);
                    });
                }
                if (common_1._isNullOrUndefined(rule.maxType) || rule.maxType === 7) {
                    writer.writeLeafElement('x14:cfvo', function () {
                        writer.writeAttributeString('type', 'autoMax');
                    });
                }
                else if (!common_1._isNullOrUndefined(rule.maxValue)) {
                    writer.writeElement('x14:cfvo', function () {
                        writer.writeAttributeString('type', ScaleValueType[rule.maxType]);
                    }, function () {
                        writer.writeElement('xm:f', function () {
                            writer.writeValue(common_1.Util._xmlEncode(removeEqualSignIfExist(rule.maxValue)));
                        });
                    });
                }
                else {
                    writer.writeLeafElement('x14:cfvo', function () {
                        writer.writeAttributeString('type', ScaleValueType[rule.maxType]);
                    });
                }
                if (rule.showBorder && rule.borderColor) {
                    color_writer_1.writeColor(writer, 'x14:borderColor', convertColor(rule.borderColor));
                }
                if (!common_1._isNullOrUndefined(rule.negativeFillColor)) {
                    color_writer_1.writeColor(writer, 'x14:negativeFillColor', convertColor(rule.negativeFillColor));
                }
                else {
                    color_writer_1.writeColor(writer, 'x14:negativeFillColor', convertColor('red'));
                }
                if (!common_1._isNullOrUndefined(rule.negativeBorderColor)) {
                    color_writer_1.writeColor(writer, 'x14:negativeBorderColor', convertColor(rule.negativeBorderColor));
                }
                else {
                    color_writer_1.writeColor(writer, 'x14:negativeBorderColor', convertColor('black'));
                }
                if (rule.axisPosition !== 2) {
                    color_writer_1.writeColor(writer, 'x14:axisColor', convertColor(rule.axisColor));
                }
            });
        });
        writer.writeElement('xm:sqref', function () {
            writer.writeValue(range_parser_1.getRangeString(rule.ranges));
        });
    });
}
function writeIconSetExtensionRecord(writer, sheetName, rule) {
    writer.writeElement('x14:conditionalFormatting', function () {
        writer.writeAttributeString('xmlns:xm', 'http://schemas.microsoft.com/office/excel/2006/main');
    }, function () {
        writer.writeElement('x14:cfRule', function () {
            writer.writeAttributeString('type', 'iconSet');
            if (rule.priority) {
                writer.writeAttributeString('priority', rule.priority);
            }
            writer.writeAttributeString('id', rule.id);
        }, function () {
            writer.writeElement('x14:iconSet', function () {
                var iconSetType = rule.iconSetType;
                if (common_1._isNullOrUndefined(iconSetType)) {
                    iconSetType = 0;
                }
                writer.writeAttributeString('iconSet', IconSetTypes[iconSetType]);
                var isCustomIconSetFlag = isCustomIconSet(iconSetType, rule.icons);
                if (isCustomIconSetFlag) {
                    writer.writeAttributeString('custom', '1');
                }
                if (rule.showIconOnly) {
                    writer.writeAttributeString('showValue', '0');
                }
                if (rule.reverseIconOrder) {
                    if (isCustomIconSetFlag) {
                        rule.icons.reverse();
                    }
                    else {
                        writer.writeAttributeString('reverse', '1');
                    }
                }
            }, function () {
                writer.writeElement('x14:cfvo', function () {
                    writer.writeAttributeString('type', 'percent');
                }, function () {
                    writer.writeElement('xm:f', function () {
                        writer.writeValue('0');
                    });
                });
                var _loop_4 = function (i) {
                    var criteria = rule.iconCriteria[i];
                    writer.writeElement('x14:cfvo', function () {
                        writer.writeAttributeString('type', IconValueTypes[criteria.iconValueType]);
                        if (criteria.isGreaterThanOrEqualTo === false) {
                            writer.writeAttributeString('gte', '0');
                        }
                    }, function () {
                        writer.writeElement('xm:f', function () {
                            writer.writeValue(common_1.Util._xmlEncode(removeEqualSignIfExist(criteria.iconValue)));
                        });
                    });
                };
                for (var i = 0; i < rule.iconCriteria.length; i++) {
                    _loop_4(i);
                }
                var icons = rule.icons;
                var _loop_5 = function (j) {
                    writer.writeLeafElement('x14:cfIcon', function () {
                        var iconSetType = icons[j].iconSetType;
                        var iconIndex = icons[j].iconIndex;
                        var iconInfo = distinctIcon(iconSetType, iconIndex);
                        writer.writeAttributeString('iconSet', IconSetTypes[iconInfo.iconSetType]);
                        writer.writeAttributeString('iconId', iconInfo.iconIndex);
                    });
                };
                for (var j = 0; j < icons.length; j++) {
                    _loop_5(j);
                }
            });
        });
        writer.writeElement('xm:sqref', function () {
            writer.writeValue(range_parser_1.getRangeString(rule.ranges));
        });
    });
}
function isCustomIconSet(iconSetType, icons) {
    var isSameIconSetType = true, isAscend = true, isDescend = true;
    var i;
    for (i = 0; i < icons.length; i++) {
        if (icons[i].iconSetType !== iconSetType) {
            isSameIconSetType = false;
            break;
        }
    }
    for (i = 0; i < icons.length; i++) {
        if (icons[i].iconIndex !== i) {
            isAscend = false;
            break;
        }
    }
    for (i = 0; i < icons.length; i++) {
        if (icons[i].iconIndex !== icons.length - 1 - i) {
            isDescend = false;
            break;
        }
    }
    if (!isSameIconSetType || !(isAscend || isDescend)) {
        return true;
    }
    return false;
}
function distinctIcon(iconSetType, iconIndex) {
    if (iconSetType === 10) {
        if (iconIndex === 3) {
            return {
                iconSetType: 0,
                iconIndex: 2
            };
        }
        else if (iconIndex === 0) {
            return {
                iconSetType: 0,
                iconIndex: 0
            };
        }
    }
    else if (iconSetType === 15) {
        if (iconIndex === 4) {
            return {
                iconSetType: 0,
                iconIndex: 2
            };
        }
        else if (iconIndex === 0) {
            return {
                iconSetType: 0,
                iconIndex: 0
            };
        }
        else if (iconIndex === 2) {
            return {
                iconSetType: 0,
                iconIndex: 1
            };
        }
        else if (iconIndex === 3) {
            return {
                iconSetType: 10,
                iconIndex: 2
            };
        }
        else if (iconIndex === 1) {
            return {
                iconSetType: 10,
                iconIndex: 1
            };
        }
    }
    else if (iconSetType === 11) {
        if (iconIndex === 3) {
            return {
                iconSetType: 1,
                iconIndex: 2
            };
        }
        else if (iconIndex === 0) {
            return {
                iconSetType: 1,
                iconIndex: 0
            };
        }
    }
    else if (iconSetType === 16) {
        if (iconIndex === 4) {
            return {
                iconSetType: 1,
                iconIndex: 2
            };
        }
        else if (iconIndex === 0) {
            return {
                iconSetType: 1,
                iconIndex: 0
            };
        }
        else if (iconIndex === 2) {
            return {
                iconSetType: 1,
                iconIndex: 1
            };
        }
        else if (iconIndex === 3) {
            return {
                iconSetType: 11,
                iconIndex: 2
            };
        }
        else if (iconIndex === 1) {
            return {
                iconSetType: 11,
                iconIndex: 1
            };
        }
    }
    else if (iconSetType === 14) {
        if (iconIndex === 3) {
            return {
                iconSetType: 5,
                iconIndex: 2
            };
        }
        else if (iconIndex === 2) {
            return {
                iconSetType: 5,
                iconIndex: 1
            };
        }
        else if (iconIndex === 1) {
            return {
                iconSetType: 5,
                iconIndex: 0
            };
        }
    }
    else if (iconSetType === 13) {
        if (iconIndex === 0) {
            return {
                iconSetType: 17,
                iconIndex: 1
            };
        }
        else if (iconIndex === 1) {
            return {
                iconSetType: 17,
                iconIndex: 2
            };
        }
        else if (iconIndex === 2) {
            return {
                iconSetType: 17,
                iconIndex: 3
            };
        }
        else if (iconIndex === 3) {
            return {
                iconSetType: 17,
                iconIndex: 4
            };
        }
    }
    return {
        iconSetType: iconSetType,
        iconIndex: iconIndex
    };
}


/***/ }),

/***/ "./src/xlsx-io/writer/datavalidation-writer.ts":
/*!*****************************************************!*\
  !*** ./src/xlsx-io/writer/datavalidation-writer.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var isNullOrWhiteSpace = common_1.StringEx._isNullOrWhiteSpace;
var xmlEncode = common_1.Util._xmlEncode;
var keyword_null = null;
var ExcelDataValidationType = {
    0: 'none',
    1: 'whole',
    2: 'decimal',
    3: 'list',
    4: 'date',
    5: 'time',
    6: 'textLength',
    7: 'custom'
};
var ExcelDataValidationErrorStyle = {
    0: 'stop',
    1: 'warning',
    2: 'information'
};
var ExcelDataValidationOperator = {
    6: 'between',
    7: 'notBetween',
    0: 'equal',
    1: 'notEqual',
    2: 'greaterThan',
    4: 'lessThan',
    3: 'greaterThanOrEqual',
    5: 'lessThanOrEqual'
};
function isNullOrEmpty(value) {
    return common_1.isNullOrUndefined(value) || value === '';
}
function writeValidationAttribute(writer, item) {
    if (!common_1.isNullOrUndefined(item.type) && item.type !== 0) {
        writer.writeAttributeString("type", ExcelDataValidationType[item.type]);
    }
    if (!common_1.isNullOrUndefined(item.errorStyle) && item.errorStyle !== 0) {
        writer.writeAttributeString("errorStyle", ExcelDataValidationErrorStyle[item.errorStyle]);
    }
    if (!common_1.isNullOrUndefined(item.compareOperator) && item.compareOperator !== 6) {
        writer.writeAttributeString("operator", ExcelDataValidationOperator[item.compareOperator]);
    }
    if (item.allowBlank !== false) {
        writer.writeAttributeString("allowBlank", "1");
    }
    if (item.showPromptBox === false) {
        writer.writeAttributeString("showDropDown", "1");
    }
    if (item.showInputMessage !== false) {
        writer.writeAttributeString("showInputMessage", "1");
    }
    if (item.showErrorBox !== false) {
        writer.writeAttributeString("showErrorMessage", "1");
    }
    if (!isNullOrEmpty(item.errorTitle)) {
        writer.writeAttributeString("errorTitle", xmlEncode(item.errorTitle));
    }
    if (!isNullOrEmpty(item.error)) {
        writer.writeAttributeString("error", xmlEncode(common_1.Util._encodeSpecialCharacterToXML(item.error)));
    }
    if (!isNullOrEmpty(item.promptTitle)) {
        writer.writeAttributeString("promptTitle", xmlEncode(item.promptTitle));
    }
    if (!isNullOrEmpty(item.prompt)) {
        writer.writeAttributeString("prompt", xmlEncode(common_1.Util._encodeSpecialCharacterToXML(item.prompt)));
    }
}
function writeDataValidations(writer, sheetName, writerDataModel) {
    var allDvs = writerDataModel._getValidationData(sheetName);
    var dvs = [];
    if (!writerDataModel._extensionDataValidations) {
        writerDataModel._extensionDataValidations = [];
    }
    if (allDvs.length > 0) {
        allDvs.forEach(function (dv) {
            if (dv.external) {
                writerDataModel._extensionDataValidations.push(dv);
            }
            else {
                dvs.push(dv);
            }
        });
    }
    if (dvs.length > 0) {
        writer.writeElement("dataValidations", function () {
            writer.writeAttributeString("count", dvs.length);
        }, function () {
            dvs.forEach(function (item) {
                if (common_1.isNullOrUndefined(item) || common_1.isNullOrUndefined(item.ranges)) {
                    return;
                }
                writer.writeElement("dataValidation", function () {
                    writeValidationAttribute(writer, item);
                    writer.writeAttributeString("sqref", item.ranges);
                }, function () {
                    if (!isNullOrWhiteSpace(item.firstFormula)) {
                        writer.writeElementString("formula1", xmlEncode(item.firstFormula));
                    }
                    if (!isNullOrWhiteSpace(item.secondFormula)) {
                        writer.writeElementString("formula2", xmlEncode(item.secondFormula));
                    }
                });
            });
        });
    }
}
exports.writeDataValidations = writeDataValidations;
function writeExtensionDataValidations(writer, writerDataModel) {
    var _extensionDataValidations = writerDataModel._extensionDataValidations;
    if (_extensionDataValidations && _extensionDataValidations.length === 0) {
        return;
    }
    writer.writeElement("ext", function () {
        writer.writeAttributeString("xmlns:x14", "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main");
        writer.writeAttributeString("uri", "{CCE6A557-97BC-4b89-ADB6-D9C93CAAB3DF}");
    }, function () {
        writer.writeElement("x14:dataValidations", function () {
            writer.writeAttributeString("xmlns:xm", "http://schemas.microsoft.com/office/excel/2006/main");
            writer.writeAttributeString("count", _extensionDataValidations.length);
        }, function () {
            _extensionDataValidations.forEach(function (item) {
                writer.writeElement("x14:dataValidation", function () {
                    writeValidationAttribute(writer, item);
                }, function () {
                    if (!isNullOrWhiteSpace(item.firstFormula)) {
                        writer.writeElement("x14:formula1", function () {
                            writer.writeElementString("xm:f", xmlEncode(item.firstFormula));
                        });
                    }
                    if (!isNullOrWhiteSpace(item.secondFormula)) {
                        writer.writeElement("x14:formula2", function () {
                            writer.writeElementString("xm:f", xmlEncode(item.secondFormula));
                        });
                    }
                    writer.writeElementString("xm:sqref", item.ranges);
                });
            });
        });
    });
    writerDataModel._extensionDataValidations = keyword_null;
}
exports.writeExtensionDataValidations = writeExtensionDataValidations;


/***/ }),

/***/ "./src/xlsx-io/writer/docPropsAppWriter.ts":
/*!*************************************************!*\
  !*** ./src/xlsx-io/writer/docPropsAppWriter.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
function writeDocPropsApp(writerDataModel) {
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('Properties', function () {
        writer.writeAttributeString('xmlns', excel_types_1.XFileConstants._docPropsAppRootNameSpace);
        writer.writeAttributeString('xmlns:vt', excel_types_1.XFileConstants._docPropsAppVTypesNameSpace);
    }, function () {
        var docPropsAppObj = writerDataModel._spread.docProps.docPropsApp;
        for (var key in docPropsAppObj) {
            if (docPropsAppObj.hasOwnProperty(key)) {
                switch (key) {
                    case "HeadingPairs":
                        writeHeadingPairs(writer, docPropsAppObj);
                        break;
                    case "TitlesOfParts":
                        writerTitlesOfParts(writer, docPropsAppObj);
                        break;
                    default:
                        writeElementWithoutAttr(key, writer, docPropsAppObj);
                        break;
                }
            }
        }
    });
    return writer.getXmlString();
}
exports.writeDocPropsApp = writeDocPropsApp;
function writeHeadingPairs(writer, docPropsAppObj) {
    writer.writeElement("HeadingPairs", function () {
    }, function () {
        writer.writeElement("vt:vector", function () {
            writer.writeAttributeString("size", docPropsAppObj.HeadingPairs.size);
            writer.writeAttributeString("baseType", docPropsAppObj.HeadingPairs.baseType);
        }, function () {
            var workbookInfoArray = docPropsAppObj.HeadingPairs.workbookInfoArray;
            var _loop_1 = function (i) {
                writer.writeElement("vt:variant", function () {
                }, function () {
                    writer.writeElement(workbookInfoArray[i].elementType, function () {
                    }, function () {
                        writer.writeValue(workbookInfoArray[i].value);
                    });
                });
            };
            for (var i = 0; i < workbookInfoArray.length; i++) {
                _loop_1(i);
            }
        });
    });
}
function writerTitlesOfParts(writer, docPropsAppObj) {
    writer.writeElement("TitlesOfParts", function () {
    }, function () {
        writer.writeElement("vt:vector", function () {
            writer.writeAttributeString("size", docPropsAppObj.TitlesOfParts.size);
            writer.writeAttributeString("baseType", docPropsAppObj.TitlesOfParts.baseType);
        }, function () {
            var sheetsNameArray = docPropsAppObj.TitlesOfParts.sheetsNameArray;
            var _loop_2 = function (i) {
                writer.writeElement("vt:lpstr", function () {
                }, function () {
                    writer.writeValue(sheetsNameArray[i]);
                });
            };
            for (var i = 0; i < sheetsNameArray.length; i++) {
                _loop_2(i);
            }
        });
    });
}
function writeElementWithoutAttr(name, writer, docPropsAppObj) {
    var key = name.slice(0, 1).toUpperCase() + name.slice(1);
    writer.writeElement(key, function () {
    }, function () {
        writer.writeValue(docPropsAppObj[name]);
    });
}


/***/ }),

/***/ "./src/xlsx-io/writer/docPropsCoreWriter.ts":
/*!**************************************************!*\
  !*** ./src/xlsx-io/writer/docPropsCoreWriter.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
function writeDocPropsCore(writerDataModel) {
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('cp:coreProperties', function () {
        writer.writeAttributeString('xmlns:cp', excel_types_1.XFileConstants._docPropsCoreRootNameSpace);
        writer.writeAttributeString('xmlns:dc', excel_types_1.XFileConstants._docPropsElementsNameSpace);
        writer.writeAttributeString('xmlns:dcterms', excel_types_1.XFileConstants._docPropsTermsNameSpace);
        writer.writeAttributeString('xmlns:dcmitype', excel_types_1.XFileConstants._docPropsDcmitypeNameSpace);
        writer.writeAttributeString('xmlns:xsi', excel_types_1.XFileConstants._docPropsXMLSchemaNameSpace);
    }, function () {
        var docPropsCoreObj = writerDataModel._spread.docProps.docPropsCore;
        var _loop_1 = function (key) {
            if (docPropsCoreObj.hasOwnProperty(key)) {
                switch (key) {
                    case "title":
                        writer.writeElement('dc:title', function () {
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "subject":
                        writer.writeElement('dc:subject', function () {
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "creator":
                        writer.writeElement('dc:creator', function () {
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "keywords":
                        writer.writeElement('cp:keywords', function () {
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "description":
                        writer.writeElement('dc:description', function () {
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "lastModifiedBy":
                        writer.writeElement('cp:lastModifiedBy', function () {
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "created":
                        writer.writeElement('dcterms:created', function () {
                            writer.writeAttributeString("xsi:type", "dcterms:W3CDTF");
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "modified":
                        writer.writeElement('dcterms:modified', function () {
                            writer.writeAttributeString("xsi:type", "dcterms:W3CDTF");
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "lastPrinted":
                        writer.writeElement('cp:lastPrinted', function () {
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "category":
                        writer.writeElement('cp:category', function () {
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "contentStatus":
                        writer.writeElement('cp:contentStatus', function () {
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "language":
                        writer.writeElement('dc:language', function () {
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "version":
                        writer.writeElement('cp:version', function () {
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    case "revision":
                        writer.writeElement('cp:revision', function () {
                        }, function () {
                            writer.writeValue(docPropsCoreObj[key]);
                        });
                        break;
                    default:
                        break;
                }
            }
        };
        for (var key in docPropsCoreObj) {
            _loop_1(key);
        }
    });
    return writer.getXmlString();
}
exports.writeDocPropsCore = writeDocPropsCore;


/***/ }),

/***/ "./src/xlsx-io/writer/docPropsCustomWriter.ts":
/*!****************************************************!*\
  !*** ./src/xlsx-io/writer/docPropsCustomWriter.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
function writeDocPropsCustom(writerDataModel) {
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('Properties', function () {
        writer.writeAttributeString('xmlns', excel_types_1.XFileConstants._docPropsCustomNameSpace);
        writer.writeAttributeString('xmlns:vt', excel_types_1.XFileConstants._docPropsCustomVTypesNameSpace);
    }, function () {
        var docPropsCustomArray = writerDataModel._spread.docProps.docPropsCustom;
        var _loop_1 = function (i) {
            var customPropsItem = docPropsCustomArray[i];
            writer.writeElement('property', function () {
                for (var key in customPropsItem) {
                    if (key !== "propertyItemChildElement") {
                        writer.writeAttributeString(key, customPropsItem[key]);
                    }
                }
            }, function () {
                var customPropsItemChildItem = customPropsItem.propertyItemChildElement;
                var _loop_2 = function (key) {
                    if (customPropsItemChildItem.hasOwnProperty(key)) {
                        writer.writeElement(key, function () {
                        }, function () {
                            writer.writeValue(customPropsItemChildItem[key]);
                        });
                    }
                };
                for (var key in customPropsItemChildItem) {
                    _loop_2(key);
                }
            });
        };
        for (var i = 0; i < docPropsCustomArray.length; i++) {
            _loop_1(i);
        }
    });
    return writer.getXmlString();
}
exports.writeDocPropsCustom = writeDocPropsCustom;


/***/ }),

/***/ "./src/xlsx-io/writer/drawing-writer.ts":
/*!**********************************************!*\
  !*** ./src/xlsx-io/writer/drawing-writer.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var slicer_writer_1 = __webpack_require__(/*! ./slicer-writer */ "./src/xlsx-io/writer/slicer-writer.ts");
var color_writer_1 = __webpack_require__(/*! ./../common/color-writer */ "./src/xlsx-io/common/color-writer.ts");
var chart_writer_1 = __webpack_require__(/*! ./chart-writer */ "./src/xlsx-io/writer/chart-writer.ts");
var chart_model_1 = __webpack_require__(/*! ./../../datamodel/chart-model */ "./src/datamodel/chart-model.ts");
function _getXFileConstants() {
    return excel_types_1.XFileConstants;
}
function _writeColorScheme(writer, node, color) {
    color_writer_1.writeColorScheme(writer, node, color);
}
function pixel2EMU(val) {
    return excel_style_1.UnitHelper.pixelToEMU(val);
}
function getMaxIDFromChildren(shapes, ids) {
    shapes.forEach(function (item) {
        ids.push((item.nvSpPr || item.nvCxnSpPr || item.nvGrpSpPr || item.nvPicPr).cNvPr.id);
        if (item.nvGrpSpPr) {
            getMaxIDFromChildren(item.sp, ids);
        }
    });
}
function getMaxID(shapes) {
    var ids = [];
    shapes.forEach(function (item) {
        if (item.sp) {
            ids.push(item.sp.nvSpPr.cNvPr.id);
        }
        else if (item.cxnSp) {
            ids.push(item.cxnSp.nvCxnSpPr.cNvPr.id);
        }
        else if (item.grpSp) {
            var grpSp = item.grpSp;
            ids.push(grpSp.nvGrpSpPr.cNvPr.id);
            getMaxIDFromChildren(grpSp.sp, ids);
        }
    });
    return Math.max.apply(null, ids);
}
function writeDrawing(model, drawingObjects, drawingFile) {
    var writer = new xml_writer_1.XmlWriter();
    writer._id = 1;
    writer.writeDocument(true);
    writer.currentFile = drawingFile;
    writer.writeElement('xdr:wsDr', function () {
        writer.writeAttributeString('xmlns:xdr', _getXFileConstants()._drawingNameSpace);
        writer.writeAttributeString('xmlns:a', _getXFileConstants()._drawingNameSpace2);
    }, function () {
        var shapes = drawingObjects.shapes, hasShapes;
        if (shapes && shapes.length) {
            hasShapes = true;
            var maxId = getMaxID(shapes);
            writer._id = maxId + 1;
        }
        var pictures = drawingObjects.pictures;
        if (pictures && pictures.length) {
            writePictures(writer, pictures);
        }
        var slicers = drawingObjects.slicers;
        if (slicers && slicers.length) {
            slicer_writer_1.writeSlicerDrawings(writer, slicers, writeAnchorPoint);
        }
        var charts = drawingObjects.charts;
        if (charts && charts.length) {
            writeChartCellAnchorInfo(writer, charts);
        }
        if (hasShapes) {
            writeShapes(writer, shapes);
        }
    });
    return writer.getXmlString();
}
exports.writeDrawing = writeDrawing;
function preprocessChartWriter(charts) {
    var chartDrawingInfo = {
        AnchorBaseList: []
    };
    charts.forEach(function (chartInfo) {
        if (!chartInfo.graphicFrame) {
            chartInfo.graphicFrame = {};
        }
        chartInfo.graphicFrame.graphic = {
            graphicData: {
                chart: {
                    id: chartInfo.chartId,
                    typeName: 'chartSpace'
                }
            }
        };
        chartDrawingInfo.AnchorBaseList.push(chartInfo);
    });
    return chartDrawingInfo;
}
function writeChartCellAnchorInfo(writer, charts) {
    var chartDrawingInfo = preprocessChartWriter(charts);
    chartDrawingInfo.AnchorBaseList.forEach(function (item) {
        if (item.anchorType === 1) {
            chart_writer_1.DrawingWriter.WriteCT_OneCellAnchor(writer, "xdr", "oneCellAnchor", item);
        }
        else if (item.anchorType === 0) {
            chart_writer_1.DrawingWriter.WriteCT_TwoCellAnchor(writer, "xdr", "twoCellAnchor", item);
        }
        else if (item.anchorType === 2) {
            chart_writer_1.DrawingWriter.WriteCT_AbsoluteAnchor(writer, "xdr", "absoluteAnchor", item);
        }
    });
}
function writeShapes(writer, shapes) {
    shapes.forEach(function (item) {
        if (item.pic && item.pic.cameraTool === true) {
            item.AlternateContent = chart_writer_1.DrawingWriter.mc;
            chart_writer_1.DrawingWriter.WriteCT_AlternateContent(writer, "mc", "AlternateContent", item);
        }
        else if (item.anchorType === 1) {
            chart_writer_1.DrawingWriter.WriteCT_OneCellAnchor(writer, "xdr", "oneCellAnchor", item);
        }
        else if (item.anchorType === 0) {
            chart_writer_1.DrawingWriter.WriteCT_TwoCellAnchor(writer, "xdr", "twoCellAnchor", item);
        }
        else if (item.anchorType === 2) {
            chart_writer_1.DrawingWriter.WriteCT_AbsoluteAnchor(writer, "xdr", "absoluteAnchor", item);
        }
    });
}
function writePictures(writer, pictures) {
    pictures.forEach(function (picture) {
        writeTwoCellAnchor(writer, picture);
    });
}
function writeTwoCellAnchor(writer, picture) {
    var twoCellAnchor = picture && picture.twoCellAnchor;
    if (twoCellAnchor) {
        writer.writeElement('xdr:twoCellAnchor', function () {
            var editAs = twoCellAnchor.editAs;
            if (editAs) {
                writer.writeAttributeString("editAs", chart_model_1.Charts.ST_EditAs[editAs]);
            }
        }, function () {
            writeAnchorPoint(writer, 'xdr:from', twoCellAnchor.startPoint);
            writeAnchorPoint(writer, 'xdr:to', twoCellAnchor.endPoint);
            writePicture(writer, picture);
            writeClientData(writer, picture);
        });
    }
}
function writeAnchorPoint(writer, name, anchorPoint) {
    writer.writeElement(name, function () {
        writer.writeElementString('xdr:col', anchorPoint.col);
        writer.writeElementString('xdr:colOff', pixel2EMU(anchorPoint.colOffset));
        writer.writeElementString('xdr:row', anchorPoint.row);
        writer.writeElementString('xdr:rowOff', pixel2EMU(anchorPoint.rowOffset));
    });
}
function writePicture(writer, picture) {
    writer.writeElement('xdr:pic', function () {
        writer.writeElement('xdr:nvPicPr', function () {
            writer.writeLeafElement('xdr:cNvPr', function () {
                writer.writeAttributeString('id', writer._id++);
                writer.writeAttributeString('name', picture.name);
                if (picture.descr) {
                    writer.writeAttributeString("descr", picture.descr);
                }
                if (picture.hidden) {
                    writer.writeAttributeString('hidden', '1');
                }
            });
            writer.writeElement('xdr:cNvPicPr', function () {
                writer.writeLeafElement('a:picLocks', function () {
                    writer.writeAttributeString('noChangeAspect', '1');
                });
            });
        });
        writer.writeElement('xdr:blipFill', function () {
            if (picture.imageType === "svg+xml") {
                writer.writeElement('a:blip', function () {
                    writer.writeAttributeString('xmlns:r', _getXFileConstants()._relationShipNameSpace);
                }, function () {
                    writer.writeElement('a:extLst', function () {
                        writer.writeElement('a:ext', function () {
                            writer.writeAttributeString('uri', '{96DAC541-7B7A-43D3-8B79-37D633B846F1}');
                        }, function () {
                            writer.writeLeafElement('asvg:svgBlip', function () {
                                writer.writeAttributeString('xmlns:asvg', _getXFileConstants()._asvg);
                                writer.writeAttributeString('r:embed', picture.rid);
                            });
                        });
                    });
                });
            }
            else {
                writer.writeElement('a:blip', function () {
                    writer.writeAttributeString('xmlns:r', _getXFileConstants()._relationShipNameSpace);
                    writer.writeAttributeString('r:embed', picture.rid);
                    writer.writeAttributeString('cstate', 'print');
                }, function () {
                    writer.writeElement('a:extLst', function () {
                        writer.writeElement('a:ext', function () {
                            writer.writeAttributeString('uri', '{28A0092B-C50C-407E-A947-70E740481C1C}');
                        }, function () {
                            writer.writeLeafElement('a14:useLocalDpi', function () {
                                writer.writeAttributeString('xmlns:a14', _getXFileConstants()._a14);
                                writer.writeAttributeString('val', '0');
                            });
                        });
                    });
                });
            }
            var srcRect = picture.srcRect;
            if (srcRect) {
                chart_writer_1.DrawingWriter.WriteCT_RelativeRect(writer, 'a', 'srcRect', srcRect);
            }
            writer.writeElement('a:stretch', function () {
                if (!srcRect) {
                    writer.writeLeafElement('a:fillRect');
                }
            });
        });
        writeShapeProperties(writer, picture);
    });
}
function writeShapeProperties(writer, picture) {
    writer.writeElement('xdr:spPr', function () {
        writer.writeElement('a:xfrm', function () {
            if (picture.rot) {
                writer.writeAttributeString('rot', chart_writer_1.DrawingWriter.getRotationData(picture.rot));
            }
        }, function () {
            writer.writeLeafElement('a:off', function () {
                writer.writeAttributeString('x', '0');
                writer.writeAttributeString('y', '0');
            });
            writer.writeLeafElement('a:ext', function () {
                writer.writeAttributeString('cx', '0');
                writer.writeAttributeString('cy', '0');
            });
        });
        writer.writeElement('a:prstGeom', function () {
            writer.writeAttributeString('prst', 'rect');
        }, function () {
            writer.writeLeafElement('a:avLst');
        });
        var fillColor = picture.fillColor;
        if (fillColor) {
            _writeColorScheme(writer, 'a:solidFill', fillColor);
        }
        var lineBorder = picture.lineBorder, width = lineBorder.width, color = lineBorder.color, style = lineBorder.style, isNoFill = lineBorder.noFill;
        writer.writeElement('a:ln', function () {
            if (width !== null && width !== undefined) {
                writer.writeAttributeString('w', pixel2EMU(width));
            }
            if (style === 'dbl') {
                writer.writeAttributeString('cmpd', 'dbl');
            }
        }, function () {
            if (isNoFill) {
                writer.writeLeafElement('a:noFill');
            }
            else {
                _writeColorScheme(writer, 'a:solidFill', color);
            }
            if (style !== 'dbl') {
                writer.writeLeafElement('a:prstDash', function () {
                    writer.writeAttributeString('val', style);
                });
            }
        });
    });
}
function writeClientData(writer, picture) {
    writer.writeLeafElement('xdr:clientData', function () {
        if (picture.locked === false) {
            writer.writeAttributeString('fLocksWithSheet', '0');
        }
    });
}


/***/ }),

/***/ "./src/xlsx-io/writer/metadata-writer.ts":
/*!***********************************************!*\
  !*** ./src/xlsx-io/writer/metadata-writer.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
function addNamespaces(lines, withDynamicArray, withSpillError) {
    if (withSpillError) {
        lines.push('\txmlns:xlrd="' + excel_types_1.XFileConstants._richDataNameSpace + '"');
    }
    if (withDynamicArray) {
        lines.push('\txmlns:xda="' + excel_types_1.XFileConstants._dynamicArrayNameSpace + '">');
    }
}
var MetadataType_Common_Attributes = 'minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1"';
function addMetaDataTypes(lines, withDynamicArray, withSpillError) {
    var count = (withDynamicArray ? 1 : 0) + (withSpillError ? 1 : 0);
    lines.push('\t<metadataTypes count="' + count + '">');
    if (withDynamicArray) {
        lines.push('\t\t<metadataType name="XLDAPR" ' + MetadataType_Common_Attributes + ' cellMeta="1"/>');
    }
    if (withSpillError) {
        lines.push('\t\t<metadataType name="XLRICHVALUE" ' + MetadataType_Common_Attributes + '/>');
    }
    lines.push('\t</metadataTypes>');
}
function addFutureMetadatas(lines, withDynamicArray, withSpillError, withPropagatedError) {
    if (withDynamicArray) {
        lines.push('\t<futureMetadata name="XLDAPR" count="1"> <bk> <extLst> <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}"> <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/> </ext> </extLst> </bk> </futureMetadata>');
    }
    if (withSpillError) {
        var s = '<futureMetadata name="XLRICHVALUE" count="' + (withPropagatedError ? 2 : 1) + '"> <bk> <extLst> <ext uri="{3e2802c4-a4d2-4d8b-9148-e3be6c30e623}"> <xlrd:rvb i="0"/> </ext> </extLst> </bk>';
        if (withPropagatedError) {
            s += ' <bk> <extLst> <ext uri="{3e2802c4-a4d2-4d8b-9148-e3be6c30e623}"> <xlrd:rvb i="1"/> </ext> </extLst> </bk>';
        }
        lines.push('\t' + s + ' </futureMetadata>');
    }
}
function getMetadataContent(dynamicArrayLevel) {
    var lines = [];
    var withDynamicArray = dynamicArrayLevel > 0, withSpillError = dynamicArrayLevel > 1, withPropagatedError = dynamicArrayLevel > 2;
    lines.push('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>');
    lines.push('<metadata');
    lines.push('\txmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"');
    addNamespaces(lines, withDynamicArray, withSpillError);
    addMetaDataTypes(lines, withDynamicArray, withSpillError);
    addFutureMetadatas(lines, withDynamicArray, withSpillError, withPropagatedError);
    if (withDynamicArray) {
        lines.push('\t<cellMetadata count="1"> <bk> <rc t="1" v="0"/> </bk> </cellMetadata>');
    }
    if (withSpillError) {
        lines.push('\t<valueMetadata count="' + (withPropagatedError ? 2 : 1) + '"> <bk> <rc t="2" v="0"/> </bk>' + (withPropagatedError ? '<bk> <rc t="2" v="1"/> </bk>' : '') + ' </valueMetadata>');
    }
    lines.push('</metadata>');
    return lines.join('\r\n');
}
exports.getMetadataContent = getMetadataContent;


/***/ }),

/***/ "./src/xlsx-io/writer/pivot-writer.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/writer/pivot-writer.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var datetime_helper_1 = __webpack_require__(/*! ./../../datamodel/datetime-helper */ "./src/datamodel/datetime-helper.ts");
var autofilter_writer_1 = __webpack_require__(/*! ./autofilter-writer */ "./src/xlsx-io/writer/autofilter-writer.ts");
var captionCompareTypeExcel = [["captionEqual",
        "captionNotEqual",
        "captionBeginsWith",
        "captionNotBeginsWith",
        "captionEndsWith",
        "captionNotEndsWith",
        "captionContains",
        "captionNotContains",
        "captionGreaterThan",
        "captionGreaterThanOrEqual",
        "captionLessThan",
        "captionLessThanOrEqual",
        "captionBetween",
        "captionNotBetween"],
    [
        "dateEqual",
        "dateNotEqual",
        "dateOlderThan",
        "dateOlderThanOrEqual",
        "dateNewerThan",
        "dateNewerThanOrEqual",
        "dateBetween",
        "dateNotBetween",
        "today",
        "yesterday",
        "tomorrow",
        ,
        "thisMonth",
        "lastMonth",
        "nextMonth",
        "thisWeek",
        "lastWeek",
        "nextWeek",
        "nextQuarter",
        "thisQuarter",
        "lastQuarter",
        "nextYear",
        "thisYear",
        "lastYear",
        "Q1",
        "Q2",
        "Q3",
        "Q4",
        "M1",
        "M2",
        "M3",
        "M4",
        "M5",
        "M6",
        "M7",
        "M8",
        "M9",
        "M10",
        "M11",
        "M12",
        "yearToDate",
    ],
    ["valueEqual",
        "valueNotEqual",
        "valueGreaterThan",
        "valueGreaterThanOrEqual",
        "valueLessThan",
        "valueLessThanOrEqual",
        "valueBetween",
        "valueNotBetwee"],
    [
        "count",
        "percent",
        "sum",
    ]];
var xmlEncode = common_1.Util._xmlEncode, _getDateString = common_1.Util._getDateString;
function writePivotCacheDefinition(pivotCache) {
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('pivotCacheDefinition', function () {
        writer.writeAttributeString("xmlns", excel_types_1.XFileConstants._workbookNameSpace);
        writer.writeAttributeString("xmlns:r", excel_types_1.XFileConstants._relationShipNameSpace);
        writer.writeAttributeString("xmlns:mc", excel_types_1.XFileConstants._markupCompatibility);
        writer.writeAttributeString("mc:Ignorable", excel_types_1.XFileConstants._ignorableXR);
        writer.writeAttributeString("xmlns:xr", excel_types_1.XFileConstants._revision);
        writer.writeAttributeString("r:id", "rId1");
        if (pivotCache.saveData === false) {
            writer.writeAttributeString("saveData", "0");
        }
        if (!common_1.isNullOrUndefined(pivotCache.refreshedBy)) {
            writer.writeAttributeString("refreshedBy", pivotCache.refreshedBy);
        }
        if (!common_1.isNullOrUndefined(pivotCache.refreshedDate)) {
            writer.writeAttributeString("refreshedDate", datetime_helper_1.DateTimeHelper._toOADate(pivotCache.refreshedDate));
        }
        if (pivotCache.backgroundQuery) {
            writer.writeAttributeString("backgroundQuery", "1");
        }
        if (!common_1.isNullOrUndefined(pivotCache.createdVersion)) {
            writer.writeAttributeString("createdVersion", pivotCache.createdVersion);
        }
        else {
            writer.writeAttributeString("createdVersion", "7");
        }
        if (!common_1.isNullOrUndefined(pivotCache.refreshedVersion)) {
            writer.writeAttributeString("refreshedVersion", pivotCache.refreshedVersion);
        }
        else {
            writer.writeAttributeString("refreshedVersion", "7");
        }
        if (pivotCache.enableRefresh === false) {
            writer.writeAttributeString("enableRefresh", "0");
        }
        if (pivotCache.invalid) {
            writer.writeAttributeString("invalid", "1");
        }
        if (pivotCache.minRefreshableVersion > 0 && pivotCache.minRefreshableVersion <= pivotCache.createdVersion) {
            writer.writeAttributeString("minRefreshableVersion", pivotCache.minRefreshableVersion);
        }
        if (pivotCache.missingItemsLimit > 0) {
            writer.writeAttributeString("missingItemsLimit", pivotCache.missingItemsLimit);
        }
        if (pivotCache.optimizeMemory) {
            writer.writeAttributeString("optimizeMemory", "1");
        }
        if (!common_1.isNullOrUndefined(pivotCache.recordCount)) {
            writer.writeAttributeString("recordCount", pivotCache.recordCount);
        }
        writer.writeAttributeString("refreshOnLoad", "1");
        if (pivotCache.supportSubquery) {
            writer.writeAttributeString("supportSubquery", "1");
        }
        if (pivotCache.supportAdvancedDrill) {
            writer.writeAttributeString("supportAdvancedDrill", "1");
        }
        if (pivotCache.tupleCache) {
            writer.writeAttributeString("tupleCache", "1");
        }
        if (pivotCache.upgradeOnRefresh) {
            writer.writeAttributeString("upgradeOnRefresh", "1");
        }
    }, function () {
        writeCacheSource(writer, pivotCache);
        writePivotCacheDefinitionFields(writer, pivotCache.fields);
        if (pivotCache.cacheHierarchies && pivotCache.cacheHierarchies.length > 0) {
            writePivotCacheHierarchies(writer, pivotCache);
        }
        if (pivotCache.KPIs && pivotCache.KPIs.length > 0) {
            writePivotCachePCDKPIs(writer, pivotCache);
        }
        if (!common_1.isNullOrUndefined(pivotCache.pivotTupleCache)) {
            writePivotCacheTupleCache(writer, pivotCache.pivotTupleCache);
        }
        if (pivotCache.calculatedItems && pivotCache.calculatedItems.length > 0) {
            writePivotCalculatedItems(writer, pivotCache);
        }
        if (pivotCache.calculatedMembers && pivotCache.calculatedMembers.length > 0) {
            writePivotCalculatedMembers(writer, pivotCache);
        }
        if (pivotCache.dimensions && pivotCache.dimensions.length > 0) {
            writePivotCacheDimensions(writer, pivotCache);
        }
        if (pivotCache.measureGroups && pivotCache.measureGroups.length > 0) {
            writePivotCacheMeasureGroups(writer, pivotCache);
        }
        if (pivotCache.measureDimensionMaps && pivotCache.measureDimensionMaps.length > 0) {
            writePivotCacheMeasureDimensionMaps(writer, pivotCache);
        }
        writeExtLst(writer);
    });
    return writer.getXmlString();
}
exports.writePivotCacheDefinition = writePivotCacheDefinition;
function writeExtLst(writer) {
    writer.writeElement('extLst', function () {
    }, function () {
        writer.writeElement('ext', function () {
            writer.writeAttributeString('xmlns:x14', excel_types_1.XFileConstants._extensionListNameSpace);
        }, function () {
            writer.writeLeafElement('x14:pivotCacheDefinition');
        });
    });
}
function writeCacheSource(writer, pivotCache) {
    writer.writeElement("cacheSource", function () {
        writer.writeAttributeString("type", pivotCache.sourceType);
    }, function () {
        if (pivotCache.sourceType === "worksheet") {
            writer.writeLeafElement("worksheetSource", function () {
                if (pivotCache.sourceName) {
                    writer.writeAttributeString("name", pivotCache.sourceName);
                }
                if (pivotCache.ref) {
                    writer.writeAttributeString("ref", pivotCache.ref);
                }
                if (pivotCache.sheet) {
                    writer.writeAttributeString("sheet", pivotCache.sheet);
                }
            });
        }
    });
}
function writePivotCacheDefinitionFields(writer, fields) {
    writer.writeElement("cacheFields", function () {
        writer.writeAttributeString("count", fields.length);
    }, function () {
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            writePivotCacheDefinitionField(writer, field);
        }
    });
}
function writePivotCacheDefinitionField(writer, field) {
    writer.writeElement("cacheField", function () {
        if (!common_1.isNullOrUndefined(field.name)) {
            writer.writeAttributeString("name", xmlEncode(field.name));
        }
        if (!common_1.isNullOrUndefined(field.caption)) {
            writer.writeAttributeString("caption", field.caption);
        }
        if (!common_1.isNullOrUndefined(field.formula)) {
            writer.writeAttributeString("formula", field.formula);
        }
        if (!common_1.isNullOrUndefined(field.numFmtId)) {
            writer.writeAttributeString("numFmtId", field.numFmtId);
        }
        if (field.databaseField === false) {
            writer.writeAttributeString("databaseField", "0");
        }
        if (field.hierarchy > 0) {
            writer.writeAttributeString("hierarchy", field.hierarchy);
        }
        if (field.level > 0) {
            writer.writeAttributeString("level", field.level);
        }
        if (field.mappingCount > 0) {
            writer.writeAttributeString("mappingCount", field.mappingCount);
        }
        if (!common_1.isNullOrUndefined(field.memberPropertyField)) {
            writer.writeAttributeString("memberPropertyField", "1");
        }
        if (!common_1.isNullOrUndefined(field.propertyName)) {
            writer.writeAttributeString("propertyName", field.propertyName);
        }
        if (!common_1.isNullOrUndefined(field.serverField)) {
            writer.writeAttributeString("serverField", "1");
        }
        if (field.sqlType > 0) {
            writer.writeAttributeString("sqlType", field.sqlType);
        }
        if (field.uniqueList === false) {
            writer.writeAttributeString("uniqueList", "0");
        }
    }, function () {
        if (field.databaseField !== false) {
            if (field.entities && field.entities.length > 0) {
                writer.writeElement("sharedItems", function () {
                    writeSharedItemsAttr(writer, field);
                }, function () {
                    writeSharedItemsContent(writer, field);
                });
            }
            else {
                writer.writeLeafElement("sharedItems", function () {
                    writeSharedItemsAttr(writer, field);
                });
            }
        }
        writePivotCacheDefinitionFieldGroup(writer, field.fieldGroup);
    });
}
function writeSharedItemsAttr(writer, field) {
    if (field.containsSemiMixedTypes === false) {
        writer.writeAttributeString("containsSemiMixedTypes", "0");
    }
    if (field.containsNonDate === false) {
        writer.writeAttributeString("containsNonDate", "0");
    }
    if (field.containsDate) {
        writer.writeAttributeString("containsDate", "1");
    }
    if (field.containsString === false) {
        writer.writeAttributeString("containsString", "0");
    }
    if (field.containsBlank) {
        writer.writeAttributeString("containsBlank", "1");
    }
    if (field.containsMixedTypes) {
        writer.writeAttributeString("containsMixedTypes", "1");
    }
    if (field.containsNumber && !field.containsDate) {
        writer.writeAttributeString("containsNumber", "1");
    }
    if (field.containsInteger && !field.containsDate) {
        writer.writeAttributeString("containsInteger", "1");
    }
    if (field.isShared && field.longText) {
        writer.writeAttributeString("longText", "0");
    }
    if (field.containsDate) {
        writer.writeAttributeString("minDate", _getDateString(new Date(field.minDate)));
        writer.writeAttributeString("maxDate", _getDateString(new Date(field.maxDate)));
    }
    else {
        if (field.containsNumber || field.containsInteger) {
            writer.writeAttributeString("minValue", field.minValue.toString());
            writer.writeAttributeString("maxValue", field.maxValue.toString());
        }
    }
    if (field.isShared) {
        writer.writeAttributeString("minDate", _getDateString(new Date(field.minDate)));
        writer.writeAttributeString("maxDate", _getDateString(new Date(field.maxDate)));
    }
    if (field.entities && field.entities.length > 0) {
        writer.writeAttributeString("count", field.entities.length);
    }
}
function writeSharedItemsContent(writer, field) {
    var i;
    for (i = 0; i < field.entities.length; i++) {
        var entity = field.entities[i];
        writePivotCacheDefinitionSharedItem(writer, entity);
    }
}
function writePivotCacheDefinitionSharedItem(writer, sharedItem) {
    var valueString = null;
    switch (sharedItem.type) {
        case excel_types_1.PivotSharedItemType.B:
            writer.writeLeafElement("b", function () {
                if (!common_1.isNullOrUndefined(sharedItem.value)) {
                    valueString = sharedItem.value ? "1" : "0";
                    writePivotCacheDefinitionSharedItemAttribute(writer, sharedItem, valueString);
                }
            });
            break;
        case excel_types_1.PivotSharedItemType.D:
            writer.writeLeafElement("d", function () {
                if (!common_1.isNullOrUndefined(sharedItem.value)) {
                    valueString = _getDateString(new Date(sharedItem.value));
                    writePivotCacheDefinitionSharedItemAttribute(writer, sharedItem, valueString);
                }
            });
            break;
        case excel_types_1.PivotSharedItemType.E:
            writer.writeLeafElement("e", function () {
                if (!common_1.isNullOrUndefined(sharedItem.value)) {
                    valueString = sharedItem.value;
                    writePivotCacheDefinitionSharedItemAttribute(writer, sharedItem, valueString);
                }
            });
            break;
        case excel_types_1.PivotSharedItemType.M:
            writer.writeLeafElement("m");
            break;
        case excel_types_1.PivotSharedItemType.N:
            writer.writeLeafElement("n", function () {
                if (!common_1.isNullOrUndefined(sharedItem.value)) {
                    valueString = sharedItem.value;
                    writePivotCacheDefinitionSharedItemAttribute(writer, sharedItem, valueString);
                }
            });
            break;
        case excel_types_1.PivotSharedItemType.S:
            writer.writeLeafElement("s", function () {
                if (!common_1.isNullOrUndefined(sharedItem.value)) {
                    valueString = sharedItem.value;
                    writePivotCacheDefinitionSharedItemAttribute(writer, sharedItem, valueString);
                }
            });
            break;
        case excel_types_1.PivotSharedItemType.X:
            writer.writeLeafElement("x", function () {
                if (!common_1.isNullOrUndefined(sharedItem.value)) {
                    valueString = sharedItem.value;
                    writePivotCacheDefinitionSharedItemAttribute(writer, sharedItem, valueString);
                }
            });
            break;
    }
}
function writePivotCacheDefinitionSharedItemAttribute(writer, sharedItem, valueString) {
    if (!common_1.isNullOrUndefined(valueString)) {
        writer.writeAttributeString("v", xmlEncode(valueString));
    }
    if (!common_1.isNullOrUndefined(sharedItem.caption)) {
        writer.writeAttributeString("c", sharedItem.caption);
    }
    if (sharedItem.propertyCount > 0) {
        writer.writeAttributeString("cp", sharedItem.propertyCount);
    }
    if (!common_1.isNullOrUndefined(sharedItem.isCalculatedItem)) {
        writer.writeAttributeString("f", "1");
    }
    if (!common_1.isNullOrUndefined(sharedItem.isUnusedItem)) {
        writer.writeAttributeString("u", "1");
    }
    if (!common_1.isNullOrUndefined(sharedItem.isBold)) {
        writer.writeAttributeString("b", "1");
    }
    if (!common_1.isNullOrUndefined(sharedItem.backgroundColor)) {
        writer.writeAttributeString("bc", sharedItem.backgroundColor);
    }
    if (!common_1.isNullOrUndefined(sharedItem.foregroundColor)) {
        writer.writeAttributeString("fc", sharedItem.foregroundColor);
    }
    if (!common_1.isNullOrUndefined(sharedItem.isItalic)) {
        writer.writeAttributeString("i", "1");
    }
    if (sharedItem.formatIndex > 0) {
        writer.writeAttributeString("in", sharedItem.formatIndex);
    }
    if (!common_1.isNullOrUndefined(sharedItem.isStrikethrough)) {
        writer.writeAttributeString("st", "1");
    }
    if (!common_1.isNullOrUndefined(sharedItem.isUnderline)) {
        writer.writeAttributeString("un", "1");
    }
}
function writePivotCacheDefinitionFieldGroup(writer, fieldGroup) {
    if (!common_1.isNullOrUndefined(fieldGroup)) {
        writer.writeElement("fieldGroup", function () {
            if (fieldGroup.parent > 0) {
                writer.writeAttributeString("par", fieldGroup.parent);
            }
            if (fieldGroup.base >= 0) {
                writer.writeAttributeString("base", fieldGroup.base);
            }
        }, function () {
            if (fieldGroup.hasRangeGroup) {
                writer.writeLeafElement("rangePr", function () {
                    if (fieldGroup.autoStart === false) {
                        writer.writeAttributeString("autoStart", "0");
                    }
                    if (fieldGroup.autoEnd === false) {
                        writer.writeAttributeString("autoEnd", "0");
                    }
                    if (!common_1.isNullOrUndefined(fieldGroup.groupInterval)) {
                        writer.writeAttributeString("groupInterval", fieldGroup.groupInterval);
                    }
                    if (!common_1.isNullOrUndefined(fieldGroup.groupBy)) {
                        writer.writeAttributeString("groupBy", fieldGroup.groupBy);
                    }
                    if (!common_1.isNullOrUndefined(fieldGroup.startNum)) {
                        writer.writeAttributeString("startNum", fieldGroup.startNum);
                    }
                    if (!common_1.isNullOrUndefined(fieldGroup.endNum)) {
                        writer.writeAttributeString("endNum", fieldGroup.endNum);
                    }
                    if (!common_1.isNullOrUndefined(fieldGroup.startDate)) {
                        writer.writeAttributeString("startDate", _getDateString(new Date(fieldGroup.startDate)));
                    }
                    if (!common_1.isNullOrUndefined(fieldGroup.endDate)) {
                        writer.writeAttributeString("endDate", _getDateString(new Date(fieldGroup.endDate)));
                    }
                });
            }
            var discreteGroup = fieldGroup.discreteGroup;
            if (discreteGroup && discreteGroup.length > 0) {
                writer.writeElement('discretePr', function () {
                    writer.writeAttributeString('count', discreteGroup.length);
                }, function () {
                    var _loop_1 = function (i) {
                        writer.writeLeafElement('x', function () {
                            writer.writeAttributeString("v", discreteGroup[i]);
                        });
                    };
                    for (var i = 0; i < discreteGroup.length; i++) {
                        _loop_1(i);
                    }
                });
            }
            var groupItems = fieldGroup.groupItems;
            if (groupItems && groupItems.length > 0) {
                writer.writeElement('groupItems', function () {
                    writer.writeAttributeString('count', groupItems.length);
                }, function () {
                    for (var i = 0; i < groupItems.length; i++) {
                        writePivotCacheDefinitionSharedItem(writer, groupItems[i]);
                    }
                });
            }
        });
    }
}
function writePivotCacheHierarchies(writer, pivotCache) {
    if (pivotCache.cacheHierarchies && pivotCache.cacheHierarchies.length > 0) {
        writer.writeElement("cacheHierarchies", function () {
            writer.writeAttributeString("count", pivotCache.cacheHierarchies.length);
        }, function () {
            for (var i = 0; i < pivotCache.cacheHierarchies.length; i++) {
                writePivotCacheDefinitionHierarchy(writer, pivotCache.cacheHierarchies[i]);
            }
        });
    }
}
function writePivotCacheDefinitionHierarchy(writer, cacheHierarchy) {
    writer.writeElement("cacheHierarchy", function () {
        if (!common_1.isNullOrUndefined(cacheHierarchy.uniqueName)) {
            writer.writeAttributeString("uniqueName", cacheHierarchy.uniqueName);
        }
        if (!common_1.isNullOrUndefined(cacheHierarchy.caption)) {
            writer.writeAttributeString("caption", cacheHierarchy.caption);
        }
        if (cacheHierarchy.measure) {
            writer.writeAttributeString("measure", "1");
        }
        if (cacheHierarchy.set) {
            writer.writeAttributeString("set", "1");
        }
        if (cacheHierarchy.parentSet >= 0) {
            writer.writeAttributeString("parentSet", cacheHierarchy.parentSet);
        }
        if (cacheHierarchy.iconSet > 0) {
            writer.writeAttributeString("iconSet", cacheHierarchy.iconSet);
        }
        if (cacheHierarchy.attribute) {
            writer.writeAttributeString("attribute", "1");
        }
        if (cacheHierarchy.time) {
            writer.writeAttributeString("time", "1");
        }
        if (cacheHierarchy.keyAttribute) {
            writer.writeAttributeString("keyAttribute", "1");
        }
        if (!common_1.isNullOrUndefined(cacheHierarchy.defaultMemberUniqueName)) {
            writer.writeAttributeString("defaultMemberUniqueName", cacheHierarchy.defaultMemberUniqueName);
        }
        if (!common_1.isNullOrUndefined(cacheHierarchy.allUniqueName)) {
            writer.writeAttributeString("allUniqueName", cacheHierarchy.allUniqueName);
        }
        if (!common_1.isNullOrUndefined(cacheHierarchy.allCaption)) {
            writer.writeAttributeString("allCaption", cacheHierarchy.allCaption);
        }
        if (!common_1.isNullOrUndefined(cacheHierarchy.dimensionUniqueName)) {
            writer.writeAttributeString("dimensionUniqueName", cacheHierarchy.dimensionUniqueName);
        }
        if (!common_1.isNullOrUndefined(cacheHierarchy.displayFolder)) {
            writer.writeAttributeString("displayFolder", cacheHierarchy.displayFolder);
        }
        if (!common_1.isNullOrUndefined(cacheHierarchy.measureGroup)) {
            writer.writeAttributeString("measureGroup", cacheHierarchy.measureGroup);
        }
        if (cacheHierarchy.measures) {
            writer.writeAttributeString("measures", "1");
        }
        if (cacheHierarchy.count >= 0) {
            writer.writeAttributeString("count", cacheHierarchy.count);
        }
        if (cacheHierarchy.oneField) {
            writer.writeAttributeString("oneField", "1");
        }
        if (cacheHierarchy.memberValueDatatype > 0) {
            writer.writeAttributeString("memberValueDatatype", cacheHierarchy.memberValueDatatype);
        }
        if (!cacheHierarchy.unbalanced) {
            writer.writeAttributeString("unbalanced", "0");
        }
        if (!cacheHierarchy.unbalancedGroup) {
            writer.writeAttributeString("unbalancedGroup", "0");
        }
        if (cacheHierarchy.hidden) {
            writer.writeAttributeString("hidden", "1");
        }
    }, function () {
        if (cacheHierarchy.fieldsUsage.length > 0) {
            writer.writeElement("fieldsUsage", function () {
                writer.writeAttributeString("count", cacheHierarchy.fieldsUsage.length);
            }, function () {
                for (var i = 0; i < cacheHierarchy.fieldsUsage.length; i++) {
                    writeFieldUsage(writer, cacheHierarchy.fieldsUsage[i]);
                }
            });
        }
        if (cacheHierarchy.groupLevels.length > 0) {
            writer.writeElement("groupLevels", function () {
                writer.writeAttributeString("count", cacheHierarchy.groupLevels.length);
            }, function () {
                for (var i = 0; i < cacheHierarchy.groupLevels.length; i++) {
                    writeGroupLevel(writer, cacheHierarchy.groupLevels[i]);
                }
            });
        }
    });
}
function writeFieldUsage(writer, fieldUsage) {
    writer.writeElement("fieldUsage", function () {
        writer.writeAttributeString("x", fieldUsage);
    });
}
function writeGroupLevel(writer, groupLevel) {
    writer.writeElement("groupLevel", function () {
        if (!common_1.isNullOrUndefined(groupLevel.uniqueName)) {
            writer.writeAttributeString("uniqueName", groupLevel.uniqueName);
        }
        if (!common_1.isNullOrUndefined(groupLevel.caption)) {
            writer.writeAttributeString("caption", groupLevel.caption);
        }
        if (groupLevel.user) {
            writer.writeAttributeString("user", "1");
        }
        if (groupLevel.customRollUp) {
            writer.writeAttributeString("customRollUp", "1");
        }
    }, function () {
        if (groupLevel.groups.length > 0) {
            writer.writeElement("groups", function () {
                writer.writeAttributeString("count", groupLevel.groups.length);
            }, function () {
                for (var i = 0; i < groupLevel.groups.length; i++) {
                    var group = groupLevel.groups[i];
                    writeGroup(writer, group);
                }
            });
        }
    });
}
function writeGroup(writer, group) {
    writer.writeElement('group', function () {
        if (!common_1.isNullOrUndefined(group.name)) {
            writer.writeAttributeString("name", xmlEncode(group.Name));
        }
        if (!common_1.isNullOrUndefined(group.uniqueName)) {
            writer.writeAttributeString("uniqueName", group.uniqueName);
        }
        if (!common_1.isNullOrUndefined(group.caption)) {
            writer.writeAttributeString("caption", group.caption);
        }
        if (!common_1.isNullOrUndefined(group.uniqueParent)) {
            writer.writeAttributeString("uniqueParent", group.uniqueParent);
        }
        if (group.id > 0) {
            writer.writeAttributeString("id", group.id);
        }
    }, function () {
        if (group.groupMembers.length > 0) {
            writer.writeElement("groupMembers", function () {
                writer.writeAttributeString("count", group.groupMembers.length);
            }, function () {
                var i = 0;
                for (; i < group.groupMembers.length; i++) {
                    writeGroupMember(writer, group.groupMembers[i]);
                }
            });
        }
    });
}
function writeGroupMember(writer, groupMember) {
    writer.writeLeafElement("groupMember", function () {
        if (!common_1.isNullOrUndefined(groupMember.uniqueName)) {
            writer.writeAttributeString("uniqueName", groupMember.uniqueName);
        }
        if (groupMember.group) {
            writer.writeAttributeString("group", 1);
        }
    });
}
function writePivotCachePCDKPIs(writer, pivotCache) {
    if (pivotCache.KPIs && pivotCache.KPIs.length > 0) {
        writer.writeElement('kpis', function () {
            writer.writeAttributeString('count', pivotCache.KPIs.length);
        }, function () {
            for (var i = 0; i < pivotCache.KPIs.length; i++) {
                var kpi = pivotCache.KPIs[i];
                writePivotCachePCDKPI(writer, kpi);
            }
        });
    }
}
function writePivotCachePCDKPI(writer, kpi) {
    writer.writeLeafElement('kpi', function () {
        if (!common_1.isNullOrUndefined(kpi.uniqueName)) {
            writer.writeAttributeString("uniqueName", kpi.uniqueName);
        }
        if (!common_1.isNullOrUndefined(kpi.caption)) {
            writer.writeAttributeString("caption", kpi.caption);
        }
        if (!common_1.isNullOrUndefined(kpi.displayFolder)) {
            writer.writeAttributeString("displayFolder", kpi.displayFolder);
        }
        if (!common_1.isNullOrUndefined(kpi.measureGroup)) {
            writer.writeAttributeString("measureGroup", kpi.measureGroup);
        }
        if (!common_1.isNullOrUndefined(kpi.parent)) {
            writer.writeAttributeString("parent", kpi.parent);
        }
        if (!common_1.isNullOrUndefined(kpi.value)) {
            writer.writeAttributeString("value", kpi.value);
        }
        if (!common_1.isNullOrUndefined(kpi.goal)) {
            writer.writeAttributeString("goal", kpi.goal);
        }
        if (!common_1.isNullOrUndefined(kpi.status)) {
            writer.writeAttributeString("status", kpi.status);
        }
        if (!common_1.isNullOrUndefined(kpi.trend)) {
            writer.writeAttributeString("trend", kpi.trend);
        }
        if (!common_1.isNullOrUndefined(kpi.weight)) {
            writer.writeAttributeString("weight", kpi.weight);
        }
        if (!common_1.isNullOrUndefined(kpi.time)) {
            writer.writeAttributeString("time", kpi.time);
        }
    });
}
function writePivotCacheTupleCache(writer, pivotCacheTupleCache) {
    writer.writeElement('tupleCache', function () {
    }, function () {
        var i;
        if (pivotCacheTupleCache.entries && pivotCacheTupleCache.entries.length > 0) {
            writer.writeElement('entries', function () {
                writer.writeAttributeString('count', pivotCacheTupleCache.entries.length);
            }, function () {
                for (i = 0; i < pivotCacheTupleCache.entries.length; i++) {
                    writer.writePivotCacheDefinitionSharedItem(writer, pivotCacheTupleCache.entries[i]);
                }
            });
        }
        if (pivotCacheTupleCache.sets && pivotCacheTupleCache.sets.length > 0) {
            writer.writeElement("sets", function () {
                writer.writeAttributeString("count", pivotCacheTupleCache.sets.length);
            }, function () {
                for (i = 0; i < pivotCacheTupleCache.sets.length; i++) {
                    writePivotCacheSet(writer, pivotCacheTupleCache.sets[i]);
                }
            });
        }
        if (pivotCacheTupleCache.queryCache && pivotCacheTupleCache.queryCache.length > 0) {
            writer.writeElement("queryCache", function () {
                writer.writeAttributeString("count", pivotCacheTupleCache.queryCache.length);
            }, function () {
                for (i = 0; i < pivotCacheTupleCache.queryCache.length; i++) {
                    writeQueryCache(writer, pivotCacheTupleCache.queryCache[i]);
                }
            });
        }
        if (pivotCacheTupleCache.serverFormats && pivotCacheTupleCache.serverFormats.length > 0) {
            writer.writeElement("serverFormats", function () {
                writer.writeAttributeString("count", pivotCacheTupleCache.serverFormats.length);
            }, function () {
                for (i = 0; i < pivotCacheTupleCache.serverFormats.length; i++) {
                    writeServerFormat(writer, pivotCacheTupleCache.serverFormats[i]);
                }
            });
        }
    });
}
function writePivotCacheSet(writer, item) {
}
function writeQueryCache(writer, queryCache) {
    writer.writeElement("query", function () {
        if (queryCache.mdx) {
            writer.writeAttributeString("mdx", queryCache.mdx);
        }
    }, function () {
        if (queryCache.tpls && queryCache.tpls.length > 0) {
            writer.writeElement("tpls", function () {
                writer.writeAttributeString("c", queryCache.tpls.length);
            }, function () {
                for (var i = 0; i < queryCache.tpls.length; i++) {
                    writeQueryCacheTuple(writer, queryCache.tpls[i]);
                }
            });
        }
    });
}
function writeQueryCacheTuple(writer, queryCacheTuple) {
    writer.writeElement('tpl', function () {
        if (queryCacheTuple.fld >= 0) {
            writer.writeAttributeString("fld", queryCacheTuple.fld);
        }
        if (queryCacheTuple.hier >= 0) {
            writer.writeAttributeString("hier", queryCacheTuple.hier);
        }
        if (queryCacheTuple.item >= 0) {
            writer.writeAttributeString("item", queryCacheTuple.item);
        }
    });
}
function writeServerFormat(writer, serverFormat) {
    writer.writeLeafElement('serverFormat', function () {
        if (!common_1.isNullOrUndefined(serverFormat.culture)) {
            writer.writeAttributeString("culture", serverFormat.culture);
        }
        if (!common_1.isNullOrUndefined(serverFormat.format)) {
            writer.writeAttributeString("format", serverFormat.format);
        }
    });
}
function writePivotCalculatedItems(writer, pivotCache) {
    var calculatedItems = pivotCache.calculatedItems;
    if (!calculatedItems) {
        return;
    }
    writer.writeElement('calculatedItems', function () {
        writer.writeAttributeString("count", calculatedItems.length);
    }, function () {
        for (var i = 0; i < calculatedItems.length; i++) {
            writePivotCalculatedItem(writer, calculatedItems[i]);
        }
    });
}
function writePivotCalculatedItem(writer, calculatedItem) {
    if (!calculatedItem) {
        return;
    }
    writer.writeElement('calculatedItem', function () {
        if (calculatedItem.field >= 0) {
            writer.writeAttributeString("field", calculatedItem.field);
        }
        if (calculatedItem.formula) {
            writer.writeAttributeString("formula", calculatedItem.formula);
        }
    }, function () {
        if (calculatedItem.pivotArea) {
            writePivotArea(writer, calculatedItem.pivotArea);
        }
    });
}
function writePivotCalculatedMembers(writer, pivotCache) {
    var calculatedMembers = pivotCache.calculatedMembers;
    if (!calculatedMembers) {
        return;
    }
    writer.writeElement('calculatedMembers', function () {
        writer.writeAttributeString("count", calculatedMembers.length);
    }, function () {
        for (var i = 0; i < calculatedMembers.length; i++) {
            writeCalculatedMember(writer, calculatedMembers[i]);
        }
    });
}
function writeCalculatedMember(writer, calculatedMember) {
    writer.writeLeafElement('calculatedMember', function () {
        if (!common_1.isNullOrUndefined(calculatedMember.name)) {
            writer.writeAttributeString("name", xmlEncode(calculatedMember.name));
        }
        if (!common_1.isNullOrUndefined(calculatedMember.mdx)) {
            writer.writeAttributeString("mdx", calculatedMember.mdx);
        }
        if (!common_1.isNullOrUndefined(calculatedMember.memberName)) {
            writer.writeAttributeString("memberName", calculatedMember.memberName);
        }
        if (!common_1.isNullOrUndefined(calculatedMember.hierarchy)) {
            writer.writeAttributeString("hierarchy", calculatedMember.hierarchy);
        }
        if (!common_1.isNullOrUndefined(calculatedMember.parent)) {
            writer.writeAttributeString("parent", calculatedMember.parent);
        }
        if (calculatedMember.solveOrder > 0) {
            writer.writeAttributeString("solveOrder", calculatedMember.solveOrder);
        }
        if (calculatedMember.set) {
            writer.writeAttributeString("set", "1");
        }
    });
}
function writePivotCacheDimensions(writer, pivotCache) {
    if (!pivotCache.dimensions || pivotCache.dimensions.length <= 0) {
        return;
    }
    writer.writeElement('dimensions', function () {
        writer.writeAttributeString('count', pivotCache.dimensions.length);
    }, function () {
        for (var i = 0; i < pivotCache.dimensions.length; i++) {
            writePivotCacheDimension(writer, pivotCache.dimensions[i]);
        }
    });
}
function writePivotCacheDimension(writer, dimension) {
    writer.writeLeafElement('dimension', function () {
        if (dimension.measure) {
            writer.writeAttributeString("measure", "1");
        }
        if (!common_1.isNullOrUndefined(dimension.name)) {
            writer.writeAttributeString("name", xmlEncode(dimension.name));
        }
        if (!common_1.isNullOrUndefined(dimension.uniqueName)) {
            writer.writeAttributeString("uniqueName", dimension.uniqueName);
        }
        if (!common_1.isNullOrUndefined(dimension.caption)) {
            writer.writeAttributeString("caption", dimension.caption);
        }
    });
}
function writePivotCacheMeasureGroups(writer, pivotCache) {
    if (!pivotCache.measureGroups || pivotCache.measureGroups.length <= 0) {
        return;
    }
    writer.writeElement('measureGroups', function () {
        writer.writeAttributeString('count', pivotCache.measureGroups.length);
    }, function () {
        for (var i = 0; i < pivotCache.measureGroups.length; i++) {
            writePivotCacheMeasureGroup(writer, pivotCache.measureGroups[i]);
        }
    });
}
function writePivotCacheMeasureGroup(writer, measureGroup) {
    writer.writeLeafElement('measureGroup', function () {
        if (measureGroup.name) {
            writer.writeAttributeString("name", xmlEncode(measureGroup.name));
        }
        if (measureGroup.caption) {
            writer.writeAttributeString("caption", measureGroup.caption);
        }
    });
}
function writePivotCacheMeasureDimensionMaps(writer, pivotCache) {
    if (!pivotCache.measureDimensionMaps || pivotCache.measureDimensionMaps.length <= 0) {
        return;
    }
    writer.writeElement('maps', function () {
        writer.writeAttributeString('count');
    }, function () {
        for (var i = 0; i < pivotCache.measureDimensionMaps.length; i++) {
            writePivotCacheMeasureDimensionMap(writer, pivotCache.measureDimensionMaps[i]);
        }
    });
}
function writePivotCacheMeasureDimensionMap(writer, measureDimensionMap) {
    writer.writeLeafElement('measureDimensionMap', function () {
        if (measureDimensionMap.measureGroup >= 0) {
            writer.writeAttributeString("measureGroup", measureDimensionMap.measureGroup);
        }
        if (measureDimensionMap.dimension >= 0) {
            writer.writeAttributeString("dimension", measureDimensionMap.dimension);
        }
    });
}
function writePivotCacheRecords(pivotCacheRecords) {
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('pivotCacheRecords', function () {
        writer.writeAttributeString("xmlns", excel_types_1.XFileConstants._workbookNameSpace);
        writer.writeAttributeString("xmlns:r", excel_types_1.XFileConstants._relationShipNameSpace);
        writer.writeAttributeString("xmlns:mc", excel_types_1.XFileConstants._markupCompatibility);
        writer.writeAttributeString("mc:Ignorable", excel_types_1.XFileConstants._ignorableXR);
        writer.writeAttributeString("xmlns:xr", excel_types_1.XFileConstants._revision);
        writer.writeAttributeString("count", pivotCacheRecords.length);
    }, function () {
        for (var i = 0; i < pivotCacheRecords.length; i++) {
            writePivotCacheRecordsRow(writer, pivotCacheRecords[i]);
        }
    });
    return writer.getXmlString();
}
exports.writePivotCacheRecords = writePivotCacheRecords;
function writePivotCacheRecordsRow(writer, pivotCacheRecordsRow) {
    writer.writeElement('r', function () {
    }, function () {
        for (var i = 0; i < pivotCacheRecordsRow.length; i++) {
            writePivotCacheDefinitionSharedItem(writer, pivotCacheRecordsRow[i]);
        }
    });
}
function writePivotTable(model, pivotTable) {
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('pivotTableDefinition', function () {
        writer.writeAttributeString("xmlns", excel_types_1.XFileConstants._workbookNameSpace);
        writer.writeAttributeString("xmlns:mc", excel_types_1.XFileConstants._markupCompatibility);
        writer.writeAttributeString("mc:Ignorable", excel_types_1.XFileConstants._ignorableXR);
        writer.writeAttributeString("xmlns:xr", excel_types_1.XFileConstants._revision);
        if (!common_1.isNullOrUndefined(pivotTable.name)) {
            writer.writeAttributeString("name", xmlEncode(pivotTable.name));
        }
        writer.writeAttributeString("cacheId", pivotTable.cacheId);
        if (pivotTable.applyNumberFormats === false) {
            writer.writeAttributeString("applyNumberFormats", "0");
        }
        if (pivotTable.applyBorderFormats === false) {
            writer.writeAttributeString("applyBorderFormats", "0");
        }
        if (pivotTable.applyFontFormats === false) {
            writer.writeAttributeString("applyFontFormats", "0");
        }
        if (pivotTable.applyPatternFormats === false) {
            writer.writeAttributeString("applyPatternFormats", "0");
        }
        if (pivotTable.applyAlignmentFormats === false) {
            writer.writeAttributeString("applyAlignmentFormats", "0");
        }
        if (pivotTable.applyWidthHeightFormats) {
            writer.writeAttributeString("applyWidthHeightFormats", "1");
        }
        if (pivotTable.dataCaption) {
            writer.writeAttributeString("dataCaption", pivotTable.dataCaption);
        }
        if (!common_1.isNullOrUndefined(pivotTable.grandTotalCaption)) {
            writer.writeAttributeString("grandTotalCaption", pivotTable.grandTotalCaption);
        }
        if (!common_1.isNullOrUndefined(pivotTable.errorCaption)) {
            writer.writeAttributeString("errorCaption", pivotTable.errorCaption);
        }
        if (pivotTable.showError) {
            writer.writeAttributeString("showError", "1");
        }
        if (!common_1.isNullOrUndefined(pivotTable.missingCaption)) {
            writer.writeAttributeString("missingCaption", pivotTable.missingCaption);
        }
        if (pivotTable.showMissing === false) {
            writer.writeAttributeString("showMissing", "0");
        }
        if (pivotTable.updatedVersion > 0) {
            writer.writeAttributeString("updatedVersion", pivotTable.updatedVersion);
        }
        else {
            writer.writeAttributeString("updatedVersion", "7");
        }
        if (pivotTable.minRefreshableVersion > 0 && pivotTable.minRefreshableVersion <= pivotTable.createdVersion) {
            writer.writeAttributeString("minRefreshableVersion", pivotTable.minRefreshableVersion);
        }
        if (pivotTable.printDrill) {
            writer.writeAttributeString("printDrill", "1");
        }
        if (pivotTable.showDrill === false) {
            writer.writeAttributeString("showDrill", "0");
        }
        if (pivotTable.showDataTips === false) {
            writer.writeAttributeString("showDataTips", "0");
        }
        if (pivotTable.enableDrill === false) {
            writer.writeAttributeString("enableDrill", "0");
        }
        if (pivotTable.preserveFormatting === false) {
            writer.writeAttributeString("preserveFormatting", "0");
        }
        if (pivotTable.useAutoFormatting) {
            writer.writeAttributeString("useAutoFormatting", "1");
        }
        if (pivotTable.pageWrap > 0) {
            writer.writeAttributeString("pageWrap", pivotTable.pageWrap);
        }
        if (pivotTable.pageOverThenDown) {
            writer.writeAttributeString("pageOverThenDown", "1");
        }
        if (pivotTable.rowGrandTotals === false) {
            writer.writeAttributeString("rowGrandTotals", "0");
        }
        if (pivotTable.colGrandTotals === false) {
            writer.writeAttributeString("colGrandTotals", "0");
        }
        if (pivotTable.itemPrintTitles) {
            writer.writeAttributeString("itemPrintTitles", "1");
        }
        if (pivotTable.fieldPrintTitles) {
            writer.writeAttributeString("fieldPrintTitles", "1");
        }
        if (pivotTable.mergeItem) {
            writer.writeAttributeString("mergeItem", "1");
        }
        if (pivotTable.createdVersion > 0) {
            writer.writeAttributeString("createdVersion", pivotTable.createdVersion);
        }
        else {
            writer.writeAttributeString("createdVersion", "7");
        }
        if (pivotTable.indent >= 0) {
            writer.writeAttributeString("indent", pivotTable.indent);
        }
        if (pivotTable.asteriskTotals) {
            writer.writeAttributeString("asteriskTotals", "1");
        }
        if (pivotTable.autoFormatId > 0) {
            writer.writeAttributeString("autoFormatId", pivotTable.autoFormatId);
        }
        if (!common_1.isNullOrUndefined(pivotTable.colHeaderCaption)) {
            writer.writeAttributeString("colHeaderCaption", pivotTable.colHeaderCaption);
        }
        if (pivotTable.compact === false) {
            writer.writeAttributeString("compact", "0");
        }
        if (pivotTable.compactData === false) {
            writer.writeAttributeString("compactData", "0");
        }
        if (pivotTable.dataOnRows) {
            writer.writeAttributeString("dataOnRows", "1");
        }
        if (pivotTable.dataPosition > 0) {
            writer.writeAttributeString("dataPosition", pivotTable.dataPosition);
        }
        if (pivotTable.disableFieldList) {
            writer.writeAttributeString("disableFieldList", "1");
        }
        if (pivotTable.editData) {
            writer.writeAttributeString("editData", "1");
        }
        if (pivotTable.enableFieldProperties === false) {
            writer.writeAttributeString("enableFieldProperties", "0");
        }
        if (pivotTable.enableWizard === false) {
            writer.writeAttributeString("enableWizard", "0");
        }
        if (pivotTable.gridDropZones) {
            writer.writeAttributeString("gridDropZones", "1");
        }
        if (pivotTable.immersive) {
            writer.writeAttributeString("immersive", "1");
        }
        if (pivotTable.mdxSubqueries) {
            writer.writeAttributeString("mdxSubqueries", "1");
        }
        if (pivotTable.showHeaders === false) {
            writer.writeAttributeString("showHeaders", "0");
        }
        if (pivotTable.outline) {
            writer.writeAttributeString("outline", "1");
        }
        if (pivotTable.outlineData) {
            writer.writeAttributeString("outlineData", "1");
        }
        if (pivotTable.multipleFieldFilters === false) {
            writer.writeAttributeString("multipleFieldFilters", "0");
        }
        if (pivotTable.chartFormat > 0) {
            writer.writeAttributeString("chartFormat", pivotTable.chartFormat);
        }
        if (pivotTable.fieldListSortAscending) {
            writer.writeAttributeString("fieldListSortAscending", "1");
        }
        if (pivotTable.customListSort === false) {
            writer.writeAttributeString("customListSort", "0");
        }
        if (!common_1.isNullOrUndefined(pivotTable.pageStyle)) {
            writer.writeAttributeString("pageStyle", pivotTable.PageStyle);
        }
        if (!common_1.isNullOrUndefined(pivotTable.pivotTableStyle)) {
            writer.writeAttributeString("pivotTableStyle", pivotTable.pivotTableStyle);
        }
        if (pivotTable.published) {
            writer.writeAttributeString("published", "1");
        }
        if (!common_1.isNullOrUndefined(pivotTable.rowHeaderCaption)) {
            writer.writeAttributeString("rowHeaderCaption", pivotTable.rowHeaderCaption);
        }
        if (pivotTable.showCalcMbrs === false) {
            writer.writeAttributeString("showCalcMbrs", "0");
        }
        if (pivotTable.showDataDropDown) {
            writer.writeAttributeString("showDataDropDown", "0");
        }
        if (pivotTable.showDropZones === false) {
            writer.writeAttributeString("showDropZones", "0");
        }
        if (pivotTable.showEmptyCol === false) {
            writer.writeAttributeString("showEmptyCol", "0");
        }
        if (pivotTable.showEmptyRow === false) {
            writer.writeAttributeString("showEmptyRow", "0");
        }
        if (pivotTable.showItems === false) {
            writer.writeAttributeString("showItems", "0");
        }
        if (pivotTable.showMemberPropertyTips === false) {
            writer.writeAttributeString("showMemberPropertyTips", "0");
        }
        if (pivotTable.showMultipleLabel === false) {
            writer.writeAttributeString("showMultipleLabel", "0");
        }
        if (pivotTable.subtotalHiddenItems) {
            writer.writeAttributeString("subtotalHiddenItems", "1");
        }
        if (!common_1.isNullOrUndefined(pivotTable.tag)) {
            writer.writeAttributeString("tag", pivotTable.tag);
        }
        if (!common_1.isNullOrUndefined(pivotTable.vacatedStyle)) {
            writer.writeAttributeString("vacatedStyle", pivotTable.vacatedStyle);
        }
        if (pivotTable.visualTotals === false) {
            writer.writeAttributeString("visualTotals", "0");
        }
    }, function () {
        writePivotLocation(writer, pivotTable);
        writePivotFields(writer, pivotTable);
        writePivotRowOrColFields(writer, pivotTable, true);
        writePivotRowItems(writer, pivotTable);
        writePivotRowOrColFields(writer, pivotTable, false);
        writePivotColumnItems(writer, pivotTable);
        writePageFields(writer, pivotTable);
        writeDataFields(writer, pivotTable);
        writePivotFormats(writer, pivotTable);
        writePivotTableConditionalFormats(writer, pivotTable);
        writePivotTableChartFormats(writer, pivotTable);
        writePivotHierarchies(writer, pivotTable);
        writePivotStyleInfo(writer, pivotTable);
        writePivotFilters(model, writer, pivotTable);
        writeRowHierarchiesUsage(writer, pivotTable);
        writeColHierarchiesUsage(writer, pivotTable);
        writePivotTableExtList(writer, pivotTable);
    });
    return writer.getXmlString();
}
exports.writePivotTable = writePivotTable;
function writePivotLocation(writer, pivotTable) {
    writer.writeLeafElement('location', function () {
        writer.writeAttributeString("ref", pivotTable.ref);
        if (pivotTable.firstHeaderRow >= 0) {
            writer.writeAttributeString("firstHeaderRow", pivotTable.firstHeaderRow);
        }
        if (pivotTable.firstDataRow >= 0) {
            writer.writeAttributeString("firstDataRow", pivotTable.firstDataRow);
        }
        if (pivotTable.firstDataCol >= 0) {
            writer.writeAttributeString("firstDataCol", pivotTable.firstDataCol);
        }
        if (pivotTable.rowPageCount > 0) {
            writer.writeAttributeString("rowPageCount", pivotTable.rowPageCount);
        }
        if (pivotTable.colPageCount > 0) {
            writer.writeAttributeString("colPageCount", pivotTable.colPageCount);
        }
    });
}
function writePivotFields(writer, pivotTable) {
    writer.writeElement('pivotFields', function () {
        writer.writeAttributeString('count', pivotTable.fields.length);
    }, function () {
        for (var i = 0; i < pivotTable.fields.length; i++) {
            writePivotField(writer, pivotTable.fields[i], pivotTable);
        }
    });
}
function writePivotField(writer, pivotField, pivotTable) {
    if (pivotField.items && pivotField.items.length > 0) {
        writer.writeElement('pivotField', function () {
            writePivotFieldAttr(writer, pivotField);
        }, function () {
            writePivotFieldContent(writer, pivotField, pivotTable);
        });
    }
    else if (pivotTable.fillDownLabels) {
        writer.writeElement('pivotField', function () {
            writePivotFieldAttr(writer, pivotField);
        }, function () {
            writer.writeElement('extLst', function () {
                writePivotFieldExtList(writer, pivotTable);
            });
        });
    }
    else {
        writer.writeLeafElement('pivotField', function () {
            writePivotFieldAttr(writer, pivotField);
        });
    }
}
function writePivotFieldAttr(writer, pivotField) {
    if (!common_1.isNullOrUndefined(pivotField.name)) {
        writer.writeAttributeString("name", xmlEncode(pivotField.name));
    }
    if (!common_1.isNullOrUndefined(pivotField.axis)) {
        writer.writeAttributeString("axis", pivotField.axis);
    }
    if (pivotField.allDrilled) {
        writer.writeAttributeString("allDrilled", "1");
    }
    if (pivotField.autoShow) {
        writer.writeAttributeString("autoShow", "1");
    }
    if (pivotField.dataField) {
        writer.writeAttributeString("dataField", "1");
    }
    if (pivotField.compact === false) {
        writer.writeAttributeString("compact", "0");
    }
    if (pivotField.numberFormatId >= 0) {
        writer.writeAttributeString("numFmtId", pivotField.numberFormatId);
    }
    if (pivotField.outline === false) {
        writer.writeAttributeString("outline", "0");
    }
    if (pivotField.subtotalTop === false) {
        writer.writeAttributeString("subtotalTop", "0");
    }
    if (pivotField.multipleItemSelectionAllowed) {
        writer.writeAttributeString("multipleItemSelectionAllowed", "1");
    }
    if (pivotField.showAll === false) {
        writer.writeAttributeString("showAll", "0");
    }
    if (pivotField.insertBlankRow) {
        writer.writeAttributeString("insertBlankRow", "1");
    }
    if (pivotField.insertPageBreak) {
        writer.writeAttributeString("insertPageBreak", "1");
    }
    if (pivotField.includeNewItemsInFilter) {
        writer.writeAttributeString("includeNewItemsInFilter", "1");
    }
    if (pivotField.sumSubtotal) {
        writer.writeAttributeString("sumSubtotal", "1");
    }
    if (pivotField.countASubtotal) {
        writer.writeAttributeString("countASubtotal", "1");
    }
    if (pivotField.avgSubtotal) {
        writer.writeAttributeString("avgSubtotal", "1");
    }
    if (pivotField.maxSubtotal) {
        writer.writeAttributeString("maxSubtotal", "1");
    }
    if (pivotField.minSubtotal) {
        writer.writeAttributeString("minSubtotal", "1");
    }
    if (pivotField.productSubtotal) {
        writer.writeAttributeString("productSubtotal", "1");
    }
    if (pivotField.countSubtotal) {
        writer.writeAttributeString("countSubtotal", "1");
    }
    if (pivotField.stdDevSubtotal) {
        writer.writeAttributeString("stdDevSubtotal", "1");
    }
    if (pivotField.stdDevPSubtotal) {
        writer.writeAttributeString("stdDevPSubtotal", "1");
    }
    if (pivotField.dataSourceSort) {
        writer.writeAttributeString("dataSourceSort", "1");
    }
    if (pivotField.defaultAttributeDrillState) {
        writer.writeAttributeString("defaultAttributeDrillState", "1");
    }
    if (pivotField.dragOff === false) {
        writer.writeAttributeString("dragOff", "0");
    }
    if (pivotField.dragToCol === false) {
        writer.writeAttributeString("dragToCol", "0");
    }
    if (pivotField.dragToData === false) {
        writer.writeAttributeString("dragToData", "0");
    }
    if (pivotField.dragToPage === false) {
        writer.writeAttributeString("dragToPage", "0");
    }
    if (pivotField.dragToRow === false) {
        writer.writeAttributeString("dragToRow", "0");
    }
    if (pivotField.hiddenLevel) {
        writer.writeAttributeString("hiddenLevel", "1");
    }
    if (pivotField.hideNewItems) {
        writer.writeAttributeString("hideNewItems", "1");
    }
    if (pivotField.itemPageCount && pivotField.itemPageCount !== 10) {
        writer.writeAttributeString("itemPageCount", pivotField.itemPageCount);
    }
    if (pivotField.measureFilter) {
        writer.writeAttributeString("measureFilter", "1");
    }
    if (pivotField.nonAutoSortDefault) {
        writer.writeAttributeString("nonAutoSortDefault", "1");
    }
    if (pivotField.serverField) {
        writer.writeAttributeString("serverField", "1");
    }
    if (pivotField.showDropDowns === false) {
        writer.writeAttributeString("showDropDowns", "0");
    }
    if (pivotField.showPropAsCaption) {
        writer.writeAttributeString("showPropAsCaption", "1");
    }
    if (pivotField.showPropCell) {
        writer.writeAttributeString("showPropCell", "1");
    }
    if (pivotField.showPropTip) {
        writer.writeAttributeString("showPropTip", "1");
    }
    if (!common_1.isNullOrUndefined(pivotField.sortType)) {
        writer.writeAttributeString("sortType", pivotField.sortType);
    }
    if (pivotField.rankBy >= 0) {
        writer.writeAttributeString("rankBy", pivotField.rankBy);
    }
    if (pivotField.defaultSubtotal === false) {
        writer.writeAttributeString("defaultSubtotal", "0");
    }
    if (!common_1.isNullOrUndefined(pivotField.subtotalCaption)) {
        writer.writeAttributeString("subtotalCaption", pivotField.subtotalCaption);
    }
    if (pivotField.topAutoShow === false) {
        writer.writeAttributeString("topAutoShow", "0");
    }
    if (!common_1.isNullOrUndefined(pivotField.uniqueMemberProperty)) {
        writer.writeAttributeString("uniqueMemberProperty", pivotField.uniqueMemberProperty);
    }
    if (pivotField.varSubtotal) {
        writer.writeAttributeString("varSubtotal", "1");
    }
    if (pivotField.varPSubtotal) {
        writer.writeAttributeString("varPSubtotal", "1");
    }
}
function writePivotFieldContent(writer, pivotField, pivotTable) {
    if (pivotField.items && pivotField.items.length > 0) {
        writer.writeElement('items', function () {
            writer.writeAttributeString('count', pivotField.items.length);
        }, function () {
            for (var i = 0; i < pivotField.items.length; i++) {
                writePivotFieldItem(writer, pivotField.items[i]);
            }
        });
    }
    if (!common_1.isNullOrUndefined(pivotField.AutoSortScope)) {
        writer.writeElement('autoSortScope', function () {
            writePivotArea(writer, pivotField.autoSortScope);
        });
    }
    if (pivotTable.fillDownLabels) {
        writer.writeElement('extLst', function () {
            writePivotFieldExtList(writer, pivotTable);
        });
    }
}
function writePivotFieldItem(writer, item) {
    writer.writeLeafElement('item', function () {
        if (item.childItems) {
            writer.writeAttributeString("c", "1");
        }
        if (item.expanded === false) {
            writer.writeAttributeString("d", "0");
        }
        if (item.drillAcross === false) {
            writer.writeAttributeString("e", "0");
        }
        if (item.calculatedMember) {
            writer.writeAttributeString("f", "1");
        }
        if (item.hidden) {
            writer.writeAttributeString("h", "1");
        }
        if (item.missing) {
            writer.writeAttributeString("m", "1");
        }
        if (!common_1.isNullOrUndefined(item.caption)) {
            writer.writeAttributeString("n", item.caption);
        }
        if (item.character) {
            writer.writeAttributeString("s", "1");
        }
        if (item.collapse === true) {
            writer.writeAttributeString("sd", "0");
        }
        if (item.type) {
            writer.writeAttributeString("t", item.type);
        }
        if (!common_1.isNullOrUndefined(item.indexValue)) {
            writer.writeAttributeString("x", item.indexValue);
        }
    });
}
function writePivotArea(writer, pivotArea, isAxisRequired) {
    writer.writeElement('pivotArea', function () {
        if (pivotArea.field && pivotArea.field !== -1) {
            writer.writeAttributeString("field", pivotArea.field);
        }
        if (!common_1.isNullOrUndefined(pivotArea.type) && pivotArea.type !== 'normal') {
            writer.writeAttributeString("type", pivotArea.type);
        }
        if (pivotArea.dataOnly === false) {
            writer.writeAttributeString("dataOnly", "0");
        }
        if (pivotArea.dataOnly === true) {
            writer.writeAttributeString("dataOnly", "1");
        }
        if (pivotArea.labelOnly) {
            writer.writeAttributeString("labelOnly", "1");
        }
        if (pivotArea.grandRow) {
            writer.writeAttributeString("grandRow", "1");
        }
        if (pivotArea.grandCol) {
            writer.writeAttributeString("grandCol", "1");
        }
        if (pivotArea.cacheIndex) {
            writer.writeAttributeString("cacheIndex", "1");
        }
        if (!common_1.isNullOrUndefined(pivotArea.outline)) {
            writer.writeAttributeString("outline", "0");
        }
        if (pivotArea.collapsedLevelsAreSubtotals) {
            writer.writeAttributeString("collapsedLevelsAreSubtotals", "1");
        }
        if (pivotArea.axis && (isAxisRequired || pivotArea.axis !== 'axisValue')) {
            writer.writeAttributeString("axis", pivotArea.axis);
        }
        if (pivotArea.fieldPosition >= 0) {
            writer.writeAttributeString("fieldPosition", pivotArea.fieldPosition);
        }
        if (!common_1.isNullOrUndefined(pivotArea.offset)) {
            writer.writeAttributeString("offset", pivotArea.offset);
        }
    }, function () {
        if (pivotArea.references && pivotArea.references.length > 0) {
            writer.writeElement('references', function () {
                writer.writeAttributeString('count', pivotArea.references.length);
            }, function () {
                for (var i = 0; i < pivotArea.references.length; i++) {
                    writeReference(writer, pivotArea.references[i]);
                }
            });
        }
    });
}
function writeReference(writer, reference) {
    writer.writeElement('reference', function () {
        if (!common_1.isNullOrUndefined(reference.field) && reference.field >= 0) {
            writer.writeAttributeString("field", reference.field);
        }
        writer.writeAttributeString("count", reference.indexes ? reference.indexes.length : 0);
        if (reference.avgSubtotal) {
            writer.writeAttributeString("avgSubtotal", "1");
        }
        if (reference.byPosition) {
            writer.writeAttributeString("byPosition", "1");
        }
        if (reference.countASubtotal) {
            writer.writeAttributeString("countASubtotal", "1");
        }
        if (reference.countSubtotal) {
            writer.writeAttributeString("countSubtotal", "1");
        }
        if (reference.defaultSubtotal) {
            writer.writeAttributeString("defaultSubtotal", "1");
        }
        if (reference.maxSubtotal) {
            writer.writeAttributeString("maxSubtotal", "1");
        }
        if (reference.minSubtotal) {
            writer.writeAttributeString("minSubtotal", "1");
        }
        if (reference.productSubtotal) {
            writer.writeAttributeString("productSubtotal", "1");
        }
        if (reference.relative) {
            writer.writeAttributeString("relative", "1");
        }
        if (reference.selected === false) {
            writer.writeAttributeString("selected", "0");
        }
        if (reference.stdDevPSubtotal) {
            writer.writeAttributeString("stdDevPSubtotal", "1");
        }
        if (reference.stdDevSubtotal) {
            writer.writeAttributeString("stdDevSubtotal", "1");
        }
        if (reference.sumSubtotal) {
            writer.writeAttributeString("sumSubtotal", "1");
        }
        if (reference.varPSubtotal) {
            writer.writeAttributeString("varPSubtotal", "1");
        }
        if (reference.varSubtotal) {
            writer.writeAttributeString("varSubtotal", "1");
        }
    }, function () {
        if (reference.indexes && reference.indexes.length > 0) {
            for (var i = 0; i < reference.indexes.length; i++) {
                writeXElement(writer, reference.indexes[i]);
            }
        }
    });
}
function writeXElement(writer, referenceIndex) {
    writer.writeLeafElement('x', function () {
        writer.writeAttributeString('v', referenceIndex);
    });
}
function writePivotRowOrColFields(writer, pivotTable, isRowFields) {
    if ((isRowFields && pivotTable.rowFields && pivotTable.rowFields.length > 0)
        || (!isRowFields && pivotTable.columnFields && pivotTable.columnFields.length > 0)) {
        writer.writeElement(isRowFields ? 'rowFields' : 'colFields', function () {
            writer.writeAttributeString('count', isRowFields ? pivotTable.rowFields.length : pivotTable.columnFields.length);
        }, function () {
            var fields = isRowFields ? pivotTable.rowFields : pivotTable.columnFields;
            for (var i = 0; i < fields.length; i++) {
                writePivotRowOrColField(writer, fields[i]);
            }
        });
    }
}
function writePivotRowOrColField(writer, fieldIndex) {
    writer.writeLeafElement('field', function () {
        writer.writeAttributeString('x', fieldIndex);
    });
}
function writePivotRowItems(writer, pivotTable) {
    var rowItems = [];
    rowItems = pivotTable.rowItems;
    if (rowItems.length <= 0) {
        return;
    }
    writer.writeElement('rowItems', function () {
        writer.writeAttributeString('count', rowItems.length);
    }, function () {
        for (var i = 0; i < rowItems.length; i++) {
            writePivotLayoutItem(writer, rowItems[i]);
        }
    });
}
function writePivotColumnItems(writer, pivotTable) {
    var columnItems = pivotTable.columnItems;
    if (!common_1.isNullOrUndefined(columnItems) && columnItems.length > 0) {
        writer.writeElement('colItems', function () {
            writer.writeAttributeString('count', columnItems.length);
        }, function () {
            for (var i = 0; i < columnItems.length; i++) {
                writePivotLayoutItem(writer, columnItems[i]);
            }
        });
    }
}
function writePivotLayoutItem(writer, item) {
    writer.writeElement("i", function () {
        if (!common_1.isNullOrUndefined(item.type)) {
            writer.writeAttributeString("t", item.type);
        }
        if (item.repeatCount > 0) {
            writer.writeAttributeString("r", item.repeatCount);
        }
        if (item.dataFieldIndex > 0) {
            writer.writeAttributeString("i", item.dataFieldIndex);
        }
    }, function () {
        if (item.pivotItemIndexes && item.pivotItemIndexes.length > 0) {
            for (var i = 0; i < item.pivotItemIndexes.length; i++) {
                writeLeafXElement(writer, item.pivotItemIndexes[i]);
            }
        }
    });
}
function writeLeafXElement(writer, value) {
    writer.writeLeafElement("x", function () {
        if (value && value > 0) {
            writer.writeAttributeString("v", value);
        }
    });
}
function writePageFields(writer, pivotTable) {
    if (pivotTable.pageFields && pivotTable.pageFields.length > 0) {
        writer.writeElement("pageFields", function () {
            writer.writeAttributeString("count", pivotTable.pageFields.length);
        }, function () {
            for (var i = 0; i < pivotTable.pageFields.length; i++) {
                writePageField(writer, pivotTable.pageFields[i]);
            }
        });
    }
}
function writePageField(writer, pageField) {
    writer.writeLeafElement("pageField", function () {
        if (!common_1.isNullOrUndefined(pageField.name)) {
            writer.writeAttributeString("name", xmlEncode(pageField.name));
        }
        if (!common_1.isNullOrUndefined(pageField.fld)) {
            writer.writeAttributeString("fld", pageField.fld);
        }
        if (!common_1.isNullOrUndefined(pageField.cap)) {
            writer.writeAttributeString("cap", pageField.cap);
        }
        if (!common_1.isNullOrUndefined(pageField.item)) {
            writer.writeAttributeString("item", pageField.item);
        }
        if (!common_1.isNullOrUndefined(pageField.hier)) {
            writer.writeAttributeString("hier", pageField.hier);
        }
    });
}
function writeDataFields(writer, pivotTable) {
    if (pivotTable.dataFields && pivotTable.dataFields.length > 0) {
        writer.writeElement("dataFields", function () {
            writer.writeAttributeString("count", pivotTable.dataFields.length);
        }, function () {
            for (var i = 0; i < pivotTable.dataFields.length; i++) {
                writeDataField(writer, pivotTable.dataFields[i]);
            }
        });
    }
}
function writeDataField(writer, dataField) {
    var isExtShowDataAs = ["difference", "index", "normal", "percent", "percentDiff", "percentOfCol", "percentOfRow", "percentOfTotal", "runTotal"].indexOf(dataField.showDataAs) === -1;
    writer.writeElement("dataField", function () {
        if (!common_1.isNullOrUndefined(dataField.name)) {
            writer.writeAttributeString("name", xmlEncode(dataField.name));
        }
        if (!common_1.isNullOrUndefined(dataField.fld)) {
            writer.writeAttributeString("fld", dataField.fld);
        }
        if (!common_1.isNullOrUndefined(dataField.subtotal)) {
            writer.writeAttributeString("subtotal", dataField.subtotal);
        }
        if (!common_1.isNullOrUndefined(dataField.showDataAs)) {
            if (!isExtShowDataAs) {
                writer.writeAttributeString("showDataAs", dataField.showDataAs);
            }
        }
        if (!common_1.isNullOrUndefined(dataField.baseField)) {
            writer.writeAttributeString("baseField", dataField.baseField);
        }
        if (!common_1.isNullOrUndefined(dataField.baseItem)) {
            writer.writeAttributeString("baseItem", dataField.baseItem);
        }
        if (!common_1.isNullOrUndefined(dataField.numberFormatId)) {
            writer.writeAttributeString("numFmtId", dataField.numberFormatId);
        }
    }, function () {
        if (!common_1.isNullOrUndefined(dataField.showDataAs) && isExtShowDataAs) {
            writeDataFieldExtLst(writer, dataField.showDataAs);
        }
    });
}
function writeDataFieldExtLst(writer, showDataAs) {
    writer.writeElement('extLst', function () {
    }, function () {
        writer.writeElement('ext', function () {
            writer.writeAttributeString('uri', '{E15A36E0-9728-4e99-A89B-3F7291B0FE68}');
            writer.writeAttributeString('xmlns:x14', excel_types_1.XFileConstants._extensionListNameSpace);
        }, function () {
            writer.writeLeafElement('x14:dataField', function () {
                writer.writeAttributeString('pivotShowAs', showDataAs);
            });
        });
    });
}
function writePivotFormats(writer, pivotTable) {
    var formats = pivotTable.formats;
    if (formats && formats.length > 0) {
        writer.writeElement("formats", function () {
            writer.writeAttributeString("count", formats.length);
        }, function () {
            for (var i = 0; i < formats.length; i++) {
                writeFormat(writer, formats[i]);
            }
        });
    }
}
function writeFormat(writer, format) {
    if (format && format.style) {
        writer.writeElement("format", function () {
            if (format.action !== 'Formatting' && !common_1.isNullOrUndefined(format.action)) {
                writer.writeAttributeString("action", format.action);
            }
            if (format.dxfId >= 0) {
                writer.writeAttributeString("dxfId", format.dxfId);
            }
        }, function () {
            if (!common_1.isNullOrUndefined(format.pivotArea)) {
                writePivotArea(writer, format.pivotArea, true);
            }
        });
    }
}
function writePivotTableConditionalFormats(writer, pivotTable) {
    var validRules = pivotTable.pivotTableConditionFormats;
    if (validRules && validRules.length > 0) {
        writer.writeElement("conditionalFormats", function () {
            writer.writeAttributeString("count", validRules.length);
        }, function () {
            for (var i = 0; i < validRules.length; i++) {
                writeConditionFormat(writer, validRules[i]);
            }
        });
    }
}
function writeConditionFormat(writer, format) {
    writer.writeElement("conditionalFormat", function () {
        if (format.scope && format.scope !== 'Selection') {
            writer.writeAttributeString("scope", format.scope);
        }
        if (format.type && format.type !== 'None') {
            writer.writeAttributeString("type", format.type);
        }
        writer.writeAttributeString("priority", format.rule.priority || 0);
    }, function () {
        if (format.pivotAreas && format.pivotAreas.length > 0) {
            writer.writeElement("pivotAreas", function () {
                writer.writeAttributeString("count", format.pivotAreas.length);
            }, function () {
                for (var i = 0; i < format.pivotAreas.length; i++) {
                    writePivotArea(writer, format.pivotAreas[i]);
                }
            });
        }
    });
}
function writePivotTableChartFormats(writer, pivotTable) {
    if (pivotTable.chartFormats && pivotTable.chartFormats.length > 0) {
        writer.writeElement("chartFormats", function () {
            writer.writeAttributeString("count", pivotTable.chartFormats.length);
        }, function () {
            for (var i = 0; i < pivotTable.chartFormats.length; i++) {
                writePivotTableChartFormat(writer, pivotTable.chartFormats[i]);
            }
        });
    }
}
function writePivotTableChartFormat(writer, chartFormat) {
    writer.writeElement('chartFormat', function () {
        if (chartFormat.chart >= 0) {
            writer.writeAttributeString("chart", chartFormat.chart);
        }
        if (chartFormat.format >= 0) {
            writer.writeAttributeString("format", chartFormat.format);
        }
        if (chartFormat.series) {
            writer.writeAttributeString("series", "1");
        }
    }, function () {
        if (!common_1.isNullOrUndefined(chartFormat.pivotArea)) {
            writePivotArea(writer, chartFormat.pivotArea);
        }
    });
}
function writePivotHierarchies(writer, pivotTable) {
    if (pivotTable.pivotHierarchies && pivotTable.pivotHierarchies.length > 0) {
        writer.writeElement("pivotHierarchies", function () {
            writer.writeAttributeString("count", pivotTable.pivotHierarchies.length);
        }, function () {
            for (var i = 0; i < pivotTable.pivotHierarchies.length; i++) {
                writePivotHierarchy(writer, pivotTable.pivotHierarchies[i]);
            }
        });
    }
}
function writePivotHierarchy(writer, pivotHierarchy) {
    writer.writeElement("pivotHierarchy", function () {
        if (!common_1.isNullOrUndefined(pivotHierarchy.caption)) {
            writer.writeAttributeString("caption", pivotHierarchy.caption);
        }
        if (!pivotHierarchy.dragOff) {
            writer.writeAttributeString("dragOff", "0");
        }
        if (!pivotHierarchy.dragToRow) {
            writer.writeAttributeString("dragToRow", "0");
        }
        if (!pivotHierarchy.dragToCol) {
            writer.writeAttributeString("dragToCol", "0");
        }
        if (!pivotHierarchy.dragToPage) {
            writer.writeAttributeString("dragToPage", "0");
        }
        if (pivotHierarchy.dragToData) {
            writer.writeAttributeString("dragToData", "1");
        }
        if (pivotHierarchy.includeNewItemsInFilter) {
            writer.writeAttributeString("includeNewItemsInFilter", "1");
        }
        if (pivotHierarchy.multipleItemSelectionAllowed) {
            writer.writeAttributeString("multipleItemSelectionAllowed", "1");
        }
        if (pivotHierarchy.outline) {
            writer.writeAttributeString("outline", "1");
        }
        if (pivotHierarchy.showInFieldList) {
            writer.writeAttributeString("showInFieldList", "1");
        }
        if (pivotHierarchy.subtotalTop) {
            writer.writeAttributeString("subtotalTop", "1");
        }
    }, function () {
        var i;
        if (pivotHierarchy.memberProperties && pivotHierarchy.memberProperties.length > 0) {
            writer.writeElement('mps', function () {
                writer.writeAttributeString('count', pivotHierarchy.memberProperties.length);
            }, function () {
                for (i = 0; i < pivotHierarchy.memberProperties.length; i++) {
                    writerPivotMemberProperty(writer, pivotHierarchy.memberProperties[i]);
                }
            });
        }
        if (pivotHierarchy.members && pivotHierarchy.members.length > 0) {
            writer.writeElement('members', function () {
                writer.writeAttributeString('count', pivotHierarchy.members.length);
            }, function () {
                for (i = 0; i < pivotHierarchy.members.length; i++) {
                    writerPivotMember(writer, pivotHierarchy.members[i]);
                }
            });
        }
    });
}
function writerPivotMemberProperty(writer, memberProperty) {
    writer.writeLeafElement('mp', function () {
        if (!common_1.isNullOrUndefined(memberProperty.name)) {
            writer.writeAttributeString("name", xmlEncode(memberProperty.name));
        }
        if (memberProperty.showCell) {
            writer.writeAttributeString("showCell", "1");
        }
        if (memberProperty.showTip) {
            writer.writeAttributeString("showTip", "1");
        }
        if (memberProperty.showAsCaption) {
            writer.writeAttributeString("showAsCaption", "1");
        }
        if (memberProperty.nameLen > 0) {
            writer.writeAttributeString("nameLen", xmlEncode(memberProperty.nameLen));
        }
        if (memberProperty.pPos >= 0) {
            writer.writeAttributeString("pPos", memberProperty.pPos);
        }
        if (memberProperty.pLen > 0) {
            writer.writeAttributeString("pLen", memberProperty.pLen);
        }
        if (memberProperty.level > 0) {
            writer.writeAttributeString("level", memberProperty.level);
        }
        if (memberProperty.field >= 0) {
            writer.writeAttributeString("field", memberProperty.field);
        }
    });
}
function writerPivotMember(writer, member) {
    writer.writeLeafElement('member', function () {
        if (!common_1.isNullOrUndefined(member.name)) {
            writer.writeAttributeString("name", xmlEncode(member.name));
        }
    });
}
function writePivotStyleInfo(writer, pivotTable) {
    writer.writeLeafElement("pivotTableStyleInfo", function () {
        if (!common_1.isNullOrUndefined(pivotTable.styleName)) {
            writer.writeAttributeString("name", pivotTable.styleName);
        }
        if (pivotTable.showRowHeaders) {
            writer.writeAttributeString("showRowHeaders", "1");
        }
        if (pivotTable.showColHeaders) {
            writer.writeAttributeString("showColHeaders", "1");
        }
        if (pivotTable.showRowStripes === false) {
            writer.writeAttributeString("showRowStripes", "0");
        }
        else {
            writer.writeAttributeString("showRowStripes", "1");
        }
        if (pivotTable.showColStripes === false) {
            writer.writeAttributeString("showColStripes", "0");
        }
        else {
            writer.writeAttributeString("showColStripes", "1");
        }
        if (pivotTable.showLastColumn) {
            writer.writeAttributeString("showLastColumn", "1");
        }
    });
}
function writePivotFilters(model, writer, pivotTable) {
    if (pivotTable.pivotFilters && pivotTable.pivotFilters.length > 0) {
        writer.writeElement("filters", function () {
            writer.writeAttributeString("count", pivotTable.pivotFilters.length);
        }, function () {
            for (var i = 0; i < pivotTable.pivotFilters.length; i++) {
                writePivotFilter(model, writer, pivotTable.pivotFilters[i]);
            }
        });
    }
}
function writePivotFilter(model, writer, pivotFilter) {
    var operator = pivotFilter.operator;
    var conType = pivotFilter.conType;
    var type = captionCompareTypeExcel[conType][operator];
    writer.writeElement("filter", function () {
        if (pivotFilter.fld >= 0) {
            writer.writeAttributeString("fld", pivotFilter.fld);
        }
        if (pivotFilter.mpFld >= 0) {
            writer.writeAttributeString("mpFld", pivotFilter.mpFld);
        }
        if (type !== undefined) {
            writer.writeAttributeString("type", type);
        }
        if (!common_1.isNullOrUndefined(pivotFilter.evalOrder)) {
            writer.writeAttributeString("evalOrder", pivotFilter.evalOrder);
        }
        if (pivotFilter.id >= 0) {
            writer.writeAttributeString("id", pivotFilter.id);
        }
        if (pivotFilter.iMeasureHier >= 0) {
            writer.writeAttributeString("iMeasureHier", pivotFilter.iMeasureHier);
        }
        if (pivotFilter.iMeasureFld >= 0) {
            writer.writeAttributeString("iMeasureFld", pivotFilter.iMeasureFld);
        }
        if (!common_1.isNullOrUndefined(pivotFilter.name)) {
            writer.writeAttributeString("name", xmlEncode(pivotFilter.name));
        }
        if (!common_1.isNullOrUndefined(pivotFilter.description)) {
            writer.writeAttributeString("description", pivotFilter.description);
        }
        if (!common_1.isNullOrUndefined(pivotFilter.stringValue1)) {
            writer.writeAttributeString("stringValue1", pivotFilter.stringValue1);
        }
        if (!common_1.isNullOrUndefined(pivotFilter.stringValue2)) {
            writer.writeAttributeString("stringValue2", pivotFilter.stringValue2);
        }
    }, function () {
        if (!common_1.isNullOrUndefined(pivotFilter.autoFilter)) {
            var autoFilter = model._convertPivotAutoFilterFromJSON(pivotFilter, type);
            autofilter_writer_1.writePivotAutoFilter(writer, autoFilter);
        }
    });
}
function writeRowHierarchiesUsage(writer, pivotTable) {
    if (pivotTable.rowHierarchies && pivotTable.rowHierarchies.length > 0) {
        writer.writeElement("rowHierarchiesUsage", function () {
            writer.writeAttributeString("count", pivotTable.rowHierarchies.length);
        }, function () {
            for (var i = 0; i < pivotTable.rowHierarchies.length; i++) {
                writeHierarchyUsage(writer, pivotTable.rowHierarchies[i], true);
            }
        });
    }
}
function writeColHierarchiesUsage(writer, pivotTable) {
    if (pivotTable.colHierarchies && pivotTable.colHierarchies.length > 0) {
        writer.writeElement("rowHierarchiesUsage", function () {
            writer.writeAttributeString("count", pivotTable.colHierarchies.length);
        }, function () {
            for (var i = 0; i < pivotTable.colHierarchies.length; i++) {
                writeHierarchyUsage(writer, pivotTable.colHierarchies[i], false);
            }
        });
    }
}
function writeHierarchyUsage(writer, hierarchyUsage, isRow) {
    var tagName = isRow ? 'rowHierarchyUsage' : 'colHierarchyUsage';
    writer.writeLeafElement(tagName, function () {
        writer.writeAttributeString("hierarchyUsage", hierarchyUsage);
    });
}
function writePivotTableExtList(writer, pivotTable) {
    writer.writeElement("extLst", function () {
        writer.writeElement("ext", function () {
            writer.writeAttributeString("uri", "{962EF5D1-5CA2-4c93-8EF4-DBF5C05439D2}");
            writer.writeAttributeString("xmlns:x14", "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main");
        }, function () {
            writer.writeLeafElement("x14:pivotTableDefinition", function () {
                if (pivotTable.altText) {
                    writer.writeAttributeString("altText", pivotTable.altText);
                }
                if (pivotTable.fillDownLabels) {
                    writer.writeAttributeString("fillDownLabelsDefault", "1");
                }
                if (pivotTable.altTextSummary) {
                    writer.writeAttributeString("altTextSummary", pivotTable.altTextSummary);
                }
                if (pivotTable.hideValuesRow) {
                    writer.writeAttributeString("hideValuesRow", "1");
                }
                writer.writeAttributeString("xmlns:xm", "http://schemas.microsoft.com/office/excel/2006/main");
            });
        });
        writer.writeElement("ext", function () {
            writer.writeAttributeString("uri", "{747A6164-185A-40DC-8AA5-F01512510D54}");
            writer.writeAttributeString("xmlns:xpdl", "http://schemas.microsoft.com/office/spreadsheetml/2016/pivotdefaultlayout");
        }, function () {
            writer.writeLeafElement("xpdl:pivotTableDefinition16", function () {
                if (pivotTable.subtotalsOnTopDefault === 0) {
                    writer.writeAttributeString("SubtotalsOnTopDefault", "0");
                }
            });
        });
    });
}
function writePivotFieldExtList(writer, pivotTable) {
    writer.writeElement("ext", function () {
        writer.writeAttributeString("uri", "{2946ED86-A175-432a-8AC1-64E0C546D7DE}");
        writer.writeAttributeString("xmlns:x14", "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main");
    }, function () {
        writer.writeLeafElement("x14:pivotField", function () {
            if (pivotTable.fillDownLabels) {
                writer.writeAttributeString("fillDownLabels", "1");
            }
        });
    });
}


/***/ }),

/***/ "./src/xlsx-io/writer/print-writer.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/writer/print-writer.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var isNullOrWhiteSpace = common_1.StringEx._isNullOrWhiteSpace;
var xmlEncode = common_1.Util._xmlEncode;
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var ExcelPrintPageOrder = {
    0: 'auto',
    1: 'downThenOver',
    2: 'overThenDown'
};
var ExcelPrintOrientation = {
    0: 'auto',
    1: 'portrait',
    2: 'landscape'
};
function writePageMargins(writer, sheetName, writerDataModel) {
    var printPageMargin = writerDataModel._getPrintPageMargin(sheetName);
    if (printPageMargin) {
        writer.writeLeafElement('pageMargins', function () {
            writer.writeAttributeString('left', printPageMargin.left);
            writer.writeAttributeString('right', printPageMargin.right);
            writer.writeAttributeString('top', printPageMargin.top);
            writer.writeAttributeString('bottom', printPageMargin.bottom);
            writer.writeAttributeString('header', printPageMargin.header);
            writer.writeAttributeString('footer', printPageMargin.footer);
        });
    }
}
exports.writePageMargins = writePageMargins;
function writePrintOptions(writer, sheetName, writerDataModel) {
    var option = writerDataModel._getPrintOptions(sheetName);
    if (option) {
        if (option.printGridLine || option.printRowColumnsHeaders || option.horizontalCentered || option.verticalCentered) {
            writer.writeLeafElement("printOptions", function () {
                if (option.printRowColumnsHeaders) {
                    writer.writeAttributeString("headings", "1");
                }
                if (option.printGridLine) {
                    writer.writeAttributeString("gridLines", "1");
                }
                if (option.horizontalCentered) {
                    writer.writeAttributeString("horizontalCentered", "1");
                }
                if (option.verticalCentered) {
                    writer.writeAttributeString("verticalCentered", "1");
                }
            });
        }
    }
}
exports.writePrintOptions = writePrintOptions;
function writePageSetup(writer, sheetName, writerDataModel) {
    var setting = writerDataModel._getPrintPageSetting(sheetName);
    if (setting) {
        writer.writeLeafElement("pageSetup", function () {
            var useSmartPrint = setting.useSmartPrint, paperSizeIndex = setting.paperSizeIndex, zoomFactor = setting.zoomFactor, firstPageNumber = setting.firstPageNumber, smartPrintPagesWidth = setting.smartPrintPagesWidth, smartPrintPagesHeight = setting.smartPrintPagesHeight, pageOrder = ExcelPrintPageOrder[setting.pageOrder], orientation = ExcelPrintOrientation[setting.orientation], copies = setting.copies;
            if (useSmartPrint) {
                if (smartPrintPagesWidth === undefined) {
                    smartPrintPagesWidth = 0;
                }
                if (smartPrintPagesHeight === undefined) {
                    smartPrintPagesHeight = 0;
                }
            }
            if (!common_1.isNullOrUndefined(paperSizeIndex) && paperSizeIndex > 1) {
                writer.writeAttributeString("paperSize", paperSizeIndex);
            }
            if (!common_1.isNullOrUndefined(zoomFactor) && Math.abs(zoomFactor - 1.0) > 0.01) {
                writer.writeAttributeString("scale", Math.round(zoomFactor * 100));
            }
            if (!common_1.isNullOrUndefined(firstPageNumber)) {
                writer.writeAttributeString("firstPageNumber", firstPageNumber);
            }
            if ((smartPrintPagesWidth > 0 && smartPrintPagesWidth !== 1) || smartPrintPagesWidth === 0) {
                writer.writeAttributeString("fitToWidth", smartPrintPagesWidth);
            }
            if ((smartPrintPagesHeight > 0 && smartPrintPagesHeight !== 1) || smartPrintPagesHeight === 0) {
                writer.writeAttributeString("fitToHeight", smartPrintPagesHeight);
            }
            if (!common_1.isNullOrUndefined(pageOrder) && pageOrder !== 0) {
                writer.writeAttributeString("pageOrder", pageOrder);
            }
            if (!common_1.isNullOrUndefined(orientation) && orientation !== 0) {
                writer.writeAttributeString("orientation", orientation);
            }
            if (setting.showColor === false) {
                writer.writeAttributeString("blackAndWhite", "1");
            }
            if (setting.draft === true) {
                writer.writeAttributeString("draft", "1");
            }
            if (setting.useCustomStartingPage === true) {
                writer.writeAttributeString("useFirstPageNumber", "1");
            }
            if (copies > 1 && copies < 32767) {
                writer.writeAttributeString("copies", copies);
            }
        });
    }
}
exports.writePageSetup = writePageSetup;
function needWriteHeaderFooter(setting) {
    var advancedHeadFooterSetting = setting.advancedHeadFooterSetting;
    return advancedHeadFooterSetting && (advancedHeadFooterSetting.headerFooterDifferentOddEvenPages ||
        advancedHeadFooterSetting.headerFooterDifferentFirstPage || !advancedHeadFooterSetting.headerFooterScalesWithDocument || !advancedHeadFooterSetting.headerFooterAlignWithPageMargin || !isNullOrWhiteSpace(setting.header) || !isNullOrWhiteSpace(setting.footer) || !isNullOrWhiteSpace(advancedHeadFooterSetting.headerOddPage) || !isNullOrWhiteSpace(advancedHeadFooterSetting.footerOddPage) || !isNullOrWhiteSpace(advancedHeadFooterSetting.headerEvenPage) || !isNullOrWhiteSpace(advancedHeadFooterSetting.footerEvenPage) || !isNullOrWhiteSpace(advancedHeadFooterSetting.headerFirstPage) || !isNullOrWhiteSpace(advancedHeadFooterSetting.footerFirstPage));
}
function writeHeadFooter(writer, sheetName, writerDataModel) {
    var setting = writerDataModel._getPrintPageSetting(sheetName);
    if (setting && needWriteHeaderFooter(setting)) {
        var advancedHeadFooterSetting_1 = setting.advancedHeadFooterSetting;
        writer.writeElement("headerFooter", function () {
            if (advancedHeadFooterSetting_1.headerFooterDifferentOddEvenPages === true) {
                writer.writeAttributeString("differentOddEven", "1");
            }
            if (advancedHeadFooterSetting_1.headerFooterDifferentFirstPage === true) {
                writer.writeAttributeString("differentFirst", "1");
            }
            if (advancedHeadFooterSetting_1.headerFooterScalesWithDocument === false) {
                writer.writeAttributeString("scaleWithDoc", "0");
            }
            if (advancedHeadFooterSetting_1.headerFooterAlignWithPageMargin === false) {
                writer.writeAttributeString("alignWithMargins", "0");
            }
        }, function () {
            if (!isNullOrWhiteSpace(advancedHeadFooterSetting_1.headerOddPage)) {
                writer.writeElementString("oddHeader", xmlEncode(advancedHeadFooterSetting_1.headerOddPage));
            }
            else if (!isNullOrWhiteSpace(setting.header)) {
                writer.writeElementString("oddHeader", xmlEncode(setting.header));
            }
            if (!isNullOrWhiteSpace(advancedHeadFooterSetting_1.footerOddPage)) {
                writer.writeElementString("oddFooter", xmlEncode(advancedHeadFooterSetting_1.footerOddPage));
            }
            else if (!isNullOrWhiteSpace(setting.footer)) {
                writer.writeElementString("oddFooter", xmlEncode(setting.footer));
            }
            if (!isNullOrWhiteSpace(advancedHeadFooterSetting_1.headerEvenPage)) {
                writer.writeElementString("evenHeader", xmlEncode(advancedHeadFooterSetting_1.headerEvenPage));
            }
            if (!isNullOrWhiteSpace(advancedHeadFooterSetting_1.footerEvenPage)) {
                writer.writeElementString("evenFooter", xmlEncode(advancedHeadFooterSetting_1.footerEvenPage));
            }
            if (!isNullOrWhiteSpace(advancedHeadFooterSetting_1.headerFirstPage)) {
                writer.writeElementString("firstHeader", advancedHeadFooterSetting_1.headerFirstPage);
            }
            if (!isNullOrWhiteSpace(advancedHeadFooterSetting_1.footerFirstPage)) {
                writer.writeElementString("firstFooter", advancedHeadFooterSetting_1.footerFirstPage);
            }
        });
    }
}
exports.writeHeadFooter = writeHeadFooter;
function writeRowOrColumnBreaks(writer, breaks, node) {
    if (breaks && breaks.length > 0) {
        writer.writeElement(node, function () {
            var breakLength = breaks.length;
            writer.writeAttributeString("count", breakLength);
            writer.writeAttributeString("manualBreakCount", breakLength);
        }, function () {
            breaks.forEach(function (item) {
                if (item > 0) {
                    writer.writeLeafElement("brk", function () {
                        writer.writeAttributeString("id", item);
                        writer.writeAttributeString("man", "1");
                        if (node === "rowBreaks") {
                            writer.writeAttributeString("max", excel_types_1.ExcelConstants._openXmlMaxRow);
                        }
                        else if (node === "colBreaks") {
                            writer.writeAttributeString("max", excel_types_1.ExcelConstants._openXmlMaxColumn);
                        }
                    });
                }
            });
        });
    }
}
function writeRowColumnBreaks(writer, sheetName, writerDataModel) {
    var setting = writerDataModel._getPrintPageSetting(sheetName);
    if (setting) {
        writeRowOrColumnBreaks(writer, setting.rowBreakLines, "rowBreaks");
        writeRowOrColumnBreaks(writer, setting.columnBreakLines, "colBreaks");
    }
}
exports.writeRowColumnBreaks = writeRowColumnBreaks;
function writeLegacyDrawingHF(writer, writerDataModel) {
    if (writerDataModel._legacyDrawingHFId) {
        writer.writeLeafElement("legacyDrawingHF", function () {
            writer.writeAttributeString('r:id', writerDataModel._legacyDrawingHFId);
        });
        writerDataModel._legacyDrawingHFId = '';
    }
}
exports.writeLegacyDrawingHF = writeLegacyDrawingHF;
function writeHeaderFooterImage(writer, image, spid, zIndex) {
    writer.writeElement("v:shape", function () {
        writer.writeAttributeString("id", image.name);
        if (image.spid) {
            writer.writeAttributeString("o:spid", image.spid);
        }
        else {
            writer.writeAttributeString("o:spid", "_x0000_s10" + spid);
        }
        writer.writeAttributeString("type", "#_x0000_t75");
        if (image.style) {
            writer.writeAttributeString("style", image.style);
        }
        else {
            writer.writeAttributeString("style", "position:absolute;margin-left:0;margin-top:0;width:100%pt;height:100%pt;z-index:" + zIndex);
        }
    }, function () {
        writer.writeLeafElement("v:imagedata", function () {
            writer.writeAttributeString("o:relid", image.rid);
            writer.writeAttributeString("o:title", image.name);
        });
        if (!image.cellRange) {
            writer.writeLeafElement("o:lock", function () {
                writer.writeAttributeString("v:ext", "edit");
                writer.writeAttributeString("rotation", "t");
            });
        }
        if (image.cellRange) {
            writer.writeElement('x:ClientData', function () {
                writer.writeAttributeString("ObjectType", "Pict");
            }, function () {
                writer.writeLeafElement('x:SizeWithCells');
                writer.writeElementString("x:Anchor", image.anchor);
                writer.writeElementString("x:FmlaPict", image.cellRange);
                writer.writeElementString("x:CF", 'Pict');
                writer.writeElementString('x:Camera', '');
            });
        }
    });
}
exports.writeVmlDrawingFile = function (headerFooterImages) {
    var writer = new xml_writer_1.XmlWriter();
    writer.writeElement("xml", function () {
        writer.writeAttributeString("xmlns:v", "urn:schemas-microsoft-com:vml");
        writer.writeAttributeString("xmlns:o", "urn:schemas-microsoft-com:office:office");
        writer.writeAttributeString("xmlns:x", "urn:schemas-microsoft-com:office:excel");
    }, function () {
        writer.writeElement("o:shapelayout", function () {
            writer.writeAttributeString("v:ext", "edit");
        }, function () {
            writer.writeLeafElement("o:idmap", function () {
                writer.writeAttributeString("v:ext", "edit");
                writer.writeAttributeString("data", "1");
            });
        });
        writer.writeElement("v:shapetype", function () {
            writer.writeAttributeString("id", "_x0000_t75");
            writer.writeAttributeString("coordsize", "21600,21600");
            writer.writeAttributeString("o:spt", "75");
            writer.writeAttributeString("o:preferrelative", "t");
            writer.writeAttributeString("path", "m@4@5l@4@11@9@11@9@5xe");
            writer.writeAttributeString("filled", "f");
            writer.writeAttributeString("stroked", "f");
        }, function () {
            writer.writeLeafElement("v:stroke", function () {
                writer.writeAttributeString("joinstyle", "miter");
            });
            writer.writeElement("v:formulas", function () {
                writer.writeLeafElement("v:f", function () {
                    writer.writeAttributeString("eqn", "if lineDrawn pixelLineWidth 0");
                });
                writer.writeLeafElement("v:f", function () {
                    writer.writeAttributeString("eqn", "sum @0 1 0");
                });
                writer.writeLeafElement("v:f", function () {
                    writer.writeAttributeString("eqn", "sum 0 0 @1");
                });
                writer.writeLeafElement("v:f", function () {
                    writer.writeAttributeString("eqn", "prod @2 1 2");
                });
                writer.writeLeafElement("v:f", function () {
                    writer.writeAttributeString("eqn", "prod @3 21600 pixelWidth");
                });
                writer.writeLeafElement("v:f", function () {
                    writer.writeAttributeString("eqn", "prod @3 21600 pixelHeight");
                });
                writer.writeLeafElement("v:f", function () {
                    writer.writeAttributeString("eqn", "sum @0 0 1");
                });
                writer.writeLeafElement("v:f", function () {
                    writer.writeAttributeString("eqn", "prod @6 1 2");
                });
                writer.writeLeafElement("v:f", function () {
                    writer.writeAttributeString("eqn", "prod @7 21600 pixelWidth");
                });
                writer.writeLeafElement("v:f", function () {
                    writer.writeAttributeString("eqn", "sum @8 21600 0");
                });
                writer.writeLeafElement("v:f", function () {
                    writer.writeAttributeString("eqn", "prod @7 21600 pixelHeight");
                });
                writer.writeLeafElement("v:f", function () {
                    writer.writeAttributeString("eqn", "sum @10 21600 0");
                });
            });
            writer.writeLeafElement("v:path", function () {
                writer.writeAttributeString("o:extrusionok", "f");
                writer.writeAttributeString("gradientshapeok", "t");
                writer.writeAttributeString("o:connecttype", "rect");
            });
            writer.writeLeafElement("o:lock", function () {
                writer.writeAttributeString("v:ext", "edit");
                writer.writeAttributeString("aspectratio", "t");
            });
        });
        var spid = 25, zIndex = 1;
        headerFooterImages.forEach(function (image) {
            if (['LH', 'CH', 'RH', 'LF', 'CF', 'RF'].indexOf(image.name) >= 0 || image.name.indexOf('Picture_x0020') !== -1) {
                writeHeaderFooterImage(writer, image, spid++, zIndex++);
            }
        });
    });
    return writer.getXmlString();
};


/***/ }),

/***/ "./src/xlsx-io/writer/sharedString-writer.ts":
/*!***************************************************!*\
  !*** ./src/xlsx-io/writer/sharedString-writer.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var style_writer_1 = __webpack_require__(/*! ./style-writer */ "./src/xlsx-io/writer/style-writer.ts");
function writeSharedString(sharedString) {
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('sst', function () {
        writer.writeAttributeString('xmlns', excel_types_1.XFileConstants._workbookNameSpace);
        writer.writeAttributeString('count', sharedString._sstTableCount.toString());
        writer.writeAttributeString('uniqueCount', sharedString._sstTable.length.toString());
    }, function () {
        var _loop_1 = function (i, len) {
            var item = sharedString._sstTable[i];
            var value = item.value;
            var keepSpace = value.length !== value.trim().length;
            writer.writeElement('si', undefined, function () {
                if (item.richText) {
                    var richText_1 = item.richText;
                    var _loop_2 = function (j) {
                        if (richText_1[j].text !== undefined) {
                            writer.writeElement('r', undefined, function () {
                                style_writer_1.writerRichTextStyle(writer, excel_style_1.ConverterHelper.fromRichTextStyle(richText_1[j].style));
                                if (richText_1[j].text) {
                                    keepSpace = richText_1[j].text.length !== richText_1[j].text.trim().length;
                                }
                                writer.writeElement('t', function () {
                                    if (keepSpace) {
                                        writer.writeAttributeString('xml:space', 'preserve');
                                    }
                                }, function () {
                                    writer.writeValue(common_1.Util._xmlEncode(common_1.Util._encodeSpecialCharacterToXML(richText_1[j].text, true)));
                                });
                            });
                        }
                    };
                    for (var j = 0; j < richText_1.length; j++) {
                        _loop_2(j);
                    }
                }
                else {
                    writer.writeElement('t', function () {
                        if (keepSpace) {
                            writer.writeAttributeString('xml:space', 'preserve');
                        }
                    }, function () {
                        writer.writeValue(common_1.Util._xmlEncode(common_1.Util._encodeSpecialCharacterToXML(value, true)));
                    });
                }
            });
        };
        for (var i = 0, len = sharedString._sstTable.length; i < len; i++) {
            _loop_1(i, len);
        }
    });
    return writer.getXmlString();
}
exports.writeSharedString = writeSharedString;


/***/ }),

/***/ "./src/xlsx-io/writer/slicer-writer.ts":
/*!*********************************************!*\
  !*** ./src/xlsx-io/writer/slicer-writer.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var pixelToEMU = excel_style_1.UnitHelper.pixelToEMU;
function writeSlicer(slicers) {
    if (common_1.isNullOrUndefined(slicers)) {
        return null;
    }
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('slicers', function () {
        writer.writeAttributeString('xmlns', excel_types_1.XFileConstants._slicerNameSpace);
        writer.writeAttributeString('xmlns:mc', excel_types_1.XFileConstants._slicerCompatibility);
        writer.writeAttributeString('mc:Ignorable', 'x');
        writer.writeAttributeString('xmlns:x', excel_types_1.XFileConstants._slicerNameSpaceX);
    }, function () {
        slicers.forEach(function (slicer) {
            writer.writeLeafElement('slicer', function () {
                writer.writeAttributeString('name', common_1.Util._replaceAll(slicer.name, '\n', '_x000a_'));
                writer.writeAttributeString('cache', slicer.nameInFormula);
                writer.writeAttributeString('caption', slicer.captionName);
                if (!common_1.isNullOrUndefined(slicer.columnCount)) {
                    writer.writeAttributeString('columnCount', slicer.columnCount);
                }
                if (!common_1.isNullOrUndefined(slicer.showHeader) && !slicer.showHeader) {
                    writer.writeAttributeString('showCaption', '0');
                }
                writer.writeAttributeString('style', slicer.style.name);
                var rowHight = 241300;
                if (slicer.itemHeight) {
                    rowHight = pixelToEMU(slicer.itemHeight);
                }
                writer.writeAttributeString('rowHeight', rowHight);
                if (slicer.disableResizingAndMoving) {
                    writer.writeAttributeString('lockedPosition', '1');
                }
            });
        });
    });
    return writer.getXmlString();
}
exports.writeSlicer = writeSlicer;
function getTableId(tableName, tables) {
    var tableId = null;
    tables.forEach(function (table) {
        if (table.name === tableName) {
            tableId = table.id;
        }
    });
    return tableId;
}
function getTableColumnId(tableColumnName, tableName, tables) {
    var columnID = null;
    tables.forEach(function (table) {
        if (table.name === tableName) {
            table.columns.forEach(function (column) {
                if (column.name === tableColumnName) {
                    columnID = column.id;
                }
            });
        }
    });
    return columnID;
}
function writeSlicerCache(slicer, tables) {
    if (common_1.isNullOrUndefined(slicer)) {
        return null;
    }
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('slicerCacheDefinition', function () {
        writer.writeAttributeString('xmlns', excel_types_1.XFileConstants._slicerNameSpace);
        writer.writeAttributeString('xmlns:mc', excel_types_1.XFileConstants._slicerCompatibility);
        writer.writeAttributeString('mc:Ignorable', 'x');
        writer.writeAttributeString('xmlns:x', excel_types_1.XFileConstants._slicerNameSpaceX);
        writer.writeAttributeString('name', slicer.nameInFormula);
        writer.writeAttributeString('sourceName', slicer.sourceName);
    }, function () {
        writer.writeElement('extLst', function () {
        }, function () {
            writer.writeElement('x:ext', function () {
                writer.writeAttributeString('uri', '{2F2917AC-EB37-4324-AD4E-5DD8C200BD13}');
                writer.writeAttributeString('xmlns:x15', excel_types_1.XFileConstants._relationship_spreadsheetml_201011);
            }, function () {
                writer.writeLeafElement('x15:tableSlicerCache', function () {
                    writer.writeAttributeString("tableId", getTableId(slicer.tableName, tables));
                    writer.writeAttributeString("column", getTableColumnId(slicer.columnName, slicer.tableName, tables));
                    if (slicer.sortState === 2) {
                        writer.writeAttributeString("sortOrder", "descending");
                    }
                    if (slicer.visuallyNoDataItems === false) {
                        writer.writeAttributeString("crossFilter", "none");
                    }
                    else if (slicer.showNoDataItemsInLast === false) {
                        writer.writeAttributeString("crossFilter", "showItemsWithNoData");
                    }
                });
            });
            if (slicer.showNoDataItems === false) {
                writer.writeElement('x:ext', function () {
                    writer.writeAttributeString("uri", "{470722E0-AACD-4C17-9CDC-17EF765DBC7E}");
                    writer.writeAttributeString("xmlns:x15", excel_types_1.XFileConstants._relationship_spreadsheetml_201011);
                }, function () {
                    writer.writeLeafElement("x15:slicerCacheHideItemsWithNoData", function () {
                    });
                });
            }
        });
    });
    return writer.getXmlString();
}
exports.writeSlicerCache = writeSlicerCache;
function writeSlicersInWorkSheet(writer, sheetName, model) {
    var slicers = model._getSlicers(sheetName);
    if (!slicers || slicers.length === 0) {
        return;
    }
    writer.writeElement('ext', function () {
        writer.writeAttributeString("uri", "{3A4CF648-6AED-40f4-86FF-DC5316D8AED3}");
        writer.writeAttributeString("xmlns:x15", excel_types_1.XFileConstants._relationship_spreadsheetml_201011);
    }, function () {
        writer.writeElement('x14:slicerList', function () {
            writer.writeAttributeString("xmlns:x14", excel_types_1.XFileConstants._slicerNameSpace);
        }, function () {
            if (slicers[0].rid) {
                writer.writeLeafElement('x14:slicer', function () {
                    writer.writeAttributeString("r:id", slicers[0].rid);
                });
            }
        });
    });
}
exports.writeSlicersInWorkSheet = writeSlicersInWorkSheet;
function writeSlicerCacheInWorkbook(writer, slicers) {
    writer.writeElement('extLst', function () {
    }, function () {
        writer.writeElement('ext', function () {
            writer.writeAttributeString("uri", "{46BE6895-7355-4a93-B00E-2C351335B9C9}");
            writer.writeAttributeString("xmlns:x15", excel_types_1.XFileConstants._relationship_spreadsheetml_201011);
        }, function () {
            writer.writeElement('x15:slicerCaches', function () {
                writer.writeAttributeString("xmlns:x14", excel_types_1.XFileConstants._slicerNameSpace);
            }, function () {
                for (var key in slicers) {
                    if (slicers.hasOwnProperty(key) && slicers[key] && slicers[key].length) {
                        slicers[key].forEach(function (s) {
                            if (s.cacheRid) {
                                writer.writeLeafElement('x14:slicerCache', function () {
                                    writer.writeAttributeString("r:id", s.cacheRid);
                                });
                            }
                        });
                    }
                }
            });
        });
    });
}
exports.writeSlicerCacheInWorkbook = writeSlicerCacheInWorkbook;
function writeSlicerDrawings(writer, slicers, writeAnchorPoint) {
    slicers.forEach(function (slicer) {
        writeTwoCellAnchorSlicer(writer, slicer, writeAnchorPoint);
    });
}
exports.writeSlicerDrawings = writeSlicerDrawings;
function writeTwoCellAnchorSlicer(writer, slicer, writeAnchorPoint) {
    var twoCellAnchor = slicer && slicer.twoCellAnchor;
    if (twoCellAnchor) {
        writer.writeElement('xdr:twoCellAnchor', function () {
            if (!slicer.dynamicMove) {
                writer.writeAttributeString("editAs", "absolute");
            }
            else if (!slicer.dynamicSize) {
                writer.writeAttributeString("editAs", "oneCell");
            }
        }, function () {
            writeAnchorPoint(writer, 'xdr:from', twoCellAnchor.startPoint);
            writeAnchorPoint(writer, 'xdr:to', twoCellAnchor.endPoint);
            writeAlternateContent(writer, slicer);
            writeClientDataSlicer(writer, slicer);
        });
    }
}
function writeClientDataSlicer(writer, slicer) {
    writer.writeLeafElement('xdr:clientData', function () {
        if (!slicer.isLocked) {
            writer.writeAttributeString("fLocksWithSheet", "0");
        }
    });
}
function writeAlternateContent(writer, slicer) {
    writer.writeElement('mc:AlternateContent', function () {
        writer.writeAttributeString("xmlns:mc", excel_types_1.XFileConstants._slicerCompatibility);
    }, function () {
        writeChoice(writer, slicer);
        writeFallback(writer);
    });
}
function writeChoice(writer, slicer) {
    writer.writeElement('mc:Choice', function () {
        writer.writeAttributeString("xmlns:sle15", "http://schemas.microsoft.com/office/drawing/2012/slicer");
        writer.writeAttributeString("Requires", "sle15");
    }, function () {
        writegGraphicFrame(writer, slicer);
    });
}
function writegGraphicFrame(writer, slicer) {
    writer.writeElement('xdr:graphicFrame', function () {
        writer.writeAttributeString("macro", "");
    }, function () {
        writeNvGraphicFramePr(writer, slicer);
        writeXfrm(writer);
        writeGraphic(writer, slicer);
    });
}
function writeNvGraphicFramePr(writer, slicer) {
    writer.writeElement('xdr:nvGraphicFramePr', function () {
    }, function () {
        writeCNvPr(writer, slicer);
        writeCNvGraphicFramePr(writer);
    });
}
function writeXfrm(writer) {
    writer.writeElement('xdr:xfrm', function () {
    }, function () {
        writeOff(writer);
        writeExt(writer);
    });
}
function writeGraphic(writer, slicer) {
    writer.writeElement('a:graphic', function () {
    }, function () {
        writeGraphicData(writer, slicer);
    });
}
function writeCNvPr(writer, slicer) {
    writer.writeLeafElement('xdr:cNvPr', function () {
        writer.writeAttributeString("id", "2");
        writer.writeAttributeString("name", common_1.Util._replaceAll(slicer.name, '\n', '&#xA;'));
    });
}
function writeOff(writer) {
    writer.writeLeafElement('a:off', function () {
        writer.writeAttributeString("x", "0");
        writer.writeAttributeString("y", "0");
    });
}
function writeExt(writer) {
    writer.writeLeafElement('a:ext', function () {
        writer.writeAttributeString("cx", "0");
        writer.writeAttributeString("cy", "0");
    });
}
function writeGraphicData(writer, slicer) {
    writer.writeElement('a:graphicData', function () {
        writer.writeAttributeString("uri", "http://schemas.microsoft.com/office/drawing/2010/slicer");
    }, function () {
        writeSleSlicer(writer, slicer);
    });
}
function writeSleSlicer(writer, slicer) {
    writer.writeLeafElement('sle:slicer', function () {
        writer.writeAttributeString("xmlns:sle", "http://schemas.microsoft.com/office/drawing/2010/slicer");
        writer.writeAttributeString("name", common_1.Util._replaceAll(slicer.name, '\n', '&#xA;'));
    });
}
function writeCNvGraphicFramePr(writer) {
    writer.writeLeafElement('xdr:cNvGraphicFramePr');
}
function writeFallback(writer) {
    writer.writeElement('mc:Fallback', function () {
        writer.writeAttributeString("xmlns", "");
    }, function () {
        writeSp(writer);
    });
}
function writeSp(writer) {
    writer.writeElement('xdr:sp', function () {
        writer.writeAttributeString("macro", "");
        writer.writeAttributeString("textlink", "");
    }, function () {
        writeNvSpPr(writer);
        writeSpPr(writer);
        writeTxBody(writer);
    });
}
function writeNvSpPr(writer) {
    writer.writeElement('xdr:nvSpPr', function () {
    }, function () {
        writeCNvPrFallback(writer);
        writeCNvSpPr(writer);
    });
}
function writeCNvPrFallback(writer) {
    writer.writeLeafElement('xdr:cNvPr', function () {
        writer.writeAttributeString("id", "0");
        writer.writeAttributeString("name", "");
    });
}
function writeCNvSpPr(writer) {
    writer.writeElement('xdr:cNvSpPr', function () {
    }, function () {
        writeSpLocks(writer);
    });
}
function writeSpLocks(writer) {
    writer.writeLeafElement('a:spLocks', function () {
        writer.writeAttributeString("noTextEdit", "1");
    });
}
function writeSpPr(writer) {
    writer.writeElement('xdr:spPr', function () {
    }, function () {
        writeXfrmFallback(writer);
        writePrstGeom(writer);
        writeSolidFill(writer);
        writeLn(writer);
    });
}
function writeXfrmFallback(writer) {
    writer.writeElement('a:xfrm', function () {
    }, function () {
        writeOffFallback(writer);
        writeExtFallback(writer);
    });
}
function writeOffFallback(writer) {
    writer.writeLeafElement('a:off', function () {
        writer.writeAttributeString("x", "5486400");
        writer.writeAttributeString("y", "942975");
    });
}
function writeExtFallback(writer) {
    writer.writeLeafElement('a:ext', function () {
        writer.writeAttributeString("cx", "1828800");
        writer.writeAttributeString("cy", "2524125");
    });
}
function writePrstGeom(writer) {
    writer.writeElement('a:prstGeom', function () {
        writer.writeAttributeString("prst", "rect");
    }, function () {
        writeAvLst(writer);
    });
}
function writeAvLst(writer) {
    writer.writeLeafElement('a:avLst');
}
function writeSolidFill(writer) {
    writer.writeElement('a:solidFill', function () {
    }, function () {
        writePrstClr(writer);
    });
}
function writePrstClr(writer) {
    writer.writeLeafElement('a:prstClr', function () {
        writer.writeAttributeString("val", "white");
    });
}
function writeLn(writer) {
    writer.writeElement('a:ln', function () {
        writer.writeAttributeString("w", "1");
    }, function () {
        writeSolidFillLn(writer);
    });
}
function writeSolidFillLn(writer) {
    writer.writeElement('a:solidFill', function () {
    }, function () {
        writePrstClrLn(writer);
    });
}
function writePrstClrLn(writer) {
    writer.writeLeafElement('a:prstClr', function () {
        writer.writeAttributeString("val", "green");
    });
}
function writeTxBody(writer) {
    writer.writeElement('xdr:txBody', function () {
    }, function () {
        writeBodyPr(writer);
        writeLstStyle(writer);
        writeP(writer);
    });
}
function writeBodyPr(writer) {
    writer.writeLeafElement('a:bodyPr', function () {
        writer.writeAttributeString("vertOverflow", "clip");
        writer.writeAttributeString("horzOverflow", "clip");
    });
}
function writeLstStyle(writer) {
    writer.writeLeafElement('a:lstStyle');
}
function writeP(writer) {
    writer.writeElement('a:p', function () {
    }, function () {
        writeR(writer);
    });
}
function writeR(writer) {
    writer.writeElement('a:r', function () {
    }, function () {
        writeRPr(writer);
        writeT(writer);
    });
}
function writeRPr(writer) {
    writer.writeLeafElement('a:rPr', function () {
        writer.writeAttributeString("lang", "en-US");
        writer.writeAttributeString("sz", "1100");
    });
}
function writeT(writer) {
    var notSupportSlicerNotice = "This shape represents a table slicer. Table slicers are supported in Excel or later.    If the shape was modified in an earlier version of Excel, or if the workbook was saved in Excel 2007 or earlier, the slicer can't be used.";
    writer.writeElement('a:t', function () {
        writer.writeValue(notSupportSlicerNotice);
    });
}


/***/ }),

/***/ "./src/xlsx-io/writer/sparkline-writer.ts":
/*!************************************************!*\
  !*** ./src/xlsx-io/writer/sparkline-writer.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var range_parser_1 = __webpack_require__(/*! ./../../common/range-parser */ "./src/common/range-parser.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var color_writer_1 = __webpack_require__(/*! ./../common/color-writer */ "./src/xlsx-io/common/color-writer.ts");
var getSheetName = common_1.IndexHelper._getSheetName;
function writeSparkline(writer, sheetName, writerDataModel) {
    if (!writerDataModel._getSparklineGroups(sheetName) || writerDataModel._getSparklineGroups(sheetName).length < 1) {
        return;
    }
    writer.writeElement('ext', function () {
        writer.writeAttributeString('uri', '{05C60535-1F16-4fd2-B633-F4F36F0B64E0}');
        writer.writeAttributeString('xmlns:x14', excel_types_1.XFileConstants._extensionListNameSpace);
    }, function () {
        writeSparklineGroups(writer, sheetName, writerDataModel);
    });
}
exports.writeSparkline = writeSparkline;
function writeSparklineGroups(writer, sheetName, writerDataModel) {
    writer.writeElement('x14:sparklineGroups', function () {
        writer.writeAttributeString('xmlns:xm', excel_types_1.XFileConstants._sparklineGroupsNameSpace);
    }, function () {
        var sparklineGroup = writerDataModel._getSparklineGroups(sheetName);
        if (sparklineGroup.length > 0) {
            sparklineGroup.forEach(function (spGroup) {
                writeSparklineGroup(writer, sheetName, spGroup);
            });
        }
    });
}
exports.writeSparklineGroups = writeSparklineGroups;
var ExcelSparklineType = {
    0: 'line',
    1: 'column',
    2: 'stacked'
};
var ExcelSparklineEmptyCellDisplayAs = {
    2: 'span',
    0: 'gap',
    1: 'zero'
};
var ExcelSparklineAxisMinMax = {
    0: 'individual',
    1: 'group',
    2: 'custom'
};
function writeSparklineGroup(writer, sheetName, sparklineGroup) {
    writer.writeElement('x14:sparklineGroup', function () {
        var setting = sparklineGroup && sparklineGroup.setting;
        if (sparklineGroup.sparklineType) {
            writer.writeAttributeString('type', ExcelSparklineType[sparklineGroup.sparklineType]);
        }
        if (sparklineGroup.displayDateAxis) {
            writer.writeAttributeString('dateAxis', '1');
        }
        if (!common_1.isNullOrUndefined(setting)) {
            if (!common_1.isNullOrUndefined(setting.lineWeight) && (setting.lineWeight.toString() * 3 / 4.0 - 0.75 > 0.001)) {
                writer.writeAttributeString('lineWeight', setting.lineWeight.toString()) * 3 / 4.0;
            }
            if (setting.displayEmptyCellsAs) {
                writer.writeAttributeString('displayEmptyCellsAs', ExcelSparklineEmptyCellDisplayAs[setting.displayEmptyCellsAs]);
            }
            else {
                writer.writeAttributeString('displayEmptyCellsAs', ExcelSparklineEmptyCellDisplayAs[0]);
            }
            if (setting.showMarkers) {
                writer.writeAttributeString('markers', '1');
            }
            if (setting.showHigh) {
                writer.writeAttributeString('high', '1');
            }
            if (setting.showLow) {
                writer.writeAttributeString('low', '1');
            }
            if (setting.showFirst) {
                writer.writeAttributeString('first', '1');
            }
            if (setting.showLast) {
                writer.writeAttributeString('last', '1');
            }
            if (setting.showNegative) {
                writer.writeAttributeString('negative', '1');
            }
            if (setting.displayXAxis) {
                writer.writeAttributeString('displayXAxis', '1');
            }
            if (setting.displayHidden) {
                writer.writeAttributeString('displayHidden', '1');
            }
            if (setting.rightToLeft) {
                writer.writeAttributeString('rightToLeft', '1');
            }
            if (setting.minAxisType) {
                writer.writeAttributeString('minAxisType', ExcelSparklineAxisMinMax[setting.minAxisType]);
            }
            if (setting.maxAxisType) {
                writer.writeAttributeString('maxAxisType', ExcelSparklineAxisMinMax[setting.maxAxisType]);
            }
            if (setting.manualMin) {
                writer.writeAttributeString('manualMin', setting.manualMin);
            }
            if (setting.manualMax) {
                writer.writeAttributeString('manualMax', setting.manualMax);
            }
        }
    }, function () {
        var setting = sparklineGroup && sparklineGroup.setting;
        var color;
        color = excel_style_1.ColorHelper.toExcelColor(setting.seriesColor || "rgba(36,64,98,1.0)");
        color_writer_1.writeColor(writer, 'x14:colorSeries', color);
        color = excel_style_1.ColorHelper.toExcelColor(setting.negativeColor || "brown");
        color_writer_1.writeColor(writer, 'x14:colorNegative', color);
        color = excel_style_1.ColorHelper.toExcelColor(setting.axisColor || "black");
        color_writer_1.writeColor(writer, 'x14:colorAxis', color);
        color = excel_style_1.ColorHelper.toExcelColor(setting.markersColor || "rgba(36,64,98,1.0)");
        color_writer_1.writeColor(writer, 'x14:colorMarkers', color);
        color = excel_style_1.ColorHelper.toExcelColor(setting.firstMarkerColor || "rgba(149,179,215,1.0)");
        color_writer_1.writeColor(writer, 'x14:colorFirst', color);
        color = excel_style_1.ColorHelper.toExcelColor(setting.lastMarkerColor || "rgba(149,179,215,1.0)");
        color_writer_1.writeColor(writer, 'x14:colorLast', color);
        color = excel_style_1.ColorHelper.toExcelColor(setting.highMarkerColor || "blue");
        color_writer_1.writeColor(writer, 'x14:colorHigh', color);
        color = excel_style_1.ColorHelper.toExcelColor(setting.lowMarkerColor || "blue");
        color_writer_1.writeColor(writer, 'x14:colorLow', color);
        if (sparklineGroup.displayDateAxis && sparklineGroup.axisReference) {
            writer.writeElement('xm:f', function () {
                writer.writeValue(convertRangeToExString(sparklineGroup.axisReference.sheetName || sheetName, sparklineGroup.axisReference));
            });
        }
        if (sparklineGroup.sparklines && sparklineGroup.sparklines.length > 0) {
            writer.writeElement('x14:sparklines', function () {
                sparklineGroup.sparklines.forEach(function (sparkline) {
                    sparklineWrite(writer, sheetName, sparkline);
                });
            });
        }
    });
}
exports.writeSparklineGroup = writeSparklineGroup;
function sparklineWrite(writer, sheetName, sparkline) {
    writer.writeElement('x14:sparkline', function () {
        if (!common_1.isNullOrUndefined(sparkline.data)) {
            writer.writeElement('xm:f', function () {
            }, function () {
                writer.writeValue(convertRangeToExString(sparkline.data.sheetName || sheetName, sparkline.data));
            });
            writer.writeElement('xm:sqref', function () {
            }, function () {
                writer.writeValue(range_parser_1.getRangeString([{ row: sparkline.row, col: sparkline.col, rowCount: 1, colCount: 1 }]));
            });
        }
    });
}
function convertRangeToExString(sheetName, range) {
    return getSheetName(sheetName) + '!' + range_parser_1.getRangeString([range]);
}


/***/ }),

/***/ "./src/xlsx-io/writer/style-writer.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/writer/style-writer.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var tuple_1 = __webpack_require__(/*! ./../../common/tuple */ "./src/common/tuple.ts");
var excel_style_1 = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var excelStyle = __webpack_require__(/*! ./../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var color_writer_1 = __webpack_require__(/*! ./../common/color-writer */ "./src/xlsx-io/common/color-writer.ts");
var keyword_undefined = void 0;
var SpreadJSTableThemeType2ExcelThemeType = {
    wholeSlicerStyle: 'wholeTable',
    headerStyle: 'headerRow',
    wholeTableStyle: 'wholeTable',
    headerRowStyle: 'headerRow',
    footerRowStyle: 'totalRow',
    highlightFirstColumnStyle: 'firstColumn',
    highlightLastColumnStyle: 'lastColumn',
    firstRowStripStyle: 'firstRowStripe',
    secondRowStripStyle: 'secondRowStripe',
    firstColumnStripStyle: 'firstColumnStripe',
    secondColumnStripStyle: 'secondColumnStripe',
    firstHeaderCellStyle: 'firstHeaderCell',
    lastHeaderCellStyle: 'lastHeaderCell',
    firstFooterCellStyle: 'firstTotalCell',
    lastFooterCellStyle: 'lastTotalCell',
    reportFilterLabelsStyle: 'pageFieldLabels',
    reportFilterValuesStyle: 'pageFieldValues',
    firstRowStripeStyle: 'firstRowStripe',
    secondRowStripeStyle: 'secondRowStripe',
    firstColumnStripeStyle: 'firstColumnStripe',
    secondColumnStripeStyle: 'secondColumnStripe',
    subtotalColumn1Style: 'firstSubtotalColumn',
    subtotalColumn2Style: 'secondSubtotalColumn',
    subtotalColumn3Style: 'thirdSubtotalColumn',
    subtotalRow1Style: 'firstSubtotalRow',
    subtotalRow2Style: 'secondSubtotalRow',
    subtotalRow3Style: 'thirdSubtotalRow',
    columnSubheading1Style: 'firstColumnSubheading',
    columnSubheading2Style: 'secondColumnSubheading',
    columnSubheading3Style: 'thirdColumnSubheading',
    rowSubheading1Style: 'firstRowSubheading',
    rowSubheading2Style: 'secondRowSubheading',
    rowSubheading3Style: 'thirdRowSubheading',
    blankRowStyle: 'blankRow',
    grandTotalColumnStyle: 'lastColumn',
    grandTotalRowStyle: 'totalRow',
    firstHeaderCellStyleL: 'firstHeaderCell',
    firstColumnStyle: 'firstColumn'
};
var SpreadJSSlicerThemeType2ExcelThemeType = {
    selectedItemWithDataStyle: 'selectedItemWithData',
    selectedItemWithNoDataStyle: "selectedItemWithNoData",
    unSelectedItemWithDataStyle: "unselectedItemWithData",
    unSelectedItemWithNoDataStyle: "unselectedItemWithNoData",
    hoveredSelectedItemWithDataStyle: "hoveredSelectedItemWithData",
    hoveredSelectedItemWithNoDataStyle: "hoveredSelectedItemWithNoData",
    hoveredUnSelectedItemWithDataStyle: "hoveredUnselectedItemWithData",
    hoveredUnSelectedItemWithNoDataStyle: "hoveredUnselectedItemWithNoData"
};
function writeStyle(writerDataModel, xfMap) {
    var styleObject = generateExcelStyle(writerDataModel, xfMap);
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('styleSheet', function () {
        writer.writeAttributeString('xmlns', excel_types_1.XFileConstants._workbookNameSpace);
        writer.writeAttributeString('xmlns:mc', excel_types_1.XFileConstants._markupCompatibility);
        writer.writeAttributeString('xmlns:x14ac', excel_types_1.XFileConstants._ac);
        writer.writeAttributeString('mc:Ignorable', excel_types_1.XFileConstants._ignorable_style);
    }, function () {
        if (styleObject._numberFormats.count > 0) {
            writer.writeElement('numFmts', function () {
                writer.writeAttributeString('count', styleObject._numberFormats.count.toString());
            }, function () {
                for (var format in styleObject._numberFormats) {
                    if (styleObject._numberFormats.hasOwnProperty(format) && format !== 'count') {
                        writeNumFmt(writer, { key: format, value: styleObject._numberFormats[format] });
                    }
                }
            });
        }
        writer.writeElement('fonts', function () {
            writer.writeAttributeString('count', styleObject._styleFonts.length.toString());
        }, function () {
            for (var i = 0, len = styleObject._styleFonts.length; i < len; i++) {
                writeFont(writer, styleObject._styleFonts[i]);
            }
        });
        writer.writeElement('fills', function () {
            writer.writeAttributeString('count', styleObject._styleFills.length.toString());
        }, function () {
            writer.writeElement('fill', keyword_undefined, function () {
                writer.writeLeafElement('patternFill', function () {
                    writer.writeAttributeString('patternType', 'none');
                });
            });
            writer.writeElement('fill', keyword_undefined, function () {
                writer.writeLeafElement('patternFill', function () {
                    writer.writeAttributeString('patternType', 'gray125');
                });
            });
            for (var i = 2; i < styleObject._styleFills.length; i++) {
                writeFill(writer, styleObject._styleFills[i]);
            }
        });
        writer.writeElement('borders', function () {
            writer.writeAttributeString('count', styleObject._styleBorders.length.toString());
        }, function () {
            for (var i = 0, len = styleObject._styleBorders.length; i < len; i++) {
                writeBorder(writer, styleObject._styleBorders[i]);
            }
        });
        writeXFs(writer, styleObject._styleXfs, 'cellStyleXfs', true);
        writeXFs(writer, styleObject._styleCellXfs, 'cellXfs', false);
        if (styleObject._styles.length === 0) {
            writeDefaultNormalStyle(writer);
        }
        else {
            var usedStyles_1 = [];
            var names = Object.keys(styleObject._cellXfsStyles);
            var namesLength = names.length;
            for (var i = 0, len = namesLength; i < len; i++) {
                var name_1 = names[i];
                var index = styleObject._cellXfsStyles[name_1];
                usedStyles_1.push(new tuple_1.Tuple(index, styleObject._styles[index], name_1));
            }
            if (usedStyles_1.length === 0) {
                writeDefaultNormalStyle(writer);
            }
            else {
                writer.writeElement('cellStyles', function () {
                    writer.writeAttributeString('count', usedStyles_1.length.toString());
                }, function () {
                    var _loop_1 = function (i, len) {
                        var item = usedStyles_1[i];
                        var style = item.item2;
                        if (style) {
                            writer.writeLeafElement('cellStyle', function () {
                                writer.writeAttributeString('name', common_1.Util._xmlEncode(item.item3));
                                writer.writeAttributeString('xfId', item.item1.toString());
                                if (style.isBuiltInStyle()) {
                                    writer.writeAttributeString('builtinId', style.builtInStyle.toString());
                                    if (style.isCustomBuiltin) {
                                        writer.writeAttributeString('customBuiltin', '1');
                                    }
                                    if (style.builtInStyle === 1 || style.builtInStyle === 2) {
                                        writer.writeAttributeString('iLevel', style.outLineLevel.toString());
                                    }
                                }
                            });
                        }
                        else {
                            writer.writeLeafElement('cellStyle', function () {
                                writer.writeAttributeString('name', item.item3);
                                writer.writeAttributeString('xfId', item.item1.toString());
                            });
                        }
                    };
                    for (var i = 0, len = usedStyles_1.length; i < len; i++) {
                        _loop_1(i, len);
                    }
                });
            }
        }
        writeDifferentialFormattings(writer, writerDataModel);
        if (writerDataModel._customerTableStyles.length > 0) {
            writer.writeElement('tableStyles', function () {
                writer.writeAttributeString('count', writerDataModel._customerTableStyles.length);
                writer.writeAttributeString('defaultTableStyle', 'TableStyleMedium2');
                writer.writeAttributeString('defaultPivotStyle', 'PivotStyleMedium9');
            }, function () {
                var customerTableStyles = writerDataModel._customerTableStyles;
                if (customerTableStyles) {
                    customerTableStyles.forEach(function (customerTableStyle) {
                        writer.writeElement('tableStyle', function () {
                            writer.writeAttributeString('name', customerTableStyle.name);
                            if (customerTableStyle.isPivot) {
                                writer.writeAttributeString('table', '0');
                            }
                            else {
                                writer.writeAttributeString('pivot', '0');
                                if (!common_1.isNullOrUndefined(customerTableStyle.tableId)) {
                                    writer.writeAttributeString('table', customerTableStyle.tableId);
                                }
                            }
                            writer.writeAttributeString('count', customerTableStyle.styleElements.length);
                        }, function () {
                            if (customerTableStyle.styleElements && customerTableStyle.styleElements.length > 0) {
                                customerTableStyle.styleElements.forEach(function (styleElement) {
                                    writer.writeLeafElement('tableStyleElement', function () {
                                        writer.writeAttributeString('type', SpreadJSTableThemeType2ExcelThemeType[styleElement.type]);
                                        writer.writeAttributeString('dxfId', styleElement.dxfId);
                                        if (!common_1.isNullOrUndefined(styleElement.size)) {
                                            writer.writeAttributeString('size', styleElement.size);
                                        }
                                    });
                                });
                            }
                        });
                    });
                }
            });
        }
        else {
            writer.writeLeafElement('tableStyles', function () {
                writer.writeAttributeString('count', '0');
                writer.writeAttributeString('defaultTableStyle', 'TableStyleMedium2');
                writer.writeAttributeString('defaultPivotStyle', 'PivotStyleLight16');
            });
        }
        if (writerDataModel._customerSlicerStyles.length > 0) {
            writer.writeElement('extLst', function () {
                writeSlicerDxfs(writer, writerDataModel);
                writeSlicerStyles(writer, writerDataModel._customerSlicerStyles);
            });
        }
    });
    return { xml: writer.getXmlString(), styleOffset: styleObject._styleOffset };
}
exports.writeStyle = writeStyle;
function writeSlicerDxfs(writer, writerDataModel) {
    writer.writeElement('ext', function () {
        writer.writeAttributeString('uri', '{46F421CA-312F-682f-3DD2-61675219B42D}');
        writer.writeAttributeString('xmlns:x14', excel_types_1.XFileConstants._slicerNameSpace);
    }, function () {
        writeDifferentialFormattingsSlicer(writer, writerDataModel);
    });
}
function writeSlicerStyles(writer, slicerStyles) {
    writer.writeElement('ext', function () {
        writer.writeAttributeString('uri', '{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}');
        writer.writeAttributeString('xmlns:x14', excel_types_1.XFileConstants._slicerNameSpace);
    }, function () {
        writer.writeElement('x14:slicerStyles', function () {
            writer.writeAttributeString('defaultSlicerStyle', 'SlicerStyleLight1');
        }, function () {
            if (slicerStyles && slicerStyles.length) {
                slicerStyles.forEach(function (slicerStyle) {
                    writer.writeElement('x14:slicerStyle', function () {
                        writer.writeAttributeString('name', slicerStyle.name);
                    }, function () {
                        if (slicerStyle.styleElements && slicerStyle.styleElements.length) {
                            writer.writeElement('x14:slicerStyleElements', function () {
                                slicerStyle.styleElements.forEach(function (styleElement) {
                                    writer.writeLeafElement('x14:slicerStyleElement', function () {
                                        writer.writeAttributeString('type', SpreadJSSlicerThemeType2ExcelThemeType[styleElement.type]);
                                        writer.writeAttributeString('dxfId', styleElement.dxfId);
                                    });
                                });
                            });
                        }
                    });
                });
            }
        });
    });
}
function removeDoubleQuotationMarksIfNeeded(font) {
    var fontName = font && font.fontName;
    if (fontName) {
        if (fontName.charAt(0) === '"') {
            fontName = fontName.substr(1);
        }
        if (fontName.charAt(fontName.length - 1) === '"') {
            fontName = fontName.substring(0, fontName.length - 1);
        }
        font.fontName = fontName;
    }
    return font;
}
function generateExcelStyle(writerDataModel, xfMap) {
    var styleObject = {
        _styleOffset: 0,
        _styleFonts: [],
        _styleFills: [],
        _styleBorders: [],
        _numberFormats: { count: 0 },
        _numberFormatsMap: {},
        _styleXfs: keyword_undefined,
        _styles: keyword_undefined,
        _cellXfsStyles: writerDataModel._getExcelCellXfsStyles()
    };
    var formats = writerDataModel._getExcelCellFormats();
    var defaultCellFormat = writerDataModel._getExcelDefaultFormat();
    var styles = writerDataModel._getExcelStyles();
    if (!styles || styles.length === 0) {
        if (defaultCellFormat) {
            var defaultStyle = new excel_style_1.ExcelStyle();
            defaultStyle.builtInStyle = 0;
            defaultStyle.name = 'Normal';
            defaultStyle.format(defaultCellFormat);
            styles = [];
            styles.push(defaultStyle);
        }
        else {
            styles = [];
            styles.push(excel_style_1.BuiltInExcelStyles.getNormalStyle());
        }
    }
    var normal = 'Normal';
    if (styles) {
        for (var i = 0, len = styles.length; i < len; i++) {
            var item = styles[i];
            if (item.isBuiltInStyle() && item.builtInStyle === 0) {
                normal = item.name;
            }
        }
    }
    styleObject._styles = styles;
    var normalStyle = common_1.Util._firstOrDefault(styles, function (item) {
        return item.name === normal;
    }, null);
    var firstNoStyleFormat = common_1.Util._firstOrDefault(formats, function (item) {
        return !item.isStyleFormat;
    }, null);
    var firstStyleFormat = common_1.Util._firstOrDefault(formats, function (item) {
        return item.isStyleFormat;
    }, null);
    if (firstNoStyleFormat === null || !firstNoStyleFormat.equals(defaultCellFormat, true)) {
        formats.splice(0, 0, defaultCellFormat);
        styleObject._styleOffset += 1;
    }
    if (firstStyleFormat === null || !firstStyleFormat.equals(normalStyle.format())) {
        formats.splice(0, 0, normalStyle.format());
        styleObject._styleOffset += 1;
    }
    var fontId = 0, formatId = 0, fillId = 0, borderId = 0;
    var normalStyleFomat = normalStyle.format();
    var font = removeDoubleQuotationMarksIfNeeded(normalStyleFomat.fontForColumnWidth ? normalStyleFomat.fontForColumnWidth : normalStyleFomat.font);
    styleObject._styleFonts.push(font);
    var f = new excelStyle.ExcelFill();
    f.patternType = 0;
    f.bgColor = excel_style_1.ExcelColor.EmptyColor;
    f.fgColor = excel_style_1.ExcelColor.EmptyColor;
    styleObject._styleFills.push(f);
    f = new excelStyle.ExcelFill();
    f.patternType = 17;
    f.bgColor = excel_style_1.ExcelColor.EmptyColor;
    f.fgColor = excel_style_1.ExcelColor.EmptyColor;
    styleObject._styleFills.push(f);
    styleObject._styleBorders.push(new excel_style_1.ExcelBorder());
    styleObject._styleCellXfs = [];
    styleObject._styleXfs = [];
    var index = 0;
    for (var i = 0, len = formats.length; i < len; i++) {
        var style = formats[i];
        if (style.font) {
            fontId = common_1.Util._indexOf(styleObject._styleFonts, style.font);
            if (fontId === -1) {
                styleObject._styleFonts.push(removeDoubleQuotationMarksIfNeeded(style.font));
                fontId = styleObject._styleFonts.length - 1;
            }
        }
        if (style.numberFormat) {
            formatId = style.numberFormat.numberFormatId;
            if (styleObject._numberFormats[formatId] === undefined) {
                styleObject._numberFormats.count++;
            }
            styleObject._numberFormats[formatId] = common_1.Util._replaceAll(style.numberFormat.numberFormatCode, '\n', '_x000a_');
            styleObject._numberFormatsMap[style.numberFormat.numberFormatCode] = formatId;
        }
        else if (style.numberFormatIndex >= 0) {
            formatId = style.numberFormatIndex;
        }
        if (style.border) {
            borderId = common_1.Util._indexOf(styleObject._styleBorders, style.border);
            if (borderId === -1) {
                styleObject._styleBorders.push(style.border);
                borderId = styleObject._styleBorders.length - 1;
            }
        }
        if (common_1.isNullOrUndefined(style.fill) || style.fill.patternType === 0) {
            fillId = 0;
        }
        else {
            var fill = style.fill;
            fillId = common_1.Util._indexOf(styleObject._styleFills, fill);
            if (fillId === -1) {
                styleObject._styleFills.push(fill);
                fillId = styleObject._styleFills.length - 1;
            }
        }
        if (style.isStyleFormat) {
            xfMap[index++] = styleObject._styleXfs.length.toString();
            styleObject._styleXfs.push(new tuple_1.Tuple(formatId, fontId, fillId, borderId, 0, style, new tuple_1.Tuple(style.isHidden, style.isLocked)));
        }
        else {
            xfMap[index++] = styleObject._styleCellXfs.length.toString();
            styleObject._styleCellXfs.push(new tuple_1.Tuple(formatId, fontId, fillId, borderId, 0, style, new tuple_1.Tuple(style.isHidden, style.isLocked)));
        }
    }
    if (writerDataModel._pivotNumberFormats && writerDataModel._pivotNumberFormats.length > 0) {
        var pivotNumberFormats = writerDataModel._pivotNumberFormats, pivotNumberFormatsCount = pivotNumberFormats.length;
        for (var i = 0; i < pivotNumberFormatsCount; i++) {
            var pivotNumberFormat = pivotNumberFormats[i];
            var numberFormatId = void 0, numberFormatCode = void 0;
            if (pivotNumberFormat.numberFormat) {
                numberFormatId = pivotNumberFormat.numberFormat.numberFormatId;
                numberFormatCode = pivotNumberFormat.numberFormat.numberFormatCode;
            }
            else {
                numberFormatId = pivotNumberFormat.numberFormatIndex;
                numberFormatCode = excel_style_1.ExtendedNumberFormatHelper.getFormatCode(pivotNumberFormat);
            }
            if (styleObject._numberFormats[numberFormatId] === undefined) {
                styleObject._numberFormats.count++;
            }
            styleObject._numberFormats[numberFormatId] = numberFormatCode;
            styleObject._numberFormatsMap[numberFormatCode] = formatId;
        }
    }
    writerDataModel._numberFormatsMap = styleObject._numberFormatsMap;
    return styleObject;
}
function writeNumFmt(writer, format) {
    if (format.key < 0) {
        return;
    }
    writer.writeLeafElement('numFmt', function () {
        writer.writeAttributeString('numFmtId', format.key.toString());
        writer.writeAttributeString('formatCode', common_1.Util._xmlEncode(format.value.toString()));
    });
}
function writeFont(writer, font, isPartFontStyle) {
    if (!font) {
        return;
    }
    writer.writeElement('font', keyword_undefined, function () {
        if (font.isBold) {
            writer.writeLeafElement('b');
        }
        if (font.isItalic) {
            writer.writeLeafElement('i');
        }
        if (font.isStrikeOut) {
            writer.writeLeafElement('strike');
        }
        if (font.underLineStyle !== 0) {
            if (font.underLineStyle === 1) {
                writer.writeLeafElement('u');
            }
            else {
                writer.writeLeafElement('u', function () {
                    writer.writeAttributeString('val', excelStyle.UnderLineStyle[font.underLineStyle]);
                });
            }
        }
        if (!isPartFontStyle && (font.fontSize !== 0 || font.fontSize !== -1)) {
            var result_1 = font.fontSize;
            if (result_1 > 0) {
                writer.writeLeafElement('sz', function () {
                    writer.writeAttributeString('val', result_1.toString());
                });
            }
        }
        if (font.fontColor !== undefined && font.fontColor !== excel_style_1.ExcelColor.EmptyColor) {
            color_writer_1.writeColor(writer, 'color', font.fontColor);
        }
        if (!isPartFontStyle) {
            if (font.vertAlign !== 0) {
                writer.writeLeafElement('vertAlign', function () {
                    writer.writeAttributeString('val', excelStyle.VertAlign[font.vertAlign]);
                });
            }
            if (!common_1.StringEx._isNullOrWhiteSpace(font.fontName)) {
                writer.writeLeafElement('name', function () {
                    writer.writeAttributeString('val', font.fontName);
                });
            }
            if (!common_1.isNullOrUndefined(font.fontFamily) && font.fontFamily !== 0) {
                writer.writeLeafElement('family', function () {
                    writer.writeAttributeString('val', font.fontFamily.toString());
                });
            }
            if (font.charSetIndex > 0) {
                writer.writeLeafElement('charset', function () {
                    writer.writeAttributeString('val', font.charSetIndex.toString());
                });
            }
            if (font.isShadowStyle) {
                writer.writeLeafElement('shadow', function () {
                    writer.writeAttributeString('val', '1');
                });
            }
            if (font.isOutlineStyle) {
                writer.writeLeafElement('outline', function () {
                    writer.writeAttributeString('val', '1');
                });
            }
            if (font.fontScheme !== 0) {
                writer.writeLeafElement('scheme', function () {
                    writer.writeAttributeString('val', excel_style_1.FontSchemeCategory[font.fontScheme]);
                });
            }
        }
    });
}
function writerRichTextStyle(writer, font) {
    if (!font) {
        return;
    }
    writer.writeElement('rPr', keyword_undefined, function () {
        if (font.isBold) {
            writer.writeLeafElement('b');
        }
        if (font.charSetIndex > 0) {
            writer.writeLeafElement('charset', function () {
                writer.writeAttributeString('val', font.charSetIndex.toString());
            });
        }
        if (font.foreColor && font.foreColor !== excel_style_1.ExcelColor.EmptyColor) {
            color_writer_1.writeColor(writer, 'color', font.foreColor);
        }
        if (font.isCondense) {
            writer.writeLeafElement('condense');
        }
        if (font.isExtend) {
            writer.writeLeafElement('extend');
        }
        if (!common_1.isNullOrUndefined(font.fontFamilySet) && font.fontFamilySet !== 0) {
            writer.writeLeafElement('family', function () {
                writer.writeAttributeString('val', font.fontFamilySet.toString());
            });
        }
        if (font.isItalic) {
            writer.writeLeafElement('i');
        }
        if (font.isOutlineStyle) {
            writer.writeLeafElement('outline', function () {
                writer.writeAttributeString('val', '1');
            });
        }
        if (!common_1.StringEx._isNullOrWhiteSpace(font.fontFamily)) {
            writer.writeLeafElement('rFont', function () {
                writer.writeAttributeString('val', font.fontFamily);
            });
        }
        if (font.fontScheme && font.fontScheme !== 0) {
            writer.writeLeafElement('scheme', function () {
                writer.writeAttributeString('val', excel_style_1.FontSchemeCategory[font.fontScheme]);
            });
        }
        if (font.isShadowStyle) {
            writer.writeLeafElement('shadow', function () {
                writer.writeAttributeString('val', '1');
            });
        }
        if (font.isStrikeOut) {
            writer.writeLeafElement('strike');
        }
        if (font.fontSize && font.fontSize !== 0 || font.fontSize !== -1) {
            var result_2 = font.fontSize;
            if (result_2 > 0) {
                writer.writeLeafElement('sz', function () {
                    writer.writeAttributeString('val', result_2.toString());
                });
            }
        }
        if (font.underLineStyle && font.underLineStyle !== 0) {
            if (font.underLineStyle === 1) {
                writer.writeLeafElement('u');
            }
            else {
                writer.writeLeafElement('u', function () {
                    writer.writeAttributeString('val', excelStyle.UnderLineStyle[font.underLineStyle]);
                });
            }
        }
        if (font.vertAlign && font.vertAlign !== 0) {
            writer.writeLeafElement('vertAlign', function () {
                writer.writeAttributeString('val', excelStyle.VertAlign[font.vertAlign]);
            });
        }
    });
}
exports.writerRichTextStyle = writerRichTextStyle;
function writeFill(writer, fill, isDxfFill) {
    writer.writeElement('fill', keyword_undefined, function () {
        if (fill.stops) {
            writer.writeElement('gradientFill', function () {
                var keys = ["degree", "left", "right", "top", "bottom"];
                for (var i in keys) {
                    var k = keys[i];
                    if (!common_1.isNullOrUndefined(fill[k])) {
                        writer.writeAttributeString(k, fill[k]);
                    }
                }
                if (fill.type === "path") {
                    writer.writeAttributeString("type", "path");
                }
            }, function () {
                var _loop_2 = function (i) {
                    writer.writeElement('stop', function () {
                        writer.writeAttributeString('position', fill.stops[i].position);
                    }, function () {
                        color_writer_1.writeColor(writer, 'color', fill.stops[i].color);
                    });
                };
                for (var i = 0; i < fill.stops.length; i++) {
                    _loop_2(i);
                }
            });
        }
        else {
            writer.writeElement('patternFill', function () {
                writer.writeAttributeString('patternType', excelStyle.FillPatternType[fill.patternType]);
            }, function () {
                if (fill.fgColor) {
                    color_writer_1.writeColor(writer, 'fgColor', fill.fgColor);
                }
                if (fill.bgColor) {
                    color_writer_1.writeColor(writer, 'bgColor', fill.bgColor);
                }
            });
        }
    });
}
function writeBorder(writer, border, isSlicerHeader) {
    writer.writeElement('border', function () {
        if (border.diagonalDown && border.diagonalDown.color && border.diagonalDown.lineStyle) {
            writer.writeAttributeString('diagonalDown', 1);
        }
        if (border.diagonalUp && border.diagonalUp.color && border.diagonalUp.lineStyle) {
            writer.writeAttributeString('diagonalUp', 1);
        }
    }, function () {
        if (!isSlicerHeader || isSlicerHeader && border.left) {
            writeBorderSide(writer, 'left', border.left);
        }
        if (!isSlicerHeader || isSlicerHeader && border.right) {
            writeBorderSide(writer, 'right', border.right);
        }
        if (!isSlicerHeader || isSlicerHeader && border.top) {
            writeBorderSide(writer, 'top', border.top);
        }
        if (!isSlicerHeader || isSlicerHeader && border.bottom) {
            writeBorderSide(writer, 'bottom', border.bottom);
        }
        if (border.vertical) {
            writeBorderSide(writer, 'vertical', border.vertical);
        }
        if (border.horizontal) {
            writeBorderSide(writer, 'horizontal', border.horizontal);
        }
        var isDiagonalUpWrite = false;
        if (border.diagonalUp && border.diagonalUp.color && border.diagonalUp.lineStyle) {
            writeBorderSide(writer, 'diagonal', border.diagonalUp);
            isDiagonalUpWrite = true;
        }
        if (border.diagonalDown && border.diagonalDown.color && border.diagonalDown.lineStyle && !isDiagonalUpWrite) {
            writeBorderSide(writer, 'diagonal', border.diagonalDown);
        }
    });
}
function writeBorderSide(writer, node, side) {
    if (!side) {
        return;
    }
    if (side.lineStyle === 0 && !side.color) {
        writer.writeLeafElement(node);
    }
    else {
        writer.writeElement(node, function () {
            if (side.lineStyle !== 0) {
                writer.writeAttributeString('style', excelStyle.ExcelBorderStyle[side.lineStyle]);
            }
        }, function () {
            if (side.color) {
                color_writer_1.writeColor(writer, 'color', side.color);
            }
        });
    }
}
function writeXFs(writer, xfs, root, isCellStyleXfs) {
    if (xfs.length === 0) {
        writer.writeElement(root, function () {
            writer.writeAttributeString('count', '1');
        }, function () {
            writer.writeLeafElement('xf', function () {
                writer.writeAttributeString('numFmtId', '0');
                writer.writeAttributeString('fontId', '0');
                writer.writeAttributeString('fillId', '0');
                writer.writeAttributeString('borderId', '0');
                if (!isCellStyleXfs) {
                    writer.writeAttributeString('xfId', '0');
                }
            });
        });
    }
    else {
        writer.writeElement(root, function () {
            writer.writeAttributeString('count', xfs.length.toString());
        }, function () {
            var _loop_3 = function (i, len) {
                var item = xfs[i], item6 = item.item6, item7 = item.item7, hasAlignment = item6.horizontalAlign !== 0 ||
                    item6.verticalAlign !== 2 || item6.rotation !== 0 ||
                    item6.readingOrder !== 0 || item6.isWordWrap ||
                    item6.isShrinkToFit || item6.isJustfyLastLine || item6.indent > 0, hasProtection = item7 && (item7.item1 || !item7.item2), method = 'writeElement';
                if (!hasAlignment && !hasProtection) {
                    method = 'writeLeafElement';
                }
                writer[method]('xf', function () {
                    writer.writeAttributeString('numFmtId', item.item1.toString());
                    writer.writeAttributeString('fontId', item.item2.toString());
                    writer.writeAttributeString('fillId', item.item3.toString());
                    writer.writeAttributeString('borderId', item.item4.toString());
                    if (item6) {
                        if (!isCellStyleXfs) {
                            if (!item6.isStyleFormat && !common_1.isNullOrUndefined(item6.parentFormatID)) {
                                var id = item6.parentFormatID;
                                if (!common_1.isNullOrUndefined(id)) {
                                    writer.writeAttributeString('xfId', id.toString());
                                }
                                else {
                                    writer.writeAttributeString('xfId', '0');
                                }
                            }
                            else {
                                writer.writeAttributeString('xfId', '0');
                            }
                            if (!common_1.isNullOrUndefined(item6.applyFont) || item.item2 !== 0) {
                                writer.writeAttributeString('applyFont', item6.applyFont === true ? '1' : '0');
                            }
                            if (!common_1.isNullOrUndefined(item6.applyFill)) {
                                writer.writeAttributeString('applyFill', item6.applyFill === true ? '1' : '0');
                            }
                            if (!common_1.isNullOrUndefined(item6.applyBorder)) {
                                writer.writeAttributeString('applyBorder', item6.applyBorder === true ? '1' : '0');
                            }
                        }
                        else {
                            writer.writeAttributeString('applyFont', item6.applyFont === true ? '1' : '0');
                            writer.writeAttributeString('applyFill', item6.applyFill === true ? '1' : '0');
                            writer.writeAttributeString('applyBorder', item6.applyBorder === true ? '1' : '0');
                        }
                        if (!common_1.isNullOrUndefined(item6.applyNumberFormat)) {
                            writer.writeAttributeString('applyNumberFormat', item6.applyNumberFormat === true ? '1' : '0');
                        }
                        if (!common_1.isNullOrUndefined(item6.applyAlignment)) {
                            writer.writeAttributeString('applyAlignment', item6.applyAlignment === true ? '1' : '0');
                        }
                        if (!common_1.isNullOrUndefined(item6.applyProtection)) {
                            writer.writeAttributeString('applyProtection', item6.applyProtection === true ? '1' : '0');
                        }
                        if (!common_1.isNullOrUndefined(item6.quotePrefix)) {
                            writer.writeAttributeString('quotePrefix', item6.quotePrefix === true ? '1' : '0');
                        }
                    }
                }, function () {
                    if (hasAlignment) {
                        writer.writeLeafElement('alignment', function () {
                            if (item6.horizontalAlign !== 0) {
                                writer.writeAttributeString('horizontal', excelStyle.ExcelHorizontalAlignment[item6.horizontalAlign]);
                            }
                            else if (item6.horizontalAlign === 0 && item6.indent > 0) {
                                writer.writeAttributeString('horizontal', excelStyle.ExcelHorizontalAlignment[1]);
                            }
                            if (item6.verticalAlign !== 2) {
                                writer.writeAttributeString('vertical', excel_style_1.ExcelVerticalAlignment[item6.verticalAlign]);
                            }
                            if (item6.isVerticalText === true) {
                                writer.writeAttributeString('textRotation', 255);
                            }
                            else if (item6.rotation !== 0) {
                                writer.writeAttributeString('textRotation', item6.rotation.toString());
                            }
                            if (item6.readingOrder !== 0) {
                                writer.writeAttributeString('readingOrder', excelStyle.TextDirection[item6.readingOrder]);
                            }
                            if (item6.isWordWrap) {
                                writer.writeAttributeString('wrapText', '1');
                            }
                            if (item6.isShrinkToFit) {
                                writer.writeAttributeString('shrinkToFit', '1');
                            }
                            if (item6.isJustfyLastLine) {
                                writer.writeAttributeString('justifyLastLine', '1');
                            }
                            if (item6.indent > 0) {
                                writer.writeAttributeString('indent', item6.indent.toString());
                            }
                        });
                    }
                    if (hasProtection) {
                        writer.writeLeafElement('protection', function () {
                            if (!item7.item2) {
                                writer.writeAttributeString('locked', '0');
                            }
                            if (item7.item1) {
                                writer.writeAttributeString('hidden', '1');
                            }
                        });
                    }
                });
            };
            for (var i = 0, len = xfs.length; i < len; i++) {
                _loop_3(i, len);
            }
        });
    }
}
function writeDefaultNormalStyle(writer) {
    writer.writeElement('cellStyles', function () {
        writer.writeAttributeString('count', '1');
    }, function () {
        writer.writeLeafElement('cellStyle', function () {
            writer.writeAttributeString('name', 'Normal');
            writer.writeAttributeString('builtinId', '0');
            writer.writeAttributeString('xfId', '0');
        });
    });
}
function writeDifferentialFormattings(writer, writerDataModel, dxfRecords) {
    var dxfs = (dxfRecords ? dxfRecords : writerDataModel._dxfRecords);
    if (dxfs.length === 0) {
        writer.writeLeafElement('dxfs', function () {
            writer.writeAttributeString('count', '0');
        });
    }
    else {
        writer.writeElement('dxfs', function () {
            writer.writeAttributeString('count', dxfs.length);
        }, function () {
            for (var i = 0; i < dxfs.length; i++) {
                writeDxf(writer, writerDataModel, dxfs[i], 'dxf');
            }
        });
    }
}
function writeDifferentialFormattingsSlicer(writer, writerDataModel) {
    var dxfs = writerDataModel._dxfSlicerRecords;
    if (dxfs.length === 0) {
        writer.writeLeafElement('x14:dxfs', function () {
            writer.writeAttributeString('count', '0');
        });
    }
    else {
        writer.writeElement('x14:dxfs', function () {
            writer.writeAttributeString('count', dxfs.length);
        }, function () {
            for (var i = 0; i < dxfs.length; i++) {
                writeDxf(writer, writerDataModel, dxfs[i], 'dxf');
            }
        });
    }
}
function writeDxf(writer, writerDataModel, dxf, rootName) {
    writer.writeElement(rootName, function () {
        var style = dxf.isColorFilter ? dxf : excel_style_1.ConverterHelper.toDifferentialFormatting(dxf, writerDataModel);
        if (style.font) {
            writeFont(writer, style.font, style.isPartFontStyle);
        }
        if (style.numberFormat || style.numberFormatIndex >= 0) {
            var id = void 0, formatCode = void 0;
            if (style.numberFormat) {
                id = style.numberFormat.numberFormatId;
                formatCode = style.numberFormat.numberFormatCode;
            }
            else {
                id = style.numberFormatIndex;
                formatCode = style.numberFormatCode;
            }
            writeNumFmt(writer, { key: id, value: formatCode });
        }
        if (style.fill) {
            if (style.fill.patternType === 1) {
                style.fill.bgColor = style.fill.fgColor;
            }
            writeFill(writer, style.fill, true);
        }
        if (style.border) {
            writeBorder(writer, style.border, style.isSlicerHeader);
        }
    });
}
exports.writeDxf = writeDxf;


/***/ }),

/***/ "./src/xlsx-io/writer/table-writer.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/writer/table-writer.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var range_parser_1 = __webpack_require__(/*! ./../../common/range-parser */ "./src/common/range-parser.ts");
var autofilter_writer_1 = __webpack_require__(/*! ./autofilter-writer */ "./src/xlsx-io/writer/autofilter-writer.ts");
var autofilter_writer_2 = __webpack_require__(/*! ./autofilter-writer */ "./src/xlsx-io/writer/autofilter-writer.ts");
function isContainsLET(formula) {
    return formula.indexOf('LET(') > -1;
}
function writeTable(sheetTable, writerDataModel, sheetName) {
    if (common_1.isNullOrUndefined(sheetTable)) {
        return null;
    }
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('table', function () {
        writer.writeAttributeString('xmlns', excel_types_1.XFileConstants._tableNameSpace);
        writer.writeAttributeString('id', sheetTable.id);
        var tableName = sheetTable.name.split(' ').join('_');
        writer.writeAttributeString('name', tableName);
        writer.writeAttributeString('displayName', tableName.split('-').join('_'));
        writer.writeAttributeString('ref', range_parser_1.getRangeString([{
                row: sheetTable.row,
                col: sheetTable.col,
                rowCount: sheetTable.rowCount,
                colCount: sheetTable.colCount
            }]));
        if (sheetTable.showHeader === false) {
            writer.writeAttributeString('headerRowCount', '0');
        }
        if (sheetTable.showFooter) {
            writer.writeAttributeString('totalsRowCount', '1');
        }
    }, function () {
        if (sheetTable.rowFilter && !common_1.isNullOrUndefined(sheetTable.rowFilter)) {
            var sortInfo = void 0;
            var autoFilter = writerDataModel._convertAutoFilterFromJSON(sheetName, sheetTable.rowFilter, sheetTable.tableSortInfo);
            if (autoFilter && autoFilter.sortInfo) {
                sortInfo = autoFilter.sortInfo;
                autoFilter.sortInfo = null;
            }
            if (sheetTable.showHeader !== false) {
                if (!needShowFilterButton(sheetTable.rowFilter)) {
                    setAutoFilterButtonHidden(autoFilter);
                }
                autofilter_writer_1.writeAutoFilter(writer, autoFilter);
            }
            if (sortInfo) {
                autofilter_writer_2.writeSortInfo(writer, sortInfo);
            }
        }
        if (sheetTable.columns && sheetTable.columns.length > 0) {
            writer.writeElement('tableColumns', function () {
                writer.writeAttributeString('count', sheetTable.columns.length);
            }, function () {
                sheetTable.columns.forEach(function (column) {
                    var formula = convertTotalRowFunction(column.footerFormula);
                    if (formula !== 'custom') {
                        writer.writeElement('tableColumn', function () {
                            writer.writeAttributeString('id', column.id.toString());
                            var columnName = column.name;
                            columnName = common_1.Util._replaceAll(columnName, '\r', '');
                            writer.writeAttributeString('name', common_1.Util._xmlEncode(common_1.Util._replaceAll(columnName, '\n', '_x000a_')));
                            if (!common_1.isNullOrUndefined(column.footerValue)) {
                                writer.writeAttributeString('totalsRowLabel', common_1.Util._xmlEncode(common_1.Util._encodeSpecialCharacterToXML(column.footerValue.toString(), true)));
                            }
                            if (!common_1.isNullOrUndefined(column.footerFormula)) {
                                writer.writeAttributeString('totalsRowFunction', formula);
                            }
                        }, function () {
                            var dataAreaFormula = column.dataAreaFormula;
                            if (!common_1.isNullOrUndefined(dataAreaFormula) && !isContainsLET(dataAreaFormula)) {
                                writer.writeElement("calculatedColumnFormula", function () {
                                    writer.writeValue(common_1.Util._xmlEncode(common_1.addXLFNPrefix(dataAreaFormula)));
                                });
                            }
                        });
                    }
                    else {
                        writer.writeElement('tableColumn', function () {
                            writer.writeAttributeString('id', column.id.toString());
                            var columnName = column.name;
                            columnName = common_1.Util._replaceAll(columnName, '\r', '');
                            writer.writeAttributeString('name', common_1.Util._xmlEncode(common_1.Util._replaceAll(columnName, '\n', '_x000a_')));
                            writer.writeAttributeString('totalsRowFunction', 'custom');
                        }, function () {
                            var dataAreaFormula = column.dataAreaFormula;
                            if (!common_1.isNullOrUndefined(dataAreaFormula) && !isContainsLET(dataAreaFormula)) {
                                writer.writeElement("calculatedColumnFormula", function () {
                                    writer.writeValue(common_1.Util._xmlEncode(common_1.addXLFNPrefix(dataAreaFormula)));
                                });
                            }
                            writer.writeElement('totalsRowFormula', function () {
                                writer.writeValue(common_1.Util._xmlEncode(column.footerFormula));
                            });
                        });
                    }
                });
            });
        }
        writer.writeLeafElement('tableStyleInfo', function () {
            if (sheetTable.style) {
                var styleName = '';
                if (!common_1.isNullOrUndefined(sheetTable.style.buildInName)) {
                    styleName = 'TableStyle' + sheetTable.style.buildInName;
                }
                else {
                    styleName = sheetTable.style.name;
                }
                writer.writeAttributeString('name', styleName);
            }
            if (sheetTable.highlightFirstColumn) {
                writer.writeAttributeString('showFirstColumn', '1');
            }
            else {
                writer.writeAttributeString('showFirstColumn', '0');
            }
            if (sheetTable.highlightLastColumn) {
                writer.writeAttributeString('showLastColumn', '1');
            }
            else {
                writer.writeAttributeString('showLastColumn', '0');
            }
            if (!common_1.isNullOrUndefined(sheetTable.bandRows)) {
                writer.writeAttributeString('showRowStripes', '0');
            }
            else {
                writer.writeAttributeString('showRowStripes', '1');
            }
            if (sheetTable.bandColumns) {
                writer.writeAttributeString('showColumnStripes', '1');
            }
            else {
                writer.writeAttributeString('showColumnStripes', '0');
            }
        });
        if (sheetTable.reservedElement) {
            writer.writeElement('extLst', function () { }, function () {
                writer.writeElement('ext', function () {
                    if (!common_1.isNullOrUndefined(sheetTable.reservedElement.ext._attr && sheetTable.reservedElement.ext._attr.uri)) {
                        writer.writeAttributeString('uri', sheetTable.reservedElement.ext._attr.uri);
                    }
                    if (!common_1.isNullOrUndefined(sheetTable.reservedElement.ext._attr && sheetTable.reservedElement.ext._attr["xmlns:x14"])) {
                        writer.writeAttributeString('xmlns:x14', sheetTable.reservedElement.ext._attr["xmlns:x14"]);
                    }
                }, function () {
                    var vpColumns = sheetTable.reservedElement.ext["vp:columns"];
                    if (!common_1.isNullOrUndefined(vpColumns)) {
                        writer.writeElement('vp:columns', function () {
                            if (!common_1.isNullOrUndefined(vpColumns._attr && vpColumns._attr['xmlns:vp'])) {
                                writer.writeAttributeString('xmlns:vp', vpColumns._attr['xmlns:vp']);
                            }
                        }, function () {
                            if (!common_1.isNullOrUndefined(vpColumns['vp:columns'])) {
                                writer.writeValue(vpColumns['vp:columns']);
                            }
                        });
                    }
                    var x14Table = sheetTable.reservedElement.ext["x14:table"];
                    if (!common_1.isNullOrUndefined(x14Table && x14Table._attr)) {
                        writer.writeLeafElement('x14:table', function () {
                            if (!common_1.isNullOrUndefined(x14Table._attr.altText)) {
                                writer.writeAttributeString('altText', x14Table._attr.altText);
                            }
                            if (!common_1.isNullOrUndefined(x14Table._attr.altTextSummary)) {
                                writer.writeAttributeString('altTextSummary', x14Table._attr.altTextSummary);
                            }
                        });
                    }
                });
            });
        }
    });
    return writer.getXmlString();
}
exports.writeTable = writeTable;
function needShowFilterButton(rowFilter) {
    if (!rowFilter.showFilterButton) {
        return false;
    }
    var filterButtonVisibleInfo = rowFilter.filterButtonVisibleInfo;
    for (var colID in filterButtonVisibleInfo) {
        if (!filterButtonVisibleInfo.hasOwnProperty(colID)) {
            continue;
        }
        if (!filterButtonVisibleInfo[colID]) {
            return false;
        }
    }
    return true;
}
var TotalRowFunction2ExcelTotalRowFunction = {
    101: 'average',
    102: 'countNums',
    103: 'count',
    104: 'max',
    105: 'min',
    107: 'stdDev',
    109: 'sum',
    110: 'let'
};
function convertTotalRowFunction(formula) {
    if (common_1.isNullOrUndefined(formula)) {
        return;
    }
    var re = /\[\S[\S\s]*\S\]/;
    formula = formula.trim();
    if (formula.substr(0, 9) !== 'SUBTOTAL(') {
        return 'custom';
    }
    else if (!re.test(formula)) {
        return 'custom';
    }
    var formulaIndex = formula.substr(9, 3);
    return TotalRowFunction2ExcelTotalRowFunction[formulaIndex] || 'custom';
}
function setAutoFilterButtonHidden(autoFilter) {
    if (autoFilter.filterColumns.length === 0) {
        for (var i = 0; i < autoFilter.range.colCount; i++) {
            autoFilter.filterColumns.push({ autoFilterColumnId: i });
        }
    }
    autoFilter.filterColumns.forEach(function (filterColumn) {
        filterColumn.hiddenButton = '1';
    });
}


/***/ }),

/***/ "./src/xlsx-io/writer/theme-writer.ts":
/*!********************************************!*\
  !*** ./src/xlsx-io/writer/theme-writer.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var builtIn_resource_1 = __webpack_require__(/*! ./../../common/builtIn-resource */ "./src/common/builtIn-resource.ts");
var color_writer_1 = __webpack_require__(/*! ./../common/color-writer */ "./src/xlsx-io/common/color-writer.ts");
function writeTheme(writerDataModel) {
    var theme = writerDataModel._getTheme();
    if (!theme) {
        theme = 'Office';
    }
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('a:theme', function () {
        writer.writeAttributeString('xmlns:a', excel_types_1.XFileConstants._themeNameSpace);
        if (theme && theme.name) {
            writer.writeAttributeString('name', theme.name);
        }
        else if (theme === 'Office') {
            writer.writeAttributeString('name', 'Office Theme');
        }
        else {
            writer.writeAttributeString('name', theme);
        }
    }, function () {
        writer.writeElement('a:themeElements', undefined, function () {
            if (theme && theme.colorScheme) {
                var colorScheme_1 = theme.colorScheme;
                writer.writeElement('a:clrScheme', function () {
                    writer.writeAttributeString('name', colorScheme_1.name);
                }, function () {
                    color_writer_1.writeColorScheme(writer, 'a:dk1', colorScheme_1.schemeColors[1]);
                    color_writer_1.writeColorScheme(writer, 'a:lt1', colorScheme_1.schemeColors[0]);
                    color_writer_1.writeColorScheme(writer, 'a:dk2', colorScheme_1.schemeColors[3]);
                    color_writer_1.writeColorScheme(writer, 'a:lt2', colorScheme_1.schemeColors[2]);
                    color_writer_1.writeColorScheme(writer, 'a:accent1', colorScheme_1.schemeColors[4]);
                    color_writer_1.writeColorScheme(writer, 'a:accent2', colorScheme_1.schemeColors[5]);
                    color_writer_1.writeColorScheme(writer, 'a:accent3', colorScheme_1.schemeColors[6]);
                    color_writer_1.writeColorScheme(writer, 'a:accent4', colorScheme_1.schemeColors[7]);
                    color_writer_1.writeColorScheme(writer, 'a:accent5', colorScheme_1.schemeColors[8]);
                    color_writer_1.writeColorScheme(writer, 'a:accent6', colorScheme_1.schemeColors[9]);
                    color_writer_1.writeColorScheme(writer, 'a:hlink', colorScheme_1.schemeColors[10]);
                    color_writer_1.writeColorScheme(writer, 'a:folHlink', colorScheme_1.schemeColors[11]);
                });
            }
            else if (builtIn_resource_1.ThemeClrSchemes[theme]) {
                writer.xml.addString(builtIn_resource_1.ThemeClrSchemes[theme]);
            }
            else {
                writer.xml.addString(builtIn_resource_1.ThemeClrSchemes.Office);
            }
            if (theme && theme.fontScheme) {
                var fontScheme_1 = theme.fontScheme;
                writer.writeElement('a:fontScheme', function () {
                    writer.writeAttributeString('name', fontScheme_1.name);
                }, function () {
                    writer.writeElement('a:majorFont', undefined, function () {
                        writeThemeFonts(writer, fontScheme_1.majorFont, true);
                    });
                    writer.writeElement('a:minorFont', undefined, function () {
                        writeThemeFonts(writer, fontScheme_1.minorFont, false);
                    });
                });
            }
            else if (builtIn_resource_1.ThemeFontSchemes[theme]) {
                writer.xml.addString(builtIn_resource_1.ThemeFontSchemes[theme]);
            }
            else {
                writer.xml.addString(builtIn_resource_1.ThemeFontSchemes.Office);
            }
            if (builtIn_resource_1.ThemeFmtSchemes[theme]) {
                writer.xml.addString(builtIn_resource_1.ThemeFmtSchemes[theme]);
            }
            else {
                writer.xml.addString(builtIn_resource_1.ThemeFmtSchemes.Office);
            }
        });
        writer.writeLeafElement('a:objectDefaults', undefined);
        writer.writeLeafElement('a:extraClrSchemeLst', undefined);
    });
    return writer.getXmlString();
}
exports.writeTheme = writeTheme;
function writeThemeFonts(writer, themeFonts, isMajorFont) {
    if (!themeFonts) {
        return;
    }
    if (themeFonts.runFormattings) {
        writer.writeLeafElement('a:' + excel_types_1.FontLanguage[0], function () {
            writer.writeAttributeString('typeface', getRunFormattingTypeface(themeFonts.runFormattings, 0));
        });
        writer.writeLeafElement('a:' + excel_types_1.FontLanguage[2], function () {
            writer.writeAttributeString('typeface', getRunFormattingTypeface(themeFonts.runFormattings, 2));
        });
        writer.writeLeafElement('a:' + excel_types_1.FontLanguage[1], function () {
            writer.writeAttributeString('typeface', getRunFormattingTypeface(themeFonts.runFormattings, 1));
        });
    }
    if (themeFonts.themesFonts && themeFonts.themesFonts.length > 0) {
        var _loop_1 = function (i, len) {
            var item = themeFonts.themesFonts[i];
            writer.writeLeafElement('a:font', function () {
                writer.writeAttributeString('script', item.script);
                writer.writeAttributeString('script', item.typeface);
            });
        };
        for (var i = 0, len = themeFonts.themesFonts.length; i < len; i++) {
            _loop_1(i, len);
        }
    }
    else if (isMajorFont) {
        writeDefaultMajorFonts(writer);
    }
    else {
        writeDefaultMinorFonts(writer);
    }
}
exports.writeThemeFonts = writeThemeFonts;
function writeDefaultMajorFonts(writer) {
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Jpan');
        writer.writeAttributeString('typeface', '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Hang');
        writer.writeAttributeString('typeface', '\ub9d1\uc740 \uace0\ub515');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Hans');
        writer.writeAttributeString('typeface', '\u5b8b\u4f53');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Hant');
        writer.writeAttributeString('typeface', '\u65b0\u7d30\u660e\u9ad4');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Arab');
        writer.writeAttributeString('typeface', 'Times New Roman');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Hebr');
        writer.writeAttributeString('typeface', 'Times New Roman');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Thai');
        writer.writeAttributeString('typeface', 'Tahoma');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Ethi');
        writer.writeAttributeString('typeface', 'Nyala');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Beng');
        writer.writeAttributeString('typeface', 'Vrinda');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Gujr');
        writer.writeAttributeString('typeface', 'Shruti');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Khmr');
        writer.writeAttributeString('typeface', 'MoolBoran');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Knda');
        writer.writeAttributeString('typeface', 'Tunga');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Guru');
        writer.writeAttributeString('typeface', 'Raavi');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Cans');
        writer.writeAttributeString('typeface', 'Euphemia');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Cher');
        writer.writeAttributeString('typeface', 'Plantagenet Cherokee');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Yiii');
        writer.writeAttributeString('typeface', 'Microsoft Yi Baiti');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Tibt');
        writer.writeAttributeString('typeface', 'Microsoft Himalaya');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Thaa');
        writer.writeAttributeString('typeface', 'MV Boli');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Deva');
        writer.writeAttributeString('typeface', 'Mangal');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Telu');
        writer.writeAttributeString('typeface', 'Gautami');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Taml');
        writer.writeAttributeString('typeface', 'Latha');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Syrc');
        writer.writeAttributeString('typeface', 'Estrangelo Edessa');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Orya');
        writer.writeAttributeString('typeface', 'Kalinga');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Mlym');
        writer.writeAttributeString('typeface', 'Kartika');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Laoo');
        writer.writeAttributeString('typeface', 'DokChampa');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Sinh');
        writer.writeAttributeString('typeface', 'Iskoola Pota');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Mong');
        writer.writeAttributeString('typeface', 'Mongolian Baiti');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Viet');
        writer.writeAttributeString('typeface', 'Times New Roman');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Uigh');
        writer.writeAttributeString('typeface', 'Microsoft Uighur');
    });
}
function writeDefaultMinorFonts(writer) {
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Jpan');
        writer.writeAttributeString('typeface', '\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Hang');
        writer.writeAttributeString('typeface', '\ub9d1\uc740 \uace0\ub515');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Hans');
        writer.writeAttributeString('typeface', '\u5b8b\u4f53');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Hant');
        writer.writeAttributeString('typeface', '\u65b0\u7d30\u660e\u9ad4');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Arab');
        writer.writeAttributeString('typeface', 'Arial');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Hebr');
        writer.writeAttributeString('typeface', 'Arial');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Thai');
        writer.writeAttributeString('typeface', 'Tahoma');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Ethi');
        writer.writeAttributeString('typeface', 'Nyala');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Beng');
        writer.writeAttributeString('typeface', 'Vrinda');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Gujr');
        writer.writeAttributeString('typeface', 'Shruti');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Khmr');
        writer.writeAttributeString('typeface', 'DaunPenh');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Knda');
        writer.writeAttributeString('typeface', 'Tunga');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Guru');
        writer.writeAttributeString('typeface', 'Raavi');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Cans');
        writer.writeAttributeString('typeface', 'Euphemia');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Cher');
        writer.writeAttributeString('typeface', 'Plantagenet Cherokee');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Yiii');
        writer.writeAttributeString('typeface', 'Microsoft Yi Baiti');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Tibt');
        writer.writeAttributeString('typeface', 'Microsoft Himalaya');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Thaa');
        writer.writeAttributeString('typeface', 'MV Boli');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Deva');
        writer.writeAttributeString('typeface', 'Mangal');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Telu');
        writer.writeAttributeString('typeface', 'Gautami');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Taml');
        writer.writeAttributeString('typeface', 'Latha');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Syrc');
        writer.writeAttributeString('typeface', 'Estrangelo Edessa');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Orya');
        writer.writeAttributeString('typeface', 'Kalinga');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Mlym');
        writer.writeAttributeString('typeface', 'Kartika');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Laoo');
        writer.writeAttributeString('typeface', 'DokChampa');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Sinh');
        writer.writeAttributeString('typeface', 'Iskoola Pota');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Mong');
        writer.writeAttributeString('typeface', 'Mongolian Baiti');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Viet');
        writer.writeAttributeString('typeface', 'Arial');
    });
    writer.writeLeafElement('a:font', function () {
        writer.writeAttributeString('script', 'Uigh');
        writer.writeAttributeString('typeface', 'Microsoft Uighur');
    });
}
function getRunFormattingTypeface(runFormats, targetLanguage) {
    if (!runFormats) {
        return '';
    }
    for (var i = 0, len = runFormats.length; i < len; i++) {
        var item = runFormats[i];
        if (item.fontLanguage === targetLanguage) {
            return item.typeface;
        }
    }
    return '';
}


/***/ }),

/***/ "./src/xlsx-io/writer/workbook-writer.ts":
/*!***********************************************!*\
  !*** ./src/xlsx-io/writer/workbook-writer.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var slicer_writer_1 = __webpack_require__(/*! ./slicer-writer */ "./src/xlsx-io/writer/slicer-writer.ts");
var datamodel_writer_1 = __webpack_require__(/*! ../../datamodel/datamodel-writer */ "./src/datamodel/datamodel-writer.ts");
var keyword_undefined = void 0;
function writeWorkbook(writerDataModel, sheetIDs, isR1C1, chart2016DefinedNames, pivotDefinitionFileMap, iterativeCalculation) {
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('workbook', function () {
        writer.writeAttributeString('xmlns', excel_types_1.XFileConstants._workbookNameSpace);
        writer.writeAttributeString('xmlns:r', excel_types_1.XFileConstants._relationShipNameSpace);
    }, function () {
        saveWorkbookView(writer, writerDataModel);
        writer.writeElement('sheets', undefined, function () {
            var _loop_1 = function (i, len) {
                var sheet = sheetIDs[i];
                if (sheet) {
                    writer.writeLeafElement('sheet', function () {
                        writer.writeAttributeString('name', common_1.Util._xmlEncode(sheet.name));
                        writer.writeAttributeString('sheetId', sheet.sheetId.toString());
                        if (writerDataModel._isSheetHidden(sheet.name)) {
                            writer.writeAttributeString('state', 'hidden');
                        }
                        writer.writeAttributeString('r:id', sheet.rID.toString());
                    });
                }
            };
            for (var i = 0, len = sheetIDs.length; i < len; i++) {
                _loop_1(i, len);
            }
        });
        saveDefinedNames(writer, writerDataModel, chart2016DefinedNames);
        saveCalcProperty(writer, isR1C1, iterativeCalculation);
        savePivotCaches(writer, pivotDefinitionFileMap);
        saveExtLst(writer, writerDataModel, sheetIDs);
    });
    return writer.getXmlString();
}
exports.writeWorkbook = writeWorkbook;
function saveWorkbookView(writer, writerDataModel) {
    var ret = writerDataModel._getTabsAndScroll();
    writer.writeElement('bookViews', undefined, function () {
        writer.writeLeafElement('workbookView', function () {
            if (ret.showHorizontalScrollbar === false) {
                writer.writeAttributeString('showHorizontalScroll', '0');
            }
            if (ret.showVerticalScrollbar === false) {
                writer.writeAttributeString('showVerticalScroll', '0');
            }
            if (ret.tabStripVisible === false) {
                writer.writeAttributeString('showSheetTabs', '0');
            }
            if (typeof ret.tabStripRatio === 'number' && ret.tabStripRatio !== 0.6) {
                writer.writeAttributeString('tabRatio', (ret.tabStripRatio * 1000).toString());
            }
            if (typeof ret.startSheetIndex === 'number' && ret.startSheetIndex > 0) {
                writer.writeAttributeString('firstSheet', ret.startSheetIndex.toString());
            }
            if (typeof ret.activeSheetIndex === 'number' && ret.activeSheetIndex > 0) {
                writer.writeAttributeString('activeTab', ret.activeSheetIndex.toString());
            }
        });
    });
}
function saveDefinedNames(writer, writerDataModel, chart2016DefinedNames) {
    var definedNames = writerDataModel._getDefinedNames();
    var slicerDefinedNames = getSlicerDefinedNames(writerDataModel);
    addDefinedNames(definedNames, slicerDefinedNames);
    var filterNames = getFilterNames(writerDataModel);
    addDefinedNames(definedNames, filterNames);
    var printAreaNames = getPrintNames(writerDataModel);
    addDefinedNames(definedNames, printAreaNames);
    addDefinedNames(definedNames, chart2016DefinedNames);
    if (definedNames.length > 0) {
        writer.writeElement('definedNames', keyword_undefined, function () {
            var _loop_2 = function (i) {
                var definedName = definedNames[i];
                writer.writeElement('definedName', function () {
                    writer.writeAttributeString('name', common_1.Util._xmlEncode(definedName.name));
                    if (definedName.comment) {
                        writer.writeAttributeString('comment', common_1.Util._xmlEncode(definedName.comment));
                    }
                    if (definedName.localSheetId > -1) {
                        writer.writeAttributeString('localSheetId', definedName.localSheetId);
                    }
                    if (definedName.hidden === true) {
                        writer.writeAttributeString('hidden', '1');
                    }
                }, function () {
                    writer.writeValue((common_1.addXLFNPrefix(definedName.formula).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')));
                });
            };
            for (var i = 0; i < definedNames.length; i++) {
                _loop_2(i);
            }
        });
    }
}
function getPrintNames(writerDataModel) {
    var definedNames = [];
    var sheetNames = writerDataModel._getSheetsName();
    for (var i = 0; i < sheetNames.length; i++) {
        var sheetName = sheetNames[i];
        var printInfo = writerDataModel._getPrintInfo(sheetName);
        if (printInfo) {
            var printAreaExpr = getAbsoluteRangeText(printInfo.rowStart, printInfo.rowEnd, printInfo.columnStart, printInfo.columnEnd, sheetName);
            if (printAreaExpr) {
                definedNames.push({ name: '_xlnm.Print_Area', localSheetId: i, formula: printAreaExpr });
            }
            var repeatRowExpr = getAbsoluteRangeText(printInfo.repeatRowStart, printInfo.repeatRowEnd, keyword_undefined, keyword_undefined, sheetName);
            var repeatColumnExpr = getAbsoluteRangeText(keyword_undefined, keyword_undefined, printInfo.repeatColumnStart, printInfo.repeatColumnEnd, sheetName);
            var printTitleExpr = void 0;
            if (repeatRowExpr && repeatColumnExpr) {
                printTitleExpr = repeatColumnExpr + ',' + repeatRowExpr;
            }
            else if (repeatRowExpr) {
                printTitleExpr = repeatRowExpr;
            }
            else if (repeatColumnExpr) {
                printTitleExpr = repeatColumnExpr;
            }
            if (printTitleExpr) {
                definedNames.push({ name: '_xlnm.Print_Titles', localSheetId: i, formula: printTitleExpr });
            }
        }
    }
    return definedNames;
}
function getAbsoluteRangeText(rowStart, rowEnd, columnStart, columnEnd, sheetName) {
    if ((columnStart === keyword_undefined) && (columnEnd === keyword_undefined) &&
        (rowStart === keyword_undefined) && (rowEnd === keyword_undefined)) {
        return keyword_undefined;
    }
    var formula = '';
    if (columnStart !== keyword_undefined) {
        formula += '$' + common_1.IndexHelper._getColumnIndexInA1Letter(columnStart);
    }
    if (rowStart !== keyword_undefined) {
        formula += '$' + (rowStart + 1);
    }
    formula += ':';
    if (columnEnd !== keyword_undefined) {
        formula += '$' + common_1.IndexHelper._getColumnIndexInA1Letter(columnEnd);
    }
    if (rowEnd !== keyword_undefined) {
        formula += '$' + (rowEnd + 1);
    }
    if (sheetName) {
        return common_1.IndexHelper._getSheetName(sheetName) + '!' + formula;
    }
    return formula;
}
function isDefinedNameExist(definedNames, slicerDefinedName) {
    for (var j = 0; j < definedNames.length; j++) {
        if (definedNames[j].name === slicerDefinedName.name && definedNames[j].localSheetId === slicerDefinedName.localSheetId) {
            return true;
        }
    }
    return false;
}
function addDefinedNames(definedNames, newDefinedNames) {
    for (var i = 0; i < newDefinedNames.length; i++) {
        if (!isDefinedNameExist(definedNames, newDefinedNames[i])) {
            definedNames.push(newDefinedNames[i]);
        }
    }
}
function getSlicerDefinedNames(writerDataModel) {
    var definedNames = [];
    var sheetNames = writerDataModel._getSheetsName();
    for (var i = 0; i < sheetNames.length; i++) {
        var slicers = writerDataModel._getSlicers(sheetNames[i]);
        if (slicers) {
            for (var j = 0; j < slicers.length; j++) {
                definedNames.push({ name: slicers[j].nameInFormula, formula: '#N/A' });
            }
        }
    }
    return definedNames;
}
function getFilterNames(writerDataModel) {
    var definedNames = [];
    var sheetNames = writerDataModel._getSheetsName();
    for (var i = 0; i < sheetNames.length; i++) {
        var sheetName = sheetNames[i];
        var filterInfo = writerDataModel._getFilterInfo(sheetName);
        if (filterInfo) {
            var sheet = writerDataModel._getSheetByName(sheetName);
            if (filterInfo.range) {
                var filterRange = datamodel_writer_1.getFilterRange(sheet, filterInfo.range);
                var filterRangeExpr = getAbsoluteRangeText(filterRange.row, filterRange.row + filterRange.rowCount, filterRange.col, filterRange.col + filterRange.colCount, sheetName);
                if (filterRangeExpr) {
                    definedNames.push({ name: '_xlnm._FilterDatabase', localSheetId: i, formula: filterRangeExpr });
                }
            }
        }
    }
    return definedNames;
}
function saveCalcProperty(writer, isR1C1, iterativeCalculation) {
    writer.writeLeafElement('calcPr', function () {
        writer.writeAttributeString('calcId', '0');
        if (isR1C1) {
            writer.writeAttributeString('refMode', 'R1C1');
        }
        var iterate = common_1.isNullOrUndefined(iterativeCalculation.iterate) || iterativeCalculation.iterate ? "1" : "0";
        var count = common_1.isNullOrUndefined(iterativeCalculation.count) ? "1000" : iterativeCalculation.count;
        var delta = common_1.isNullOrUndefined(iterativeCalculation.delta) ? "0.01" : iterativeCalculation.delta;
        writer.writeAttributeString('iterate', iterate);
        writer.writeAttributeString('iterateCount', count);
        writer.writeAttributeString('iterateDelta', delta);
    });
}
function savePivotCaches(writer, pivotDefinitionFileMap) {
    if (common_1.isEmptyObject(pivotDefinitionFileMap)) {
        return;
    }
    writer.writeElement('pivotCaches', function () {
        for (var cacheId in pivotDefinitionFileMap) {
            if (pivotDefinitionFileMap.hasOwnProperty(cacheId)) {
                savePivotCache(writer, pivotDefinitionFileMap[cacheId]);
            }
        }
    });
}
function savePivotCache(writer, pivotDefinition) {
    if (common_1.isEmptyObject(pivotDefinition)) {
        return;
    }
    writer.writeLeafElement('pivotCache', function () {
        writer.writeAttributeString('cacheId', pivotDefinition.cacheId);
        writer.writeAttributeString('r:id', pivotDefinition.rid);
    });
}
function saveExtLst(writer, writerDataModel, sheetIDs) {
    var slicers = {};
    var count = 0;
    for (var i = 0, len = sheetIDs.length; i < len; i++) {
        var sheet = sheetIDs[i];
        if (sheet) {
            var slicer = writerDataModel._getSlicers(sheet.name);
            if (slicer && slicer.length) {
                slicers[sheet.name] = writerDataModel._getSlicers(sheet.name);
                count++;
            }
        }
    }
    if (count) {
        slicer_writer_1.writeSlicerCacheInWorkbook(writer, slicers);
    }
}


/***/ }),

/***/ "./src/xlsx-io/writer/worksheet-writer.ts":
/*!************************************************!*\
  !*** ./src/xlsx-io/writer/worksheet-writer.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var color_writer_1 = __webpack_require__(/*! ./../common/color-writer */ "./src/xlsx-io/common/color-writer.ts");
var tuple_1 = __webpack_require__(/*! ./../../common/tuple */ "./src/common/tuple.ts");
var sparkline_writer_1 = __webpack_require__(/*! ./sparkline-writer */ "./src/xlsx-io/writer/sparkline-writer.ts");
var conditionalformat_writer_1 = __webpack_require__(/*! ./conditionalformat-writer */ "./src/xlsx-io/writer/conditionalformat-writer.ts");
var slicer_writer_1 = __webpack_require__(/*! ./slicer-writer */ "./src/xlsx-io/writer/slicer-writer.ts");
var autofilter_writer_1 = __webpack_require__(/*! ./autofilter-writer */ "./src/xlsx-io/writer/autofilter-writer.ts");
var datavalidation_writer_1 = __webpack_require__(/*! ./datavalidation-writer */ "./src/xlsx-io/writer/datavalidation-writer.ts");
var datavalidation_writer_2 = __webpack_require__(/*! ./datavalidation-writer */ "./src/xlsx-io/writer/datavalidation-writer.ts");
var excel_helper_1 = __webpack_require__(/*! ./../../datamodel/excel-helper */ "./src/datamodel/excel-helper.ts");
var writePrint = __webpack_require__(/*! ./print-writer */ "./src/xlsx-io/writer/print-writer.ts");
var keywords_undefined = void 0;
var _isEqualObject = common_1.Util._isEqualObject;
var MAX_FORMULA_VALUE_LENGTH = 66316;
var specialFunction = ['AVERAGEIF',
    'AVERAGEIFS',
    'CUBEKPIMEMBER',
    'CUBEMEMBER',
    'CUBEMEMBERPROPERTY',
    'CUBERANKEDMEMBER',
    'CUBESET',
    'CUBESETCOUNT',
    'CUBEVALUE',
    'COUNTIFS',
    'IFERROR',
    'SUMIFS',
    'ACOT',
    'ACOTH',
    'AGGREGATE',
    'ARABIC',
    'BASE',
    'BETA.DIST',
    'BETA.INV',
    'BINOM.DIST',
    'BINOM.DIST.RANGE',
    'BINOM.INV',
    'BITAND',
    'BITLSHIFT',
    'BITOR',
    'BITRSHIFT',
    'BITXOR',
    'CEILING.MATH',
    'CEILING.PRECISE',
    'CHISQ.DIST',
    'CHISQ.DIST.RT',
    'CHISQ.INV',
    'CHISQ.INV.RT',
    'CHISQ.TEST',
    'COMBINA',
    'CONCAT',
    'CONFIDENCE.T',
    'COT',
    'COVARIANCE.P',
    'COVARIANCE.S',
    'CSC',
    'CSCH',
    'DAYS',
    'DECIMAL',
    'ENCODEURL',
    'ERF.PRECISE',
    'ERFC.PRECISE',
    'EXPON.DIST',
    'F.DIST',
    'F.DIST.RT',
    'F.INV',
    'F.INV.RT',
    'FILTERXML',
    'FLOOR.MATH',
    'FLOOR.PRECISE',
    'FORMULATEXT',
    'GAMMA',
    'GAMMA.DIST',
    'GAMMA.INV',
    'GAMMALN.PRECISE',
    'HYPGEOM.DIST',
    'IFNA',
    'IFS',
    'IMCOSH',
    'IMCOT',
    'IMCSCH',
    'IMSEC',
    'IMSECH',
    'IMSINH',
    'IMTAN',
    'ISFORMULA',
    'ISOWEEKNUM',
    'LOGNORM.DIST',
    'LOGNORM.INV',
    'MAXIFS',
    'MINIFS',
    'MODE.MULT',
    'MODE.SNGL',
    'MUNIT',
    'NEGBINOM.DIST',
    'NORM.DIST',
    'NORM.INV',
    'NORM.S.DIST',
    'NORM.S.INV',
    'NUMBERVALUE',
    'PDURATION',
    'PERCENTILE.EXC',
    'PERCENTILE.INC',
    'PERCENTRANK.EXC',
    'PERCENTRANK.INC',
    'PERMUTATIONA',
    'PHI',
    'POISSON.DIST',
    'QUARTILE.EXC',
    'QUARTILE.INC',
    'RANK.AVG',
    'RANK.EQ',
    'RRI',
    'SECH',
    'SHEET',
    'SHEETS',
    'STDEV.P',
    'STDEV.S',
    'SWITCH',
    'T.DIST',
    'T.DIST.2T',
    'T.DIST.RT',
    'T.INV',
    'T.INV.2T',
    'TEXTJOIN',
    'UNICHAR',
    'UNICODE',
    'VAR.P',
    'VAR.S',
    'WEBSERVICE',
    'WEIBULL.DIST',
    'XOR',
    'Z.TEST'
];
var dynamicArrayFunctions = ['RANDARRAY', 'SEQUENCE', 'SORTBY', 'UNIQUE', 'ANCHORARRAY', 'FILTER', 'SORT', 'SINGLE'];
specialFunction = specialFunction.concat(dynamicArrayFunctions);
var xlwsFunctionPrefix = '_xlfn._xlws.';
var specialFuncionRegDic = {
    'AVERAGEIF': /AVERAGEIF\(/gi,
    'AVERAGEIFS': /AVERAGEIFS\(/gi,
    'CUBEKPIMEMBER': /CUBEKPIMEMBER\(/gi,
    'CUBEMEMBER': /CUBEMEMBER\(/gi,
    'CUBEMEMBERPROPERTY': /CUBEMEMBERPROPERTY\(/gi,
    'CUBERANKEDMEMBER': /CUBERANKEDMEMBER\(/gi,
    'CUBESET': /CUBESET\(/gi,
    'CUBESETCOUNT': /CUBESETCOUNT\(/gi,
    'CUBEVALUE': /CUBEVALUE\(/gi,
    'COUNTIFS': /COUNTIFS\(/gi,
    'IFERROR': /IFERROR\(/gi,
    'SUMIFS': /SUMIFS\(/gi,
    'ACOT': /ACOT\(/gi,
    'ACOTH': /ACOTH\(/gi,
    'AGGREGATE': /AGGREGATE\(/gi,
    'ARABIC': /ARABIC\(/gi,
    'BASE': /BASE\(/gi,
    'BETA.DIST': /BETA\.DIST\(/gi,
    'BETA.INV': /BETA\.INV\(/gi,
    'BINOM.DIST': /BINOM\.DIST\(/gi,
    'BINOM.DIST.RANGE': /BINOM\.DIST\.RANGE\(/gi,
    'BINOM.INV': /BINOM\.INV\(/gi,
    'BITAND': /BITAND\(/gi,
    'BITLSHIFT': /BITLSHIFT\(/gi,
    'BITOR': /BITOR\(/gi,
    'BITRSHIFT': /BITRSHIFT\(/gi,
    'BITXOR': /BITXOR\(/gi,
    'CEILING.MATH': /CEILING\.MATH\(/gi,
    'CEILING.PRECISE': /CEILING\.PRECISE\(/gi,
    'CHISQ.DIST': /CHISQ\.DIST\(/gi,
    'CHISQ.DIST.RT': /CHISQ\.DIST\.RT\(/gi,
    'CHISQ.INV': /CHISQ\.INV\(/gi,
    'CHISQ.INV.RT': /CHISQ\.INV\.RT\(/gi,
    'CHISQ.TEST': /CHISQ\.TEST\(/gi,
    'COMBINA': /COMBINA\(/gi,
    'CONCAT': /CONCAT\(/gi,
    'CONFIDENCE.T': /CONFIDENCE\.T\(/gi,
    'COT': /COT\(/gi,
    'COVARIANCE.P': /COVARIANCE\.P\(/gi,
    'COVARIANCE.S': /COVARIANCE\.S\(/gi,
    'CSC': /CSC\(/gi,
    'CSCH': /CSCH\(/gi,
    'DAYS': /DAYS\(/gi,
    'DECIMAL': /DECIMAL\(/gi,
    'ENCODEURL': /ENCODEURL\(/gi,
    'ERF.PRECISE': /ERF\.PRECISE\(/gi,
    'ERFC.PRECISE': /ERFC\.PRECISE\(/gi,
    'EXPON.DIST': /EXPON\.DIST\(/gi,
    'F.DIST': /F\.DIST\(/gi,
    'F.DIST.RT': /F\.DIST\.RT\(/gi,
    'F.INV': /F\.INV\(/gi,
    'F.INV.RT': /F\.INV\.RT\(/gi,
    'FILTERXML': /FILTERXML\(/gi,
    'FLOOR.MATH': /FLOOR\.MATH\(/gi,
    'FLOOR.PRECISE': /FLOOR\.PRECISE\(/gi,
    'FORMULATEXT': /FORMULATEXT\(/gi,
    'GAMMA': /GAMMA\(/gi,
    'GAMMA.DIST': /GAMMA\.DIST\(/gi,
    'GAMMA.INV': /GAMMA\.INV\(/gi,
    'GAMMALN.PRECISE': /GAMMALN\.PRECISE\(/gi,
    'HYPGEOM.DIST': /HYPGEOM\.DIST\(/gi,
    'IFNA': /IFNA\(/gi,
    'IFS': /IFS\(/gi,
    'IMCOSH': /IMCOSH\(/gi,
    'IMCOT': /IMCOT\(/gi,
    'IMCSCH': /IMCSCH\(/gi,
    'IMSEC': /IMSEC\(/gi,
    'IMSECH': /IMSECH\(/gi,
    'IMSINH': /IMSINH\(/gi,
    'IMTAN': /IMTAN\(/gi,
    'ISFORMULA': /ISFORMULA\(/gi,
    'ISOWEEKNUM': /ISOWEEKNUM\(/gi,
    'LOGNORM.DIST': /LOGNORM\.DIST\(/gi,
    'LOGNORM.INV': /LOGNORM\.INV\(/gi,
    'MAXIFS': /MAXIFS\(/gi,
    'MINIFS': /MINIFS\(/gi,
    'MODE.MULT': /MODE\.MULT\(/gi,
    'MODE.SNGL': /MODE\.SNGL\(/gi,
    'MUNIT': /MUNIT\(/gi,
    'NEGBINOM.DIST': /NEGBINOM\.DIST\(/gi,
    'NORM.DIST': /NORM\.DIST\(/gi,
    'NORM.INV': /NORM\.INV\(/gi,
    'NORM.S.DIST': /NORM\.S\.DIST\(/gi,
    'NORM.S.INV': /NORM\.S\.INV\(/gi,
    'NUMBERVALUE': /NUMBERVALUE\(/gi,
    'PDURATION': /PDURATION\(/gi,
    'PERCENTILE.EXC': /PERCENTILE\.EXC\(/gi,
    'PERCENTILE.INC': /PERCENTILE\.INC\(/gi,
    'PERCENTRANK.EXC': /PERCENTRANK\.EXC\(/gi,
    'PERCENTRANK.INC': /PERCENTRANK\.INC\(/gi,
    'PERMUTATIONA': /PERMUTATIONA\(/gi,
    'PHI': /PHI\(/gi,
    'POISSON.DIST': /POISSON\.DIST\(/gi,
    'QUARTILE.EXC': /QUARTILE\.EXC\(/gi,
    'QUARTILE.INC': /QUARTILE\.INC\(/gi,
    'RANK.AVG': /RANK\.AVG\(/gi,
    'RANK.EQ': /RANK\.EQ\(/gi,
    'RRI': /RRI\(/gi,
    'SECH': /SECH\(/gi,
    'SHEET': /SHEET\(/gi,
    'SHEETS': /SHEETS\(/gi,
    'STDEV.P': /STDEV\.P\(/gi,
    'STDEV.S': /STDEV\.S\(/gi,
    'SWITCH': /SWITCH\(/gi,
    'T.DIST': /T\.DIST\(/gi,
    'T.DIST.2T': /T\.DIST\.2T\(/gi,
    'T.DIST.RT': /T\.DIST\.RT\(/gi,
    'T.INV': /T\.INV\(/gi,
    'T.INV.2T': /T\.INV\.2T\(/gi,
    'TEXTJOIN': /TEXTJOIN\(/gi,
    'UNICHAR': /UNICHAR\(/gi,
    'UNICODE': /UNICODE\(/gi,
    'VAR.P': /VAR\.P\(/gi,
    'VAR.S': /VAR\.S\(/gi,
    'WEBSERVICE': /WEBSERVICE\(/gi,
    'WEIBULL.DIST': /WEIBULL\.DIST\(/gi,
    'XOR': /XOR\(/gi,
    'Z.TEST': /Z\.TEST/gi,
    'RANDARRAY': /RANDARRAY\(/gi,
    'SEQUENCE': /SEQUENCE\(/gi,
    'SORTBY': /SORTBY\(/gi,
    'UNIQUE': /UNIQUE\(/gi,
    'ANCHORARRAY': /ANCHORARRAY\(/gi,
    'SINGLE': /SINGLE\(/gi,
    'FILTER': {
        reg: /FILTER\(/gi,
        prefix: xlwsFunctionPrefix
    },
    'SORT': {
        reg: /SORT\(/gi,
        prefix: xlwsFunctionPrefix
    }
};
function writeWorksheet(writerDataModel, sheetName, xfMap, styleOffset, options, sharedString, extensions, sheetViewFile) {
    var writer = new xml_writer_1.XmlWriter();
    writer.writeDocument();
    writer.writeElement('worksheet', function () {
        writer.writeAttributeString('xmlns', excel_types_1.XFileConstants._workbookNameSpace);
        writer.writeAttributeString('xmlns:r', excel_types_1.XFileConstants._relationShipNameSpace);
        writer.writeAttributeString('xmlns:mc', excel_types_1.XFileConstants._markupCompatibility);
        if (extensions && extensions.attributes) {
            extensions.attributes.forEach(function (pair) {
                writer.writeAttributeString(pair.key, pair.value);
            });
        }
        writer.writeAttributeString('xmlns:x14ac', excel_types_1.XFileConstants._ac);
        writer.writeAttributeString('xmlns:xr', excel_types_1.XFileConstants._xr);
        writer.writeAttributeString('xmlns:xr2', excel_types_1.XFileConstants._xr2);
        writer.writeAttributeString('xmlns:xr3', excel_types_1.XFileConstants._xr3);
        writer.writeAttributeString('xr:uid', common_1._getRandomID());
        writer.writeAttributeString('mc:Ignorable', excel_types_1.XFileConstants._ignorable_worksheet);
    }, function () {
        writeSheetPr(writer, sheetName, writerDataModel);
        writeDimension(writer, sheetName, writerDataModel);
        writeSheetViews(writer, sheetName, writerDataModel);
        writeSheetFormatPr(writer, sheetName, writerDataModel);
        writeColumnInfo(writer, sheetName, writerDataModel, xfMap, styleOffset);
        writeSheetData(writer, sheetName, writerDataModel, options, xfMap, styleOffset, sharedString);
        writeSheetProtection(writer, sheetName, writerDataModel);
        autofilter_writer_1.writeAutoFilterForSheet(writer, sheetName, writerDataModel);
        writeMergeCells(writer, sheetName, writerDataModel);
        conditionalformat_writer_1.writeConditionalFormating(writer, sheetName, writerDataModel);
        datavalidation_writer_1.writeDataValidations(writer, sheetName, writerDataModel);
        writeHyperlinks(writer, sheetName, writerDataModel, sheetViewFile);
        writePrint.writePrintOptions(writer, sheetName, writerDataModel);
        writePrint.writePageMargins(writer, sheetName, writerDataModel);
        writePrint.writePageSetup(writer, sheetName, writerDataModel);
        writePrint.writeHeadFooter(writer, sheetName, writerDataModel);
        writePrint.writeRowColumnBreaks(writer, sheetName, writerDataModel);
        if (extensions) {
            var rids = [
                { name: 'drawing', value: extensions.drawingId },
                { name: 'legacyDrawing', value: extensions.legacyDrawingId }
            ];
            var _loop_1 = function (i) {
                var pair = rids[i];
                var rid = pair.value;
                if (rid) {
                    writer.writeLeafElement(pair.name, function () {
                        writer.writeAttributeString('r:id', rid);
                    });
                }
            };
            for (var i = 0; i < 2; i++) {
                _loop_1(i);
            }
        }
        writePrint.writeLegacyDrawingHF(writer, writerDataModel);
        if (writerDataModel._getTables(sheetName) && writerDataModel._getTables(sheetName).length > 0) {
            writeTableParts(writer, writerDataModel._getTables(sheetName));
        }
        if (needwriteExtension(writerDataModel, sheetName)) {
            writeExtensions(writer, sheetName, writerDataModel);
        }
    });
    return writer.getXmlString();
}
exports.writeWorksheet = writeWorksheet;
function needwriteExtension(writerDataModel, sheetName) {
    var slicers = writerDataModel._getSlicers(sheetName);
    if (slicers && slicers.length > 0) {
        return true;
    }
    var sparklineGroups = writerDataModel._getSparklineGroups(sheetName);
    if (sparklineGroups && sparklineGroups.length > 0) {
        return true;
    }
    var conditionalFormats = writerDataModel._getConditionalFormatting(sheetName);
    var rules = conditionalFormats && conditionalFormats.rules;
    if (rules && conditionalformat_writer_1.needWriteConditionalFormatExtension(rules, sheetName, writerDataModel._getSheetsName())) {
        return true;
    }
    var extensionDataValidations = writerDataModel._extensionDataValidations;
    if (extensionDataValidations && extensionDataValidations.length > 0) {
        return true;
    }
    return false;
}
function writeSheetPr(writer, sheetName, writerDataModel) {
    var ret = writerDataModel._getOutlineDirection(sheetName);
    var colsSumRight = ret.colsSumRight, rowsSumBelow = ret.rowsSumBelow;
    var sheetTabColor = writerDataModel._getSheetTabColor(sheetName);
    var printSetting = writerDataModel._getPrintPageSetting(sheetName, true);
    var useSmartPrint = printSetting && printSetting.useSmartPrint;
    if (sheetTabColor || !colsSumRight || !rowsSumBelow || useSmartPrint === true) {
        writer.writeElement('sheetPr', function () {
            if (sheetTabColor !== null) {
                color_writer_1.writeColor(writer, 'tabColor', sheetTabColor);
            }
            if (!colsSumRight || !rowsSumBelow) {
                writer.writeLeafElement('outlinePr', function () {
                    if (!colsSumRight) {
                        writer.writeAttributeString('summaryRight', '0');
                    }
                    if (!rowsSumBelow) {
                        writer.writeAttributeString('summaryBelow', '0');
                    }
                });
            }
            if (useSmartPrint === true) {
                writer.writeLeafElement('pageSetUpPr', function () {
                    writer.writeAttributeString('fitToPage', '1');
                });
            }
        });
    }
}
function writeDimension(writer, sheetName, writerDataModel) {
    var ret = writerDataModel._getDimensions(sheetName);
    var columnCount = ret.columnCount, rowCount = ret.rowCount;
    if (columnCount > 0 && rowCount > 0) {
        writer.writeLeafElement('dimension', function () {
            writer.writeAttributeString('ref', 'A1:' + writerDataModel._getColumnIndexInA1LetterForm(columnCount - 1) + rowCount);
        });
    }
    else {
        writer.writeLeafElement('dimension', function () {
            writer.writeAttributeString('ref', 'A1');
        });
    }
}
function writeSheetViews(writer, sheetName, writerDataModel) {
    writer.writeElement('sheetViews', keywords_undefined, function () {
        writer.writeElement('sheetView', function () {
            var ret = writerDataModel._getDisplayElements(sheetName);
            var gridlineColor = ret.gridlineColor;
            if (gridlineColor !== null && gridlineColor.colorType() === 1 && gridlineColor.value() !== 64) {
                writer.writeAttributeString('defaultGridColor', '0');
                writer.writeAttributeString('colorId', gridlineColor.value().toString());
            }
            var retFrozen = writerDataModel._getFrozen(sheetName);
            var topLtftCell = ret.topLeftCell, x = retFrozen.frozenColCount, y = retFrozen.frozenRowCount;
            if (topLtftCell && topLtftCell.row !== undefined && topLtftCell.col !== undefined) {
                if (!x && !y) {
                    var topLftCellAttr = '' + writerDataModel._getColumnIndexInA1LetterForm(topLtftCell.col) + (topLtftCell.row + 1);
                    writer.writeAttributeString('topLeftCell', topLftCellAttr.toString());
                }
                else if (x && !y) {
                    var topLftCellAttr = '' + "A" + (topLtftCell.row + 1);
                    writer.writeAttributeString('topLeftCell', topLftCellAttr.toString());
                }
                else if (!x && y) {
                    var topLftCellAttr = '' + writerDataModel._getColumnIndexInA1LetterForm(topLtftCell.col) + "1";
                    writer.writeAttributeString('topLeftCell', topLftCellAttr.toString());
                }
            }
            if (!ret.showGridLine) {
                writer.writeAttributeString('showGridLines', '0');
            }
            if (!ret.showRowColHeaders) {
                writer.writeAttributeString('showRowColHeaders', '0');
            }
            if (!common_1.isNullOrUndefined(ret.zoom)) {
                var zoom = Math.round(ret.zoom * 100);
                if (zoom !== 100) {
                    writer.writeAttributeString('zoomScale', zoom.toString());
                }
            }
            var sheet = writerDataModel._getSheetByName(sheetName);
            if (sheet.showFormulas) {
                writer.writeAttributeString('showFormulas', '1');
            }
            writer.writeAttributeString('workbookViewId', '0');
            var activeSheetIndex, tabsAndScrollRet;
            tabsAndScrollRet = writerDataModel._getTabsAndScroll();
            if (tabsAndScrollRet) {
                activeSheetIndex = tabsAndScrollRet.activeSheetIndex;
            }
            var isActiveSheet = sheet.index === activeSheetIndex;
            if (sheet.isSelected || isActiveSheet) {
                writer.writeAttributeString('tabSelected', 1);
            }
        }, function () {
            var ret = writerDataModel._getFrozen(sheetName);
            var x = ret.frozenColCount, y = ret.frozenRowCount, colLeft = 0, rowTop = 0, activePane = 3, top = "1", left = "A";
            var topLtftCell = writerDataModel._getDisplayElements(sheetName).topLeftCell;
            if (x > 0 || y > 0) {
                if (x > 0) {
                    colLeft = x;
                    left = writerDataModel._getColumnIndexInA1LetterForm(topLtftCell.col);
                }
                else {
                    colLeft = 0;
                }
                if (y > 0) {
                    rowTop = y;
                    top = (topLtftCell.row + 1) + "";
                }
                else {
                    rowTop = 0;
                }
                if (x > 0 && y === 0) {
                    activePane = 1;
                }
                else if (x === 0 && y > 0) {
                    activePane = 2;
                }
                else if (x > 0 && y > 0) {
                    activePane = 0;
                }
                writer.writeLeafElement('pane', function () {
                    if (x > 0) {
                        writer.writeAttributeString('xSplit', x.toString());
                    }
                    if (y > 0) {
                        writer.writeAttributeString('ySplit', y.toString());
                    }
                    if ((left + top) === "A1") {
                        writer.writeAttributeString('topLeftCell', '' + writerDataModel._getColumnIndexInA1LetterForm(colLeft) + (rowTop + 1));
                    }
                    else {
                        writer.writeAttributeString('topLeftCell', '' + left + top);
                    }
                    writer.writeAttributeString('activePane', excel_types_1.PaneType[activePane]);
                    writer.writeAttributeString('state', 'frozen');
                });
            }
            var selectionList = [];
            var activeCell = new common_1.Range();
            var selIndex = 0, selCount = 1, activeCellSelectionIndex = -1;
            var _loop_2 = function (index) {
                selectionList.length = 0;
                var paneIndex = index;
                if (writerDataModel._getSelectionList(sheetName, selectionList, activeCell, paneIndex)) {
                    selCount = selectionList.length;
                    for (selIndex = 0; selIndex < selCount; selIndex++) {
                        var r = selectionList[selIndex];
                        if (r.col === -1 || r.colCount === -1) {
                            r = new common_1.Range(r.row, 0, r.rowCount, excel_types_1.ExcelConstants._openXmlMaxColumn);
                        }
                        if (r.row === -1 || r.rowCount === -1) {
                            r = new common_1.Range(0, r.col, excel_types_1.ExcelConstants._openXmlMaxRow, r.colCount);
                        }
                        if ((activeCell.col >= r.col && activeCell.col <= r.col + r.colCount - 1) &&
                            (activeCell.row >= r.row && activeCell.row <= r.row + r.rowCount - 1)) {
                            activeCellSelectionIndex = selIndex;
                        }
                    }
                    if (activeCellSelectionIndex < 0 && selCount > 0) {
                        activeCell.row = selectionList[0].row;
                        activeCell.col = selectionList[0].col;
                    }
                    var activeCellStr_1 = '' + writerDataModel._getColumnIndexInA1LetterForm(activeCell.col) + (activeCell.row + 1);
                    var sqref_1 = '';
                    if (x > 0 && y > 0 && (paneIndex === 1 || paneIndex === 2)) {
                        sqref_1 = activeCellStr_1;
                    }
                    else {
                        for (selIndex = 0; selIndex < selCount; selIndex++) {
                            var selection = selectionList[selIndex];
                            var firstRow = Math.min(excel_types_1.ExcelConstants._openXmlMaxRow, selection.row + 1), firstColumn = Math.min(selection.col, excel_types_1.ExcelConstants._openXmlMaxColumn);
                            sqref_1 += '' + writerDataModel._getColumnIndexInA1LetterForm(firstColumn) + firstRow;
                            if (selection.colCount > 1 || selection.rowCount > 1) {
                                var endColumn = Math.min(firstColumn + selection.colCount - 1, excel_types_1.ExcelConstants._openXmlMaxColumn), endRow = Math.min(firstRow + selection.rowCount - 1, excel_types_1.ExcelConstants._openXmlMaxRow);
                                var end = '' + writerDataModel._getColumnIndexInA1LetterForm(endColumn) + endRow;
                                sqref_1 += ':' + end;
                            }
                            sqref_1 += ' ';
                        }
                        sqref_1 = sqref_1.trim();
                    }
                    if (!common_1.StringEx._isNullOrWhiteSpace(sqref_1)) {
                        if (paneIndex !== 3 || (!(x > 0 || y > 0) && paneIndex === 3)) {
                            writer.writeLeafElement('selection', function () {
                                if (paneIndex !== 3) {
                                    writer.writeAttributeString('pane', excel_types_1.PaneType[paneIndex]);
                                }
                                writer.writeAttributeString('activeCell', activeCellStr_1);
                                if (activeCellSelectionIndex !== 0 && paneIndex === 0) {
                                    writer.writeAttributeString('activeCellId', activeCellSelectionIndex.toString());
                                }
                                writer.writeAttributeString('sqref', sqref_1);
                            });
                        }
                    }
                }
            };
            for (var index = 3; index >= 0; index--) {
                _loop_2(index);
            }
        });
    });
}
function writeSheetFormatPr(writer, sheetName, writerDataModel) {
    var rowHeightInfo = writerDataModel._getDefaultRowHeight(sheetName);
    var defaultRowHeight = rowHeightInfo.height, customHeight = rowHeightInfo.customHeight, defaultColWidth = writerDataModel._getDefaultColumnWidthValue(sheetName);
    writer.writeLeafElement('sheetFormatPr', function () {
        if (!isNaN(defaultColWidth)) {
            writer.writeAttributeString('defaultColWidth', defaultColWidth.toString());
        }
        if (customHeight) {
            writer.writeAttributeString('customHeight', '1');
        }
        writer.writeAttributeString('defaultRowHeight', defaultRowHeight.toString());
        var ret = writerDataModel._getGutters(sheetName);
        var outlineLevelRow = ret.outlineLevelRow - 1, outlineLevelColumn = ret.outlineLevelColumn - 1;
        if (outlineLevelRow > 0) {
            writer.writeAttributeString('outlineLevelRow', outlineLevelRow.toString());
        }
        if (outlineLevelColumn > 0) {
            writer.writeAttributeString('outlineLevelCol', outlineLevelColumn.toString());
        }
    });
}
function writeColumnInfo(writer, sheetName, writerDataModel, _xfMap, styleOffset) {
    var columnInfoList = writerDataModel._getNonEmptyColumns(sheetName);
    var defaultColumnWidth = writerDataModel._getDefaultColumnWidth(sheetName);
    if (columnInfoList.length === 0) {
        return;
    }
    writer.writeElement('cols', keywords_undefined, function () {
        var _loop_3 = function (i, len) {
            var startColumn = columnInfoList[i];
            var startIndex = startColumn.index;
            if (startIndex >= excel_types_1.ExcelConstants._openXmlMaxColumn) {
                return out_i_1 = i, "break";
            }
            var next = i + 1, endColumnIndex = startIndex;
            while (next < columnInfoList.length) {
                var nextColumn = columnInfoList[next];
                if (nextColumn.index === (endColumnIndex + 1) && nextColumn.index < excel_types_1.ExcelConstants._openXmlMaxColumn && nextColumn.formatId === startColumn.formatId && nextColumn.visible === startColumn.visible && nextColumn.outLineLevel === startColumn.outLineLevel && nextColumn.collapsed === startColumn.collapsed && Math.abs(nextColumn.width - startColumn.width) <= 0.0001) {
                    endColumnIndex = nextColumn.index;
                    i = next;
                    next++;
                }
                else {
                    break;
                }
            }
            writer.writeLeafElement('col', function () {
                writer.writeAttributeString('min', (startIndex + 1).toString());
                writer.writeAttributeString('max', (endColumnIndex + 1).toString());
                if (startColumn.formatId >= 0) {
                    var styleID = _xfMap[startColumn.formatId + styleOffset];
                    if (styleID !== keywords_undefined) {
                        writer.writeAttributeString('style', styleID);
                    }
                    else {
                        writer.writeAttributeString('style', '0');
                    }
                }
                if (!isNaN(startColumn.width) && (startColumn.width !== keywords_undefined)) {
                    writer.writeAttributeString('width', startColumn.width.toString());
                }
                else {
                    writer.writeAttributeString('width', defaultColumnWidth.toString());
                }
                if (startColumn.visible === false) {
                    writer.writeAttributeString('hidden', '1');
                }
                if (startColumn.collapsed) {
                    writer.writeAttributeString('collapsed', '1');
                }
                if (!isNaN(startColumn.width) && Math.abs(startColumn.width - defaultColumnWidth) > 0.0001) {
                    writer.writeAttributeString('customWidth', '1');
                }
                if (typeof startColumn.outLineLevel === 'number' && startColumn.outLineLevel !== 0) {
                    writer.writeAttributeString('outlineLevel', startColumn.outLineLevel.toString());
                }
            });
            out_i_1 = i;
        };
        var out_i_1;
        for (var i = 0, len = columnInfoList.length; i < len; i++) {
            var state_1 = _loop_3(i, len);
            i = out_i_1;
            if (state_1 === "break")
                break;
        }
    });
}
function writeSheetData(writer, sheetName, writerDataModel, options, _xfMap, styleOffset, sharedString) {
    var rowInfoList = {};
    var notEmptyRows = writerDataModel._getNonEmptyRows(sheetName);
    if (notEmptyRows) {
        for (var i = 0, len = notEmptyRows.length; i < len; i++) {
            var row = notEmptyRows[i];
            if (row && row.index < excel_types_1.ExcelConstants._openXmlMaxRow) {
                rowInfoList[row.index] = new tuple_1.Tuple(row, []);
            }
        }
    }
    var cells = writerDataModel._getCells(sheetName);
    if (cells) {
        for (var rowIndex in cells) {
            if (cells.hasOwnProperty(rowIndex)) {
                var rowData = cells[rowIndex];
                for (var i = 0, len1 = rowData.length; i < len1; i++) {
                    var cell = rowData[i];
                    if (!cell) {
                        continue;
                    }
                    if (rowInfoList[cell.row]) {
                        rowInfoList[cell.row].item2.push(cell);
                    }
                    else {
                        rowInfoList[cell.row] = new tuple_1.Tuple(null, []);
                        rowInfoList[cell.row].item2.push(cell);
                    }
                }
            }
        }
    }
    writer.writeElement('sheetData', keywords_undefined, function () {
        var lastWriteRow = -1;
        for (var row in rowInfoList) {
            if (rowInfoList.hasOwnProperty(row)) {
                var rowInfo = rowInfoList[row];
                var rowIndex = parseInt(row, 10);
                writeRow(writer, sheetName, rowIndex, lastWriteRow, rowInfo.item2, rowInfo.item1, options, _xfMap, styleOffset, sharedString);
                lastWriteRow = rowIndex;
            }
        }
    });
}
function writeRow(writer, sheetName, rowIndex, lastWriteRow, cells, row, options, _xfMap, styleOffset, sharedString) {
    var rowInA1Style = (rowIndex + 1).toString();
    var writeRowAttrs = function () {
        if ((options.keepRowColIndex || rowIndex !== lastWriteRow + 1) && (row || cells)) {
            writer.writeAttributeString('r', rowInA1Style);
        }
        if (row) {
            if (row.formatId >= 0) {
                var formatId = _xfMap[row.formatId + styleOffset];
                if (formatId !== keywords_undefined) {
                    writer.writeAttributeString('s', formatId);
                    writer.writeAttributeString('customFormat', '1');
                }
            }
            if (row.customHeight) {
                writer.writeAttributeString('customHeight', '1');
                if (row.height !== keywords_undefined) {
                    writer.writeAttributeString('ht', row.height.toString());
                }
            }
            if (row.visible === false) {
                writer.writeAttributeString('hidden', '1');
            }
            if (row.collapsed) {
                writer.writeAttributeString('collapsed', '1');
            }
            if (typeof row.outLineLevel === 'number' && row.outLineLevel !== 0) {
                writer.writeAttributeString('outlineLevel', row.outLineLevel.toString());
            }
        }
    };
    if (cells && cells.length > 0) {
        writer.writeElement('row', writeRowAttrs, function () {
            var lastWritenCol = -1;
            for (var i = 0, len = cells.length; i < len; i++) {
                var cell = cells[i];
                if (cell.col >= excel_types_1.ExcelConstants._openXmlMaxColumn) {
                    continue;
                }
                writeCell(writer, cell, rowInA1Style, lastWritenCol, options, _xfMap, styleOffset, sharedString);
                lastWritenCol = cell.col;
            }
        });
    }
    else {
        writer.writeLeafElement('row', writeRowAttrs);
    }
}
var errorSet = ['#REF!', '#NULL!', '#DIV/0!', '#VALUE!', '#NAME?', '#NUM!', '#N/A', '#SPILL!', '#CALC!'];
function writeCell(writer, cell, rowInA1Style, lastWritenCol, options, _xfMap, styleOffset, sharedString) {
    var value = cell.value, formula = cell.formula, cellType = cell.cellType, richText = cell.richText;
    if (cell.prefix) {
        if (cell.prefix.LET) {
            formula = cell.prefix.LET;
        }
    }
    var writeCellAttrs = function () {
        if (options.xlsxStrictMode || cell.col !== lastWritenCol + 1) {
            writer.writeAttributeString('r', common_1.IndexHelper._getColumnIndexInA1Letter(cell.col) + rowInA1Style);
        }
        if (cell.formatId === -1) {
            writer.writeAttributeString('s', '0');
        }
        else {
            var key = cell.formatId + styleOffset;
            var xfIndex = _xfMap[key];
            if (xfIndex !== keywords_undefined) {
                writer.writeAttributeString('s', xfIndex);
            }
        }
        if (cellType === 0 && !common_1.StringEx._isNullOrWhiteSpace(cell.formula)) {
            cellType = 3;
        }
        switch (cellType) {
            case 0:
                break;
            case 9:
            case 2:
                writer.writeAttributeString('t', 's');
                break;
            case 3:
                var cellValue = cell.value;
                if (cellValue !== keywords_undefined && cellValue !== null && !cell.isArrayFormula) {
                    if (cellValue.toString().substring(0, 1) === '#') {
                        var valueStr = cellValue.toString().toUpperCase();
                        if (errorSet.indexOf(valueStr) !== -1) {
                            writer.writeAttributeString('t', 'e');
                        }
                        else if (typeof cellValue === 'string') {
                            writer.writeAttributeString('t', 'str');
                        }
                    }
                    else if (typeof cellValue === 'string') {
                        writer.writeAttributeString('t', 'str');
                    }
                }
                else if (cell.isSpillError) {
                    writer.writeAttributeString('t', 'e');
                    writer.writeAttributeString('vm', '2');
                }
                break;
            case 8:
                var isDynamicArray = cell.isDynamicArray;
                if (isDynamicArray) {
                    writer.writeAttributeString('cm', '1');
                }
                if (cell.isSpillError) {
                    writer.writeAttributeString('t', 'e');
                    writer.writeAttributeString('vm', '1');
                }
                else {
                    writer.writeAttributeString('t', 'str');
                }
                break;
            case 5:
                writer.writeAttributeString('t', 'b');
                break;
            case 7:
                writer.writeAttributeString('t', 'e');
                break;
            default:
                break;
        }
    };
    function addStringToSharedStringTable(richTextValue) {
        var si = sharedString._sstTableDict[richTextValue.value];
        var duplicatedValue = sharedString._sstDuplicatedValue[richTextValue.value];
        if (duplicatedValue === keywords_undefined) {
            duplicatedValue = sharedString._sstDuplicatedValue[richTextValue.value] = [];
        }
        var duplicatedValueIndex = getDuplicatedValueIndex(duplicatedValue, richTextValue);
        if (si === keywords_undefined || duplicatedValueIndex === keywords_undefined) {
            si = sharedString._sstTable.length;
            sharedString._sstTable.push(richTextValue);
            sharedString._sstTableDict[richTextValue.value] = si;
            duplicatedValue.push({
                index: si,
                value: richTextValue
            });
        }
        else {
            si = duplicatedValueIndex;
        }
        sharedString._sstTableCount++;
        return si;
    }
    function getDuplicatedValueIndex(duplicatedValue, richTextValue) {
        for (var i = 0, count = duplicatedValue.length; i < count; i++) {
            if (_isEqualObject(duplicatedValue[i].value, richTextValue)) {
                return duplicatedValue[i].index;
            }
        }
    }
    if ((value === keywords_undefined || value === null) && common_1.StringEx._isNullOrEmpty(formula)) {
        writer.writeLeafElement('c', writeCellAttrs);
    }
    else {
        writer.writeElement('c', writeCellAttrs, function () {
            if (!common_1.StringEx._isNullOrEmpty(formula)) {
                var arrayFormulaRange_1 = cell.arrayFormulaRange;
                if (cell.isArrayFormula && arrayFormulaRange_1) {
                    if (cell.row === arrayFormulaRange_1.row && cell.col === arrayFormulaRange_1.col) {
                        writer.writeElement('f', function () {
                            writer.writeAttributeString('t', 'array');
                            var range = common_1.IndexHelper._getColumnIndexInA1Letter(arrayFormulaRange_1.col) +
                                (arrayFormulaRange_1.row + 1) + ':' +
                                common_1.IndexHelper._getColumnIndexInA1Letter(arrayFormulaRange_1.col + arrayFormulaRange_1.colCount - 1) +
                                (arrayFormulaRange_1.row + arrayFormulaRange_1.rowCount);
                            if (arrayFormulaRange_1.isInvalid) {
                                range = range.substr(0, range.indexOf(':'));
                            }
                            writer.writeAttributeString('ref', range);
                        }, function () {
                            writer.writeValue(common_1.Util._xmlEncode(common_1.addXLFNPrefix(formula)));
                        });
                    }
                }
                else {
                    writer.writeElement('f', keywords_undefined, function () {
                        writer.writeValue(common_1.Util._xmlEncode(common_1.addXLFNPrefix(formula)));
                    });
                }
            }
            if (value !== keywords_undefined && value !== null) {
                writer.writeElement('v', keywords_undefined, function () {
                    if (typeof value === 'string' && value.substring(0, 7) === '/OADate') {
                        cellType = 6;
                    }
                    switch (cellType) {
                        case 3:
                            if (typeof value === 'boolean') {
                                value = value ? 1 : 0;
                            }
                            var valueString = value.toString();
                            if (valueString && valueString.length > MAX_FORMULA_VALUE_LENGTH) {
                                valueString = "";
                            }
                            writer.writeValue(common_1.Util._xmlEncode(valueString));
                            break;
                        case 9:
                        case 2:
                            writer.writeValue(addStringToSharedStringTable({
                                value: value,
                                richText: richText
                            }).toString());
                            break;
                        case 7:
                            writer.writeValue(value._error);
                            break;
                        case 5:
                            var boolValue = '1';
                            if (typeof value === 'boolean' && !value) {
                                boolValue = '0';
                            }
                            else if (value.toString().toUpperCase() === 'FALSE') {
                                boolValue = '0';
                            }
                            writer.writeValue(boolValue);
                            break;
                        case 6:
                        default:
                            writer.writeValue(common_1.Util._xmlEncode(value.toString()));
                    }
                });
            }
        });
    }
}
function writeSheetProtection(writer, sheetName, writerDataModel) {
    var isProtect = writerDataModel._getProtect(sheetName);
    var protectionOptions = writerDataModel._getProtectionOptions(sheetName, isProtect);
    var value;
    if (isProtect || Object.keys(protectionOptions).length > 0) {
        writer.writeLeafElement('sheetProtection', function () {
            if (isProtect) {
                writer.writeAttributeString('sheet', '1');
            }
            for (var key in protectionOptions) {
                if (protectionOptions.hasOwnProperty(key)) {
                    value = protectionOptions[key];
                    if ((typeof value === "string")
                        && (key === 'algorithmName'
                            || key === 'hashValue'
                            || key === 'saltValue'
                            || key === 'spinCount'
                            || key === 'password')) {
                        writer.writeAttributeString(key, value);
                    }
                    else if (excel_helper_1.excelSupportProtectionOptions[key]) {
                        value = protectionOptions[key] ? '0' : '1';
                        writer.writeAttributeString(key, value);
                    }
                }
            }
        });
    }
}
function writeMergeCells(writer, sheetName, writerDataModel) {
    var spans = writerDataModel._getMergedCells(sheetName);
    if (spans && spans.length > 0) {
        writer.writeElement('mergeCells', function () {
            writer.writeAttributeString('count', spans.length.toString());
        }, function () {
            var _loop_4 = function (i, len) {
                var span = spans[i];
                writer.writeLeafElement('mergeCell', function () {
                    writer.writeAttributeString('ref', common_1.IndexHelper._getColumnIndexInA1Letter(span.col) + (span.row + 1) + ':' +
                        common_1.IndexHelper._getColumnIndexInA1Letter(span.col + span.colCount - 1) + (span.row + span.rowCount));
                });
            };
            for (var i = 0, len = spans.length; i < len; i++) {
                _loop_4(i, len);
            }
        });
    }
}
function writeExtensions(writer, sheetName, writerDataModel) {
    writer.writeElement('extLst', keywords_undefined, function () {
        conditionalformat_writer_1.writeExtensionConditionalFormats(writer, sheetName, writerDataModel);
        sparkline_writer_1.writeSparkline(writer, sheetName, writerDataModel);
        slicer_writer_1.writeSlicersInWorkSheet(writer, sheetName, writerDataModel);
        datavalidation_writer_2.writeExtensionDataValidations(writer, writerDataModel);
    });
}
function writeTableParts(writer, tables) {
    writer.writeElement('tableParts', function () {
        writer.writeAttributeString('count', tables.length.toString());
    }, function () {
        tables.forEach(function (sheetTable) {
            writer.writeLeafElement('tablePart', function () {
                writer.writeAttributeString('r:id', sheetTable.rid);
            });
        });
    });
}
function writeHyperlinks(writer, sheetName, writerDataModel, sheetViewFile) {
    var hyperlinks = writerDataModel._hyperlinks[sheetName];
    if (hyperlinks && hyperlinks.length > 0) {
        writer.writeElement('hyperlinks', function () {
            var _loop_5 = function (i, len) {
                var hyperlink = hyperlinks[i];
                writer.writeLeafElement('hyperlink', function () {
                    writer.writeAttributeString('ref', hyperlink.ref);
                    if (!hyperlink.location) {
                        var hyperlinkFileName = '';
                        var hyperlinkFile = new excel_types_1.XFile(hyperlinkFileName, excel_types_1.RelationshipConstants._relationshipHyperlinkType);
                        hyperlinkFile.target = hyperlink.url;
                        hyperlinkFile.targetMode = 'External';
                        hyperlink.rid = sheetViewFile._addRelationFile(hyperlinkFile);
                        writer.writeAttributeString('r:id', hyperlink.rid);
                    }
                    else {
                        writer.writeAttributeString('location', hyperlink.location);
                    }
                    hyperlink.display && writer.writeAttributeString('display', hyperlink.display);
                    hyperlink.tooltip && writer.writeAttributeString('tooltip', hyperlink.tooltip);
                    hyperlink["xr:uid"] && writer.writeAttributeString('xr:uid', hyperlink["xr:uid"]);
                });
            };
            for (var i = 0, len = hyperlinks.length; i < len; i++) {
                _loop_5(i, len);
            }
        });
    }
}


/***/ }),

/***/ "./src/xlsx-io/writer/xlsx-writer.ts":
/*!*******************************************!*\
  !*** ./src/xlsx-io/writer/xlsx-writer.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excel_types_1 = __webpack_require__(/*! ./../../common/excel-types */ "./src/common/excel-types.ts");
var common_1 = __webpack_require__(/*! ./../../common/common */ "./src/common/common.ts");
var xml_writer_1 = __webpack_require__(/*! ./../../xml-io/xml-writer */ "./src/xml-io/xml-writer.ts");
var datamodel_writer_1 = __webpack_require__(/*! ./../../datamodel/datamodel-writer */ "./src/datamodel/datamodel-writer.ts");
var style_writer_1 = __webpack_require__(/*! ./style-writer */ "./src/xlsx-io/writer/style-writer.ts");
var docPropsCoreWriter_1 = __webpack_require__(/*! ./docPropsCoreWriter */ "./src/xlsx-io/writer/docPropsCoreWriter.ts");
var docPropsAppWriter_1 = __webpack_require__(/*! ./docPropsAppWriter */ "./src/xlsx-io/writer/docPropsAppWriter.ts");
var docPropsCustomWriter_1 = __webpack_require__(/*! ./docPropsCustomWriter */ "./src/xlsx-io/writer/docPropsCustomWriter.ts");
var worksheet_writer_1 = __webpack_require__(/*! ./worksheet-writer */ "./src/xlsx-io/writer/worksheet-writer.ts");
var sharedString_writer_1 = __webpack_require__(/*! ./sharedString-writer */ "./src/xlsx-io/writer/sharedString-writer.ts");
var theme_writer_1 = __webpack_require__(/*! ./theme-writer */ "./src/xlsx-io/writer/theme-writer.ts");
var workbook_writer_1 = __webpack_require__(/*! ./workbook-writer */ "./src/xlsx-io/writer/workbook-writer.ts");
var comment_writer_1 = __webpack_require__(/*! ./comment-writer */ "./src/xlsx-io/writer/comment-writer.ts");
var drawing_writer_1 = __webpack_require__(/*! ./drawing-writer */ "./src/xlsx-io/writer/drawing-writer.ts");
var table_writer_1 = __webpack_require__(/*! ./table-writer */ "./src/xlsx-io/writer/table-writer.ts");
var slicer_writer_1 = __webpack_require__(/*! ./slicer-writer */ "./src/xlsx-io/writer/slicer-writer.ts");
var slicer_writer_2 = __webpack_require__(/*! ./slicer-writer */ "./src/xlsx-io/writer/slicer-writer.ts");
var print_writer_1 = __webpack_require__(/*! ./print-writer */ "./src/xlsx-io/writer/print-writer.ts");
var metadata_writer_1 = __webpack_require__(/*! ./metadata-writer */ "./src/xlsx-io/writer/metadata-writer.ts");
var chart_writer_1 = __webpack_require__(/*! ./chart-writer */ "./src/xlsx-io/writer/chart-writer.ts");
var excel_helper_1 = __webpack_require__(/*! ./../../datamodel/excel-helper */ "./src/datamodel/excel-helper.ts");
var excel_style_1 = __webpack_require__(/*! ../../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var pivot_writer_1 = __webpack_require__(/*! ./pivot-writer */ "./src/xlsx-io/writer/pivot-writer.ts");
var keyword_undefined = void 0;
var JSZip = __webpack_require__(/*! ./../../lib/jszip.min.js */ "./src/lib/jszip.min.js");
function getImageFile(picture, index, pictureFile) {
    var extension = picture.imageType || 'jpg';
    if (extension === "svg+xml") {
        extension = "svg";
    }
    var imageFileName = excel_types_1.XFileConstants._imageFileNamePrefix + index + '.' + extension;
    var imageFile = new excel_types_1.XFile(excel_types_1.XFileConstants._mediaFileFolder + '/' + imageFileName, excel_types_1.RelationshipConstants._relationshipImageType);
    imageFile.target = '../media/' + imageFileName;
    var rid = pictureFile._addRelationFile(imageFile);
    picture.rid = rid;
    return imageFile;
}
function createAlternate(chartName, chartID, descr) {
    return {
        AlternateContent: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        Choice: {
            cx: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
            Requires: "cx1",
            GraphicalObjectFrame: {
                nvGraphicFramePr: {
                    cNvPr: {
                        id: 1, name: chartName,
                        descr: descr || ""
                    }
                },
                graphic: {
                    graphicData: {
                        chart: {
                            id: chartID
                        }
                    }
                }
            }
        }
    };
}
var XlsxWriter = /** @class */ (function () {
    function XlsxWriter(spread, callback) {
        var self = this;
        self._styleOffset = 0;
        self._writerDataModel = keyword_undefined;
        self._xfMap = {};
        self._sheetIDs = [];
        self._isR1C1 = spread.referenceStyle === 1;
        self._iterativeCalculation = {
            iterate: spread.iterativeCalculation,
            count: spread.iterativeCalculationMaximumIterations,
            delta: spread.iterativeCalculationMaximumChange
        };
        self._options = {};
        self._zip = JSZip();
        self._totalVmlDrawingCount = 0;
        self._totalCommentCount = 0;
        self._totalDrawingCount = 0;
        self._imageIndex = 0;
        self._totalSlicerCount = 0;
        self._totalSlicerCacheCount = 0;
        self._totalChartCount = 0;
        self._writerDataModel = new datamodel_writer_1.WriterDataModel(spread);
        self._writerDataModel.onCompleted = function () {
            callback.call(self);
        };
        self._writerDataModel._preProcessWorkbook();
        if (self._writerDataModel) {
            self._writerDataModel._triggerOnCompleted();
        }
    }
    XlsxWriter.prototype._save = function () {
        var self = this;
        var rootVirtualFile = new excel_types_1.XFile('', '');
        var workbookFile = new excel_types_1.XFile(excel_types_1.XFileConstants._workbook_default_fileName, excel_types_1.RelationshipConstants._relationshipWorkbookType);
        rootVirtualFile._addRelationFile(workbookFile);
        self._saveDocProps(rootVirtualFile);
        var sharedString = {
            _sstTable: [],
            _sstTableDict: {},
            _sstTableCount: 0,
            _sstDuplicatedValue: {}
        };
        var styleOffset = self._saveStyles(workbookFile);
        var chart2016DefinedNames = [];
        self._writePivotCaches(self._writerDataModel._spread.pivotCaches, workbookFile);
        self._saveWorksheets(workbookFile, styleOffset, sharedString, chart2016DefinedNames);
        self._saveStringTables(workbookFile, sharedString);
        self._saveTheme(workbookFile);
        self._writeMetadata(workbookFile);
        self._saveWorkbook(chart2016DefinedNames);
        self._savePackageRelationFiles(rootVirtualFile);
        self._saveContentTypes(rootVirtualFile, self._totalVmlDrawingCount > 0);
        self._dispose();
        self._zip.generateAsync({
            type: self._options.useArrayBuffer ? 'arraybuffer' : 'blob',
            mimeType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            compression: 'DEFLATE'
        }).then(function (content) {
            self.onZip(content);
        }).catch(function () {
            self.onError();
        });
    };
    XlsxWriter.prototype._saveDocProps = function (rootVirtualFile) {
        var self = this;
        var spreadJSON = self._writerDataModel._spread;
        if (common_1.isNullOrUndefined(spreadJSON.docProps)) {
            return;
        }
        if (spreadJSON.docProps.docPropsCore) {
            var docPropsCoreFile = new excel_types_1.XFile(excel_types_1.XFileConstants._docPropsCore_default_fileName, excel_types_1.RelationshipConstants._relationshipDocPropsCoreType);
            rootVirtualFile._addRelationFile(docPropsCoreFile);
            self._saveDocPropsCore();
        }
        if (spreadJSON.docProps.docPropsApp) {
            var docPropsAppFile = new excel_types_1.XFile(excel_types_1.XFileConstants._docPropsApp_default_fileName, excel_types_1.RelationshipConstants._relationshipDocPropsAppType);
            rootVirtualFile._addRelationFile(docPropsAppFile);
            self._saveDocPropsApp();
        }
        if (spreadJSON.docProps.docPropsCustom) {
            var docPropsCustomFile = new excel_types_1.XFile(excel_types_1.XFileConstants._docPropsCustom_default_fileName, excel_types_1.RelationshipConstants._relationshipDocPropsCustomType);
            rootVirtualFile._addRelationFile(docPropsCustomFile);
            self._saveDocPropsCustom();
        }
    };
    XlsxWriter.prototype._savePackageRelationFiles = function (xFile) {
        if (common_1.isNullOrUndefined(xFile) || common_1.isNullOrUndefined(xFile.relationFiles) || xFile.relationFiles.count === 0) {
            return;
        }
        var pathInfo = common_1.Util._parsePath(xFile.fileName), path = pathInfo.dir, fileName = pathInfo.fileName;
        var self = this;
        var relationFiles = {};
        for (var item in xFile.relationFiles) {
            if (xFile.relationFiles.hasOwnProperty(item)) {
                var rel = xFile.relationFiles[item];
                if (rel && item !== 'count') {
                    var targetAndType = [
                        rel.target || rel.fileName.replace(path + '/', ''),
                        rel.fileType
                    ];
                    rel.targetMode && targetAndType.push(rel.targetMode);
                    relationFiles[item] = targetAndType;
                    this._savePackageRelationFiles(rel);
                }
            }
        }
        var writer = new xml_writer_1.XmlWriter();
        writer.writeDocument();
        writer.writeElement('Relationships', function () {
            writer.writeAttributeString('xmlns', excel_types_1.XFileConstants._relationshipNameSpace);
        }, function () {
            var _loop_1 = function (key) {
                if (relationFiles.hasOwnProperty(key)) {
                    var targetAndType_1 = relationFiles[key];
                    if (targetAndType_1 && targetAndType_1.length >= 2) {
                        writer.writeLeafElement('Relationship', function () {
                            writer.writeAttributeString('Id', key);
                            writer.writeAttributeString('Type', targetAndType_1[1]);
                            writer.writeAttributeString('Target', targetAndType_1[0]);
                            targetAndType_1[2] && writer.writeAttributeString('TargetMode', targetAndType_1[2]);
                        });
                    }
                }
            };
            for (var key in relationFiles) {
                _loop_1(key);
            }
        });
        var name = path + '/' + excel_types_1.XFileConstants._relationshipFileFolder + '/' + fileName + '.' + excel_types_1.XFileConstants._relsExtension;
        self._zip.file(name.substring(1), writer.getXmlString());
    };
    XlsxWriter.prototype._saveContentTypes = function (rootVirtualFile, withVmlDrawingFiles) {
        var ctTypes = this._writerDataModel._getContentTypes(rootVirtualFile, withVmlDrawingFiles);
        var writer = new xml_writer_1.XmlWriter();
        writer.writeDocument();
        writer.writeElement('Types', function () {
            writer.writeAttributeString('xmlns', excel_types_1.XFileConstants._contentTypeNameSpace);
        }, function () {
            var _loop_2 = function (i, len) {
                var item = ctTypes[i];
                if (item instanceof excel_types_1.DefaultContentType) {
                    writer.writeLeafElement('Default', function () {
                        writer.writeAttributeString('Extension', item.extension);
                        writer.writeAttributeString('ContentType', item.contentType);
                    });
                }
                else if (item instanceof excel_types_1.OverrideContentType) {
                    writer.writeLeafElement('Override', function () {
                        writer.writeAttributeString('PartName', item.partName);
                        writer.writeAttributeString('ContentType', item.contentType);
                    });
                }
            };
            for (var i = 0, len = ctTypes.length; i < len; i++) {
                _loop_2(i, len);
            }
        });
        this._zip.file(excel_types_1.XFileConstants._contentTypeFileName, writer.getXmlString());
    };
    XlsxWriter.prototype._saveDocPropsCore = function () {
        var self = this;
        var xml = docPropsCoreWriter_1.writeDocPropsCore(self._writerDataModel);
        this._zip.file(excel_types_1.XFileConstants._docPropsCore_default_fileName.substring(1), xml);
    };
    XlsxWriter.prototype._saveDocPropsApp = function () {
        var self = this;
        var xml = docPropsAppWriter_1.writeDocPropsApp(self._writerDataModel);
        this._zip.file(excel_types_1.XFileConstants._docPropsApp_default_fileName.substring(1), xml);
    };
    XlsxWriter.prototype._saveDocPropsCustom = function () {
        var self = this;
        var xml = docPropsCustomWriter_1.writeDocPropsCustom(self._writerDataModel);
        this._zip.file(excel_types_1.XFileConstants._docPropsCustom_default_fileName.substring(1), xml);
    };
    XlsxWriter.prototype._saveStyles = function (workbookFile) {
        var self = this;
        var stylesFile = new excel_types_1.XFile(excel_types_1.XFileConstants._style_fileName, excel_types_1.RelationshipConstants._relationshipStylesType);
        workbookFile._addRelationFile(stylesFile);
        var styleResult = style_writer_1.writeStyle(self._writerDataModel, self._xfMap);
        self._zip.file(excel_types_1.XFileConstants._style_fileName.substring(1), styleResult.xml);
        return styleResult.styleOffset;
    };
    XlsxWriter.prototype._saveWorksheets = function (workbookFile, styleOffset, sharedString, outDefindNames) {
        var model = this._writerDataModel;
        var sheetNames = model._getSheetsName(), sheetCount = sheetNames.length;
        var id = 0;
        var tables = model._getTables();
        if (tables && tables.length > 0) {
            tables.forEach(function (sheetTable) {
                sheetTable.id = ++id;
            });
        }
        for (var index = 0; index < sheetCount; index++) {
            var sheetName = sheetNames[index];
            if (!sheetName) {
                continue;
            }
            var si = new excel_types_1.SheetInfo();
            si.name = sheetName;
            si.sheetId = index + 1;
            si.index = index;
            var sheetviewFile = new excel_types_1.XFile(excel_types_1.XFileConstants._worksheetFolder + '/' + excel_types_1.XFileConstants._worksheetNamePrefix + si.sheetId + '.' + excel_types_1.XFileConstants._xmlExtension, excel_types_1.RelationshipConstants._relationshipWorksheetType);
            si.rID = workbookFile._addRelationFile(sheetviewFile);
            this._sheetIDs.push(si);
            var extensions = { attributes: [] };
            this._writeComments(model, sheetName, sheetviewFile, extensions, index);
            var drawingObjects = model._getDrawingObjects(sheetName);
            var drawingFile = this._writeDrawings(sheetviewFile, extensions, drawingObjects.withDrawingObjects);
            this._writeCharts(model, drawingFile, sheetName, drawingObjects.charts, outDefindNames);
            this._writeDrawingFiles(model, drawingFile, drawingObjects);
            this._writeTables(model, sheetviewFile, sheetName);
            this._writeSlicers(model, sheetviewFile, sheetName, workbookFile);
            this._writeVmlDrawing(model, sheetviewFile, sheetName, workbookFile);
            this._writePivotTables(model, sheetviewFile, sheetName);
            this._writeSheet(si, styleOffset, sharedString, extensions, sheetviewFile);
        }
    };
    XlsxWriter.prototype._saveStringTables = function (workbookFile, sharedString) {
        var self = this;
        if (sharedString._sstTable.length <= 0) {
            return;
        }
        var ssFile = new excel_types_1.XFile(excel_types_1.XFileConstants._sharedStringsDefaultFileName, excel_types_1.RelationshipConstants._relationshipSharedStringsType);
        workbookFile._addRelationFile(ssFile);
        var xml = sharedString_writer_1.writeSharedString(sharedString);
        self._zip.file(excel_types_1.XFileConstants._sharedStringsDefaultFileName.substring(1), xml);
    };
    XlsxWriter.prototype._saveTheme = function (workbookFile) {
        var themeFile = new excel_types_1.XFile(excel_types_1.XFileConstants._themeDefaultFileName, excel_types_1.RelationshipConstants._relationshipThemeType);
        workbookFile._addRelationFile(themeFile);
        var xml = theme_writer_1.writeTheme(this._writerDataModel);
        this._zip.file(excel_types_1.XFileConstants._theme_default_fileName.substring(1), xml);
    };
    XlsxWriter.prototype._saveWorkbook = function (chart2016DefinedNames) {
        var self = this;
        var xml = workbook_writer_1.writeWorkbook(self._writerDataModel, self._sheetIDs, self._isR1C1, chart2016DefinedNames, self._pivotDefinitionFileMap, self._iterativeCalculation);
        self._zip.file(excel_types_1.XFileConstants._workbook_default_fileName.substring(1), xml);
    };
    XlsxWriter.prototype._writePivotCaches = function (pivotCaches, workbookFile) {
        if (!pivotCaches) {
            return;
        }
        var pivotCacheDefinitionOrder = 1;
        var pivotCacheRecordOrder = 1;
        this._pivotDefinitionFileMap = {};
        for (var pivotCacheKey in pivotCaches) {
            if (pivotCaches.hasOwnProperty(pivotCacheKey)) {
                var pivotCacheDefinitionFile = new excel_types_1.XFile(excel_types_1.XFileConstants._pivotCacheFilesFolder + '/' + excel_types_1.XFileConstants._pivotCacheDefinitionPrefix + pivotCacheDefinitionOrder + '.' + excel_types_1.XFileConstants._xmlExtension, excel_types_1.RelationshipConstants._relationshipPivotCacheDefinitionType);
                var pivotCacheRecordFile = new excel_types_1.XFile(excel_types_1.XFileConstants._pivotCacheFilesFolder + '/' + excel_types_1.XFileConstants._pivotCacheRecordPrefix + pivotCacheRecordOrder + '.' + excel_types_1.XFileConstants._xmlExtension, excel_types_1.RelationshipConstants._relationshipPivotCacheRecordsType);
                var rid = workbookFile._addRelationFile(pivotCacheDefinitionFile);
                this._pivotDefinitionFileMap[pivotCacheKey] = {
                    file: pivotCacheDefinitionFile,
                    cacheId: pivotCacheKey,
                    rid: rid
                };
                var pivotCacheDefinitionXML = pivot_writer_1.writePivotCacheDefinition(pivotCaches[pivotCacheKey]);
                this._zip.file((excel_types_1.XFileConstants._pivotCacheFilesFolder + '/' + excel_types_1.XFileConstants._pivotCacheDefinitionPrefix + pivotCacheDefinitionOrder + '.' + excel_types_1.XFileConstants._xmlExtension).substring(1), pivotCacheDefinitionXML);
                pivotCacheDefinitionFile._addRelationFile(pivotCacheRecordFile);
                var pivotCacheRecordXML = pivot_writer_1.writePivotCacheRecords(pivotCaches[pivotCacheKey].pivotCacheRecords);
                this._zip.file((excel_types_1.XFileConstants._pivotCacheFilesFolder + '/' + excel_types_1.XFileConstants._pivotCacheRecordPrefix + pivotCacheRecordOrder + '.' + excel_types_1.XFileConstants._xmlExtension).substring(1), pivotCacheRecordXML);
                pivotCacheDefinitionOrder++;
                pivotCacheRecordOrder++;
            }
        }
    };
    XlsxWriter.prototype._writeSheet = function (si, styleOffset, shareString, extensions, sheetViewFile) {
        var self = this;
        var xml = worksheet_writer_1.writeWorksheet(self._writerDataModel, si.name, self._xfMap, styleOffset, self._options, shareString, extensions, sheetViewFile);
        this._zip.file(excel_types_1.XFileConstants._worksheetFilePath.substring(1) + '/sheet' + si.sheetId + '.' + excel_types_1.XFileConstants._xmlExtension, xml);
    };
    XlsxWriter.prototype._writeComments = function (model, sheetName, sheetviewFile, extensions, sheetIndex) {
        var comments = model._getComments(sheetName);
        if (comments && comments.length > 0) {
            this._totalCommentCount++;
            var commentFileName = excel_types_1.XFileConstants._commentFileNamePrefix + this._totalCommentCount + '.' + excel_types_1.XFileConstants._xmlExtension;
            var commentFile = new excel_types_1.XFile(excel_types_1.XFileConstants._dataFileRootFolder + '/' + commentFileName, excel_types_1.RelationshipConstants._relationshipCommentType);
            commentFile.target = '../' + commentFileName;
            sheetviewFile._addRelationFile(commentFile);
            this._totalVmlDrawingCount++;
            var commentShapeFileName = excel_types_1.XFileConstants._vmlDrawingsFileNamePrefix + this._totalVmlDrawingCount + '.' + excel_types_1.XFileConstants._vmlExtension;
            var commentShapeFile = new excel_types_1.XFile(excel_types_1.XFileConstants._drawingsFileFolder + '/' + commentShapeFileName, excel_types_1.RelationshipConstants._relationshipVMLDrawingType);
            commentShapeFile.target = '../drawings/' + commentShapeFileName;
            var rid = sheetviewFile._addRelationFile(commentShapeFile);
            extensions.legacyDrawingId = rid;
            extensions.attributes.push({ key: 'xmlns:xdr', value: excel_types_1.XFileConstants._drawingNameSpace });
            this._writeCommentFiles(model, sheetIndex, comments, commentFile.fileName, commentShapeFile.fileName);
        }
    };
    XlsxWriter.prototype._writeCommentFiles = function (model, sheetIndex, comments, commentFileName, commentShapeFileName) {
        var self = this, zip = self._zip;
        var xml = comment_writer_1.writeComments(model, comments);
        zip.file(commentFileName.substring(1), xml);
        xml = comment_writer_1.writeCommentShapes(model, sheetIndex, comments);
        zip.file(commentShapeFileName.substring(1), xml);
    };
    XlsxWriter.prototype._writePivotTables = function (model, worksheetFile, sheetName) {
        var pivotTables = model._getPivotTables(sheetName);
        if (pivotTables && pivotTables.length > 0) {
            if (!this._pivotTableOrder) {
                this._pivotTableOrder = 1;
            }
            for (var pivotTableKey in pivotTables) {
                if (pivotTables.hasOwnProperty(pivotTableKey)) {
                    var pivotTableName = excel_types_1.XFileConstants._pivotTablePrefix + this._pivotTableOrder + '.' + excel_types_1.XFileConstants._xmlExtension;
                    var pivotTableFile = new excel_types_1.XFile(excel_types_1.XFileConstants._pivotTablesFolder + '/' + pivotTableName, excel_types_1.RelationshipConstants._relationshipPivotTableType);
                    pivotTableFile.target = '../pivotTables/' + pivotTableName;
                    worksheetFile._addRelationFile(pivotTableFile);
                    var pivotDefinitionFile = this._pivotDefinitionFileMap && this._pivotDefinitionFileMap[pivotTables[pivotTableKey].cacheId] && this._pivotDefinitionFileMap[pivotTables[pivotTableKey].cacheId].file;
                    if (pivotDefinitionFile) {
                        pivotTableFile._addRelationFile(pivotDefinitionFile);
                    }
                    var pivotTableXML = pivot_writer_1.writePivotTable(model, pivotTables[pivotTableKey]);
                    this._zip.file((excel_types_1.XFileConstants._pivotTablesFolder + '/' + pivotTableName).substring(1), pivotTableXML);
                    this._pivotTableOrder++;
                }
            }
        }
    };
    XlsxWriter.prototype._writeCharts = function (model, drawingFile, sheetName, charts, outDefindNames) {
        if (charts) {
            var _this_1 = this;
            charts.forEach(function (chartItem) {
                var seriesItemTemp = common_1.Util._get2016ChartSeries(chartItem);
                var layoutId = seriesItemTemp && seriesItemTemp.layoutId;
                var is2016Chart = common_1.Util._is2016ChartByLayoutId(layoutId);
                var relationChartType = is2016Chart ? excel_types_1.RelationshipConstants._relationshipNewChartType : excel_types_1.RelationshipConstants._relationshipChartType;
                var chartFileNamePrefix = is2016Chart ? excel_types_1.XFileConstants._chartExtensionFileNamePrefix : excel_types_1.XFileConstants._chartFileNamePrefix;
                _this_1._totalChartCount++;
                var chartFileName = chartFileNamePrefix + _this_1._totalChartCount + '.' + excel_types_1.XFileConstants._xmlExtension;
                var chartStyleName = excel_types_1.XFileConstants._chartStyleFileName + _this_1._totalChartCount + '.' + excel_types_1.XFileConstants._xmlExtension;
                var chartColorsName = excel_types_1.XFileConstants._chartColorsStyleFileName + _this_1._totalChartCount + '.' + excel_types_1.XFileConstants._xmlExtension;
                var chartFile = new excel_types_1.XFile(excel_types_1.XFileConstants._chartsFileFolder + '/' + chartFileName, relationChartType);
                var chartStyleFile = new excel_types_1.XFile(excel_types_1.XFileConstants._chartsFileFolder + '/' + chartStyleName, excel_types_1.RelationshipConstants._realationshipChartStyle);
                var chartColorsFile = new excel_types_1.XFile(excel_types_1.XFileConstants._chartsFileFolder + '/' + chartColorsName, excel_types_1.RelationshipConstants._realationshipChartColorStyle);
                chartFile.target = '../charts/' + chartFileName;
                chartItem.chartId = drawingFile._addRelationFile(chartFile);
                var cNvPrTemp = chartItem.graphicFrame.nvGraphicFramePr.cNvPr;
                chartItem.AlternateContent = createAlternate(cNvPrTemp.name, chartItem.chartId, cNvPrTemp.descr);
                var chartSpace = chartItem.chartSpace;
                if (chartSpace) {
                    _this_1._writeChartUserShapes(chartSpace, chartItem, chartFile);
                    _this_1._writeChartEmbededImage(chartSpace, chartFile);
                    var writer = new xml_writer_1.XmlWriter();
                    writer.writeDocument();
                    if (is2016Chart) {
                        var drawingInfoNames = void 0;
                        if (_this_1._writerDataModel && _this_1._writerDataModel._spread && _this_1._writerDataModel._spread.names) {
                            drawingInfoNames = _this_1._writerDataModel._spread.names;
                        }
                        else {
                            drawingInfoNames = [];
                        }
                        chart_writer_1.DrawingWriter.chart2016Write.WriteCT_ChartSpace(writer, 'cx', 'chartSpace', chartSpace, drawingInfoNames, outDefindNames);
                    }
                    else {
                        chart_writer_1.DrawingWriter.WriteCT_ChartSpace(writer, 'c', 'chartSpace', chartSpace);
                    }
                    _this_1._zip.file(chartFile.fileName.substring(1), writer.getXmlString());
                    if (is2016Chart) {
                        chartStyleFile.target = '../charts/' + chartStyleName;
                        if (common_1.isNullOrUndefined(chartItem.chartSpace.style)) {
                            chartItem.chartSpace.style = JSON.parse('{"attribute":{"cs":"http://schemas.microsoft.com/office/drawing/2012/chartStyle","a":"http://schemas.openxmlformats.org/drawingml/2006/main","id":"381"},"axisTitle":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1,"lumMod":[65000],"lumOff":[35000]}}},"idx":1},"defRPr":{"sz":12}},"categoryAxis":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1,"lumMod":[65000],"lumOff":[35000]}}},"idx":1},"spPr":{"ln":{"w":1,"cap":2,"cmpd":0,"algn":0,"solidFill":{"schemeClr":{"val":1,"lumMod":[15000],"lumOff":[85000]}},"round":true}},"defRPr":{"sz":12}},"chartArea":{"attribute":{"mods":"allowNoFillOverride allowNoLineOverride"},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"solidFill":{"schemeClr":{"val":0}},"ln":{"w":1,"cap":2,"cmpd":0,"algn":0,"solidFill":{"schemeClr":{"val":1,"lumMod":[15000],"lumOff":[85000]}},"round":true}},"defRPr":{"sz":13.33}},"dataLabel":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":14}}},"idx":1},"defRPr":{"sz":12}},"dataLabelCallout":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":13,"lumMod":[65000],"lumOff":[35000]}}},"idx":1},"spPr":{"solidFill":{"schemeClr":{"val":14}},"ln":{"solidFill":{"schemeClr":{"val":13,"lumMod":[25000],"lumOff":[75000]}}}},"defRPr":{"sz":12},"bodyPr":{"rot":0,"spcFirstLastPara":true,"vertOverflow":2,"horzOverflow":1,"vert":0,"wrap":1,"lIns":36576,"tIns":18288,"rIns":36576,"bIns":18288,"anchor":1,"anchorCtr":true,"spAutoFit":true}},"dataPoint":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{"styleClr":{"val":0}},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"solidFill":{"schemeClr":{"val":12}},"ln":{"w":2,"solidFill":{"schemeClr":{"val":14}}}}},"dataPoint3D":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{"styleClr":{"val":0}},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"solidFill":{"schemeClr":{"val":12}}}},"dataPointLine":{"attribute":{},"lnRef":{"ColorProp":{"styleClr":{"val":0}},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"ln":{"w":3,"cap":0,"solidFill":{"schemeClr":{"val":12}},"round":true}}},"dataPointMarker":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{"styleClr":{"val":0}},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"solidFill":{"schemeClr":{"val":12}},"ln":{"w":1,"solidFill":{"schemeClr":{"val":14}}}}},"dataPointMarkerLayout":{"attribute":{"symbol":"circle","size":"5"}},"dataPointWireframe":{"attribute":{},"lnRef":{"ColorProp":{"styleClr":{"val":0}},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"ln":{"w":3,"cap":0,"solidFill":{"schemeClr":{"val":12}},"round":true}}},"dataTable":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1,"lumMod":[65000],"lumOff":[35000]}}},"idx":1},"spPr":{"ln":{"w":1,"solidFill":{"schemeClr":{"val":1,"lumMod":[15000],"lumOff":[85000]}}}},"defRPr":{"sz":12}},"downBar":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":13}}},"idx":1},"spPr":{"solidFill":{"schemeClr":{"val":13,"lumMod":[65000],"lumOff":[35000]}},"ln":{"w":1,"solidFill":{"schemeClr":{"val":1,"lumMod":[65000],"lumOff":[35000]}}}}},"dropLine":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"ln":{"w":1,"cap":2,"cmpd":0,"algn":0,"solidFill":{"schemeClr":{"val":1,"lumMod":[35000],"lumOff":[65000]}},"round":true}}},"errorBar":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"ln":{"w":1,"cap":2,"cmpd":0,"algn":0,"solidFill":{"schemeClr":{"val":1,"lumMod":[65000],"lumOff":[35000]}},"round":true}}},"floor":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1}},"gridlineMajor":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"ln":{"w":1,"cap":2,"cmpd":0,"algn":0,"solidFill":{"schemeClr":{"val":1,"lumMod":[15000],"lumOff":[85000]}},"round":true}}},"gridlineMinor":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"ln":{"w":1,"cap":2,"cmpd":0,"algn":0,"solidFill":{"schemeClr":{"val":1,"lumMod":[15000],"lumOff":[85000]}},"round":true}}},"hiLoLine":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"ln":{"w":1,"cap":2,"cmpd":0,"algn":0,"solidFill":{"schemeClr":{"val":1,"lumMod":[75000],"lumOff":[25000]}},"round":true}}},"leaderLine":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"ln":{"w":1,"cap":2,"cmpd":0,"algn":0,"solidFill":{"schemeClr":{"val":1,"lumMod":[35000],"lumOff":[65000]}},"round":true}}},"legend":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1,"lumMod":[65000],"lumOff":[35000]}}},"idx":1},"defRPr":{"sz":12}},"plotArea":{"attribute":{"mods":"allowNoFillOverride allowNoLineOverride"},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1}},"plotArea3D":{"attribute":{"mods":"allowNoFillOverride allowNoLineOverride"},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1}},"seriesAxis":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1,"lumMod":[65000],"lumOff":[35000]}}},"idx":1},"spPr":{"ln":{"w":1,"cap":2,"cmpd":0,"algn":0,"solidFill":{"schemeClr":{"val":1,"lumMod":[15000],"lumOff":[85000]}},"round":true}},"defRPr":{"sz":12}},"seriesLine":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"ln":{"w":1,"cap":2,"solidFill":{"srgbClr":{"val":[217,217,217]}},"round":true}}},"title":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1,"lumMod":[65000],"lumOff":[35000]}}},"idx":1},"defRPr":{"sz":18.67}},"trendline":{"attribute":{},"lnRef":{"ColorProp":{"styleClr":{"val":0}},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1},"spPr":{"ln":{"w":2,"cap":0,"solidFill":{"schemeClr":{"val":12}},"prstDash":7}}},"trendlineLabel":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1,"lumMod":[65000],"lumOff":[35000]}}},"idx":1},"defRPr":{"sz":12}},"upBar":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":13}}},"idx":1},"spPr":{"solidFill":{"schemeClr":{"val":14}},"ln":{"w":1,"solidFill":{"schemeClr":{"val":1,"lumMod":[15000],"lumOff":[85000]}}}}},"valueAxis":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1,"lumMod":[65000],"lumOff":[35000]}}},"idx":1},"defRPr":{"sz":12}},"wall":{"attribute":{},"lnRef":{"ColorProp":{},"idx":0},"fillRef":{"ColorProp":{},"idx":0},"effectRef":{"ColorProp":{},"idx":0},"fontRef":{"TextCharacterProperties":{"solidFill":{"schemeClr":{"val":1}}},"idx":1}}}');
                        }
                        chartItem.chartSpace.style.id = chartFile._addRelationFile(chartStyleFile);
                        chartColorsFile.target = '../charts/' + chartColorsName;
                        if (common_1.isNullOrUndefined(chartItem.chartSpace.colors)) {
                            chartItem.chartSpace.colors = JSON.parse('{"schemeClr":[{"val":4},{"val":5},{"val":6},{"val":7},{"val":8},{"val":9}],"variation":[{},{"lumMod":60000},{"lumMod":80000,"lumOff":20000},{"lumMod":80000},{"lumMod":60000,"lumOff":40000},{"lumMod":50000},{"lumMod":70000,"lumOff":30000},{"lumMod":70000},{"lumMod":50000,"lumOff":50000}],"attribute":{"cs":"http://schemas.microsoft.com/office/drawing/2012/chartStyle","a":"http://schemas.openxmlformats.org/drawingml/2006/main","meth":"cycle","id":"10"}}');
                        }
                        chartItem.chartSpace.colors.id = chartFile._addRelationFile(chartColorsFile);
                        var styleWrite = new xml_writer_1.XmlWriter();
                        chart_writer_1.DrawingWriter.chart2016Write.WriteCT_ChartStyle(styleWrite, 'cs', 'chartStyle', null, chartSpace.style);
                        _this_1._zip.file(chartStyleFile.fileName.substring(1), styleWrite.getXmlString());
                        var colorWrite = new xml_writer_1.XmlWriter();
                        chart_writer_1.DrawingWriter.chart2016Write.WriteCT_ChartColors(colorWrite, 'cs', 'colorStyle', null, chartSpace.colors);
                        _this_1._zip.file(chartColorsFile.fileName.substring(1), colorWrite.getXmlString());
                    }
                }
            });
        }
    };
    XlsxWriter.prototype._writeChartUserShapes = function (chartSpace, chart, chartFile) {
        var _this = this;
        var userShapes = chartSpace.userShapes;
        var relSizeAnchor = userShapes && userShapes.relSizeAnchor;
        if (relSizeAnchor && relSizeAnchor.length > 0) {
            _this._totalDrawingCount++;
            var chartDrawingFileName = excel_types_1.XFileConstants._drawingFileNamePrefix + _this._totalDrawingCount + '.' + excel_types_1.XFileConstants._xmlExtension;
            var userShapeDrawingFile_1 = new excel_types_1.XFile(excel_types_1.XFileConstants._drawingsFileFolder + '/' + chartDrawingFileName, excel_types_1.RelationshipConstants._realationshipChartUserShapes);
            userShapeDrawingFile_1.target = '../drawings/' + chartDrawingFileName;
            chart.drawingFile = userShapeDrawingFile_1;
            var drawingId = chartFile._addRelationFile(userShapeDrawingFile_1);
            chartSpace.userShapes.id = drawingId;
            relSizeAnchor.forEach(function (shapeItem) {
                if (shapeItem.typeName === '1') {
                    _this._writePictureInChart(shapeItem, userShapeDrawingFile_1);
                }
                else if (shapeItem.typeName === '2') {
                    _this._writeChartInChart(shapeItem, userShapeDrawingFile_1);
                }
            });
        }
    };
    XlsxWriter.prototype._writePictureInChart = function (pictureInChart, userShapeDrawingFile) {
        var chartEmbedImageString = pictureInChart.src;
        if (chartEmbedImageString) {
            var _this = this;
            _this._imageIndex++;
            var imageInfo = {};
            excel_helper_1.getPictureInfo(chartEmbedImageString, imageInfo);
            var imageFile = getImageFile(imageInfo, _this._imageIndex, userShapeDrawingFile);
            _this._zip.file(imageFile.fileName.substring(1), imageInfo.base64Image, { base64: true });
            pictureInChart.pic.blipFill = {
                blip: {
                    embed: imageInfo.rid
                }
            };
        }
    };
    XlsxWriter.prototype._writePictureFromCameraTool = function (pic, userShapeDrawingFile) {
        var _this = this;
        if (!pic.src && pic.size) {
            var src = _this._renderCameraImage(pic.size.width, pic.size.height);
            src = src.replace('png', 'emf');
            pic.src = src;
        }
        var embedImageString = pic.src;
        if (embedImageString) {
            _this._imageIndex++;
            var imageInfo = {};
            excel_helper_1.getPictureInfo(embedImageString, imageInfo);
            var imageFile = getImageFile(imageInfo, _this._imageIndex, userShapeDrawingFile);
            _this._zip.file(imageFile.fileName.substring(1), imageInfo.base64Image, { base64: true });
            pic.blipFill = {
                blip: {
                    embed: imageInfo.rid
                }
            };
        }
    };
    XlsxWriter.prototype._renderCameraImage = function (width, height) {
        var buffer = document.createElement('canvas');
        buffer.width = width;
        buffer.height = height;
        return buffer.toDataURL("image/png");
    };
    XlsxWriter.prototype._writeChartInChart = function (chartInChart, userShapeDrawingFile) {
        var _this = this;
        _this._totalChartCount++;
        var chartFileName = excel_types_1.XFileConstants._chartFileNamePrefix + _this._totalChartCount + '.' + excel_types_1.XFileConstants._xmlExtension;
        var chartFile = new excel_types_1.XFile(excel_types_1.XFileConstants._chartsFileFolder + '/' + chartFileName, excel_types_1.RelationshipConstants._relationshipChartType);
        chartFile.target = '../charts/' + chartFileName;
        var chartId = userShapeDrawingFile._addRelationFile(chartFile);
        var chartSpace = chartInChart.chartSpace;
        var seriesItemTemp = common_1.Util._get2016ChartSeries(chartSpace);
        var layoutId = seriesItemTemp && seriesItemTemp.layoutId;
        var is2016Chart = common_1.Util._is2016ChartByLayoutId(layoutId);
        if (chartSpace) {
            chartInChart.graphicFrame.graphic = {
                graphicData: {
                    chart: {
                        id: chartId,
                        typeName: 'chartSpace'
                    }
                }
            };
            var writer = new xml_writer_1.XmlWriter();
            writer.writeDocument();
            if (is2016Chart) {
                var drawingInfoNames = void 0;
                if (_this._writerDataModel && _this._writerDataModel._spread && _this._writerDataModel._spread.names) {
                    drawingInfoNames = _this._writerDataModel._spread.names;
                }
                else {
                    drawingInfoNames = [];
                }
                chart_writer_1.DrawingWriter.chart2016Write.WriteCT_ChartSpace(writer, 'cx', 'chartSpace', chartSpace, drawingInfoNames);
            }
            else {
                chart_writer_1.DrawingWriter.WriteCT_ChartSpace(writer, 'c', 'chartSpace', chartSpace);
            }
            _this._zip.file(chartFile.fileName.substring(1), writer.getXmlString());
        }
    };
    XlsxWriter.prototype._writeChartEmbededImage = function (chartSpace, chartFile) {
        var _this = this;
        var plotArea = chartSpace.chart.plotArea;
        if (plotArea && plotArea.chartGroups) {
            plotArea.chartGroups.forEach(function (chart) {
                if (chart && chart.ser) {
                    chart.ser.forEach(function (serItem) {
                        if (serItem.spPr) {
                            _this._writeEmbedImageFile(chartFile, serItem.spPr);
                        }
                        if (serItem.dLbls && serItem.dLbls.spPr) {
                            _this._writeEmbedImageFile(chartFile, serItem.dLbls.spPr);
                        }
                    });
                }
            });
        }
        if (plotArea.spPr) {
            _this._writeEmbedImageFile(chartFile, plotArea.spPr);
        }
        if (chartSpace.spPr) {
            _this._writeEmbedImageFile(chartFile, chartSpace.spPr);
        }
    };
    XlsxWriter.prototype._writeShapeEmbededImage = function (shapes, pictureFile, zIndex) {
        var _this = this;
        if (shapes) {
            shapes.forEach(function (item) {
                if (item.sp || item.cxnSp || item.grpSp) {
                    if (item.sp && item.sp.spPr) {
                        _this._writeEmbedImageFile(pictureFile, item.sp.spPr);
                    }
                    else if (item.grpSp) {
                        if (item.grpSp.sp) {
                            _this._writeGroupShapeEmbededImage(item.grpSp.sp, pictureFile, zIndex);
                        }
                        if (item.grpSp.grpSpPr) {
                            _this._writeEmbedImageFile(pictureFile, item.grpSp.grpSpPr);
                        }
                    }
                }
                else if (item.pic && item.pic.cameraTool) {
                    _this._writeCameraToolEmbedImageFile(item.pic, pictureFile, zIndex);
                    zIndex++;
                }
            });
        }
    };
    XlsxWriter.prototype._writeGroupShapeEmbededImage = function (shapes, pictureFile, zIndex) {
        var _this = this;
        shapes.forEach(function (shape) {
            if (shape.spPr) {
                if (common_1.isNullOrUndefined(shape.cellRange)) {
                    _this._writeEmbedImageFile(pictureFile, shape.spPr);
                }
                else {
                    _this._writeCameraToolEmbedImageFile(shape, pictureFile, zIndex);
                    zIndex++;
                }
            }
            else if (shape.shapeType === 3) {
                _this._writeGroupShapeEmbededImage(shape.sp, pictureFile, zIndex);
            }
        });
    };
    XlsxWriter.prototype._writeCameraToolEmbedImageFile = function (pic, pictureFile, zIndex) {
        var _this = this;
        if (pic) {
            _this._writePictureFromCameraTool(pic, pictureFile);
            pic.blipFill.srcRect = {};
            pic.blipFill.stretch = {};
            pic.blipFill.stretch.fillRect = {};
            pic.spid = zIndex;
            if (pic.nvPicPr && pic.nvPicPr.cNvPicPr
                && pic.nvPicPr.cNvPicPr.extLst && pic.nvPicPr.cNvPicPr.extLst.ext
                && pic.nvPicPr.cNvPicPr.extLst.ext[0] && pic.nvPicPr.cNvPicPr.extLst.ext[0].cameraTool) {
                pic.nvPicPr.cNvPicPr.extLst.ext[0].cameraTool.spid = pic.spid;
            }
        }
    };
    XlsxWriter.prototype._writeEmbedImageFile = function (chartFile, blipFillContainer) {
        var chartEmbedImageString = blipFillContainer && blipFillContainer.blipFill && blipFillContainer.blipFill.blip &&
            blipFillContainer.blipFill.blip.blipBlob && blipFillContainer.blipFill.blip.blipBlob.blob;
        if (!chartEmbedImageString) {
            return;
        }
        var _this = this;
        _this._imageIndex++;
        var imageInfo = {};
        excel_helper_1.getPictureInfo(chartEmbedImageString, imageInfo);
        var imageFile = getImageFile(imageInfo, _this._imageIndex, chartFile);
        _this._zip.file(imageFile.fileName.substring(1), imageInfo.base64Image, { base64: true });
        blipFillContainer.blipFill.blip.embed = imageInfo.rid;
    };
    XlsxWriter.prototype._writeDrawings = function (sheetviewFile, extensions, withDrawingObjects) {
        if (withDrawingObjects) {
            this._totalDrawingCount++;
            var drawingFileName = excel_types_1.XFileConstants._drawingFileNamePrefix + this._totalDrawingCount + '.' + excel_types_1.XFileConstants._xmlExtension;
            var drawingFile = new excel_types_1.XFile(excel_types_1.XFileConstants._drawingsFileFolder + '/' + drawingFileName, excel_types_1.RelationshipConstants._relationshipDrawingType);
            drawingFile.target = '../drawings/' + drawingFileName;
            var rid = sheetviewFile._addRelationFile(drawingFile);
            extensions.drawingId = rid;
            return drawingFile;
        }
    };
    XlsxWriter.prototype._writeDrawingFiles = function (model, drawingFile, drawingObjects) {
        var _this = this, zip = _this._zip;
        var pictures = drawingObjects.pictures;
        if (pictures && pictures.length > 0) {
            pictures.forEach(function (picture) {
                _this._imageIndex++;
                var imageFile = getImageFile(picture, _this._imageIndex, drawingFile);
                zip.file(imageFile.fileName.substring(1), picture.base64Image, { base64: true });
            });
        }
        if (drawingObjects.withDrawingObjects) {
            var zIndex = 25;
            _this._writeShapeEmbededImage(drawingObjects.shapes, drawingFile, zIndex);
            var xml = drawing_writer_1.writeDrawing(model, drawingObjects, drawingFile);
            zip.file(drawingFile.fileName.substring(1), xml);
            _this._writeChartUserShapesFile(drawingObjects.charts);
        }
    };
    XlsxWriter.prototype._writeChartUserShapesFile = function (charts) {
        if (charts && charts.length > 0) {
            var zip_1 = this._zip;
            charts.forEach(function (chart) {
                var chartSpace = chart.chartSpace;
                var userShapes = chartSpace && chartSpace.userShapes, relSizeAnchor = userShapes && userShapes.relSizeAnchor;
                if (relSizeAnchor && relSizeAnchor.length > 0) {
                    var writer = new xml_writer_1.XmlWriter();
                    writer.writeDocument(false);
                    chart_writer_1.DrawingWriter.WriteCT_ChartDrawing(writer, '', 'userShapes', userShapes);
                    zip_1.file(chart.drawingFile.fileName.substring(1), writer.getXmlString());
                }
            });
        }
    };
    XlsxWriter.prototype._writeTables = function (model, sheetviewFile, sheetName) {
        var self = this;
        var tables = model._getTables(sheetName);
        if (tables && tables.length > 0) {
            tables.forEach(function (sheetTable) {
                var tableFileName = excel_types_1.XFileConstants._tableFileNamePrefix + sheetTable.id + '.' + excel_types_1.XFileConstants._xmlExtension;
                var tableFile = new excel_types_1.XFile(excel_types_1.XFileConstants._tableFilesFolder + '/' + tableFileName, excel_types_1.RelationshipConstants._relationshipTableType);
                tableFile.target = '../tables/' + tableFileName;
                var rid = sheetviewFile._addRelationFile(tableFile);
                sheetTable.rid = rid;
                self._writeSheetTable(sheetTable, tableFile.fileName, model, sheetName);
            });
        }
    };
    XlsxWriter.prototype._writeSheetTable = function (sheetTable, tableFileName, model, sheetName) {
        var self = this, zip = self._zip;
        var xml = table_writer_1.writeTable(sheetTable, model, sheetName);
        zip.file(tableFileName.substring(1), xml);
    };
    XlsxWriter.prototype._writeSlicers = function (model, sheetviewFile, sheetName, workbookFile) {
        var self = this;
        var slicers = model._getSlicers(sheetName);
        if (slicers && slicers.length > 0) {
            self._writeSlicersFile(model, sheetviewFile, sheetName, slicers);
            self._writeSliceCachesFile(model, sheetviewFile, sheetName, slicers, workbookFile);
        }
    };
    XlsxWriter.prototype._writeSlicersFile = function (model, sheetviewFile, sheetName, slicers) {
        var self = this;
        self._totalSlicerCount++;
        var slicerFileName = excel_types_1.XFileConstants._slicerFileNamePrefix + self._totalSlicerCount + '.' + excel_types_1.XFileConstants._xmlExtension;
        var slicerFile = new excel_types_1.XFile(excel_types_1.XFileConstants._slicerFilesFolder + '/' + slicerFileName, excel_types_1.RelationshipConstants._relationshipSlicerType);
        slicerFile.target = '../slicers/' + slicerFileName;
        var rid = sheetviewFile._addRelationFile(slicerFile);
        slicers[0].rid = rid;
        var zip = self._zip;
        var xml = slicer_writer_1.writeSlicer(slicers);
        zip.file(slicerFile.fileName.substring(1), xml);
    };
    XlsxWriter.prototype._writeSliceCachesFile = function (model, sheetviewFile, sheetName, slicers, workbookFile) {
        var self = this;
        var _savedSlicerCacheIDs = {};
        var tables = model._getTables();
        slicers.forEach(function (slicer) {
            var keys = Object.keys(_savedSlicerCacheIDs);
            if (keys.length === 0 || !_savedSlicerCacheIDs[slicer.nameInFormula]) {
                self._totalSlicerCacheCount++;
                var slicerCacheFileName = excel_types_1.XFileConstants._slicerCacheFileNamePrefix + self._totalSlicerCacheCount + '.' + excel_types_1.XFileConstants._xmlExtension;
                var slicerCacheFile = new excel_types_1.XFile(excel_types_1.XFileConstants._slicerCacheFilesFolder + '/' + slicerCacheFileName, excel_types_1.RelationshipConstants._relationshipSlicerCacheType);
                slicerCacheFile.target = 'slicerCaches/' + slicerCacheFileName;
                var rid = workbookFile._addRelationFile(slicerCacheFile);
                _savedSlicerCacheIDs[slicer.nameInFormula] = rid;
                slicer.cacheRid = rid;
                var zip = self._zip;
                var xml = slicer_writer_2.writeSlicerCache(slicer, tables);
                zip.file(slicerCacheFile.fileName.substring(1), xml);
            }
        });
    };
    XlsxWriter.prototype._writeVmlDrawing = function (model, sheetviewFile, sheetName, workbookFile) {
        var headerFooterImages = model._getPrintHeaderFooterImage(sheetName);
        if (headerFooterImages && headerFooterImages.length > 0) {
            this._processVmlDrawing(model, sheetviewFile, headerFooterImages, true);
        }
        var cameraToolImages = model._getCameraToolImages(sheetName);
        if (cameraToolImages && cameraToolImages.length > 0) {
            this._processVmlDrawing(model, sheetviewFile, cameraToolImages, false);
        }
    };
    XlsxWriter.prototype._processVmlDrawing = function (model, sheetviewFile, images, forPrint) {
        this._totalVmlDrawingCount++;
        var vmlDrawFileName = excel_types_1.XFileConstants._vmlDrawingsFileNamePrefix + this._totalVmlDrawingCount + "." + excel_types_1.XFileConstants._vmlExtension;
        var vmlDrawingFile = new excel_types_1.XFile(excel_types_1.XFileConstants._drawingsFileFolder + '/' + vmlDrawFileName, excel_types_1.RelationshipConstants._relationshipVMLDrawingType);
        vmlDrawingFile.target = '../drawings/' + vmlDrawFileName;
        this._writePrintImages(images, vmlDrawingFile);
        var rid = sheetviewFile._addRelationFile(vmlDrawingFile);
        if (forPrint) {
            model._legacyDrawingHFId = rid;
        }
        var xml = print_writer_1.writeVmlDrawingFile(images);
        this._zip.file(vmlDrawingFile.fileName.substring(1), xml);
    };
    XlsxWriter.prototype._writePrintImages = function (headerFooterImages, vmlDrawingFile) {
        var self = this;
        headerFooterImages.forEach(function (image) {
            self._imageIndex++;
            var imageFile = getImageFile(image, self._imageIndex, vmlDrawingFile);
            self._zip.file(imageFile.fileName.substring(1), image.base64Image, { base64: true });
            vmlDrawingFile.relationFiles[image.rid] = imageFile;
        });
    };
    XlsxWriter.prototype._writeMetadata = function (workbookFile) {
        var self = this, level = self._writerDataModel._dynamicArrayLevel;
        if (level) {
            var fileName = excel_types_1.XFileConstants._metadata_fileName;
            var metadataFile = new excel_types_1.XFile(excel_types_1.XFileConstants._dataFileRootFolder + '/' + fileName, excel_types_1.RelationshipConstants._relationshipSheetMetadata);
            metadataFile.target = fileName;
            workbookFile._addRelationFile(metadataFile);
            var xml = metadata_writer_1.getMetadataContent(level);
            self._zip.file(metadataFile.fileName.substring(1), xml);
        }
    };
    XlsxWriter.prototype._dispose = function () {
        excel_style_1.clearCache();
        this._writerDataModel = keyword_undefined;
    };
    return XlsxWriter;
}());
exports.XlsxWriter = XlsxWriter;


/***/ }),

/***/ "./src/xml-io/node-helper.ts":
/*!***********************************!*\
  !*** ./src/xml-io/node-helper.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var excel_style_1 = __webpack_require__(/*! ./../datamodel/excel-style */ "./src/datamodel/excel-style.ts");
var emuToPixles = excel_style_1.UnitHelper.emuToPixles;
var XmlNodeHelper = /** @class */ (function () {
    function XmlNodeHelper() {
    }
    XmlNodeHelper._getAttrValueOrDefaultOfBooleanType = function (attr, defaultValue) {
        if (attr === '1') {
            return true;
        }
        else if (attr === '0') {
            return false;
        }
        return defaultValue;
    };
    XmlNodeHelper._getAttrValueOrDefaultOfDoubleType = function (attr, defaultValue) {
        if (attr) {
            var result = parseFloat(attr);
            if (!isNaN(result)) {
                return result;
            }
        }
        return defaultValue;
    };
    XmlNodeHelper._getAttributeValueOrDefaultOfIntType = function (attr, defaultValue) {
        if (attr) {
            var result = parseInt(attr, 10);
            if (!isNaN(result)) {
                return result;
            }
        }
        return defaultValue;
    };
    XmlNodeHelper._getAsArray = function (obj) {
        if (!Array.isArray(obj)) {
            obj = obj ? [obj] : [];
        }
        return obj;
    };
    XmlNodeHelper._getValueFromObject = function (obj, key, subKey) {
        subKey = subKey || key;
        return obj[key] && obj[key][subKey];
    };
    XmlNodeHelper._readXY = function (off, target) {
        if (off) {
            target.x = emuToPixles(parseInt(off._attr.x, 10));
            target.y = emuToPixles(parseInt(off._attr.y, 10));
        }
    };
    XmlNodeHelper._readSize = function (ext, target) {
        if (ext) {
            target.width = emuToPixles(parseInt(ext._attr.cx, 10));
            target.height = emuToPixles(parseInt(ext._attr.cy, 10));
        }
    };
    XmlNodeHelper._readAnchorPoint = function (item) {
        if (item) {
            return {
                col: parseInt(XmlNodeHelper._getValueFromObject(item, 'xdr:col'), 10),
                colOffset: emuToPixles(parseInt(XmlNodeHelper._getValueFromObject(item, 'xdr:colOff'), 10)),
                row: parseInt(XmlNodeHelper._getValueFromObject(item, 'xdr:row'), 10),
                rowOffset: emuToPixles(parseInt(XmlNodeHelper._getValueFromObject(item, 'xdr:rowOff'), 10))
            };
        }
    };
    return XmlNodeHelper;
}());
exports.XmlNodeHelper = XmlNodeHelper;


/***/ }),

/***/ "./src/xml-io/xml-parser.ts":
/*!**********************************!*\
  !*** ./src/xml-io/xml-parser.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_reader_1 = __webpack_require__(/*! ./xml-reader */ "./src/xml-io/xml-reader.ts");
function parseXmlToObject(xmlString, keepRootNamespace) {
    if (!xmlString) {
        return;
    }
    var reader = new xml_reader_1.XmlReader(), obj = {};
    reader.reset();
    reader.setXml(xmlString);
    reader.keepRootNamespace = keepRootNamespace;
    while (reader.read()) {
        if (reader.elementType === 2) {
            continue;
        }
        var tempObj = {};
        tempObj._attr = {};
        obj[reader.name()] = tempObj;
        while (reader.moveToNextAttribute()) {
            tempObj._attr[reader.readAttributeNameAsString()] = reader.readContentAsString();
        }
        if (reader.elementType === 3) {
            continue;
        }
        parse(reader, tempObj);
    }
    return obj;
}
exports.parseXmlToObject = parseXmlToObject;
function parse(reader, obj) {
    var depth = reader.depth;
    while (reader.read()) {
        if (reader.depth <= depth) {
            break;
        }
        if (reader.nodeType() === 1) {
            var tempObj = {}, name_1 = reader.name();
            if (obj[name_1]) {
                if (!Array.isArray(obj[name_1])) {
                    obj[name_1] = [obj[name_1]];
                }
                obj[name_1].push(tempObj);
            }
            else {
                obj[name_1] = tempObj;
            }
            tempObj._attr = {};
            while (reader.moveToNextAttribute()) {
                tempObj._attr[reader.readAttributeNameAsString()] = reader.readContentAsString();
            }
            if (reader.elementType === 3) {
                continue;
            }
            var elementContent = reader.readElementContentAsString();
            if ((reader.elementType & 1) === 1 && elementContent !== '' && reader._elementContentStart > reader._nameIndex) {
                if (tempObj._attr['xml:space'] === 'preserve') {
                    elementContent = reader.readElementContentAsString(true);
                }
                tempObj[name_1] = elementContent;
            }
            parse(reader, tempObj);
        }
    }
}
function convertObjectToXml(object, rootName) {
    var xml = '<' + rootName;
    var attr = object._attr;
    if (attr) {
        for (var a in attr) {
            if (attr.hasOwnProperty(a)) {
                xml += ' ' + a + '="' + attr[a] + '"';
            }
        }
    }
    xml += '>';
    for (var p in object) {
        if (object.hasOwnProperty(p) && attr !== object[p]) {
            if (typeof object[p] === 'object') {
                xml += convertObjectToXml(object[p], p);
            }
            else {
                xml += object[p];
            }
        }
    }
    xml += '</' + rootName + '>';
    return xml;
}
exports.convertObjectToXml = convertObjectToXml;


/***/ }),

/***/ "./src/xml-io/xml-reader.ts":
/*!**********************************!*\
  !*** ./src/xml-io/xml-reader.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(/*! ./../common/common */ "./src/common/common.ts");
var xmlEncode = common_1.Util._xmlEncode;
var CDATA_START = '<![CDATA[', CDATA_END = ']]>';
var keyword_null = null;
var XmlReader = /** @class */ (function () {
    function XmlReader() {
        this._elementCursorIndex = -1;
        this._attributeCursorIndex = 0;
        this._lastCharPosition = 0;
        this._elementEndIndex = 0;
        this.buffer = '';
        this.elementType = 2;
        this.depth = 0;
        this._nameIndex = 0;
        this._nameLength = 0;
        this._attributeNameIndex = 0;
        this._attributeNameLength = 0;
        this._attributeContentStart = 0;
        this._attributeContentEnd = 0;
        this._elementContentStart = 0;
        this._elementContentEnd = 0;
        this.xmlIndex = 0;
        this.xml = '';
        this._hasCDATA = false;
        this.reset();
    }
    XmlReader.prototype.reset = function () {
        var self = this;
        self._elementCursorIndex = -1;
        self._attributeCursorIndex = 0;
        self._lastCharPosition = 0;
        self._elementEndIndex = 0;
        self.buffer = '';
        self.elementType = 2;
        self.depth = 0;
        self._nameIndex = 0;
        self._nameLength = 0;
        self._attributeNameIndex = 0;
        self._attributeNameLength = 0;
        self._attributeContentStart = 0;
        self._attributeContentEnd = 0;
        self._elementContentStart = 0;
        self._elementContentEnd = 0;
        self.xmlIndex = 0;
        self.xml = '';
        self._hasCDATA = false;
        self._rootNameSpaceLength = 0;
        self._rootNameSpace = '';
    };
    XmlReader.prototype.setXml = function (xmlString) {
        this.xml = xmlString;
    };
    XmlReader.prototype.name = function () {
        var self = this;
        var fullName = self.buffer.slice(self._nameIndex, self._nameIndex + self._nameLength);
        if (fullName && !self.keepRootNamespace) {
            var pos = fullName.lastIndexOf(':') + 1;
            if (!(pos === self._rootNameSpaceLength && fullName.substr(0, pos) === self._rootNameSpace)) {
                pos = 0;
            }
            return fullName.substr(pos);
        }
        return fullName;
    };
    XmlReader.prototype.nodeType = function () {
        if (this.elementType === 2) {
            return 15;
        }
        return 1;
    };
    XmlReader.prototype.fillBuffer = function () {
        var self = this;
        var bufferLength = self.buffer.length;
        if (bufferLength === 0) {
            self.buffer = self.xml;
            self._elementCursorIndex = 0;
            self._elementContentStart = 0;
            self._lastCharPosition = self.buffer.length;
            return true;
        }
        return false;
    };
    XmlReader.prototype.read = function () {
        var self = this;
        self._attributeCursorIndex = Number.MAX_VALUE;
        self._hasCDATA = false;
        while (true) {
            self._elementCursorIndex++;
            if (self._elementCursorIndex >= self._lastCharPosition && !self.fillBuffer()) {
                return false;
            }
            var c = self.buffer[self._elementCursorIndex];
            if (c === '\x3c') {
                break;
            }
        }
        var eleParts = [
            'elementStarting', 'elementStart', 'elementNameEnd', 'elementEnd', 'elementContent',
            'elementContentStart', 'endElementStart'
        ], elePartsLen = eleParts.length, partIndex = 0, jump = false;
        while (partIndex < elePartsLen) {
            switch (eleParts[partIndex]) {
                case 'elementStarting':
                    jump = false;
                    while (true) {
                        self._elementCursorIndex++;
                        var c = self.buffer[self._elementCursorIndex];
                        if (c === '\x2f') {
                            partIndex = 6;
                            jump = true;
                            break;
                        }
                        else if (c === '\x3f') {
                            self.elementType = 3;
                            while (true) {
                                self._elementCursorIndex++;
                                c = self.buffer[self._elementCursorIndex];
                                if (c === '\x3e') {
                                    return true;
                                }
                            }
                        }
                        else if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
                            self._nameIndex = self._elementCursorIndex;
                            break;
                        }
                    }
                    if (jump) {
                        continue;
                    }
                case 'elementStart':
                    jump = false;
                    if (self.elementType === 1) {
                        self.depth++;
                    }
                    while (true) {
                        self._elementCursorIndex++;
                        var c = self.buffer[self._elementCursorIndex];
                        if (c === '\x3e') {
                            self._nameLength = self._elementCursorIndex - self._nameIndex;
                            partIndex = 3;
                            jump = true;
                            break;
                        }
                        else if (c === '\x20' || c === '\x0d' || c === '\x0a' || c === '\x09' || c === '\x2f') {
                            self._nameLength = self._elementCursorIndex - self._nameIndex;
                            self._attributeCursorIndex = self._elementCursorIndex;
                            break;
                        }
                    }
                    if (self.depth === 0 && !self.keepRootNamespace && self._nameLength) {
                        var fullName = self.buffer.substr(self._nameIndex, self._nameLength);
                        var pos = fullName.lastIndexOf(':') + 1;
                        if (pos) {
                            self._rootNameSpace = fullName.substr(0, pos);
                            self._rootNameSpaceLength = pos;
                        }
                    }
                    if (jump) {
                        continue;
                    }
                case 'elementNameEnd':
                    var ignoreQuote = false;
                    while (true) {
                        self._elementCursorIndex++;
                        var c = self.buffer[self._elementCursorIndex];
                        if (c === '\x22') {
                            ignoreQuote = !ignoreQuote;
                        }
                        if (!ignoreQuote && c === '\x3e') {
                            break;
                        }
                    }
                    var index = self._elementCursorIndex;
                    while (true) {
                        index--;
                        var c = self.buffer[index];
                        if (c === '\x2f') {
                            self._elementEndIndex = index;
                            self.elementType = 3;
                            return true;
                        }
                        else if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
                            self._elementEndIndex = index;
                            self.elementType = 1;
                            partIndex = 4;
                            break;
                        }
                    }
                    continue;
                case 'elementEnd':
                    index = self._elementCursorIndex;
                    while (true) {
                        index--;
                        var c = self.buffer[index];
                        if (c === '\x2f') {
                            self.elementType = 3;
                            return true;
                        }
                        else if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
                            self.elementType = 1;
                            break;
                        }
                    }
                case 'elementContent':
                    var elementContentStartSet = false;
                    while (true) {
                        self._elementCursorIndex++;
                        var c = self.buffer[self._elementCursorIndex];
                        if (self.buffer.substr(self._elementCursorIndex, 9) === CDATA_START) {
                            var findCDataEnd = self.buffer.indexOf(CDATA_END, self._elementCursorIndex);
                            self._elementContentStart = self._elementCursorIndex;
                            self._elementContentEnd = findCDataEnd + CDATA_END.length;
                            self._elementCursorIndex = self._elementContentEnd - 1;
                            self._hasCDATA = true;
                            return true;
                        }
                        else if (c === '\x3c') {
                            self._elementCursorIndex--;
                            if (elementContentStartSet) {
                                self._elementContentEnd = self._elementCursorIndex + 1;
                            }
                            return true;
                        }
                        self._elementContentStart = self._elementCursorIndex;
                        elementContentStartSet = true;
                        if (c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
                            break;
                        }
                    }
                case 'elementContentStart': while (true) {
                    self._elementCursorIndex++;
                    var c = self.buffer[self._elementCursorIndex];
                    if (c === '\x3c') {
                        self._elementContentEnd = self._elementCursorIndex;
                        self._elementCursorIndex--;
                        return true;
                    }
                }
                case 'endElementStart':
                    if (self.elementType === 2 || self.elementType === 3) {
                        self.depth--;
                    }
                    self.elementType = 2;
                    self._nameIndex = self._elementCursorIndex + 1;
                    while (true) {
                        self._elementCursorIndex++;
                        var c = self.buffer[self._elementCursorIndex];
                        if (c === '\x3e') {
                            self._nameLength = self._elementCursorIndex - self._nameIndex;
                            return true;
                        }
                    }
            }
        }
    };
    XmlReader.prototype.fastRead = function () {
        var self = this;
        self._attributeCursorIndex = Number.MAX_VALUE;
        self._hasCDATA = false;
        while (true) {
            self._elementCursorIndex++;
            if (self._elementCursorIndex >= self._lastCharPosition && !self.fillBuffer()) {
                return false;
            }
            var c = self.buffer[self._elementCursorIndex];
            if (c === '\x3c') {
                break;
            }
        }
        var eleParts = [
            'elementStarting', 'elementStart', 'elementNameEnd', 'elementEnd', 'elementContent',
            'elementContentStart', 'endElementStart'
        ];
        var partIndex = 0, jump = false;
        while (partIndex < eleParts.length) {
            switch (eleParts[partIndex]) {
                case 'elementStarting':
                    jump = false;
                    while (true) {
                        self._elementCursorIndex++;
                        var c = self.buffer[self._elementCursorIndex];
                        if (c === '\x2f') {
                            partIndex = 6;
                            jump = true;
                            break;
                        }
                        else if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
                            self._nameIndex = self._elementCursorIndex;
                            break;
                        }
                    }
                    if (jump) {
                        continue;
                    }
                case 'elementStart':
                    jump = false;
                    if (self.elementType === 1) {
                        self.depth++;
                    }
                    while (true) {
                        self._elementCursorIndex++;
                        var c = self.buffer[self._elementCursorIndex];
                        if (c === '\x3e') {
                            self._nameLength = self._elementCursorIndex - self._nameIndex;
                            partIndex = 3;
                            jump = true;
                            break;
                        }
                        else if (c === '\x20' || c === '\x0d' || c === '\x0a' || c === '\x09') {
                            self._nameLength = self._elementCursorIndex - self._nameIndex;
                            self._attributeCursorIndex = self._elementCursorIndex;
                            break;
                        }
                    }
                    if (self.depth === 0 && !self.keepRootNamespace && self._nameLength) {
                        var fullName = self.buffer.substr(self._nameIndex, self._nameLength);
                        var pos = fullName.lastIndexOf(':') + 1;
                        if (pos) {
                            self._rootNameSpace = fullName.substr(0, pos);
                            self._rootNameSpaceLength = pos;
                        }
                    }
                    if (jump) {
                        continue;
                    }
                case 'elementNameEnd':
                    var ignoreQuote = false;
                    while (true) {
                        self._elementCursorIndex++;
                        var c = self.buffer[self._elementCursorIndex];
                        if (c === '\x22') {
                            ignoreQuote = !ignoreQuote;
                        }
                        if (!ignoreQuote && c === '\x3e') {
                            break;
                        }
                    }
                    var index = self._elementCursorIndex;
                    while (true) {
                        index--;
                        var c = self.buffer[index];
                        if (c === '\x2f') {
                            self._elementEndIndex = index;
                            self.elementType = 3;
                            return true;
                        }
                        else if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
                            self._elementEndIndex = index;
                            self.elementType = 1;
                            partIndex = 4;
                            break;
                        }
                    }
                    continue;
                case 'elementEnd':
                    index = self._elementCursorIndex;
                    while (true) {
                        index--;
                        var c = self.buffer[index];
                        if (c === '\x2f') {
                            self.elementType = 3;
                            return true;
                        }
                        else if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
                            self.elementType = 1;
                            break;
                        }
                    }
                case 'elementContent': while (true) {
                    self._elementCursorIndex++;
                    var c = self.buffer[self._elementCursorIndex];
                    if (self.buffer.substr(self._elementCursorIndex, 9) === CDATA_START) {
                        var findCDataEnd = self.buffer.indexOf(CDATA_END, self._elementCursorIndex);
                        self._elementContentStart = self._elementCursorIndex;
                        self._elementContentEnd = findCDataEnd + CDATA_END.length;
                        self._elementCursorIndex = self._elementContentEnd - 1;
                        self._hasCDATA = true;
                        return true;
                    }
                    else if (c === '\x3c') {
                        self._elementCursorIndex--;
                        return true;
                    }
                    else if (c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
                        self._elementContentStart = self._elementCursorIndex;
                        break;
                    }
                }
                case 'elementContentStart': while (true) {
                    self._elementCursorIndex++;
                    var c = self.buffer[self._elementCursorIndex];
                    if (c === '\x3c') {
                        self._elementContentEnd = self._elementCursorIndex;
                        self._elementCursorIndex--;
                        return true;
                    }
                }
                case 'endElementStart':
                    if (self.elementType === 2 || self.elementType === 3) {
                        self.depth--;
                    }
                    self.elementType = 2;
                    while (true) {
                        self._elementCursorIndex++;
                        var c = self.buffer[self._elementCursorIndex];
                        if (c === '\x3e') {
                            return true;
                        }
                    }
            }
        }
    };
    XmlReader.prototype.moveToNextAttribute = function () {
        var self = this;
        while (true) {
            if (self._attributeCursorIndex >= self._elementEndIndex - 1) {
                return false;
            }
            self._attributeCursorIndex++;
            var c = self.buffer[self._attributeCursorIndex];
            if (c !== '\x20' && c !== '\x0d' && c !== '\x0a' && c !== '\x09') {
                self._attributeNameIndex = self._attributeCursorIndex;
                break;
            }
        }
        while (true) {
            self._attributeCursorIndex++;
            var c = self.buffer[self._attributeCursorIndex];
            if (c === '\x3d' || c === '\x20' || c === '\x0d' || c === '\x0a' || c === '\x09') {
                self._attributeNameLength = self._attributeCursorIndex - self._attributeNameIndex;
                break;
            }
        }
        var mark = '\x22';
        while (true) {
            self._attributeCursorIndex++;
            var c = self.buffer[self._attributeCursorIndex];
            if (c === '\x22' || c === '\x27') {
                mark = c;
                self._attributeContentStart = self._attributeCursorIndex + 1;
                break;
            }
        }
        while (true) {
            self._attributeCursorIndex++;
            var c = self.buffer[self._attributeCursorIndex];
            if (c === mark) {
                self._attributeContentEnd = self._attributeCursorIndex;
                return true;
            }
        }
    };
    XmlReader.prototype.readContentAsString = function () {
        var self = this;
        return self.buffer.slice(self._attributeContentStart, self._attributeContentEnd);
    };
    XmlReader.prototype.readContentAsBoolean = function (defaultValue) {
        var self = this;
        var c = self.buffer[self._attributeContentStart];
        if (c === '1' || c === 't') {
            return true;
        }
        else if (c === '0' || c === 'f') {
            return false;
        }
        return defaultValue;
    };
    XmlReader.prototype.readContentAsInt = function (defaultValue) {
        var self = this;
        var content = parseInt(self.buffer.slice(self._attributeContentStart, self._attributeContentEnd), 10);
        if (!isNaN(content)) {
            return content;
        }
        return defaultValue;
    };
    XmlReader.prototype.readContentAsDouble = function (defaultValue) {
        var self = this;
        var content = parseFloat(self.buffer.slice(self._attributeContentStart, self._attributeContentEnd));
        if (!isNaN(content)) {
            return content;
        }
        return defaultValue;
    };
    XmlReader.prototype.readContentAsError = function () {
        var value = this.readContentAsString();
        var code = keyword_null;
        switch (value) {
            case '#DIV/0!':
                code = 0x07;
                break;
            case '#N/A':
                code = 0x2A;
                break;
            case '#NAME?':
                code = 0x1D;
                break;
            case '#NULL!':
                code = 0x00;
                break;
            case '#NUM!':
                code = 0x24;
                break;
            case '#REF!':
                code = 0x17;
                break;
            case '#VALUE!':
                code = 0x0F;
                break;
            case '#SPILL!':
                code = 99;
                break;
            default:
                break;
        }
        if (code !== keyword_null) {
            return { _error: value, _code: code };
        }
        else {
            return keyword_null;
        }
    };
    XmlReader.prototype.readElementContentAsString = function (keepSpace) {
        var self = this, start = self._elementContentStart;
        if (this._elementContentStart <= this._nameIndex) {
            return '';
        }
        if (keepSpace) {
            var buffer = self.buffer, c = buffer[start - 1];
            while (c === '\x20' || c === '\x0d' || c === '\x0a' || c === '\x09') {
                start--;
                c = buffer[start - 1];
            }
        }
        var content = self.buffer.slice(start, self._elementContentEnd);
        if (self._hasCDATA) {
            content = xmlEncode(content.replace(CDATA_START, '').replace(CDATA_END, ''));
            self._hasCDATA = false;
        }
        return content;
    };
    XmlReader.prototype.readElementContentAsInt = function (defaultValue) {
        var self = this;
        var content = parseInt(self.buffer.slice(self._elementContentStart, self._elementContentEnd), 10);
        if (!isNaN(content)) {
            return content;
        }
        return defaultValue;
    };
    XmlReader.prototype.readElementContentAsDouble = function (defaultValue) {
        var self = this;
        var content = parseFloat(self.buffer.slice(self._elementContentStart, self._elementContentEnd));
        if (!isNaN(content)) {
            return content;
        }
        return defaultValue;
    };
    XmlReader.prototype.readElementContentAsBoolean = function (defaultValue) {
        var self = this;
        var c = self.buffer[self._elementContentStart];
        if (c === '1' || c === 't') {
            return true;
        }
        else if (c === '0' || c === 'f') {
            return false;
        }
        return defaultValue;
    };
    XmlReader.prototype.readAttributeNameAsString = function () {
        var self = this;
        return self.buffer.slice(self._attributeNameIndex, self._attributeNameIndex + self._attributeNameLength);
    };
    XmlReader.prototype.readFullElement = function () {
        var self = this;
        if (self.elementType === 2) {
            return '';
        }
        var elementStartCursor = self._nameIndex - 1;
        if (self.elementType === 3) {
            return self.buffer.slice(elementStartCursor, self._elementEndIndex + 2);
        }
        var depth = self.depth;
        if (self.elementType === 1) {
            while (self.read()) {
                if (self.depth <= depth) {
                    break;
                }
            }
            return self.buffer.slice(elementStartCursor, self._nameIndex + self._nameLength + 1);
        }
        return '';
    };
    return XmlReader;
}());
exports.XmlReader = XmlReader;


/***/ }),

/***/ "./src/xml-io/xml-writer.ts":
/*!**********************************!*\
  !*** ./src/xml-io/xml-writer.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function StringBuilder(size) {
    var self = this;
    self.size = size || 500;
    self.blockIndex = -1;
    self.stringIndex = 0;
    self.blocks = [];
    this.createNewArray();
}
StringBuilder.prototype.createNewArray = function () {
    var self = this;
    var array = new Array(self.size);
    self.blocks.push(array);
    self.blockIndex++;
    self.stringIndex = 0;
};
StringBuilder.prototype.addString = function (string) {
    var self = this;
    if (self.isFullArray()) {
        self.createNewArray();
    }
    self.blocks[self.blockIndex][self.stringIndex] = string;
    self.stringIndex++;
};
StringBuilder.prototype.getAllString = function () {
    var self = this;
    for (var i = 0; i < self.blocks.length; i++) {
        self.blocks[i] = self.blocks[i].join('');
    }
    var result = self.blocks.join('');
    self.blocks = null;
    return result;
};
StringBuilder.prototype.isFullArray = function () {
    var self = this;
    return self.stringIndex > self.size - 2;
};
var XmlWriter = /** @class */ (function () {
    function XmlWriter() {
        this.xml = new StringBuilder();
    }
    XmlWriter.prototype.writeDocument = function (noStandalone) {
        this.xml.addString('<?xml version="1.0" encoding="UTF-8" ' + (noStandalone ? '' : 'standalone="yes"') + '?>\r\n');
    };
    XmlWriter.prototype.writeElement = function (elementName, writeAttr, writeContent) {
        if (writeContent === undefined) {
            writeContent = writeAttr;
            writeAttr = void 0;
        }
        this.xml.addString('<' + elementName);
        if (typeof writeAttr === 'function') {
            writeAttr();
        }
        this.xml.addString('>');
        if (typeof writeContent === 'function') {
            writeContent();
        }
        this.xml.addString('</' + elementName + '>');
    };
    XmlWriter.prototype.writeValue = function (value) {
        this.xml.addString(value);
    };
    XmlWriter.prototype.writeLeafElement = function (elementName, writeAttr) {
        this.xml.addString('<' + elementName);
        if (typeof writeAttr === 'function') {
            writeAttr();
        }
        this.xml.addString('/>');
    };
    XmlWriter.prototype.writeAttributeString = function (attrName, attrValue) {
        this.xml.addString(' ' + attrName);
        if (attrName === 'style') {
            this.xml.addString("='" + attrValue + "'");
        }
        else {
            this.xml.addString('="' + attrValue + '"');
        }
    };
    XmlWriter.prototype.writeElementString = function (elementName, writeContent) {
        this.xml.addString('<' + elementName + '>' + writeContent + '</' + elementName + '>');
    };
    XmlWriter.prototype.getXmlString = function () {
        return this.xml.getAllString();
    };
    return XmlWriter;
}());
exports.XmlWriter = XmlWriter;


/***/ })

/******/ });
});
  return GC;
};
//# sourceMappingURL=gc.spread.excelio.14.2.5.js.map